diff -uNr linux-2.6.32/arch/x86/include/asm/syscall.h clean_modified/linux-2.6.32/arch/x86/include/asm/syscall.h
--- linux-2.6.32/arch/x86/include/asm/syscall.h	2009-12-02 21:51:21.000000000 -0600
+++ clean_modified/linux-2.6.32/arch/x86/include/asm/syscall.h	2019-04-14 13:23:39.002866142 -0500
@@ -207,7 +207,11 @@
 			break;
 		}
 }
-
+asmlinkage int sys_helloworld(void);
+asmlinkage int print_self(void);
+asmlinkage int print_other(int pid);
+asmlinkage int virtual_mem(int pid);
+asmlinkage int virtual_mem_status(unsigned long v_mem, int pid);
 #endif	/* CONFIG_X86_32 */
 
 #endif	/* _ASM_X86_SYSCALL_H */
diff -uNr linux-2.6.32/arch/x86/include/asm/unistd_32.h clean_modified/linux-2.6.32/arch/x86/include/asm/unistd_32.h
--- linux-2.6.32/arch/x86/include/asm/unistd_32.h	2009-12-02 21:51:21.000000000 -0600
+++ clean_modified/linux-2.6.32/arch/x86/include/asm/unistd_32.h	2019-04-14 13:23:39.003835328 -0500
@@ -342,10 +342,15 @@
 #define __NR_pwritev		334
 #define __NR_rt_tgsigqueueinfo	335
 #define __NR_perf_event_open	336
+#define __NR_helloworld		337
+#define __NR_printself		338
+#define __NR_printother		339
+#define __NR_virtualmem		340
+#define __NR_virtualmemstatus	341
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 337
+#define NR_syscalls 342
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff -uNr linux-2.6.32/arch/x86/kernel/syscall_table_32.S clean_modified/linux-2.6.32/arch/x86/kernel/syscall_table_32.S
--- linux-2.6.32/arch/x86/kernel/syscall_table_32.S	2009-12-02 21:51:21.000000000 -0600
+++ clean_modified/linux-2.6.32/arch/x86/kernel/syscall_table_32.S	2019-04-14 13:23:39.257372003 -0500
@@ -336,3 +336,8 @@
 	.long sys_pwritev
 	.long sys_rt_tgsigqueueinfo	/* 335 */
 	.long sys_perf_event_open
+	.long sys_helloworld 		/* 337 */
+	.long print_self 		/* 338 */
+	.long print_other 		/* 339 */
+	.long virtual_mem		/* 340 */
+	.long virtual_mem_status	/* 341 */
diff -uNr linux-2.6.32/.config clean_modified/linux-2.6.32/.config
--- linux-2.6.32/.config	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/.config	2019-04-14 13:23:39.454590410 -0500
@@ -0,0 +1,4449 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Sat Apr 13 14:09:51 2019
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_X86_32_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_TREE=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_NS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+CONFIG_EVENT_PROFILE=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_OPROFILE=m
+# CONFIG_OPROFILE_IBS is not set
+CONFIG_OPROFILE_EVENT_MULTIPLEX=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_SLOW_WORK=y
+# CONFIG_SLOW_WORK_DEBUG is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_INTEGRITY=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_BIGSMP=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_ELAN is not set
+CONFIG_X86_MRST=y
+# CONFIG_X86_RDC321X is not set
+CONFIG_X86_32_NON_STANDARD=y
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_ES7000 is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_PARAVIRT_GUEST=y
+CONFIG_XEN=y
+CONFIG_XEN_MAX_DOMAIN_MEMORY=128
+CONFIG_XEN_SAVE_RESTORE=y
+CONFIG_XEN_DEBUG_FS=y
+# CONFIG_VMI is not set
+CONFIG_KVM_CLOCK=y
+CONFIG_KVM_GUEST=y
+# CONFIG_LGUEST_GUEST is not set
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+CONFIG_PARAVIRT_CLOCK=y
+# CONFIG_PARAVIRT_DEBUG is not set
+# CONFIG_MEMTEST is not set
+CONFIG_X86_CYCLONE_TIMER=y
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+# CONFIG_X86_PPRO_FENCE is not set
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_X86_DS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+CONFIG_IOMMU_API=y
+CONFIG_NR_CPUS=32
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+# CONFIG_X86_ANCIENT_MCE is not set
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_X86_MCE_INJECT=m
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_VM86=y
+CONFIG_TOSHIBA=m
+CONFIG_I8K=m
+# CONFIG_X86_REBOOTFIXUPS is not set
+CONFIG_MICROCODE=m
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+# CONFIG_X86_CPU_DEBUG is not set
+# CONFIG_NOHIGHMEM is not set
+# CONFIG_HIGHMEM4G is not set
+CONFIG_HIGHMEM64G=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+CONFIG_X86_PAE=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+# CONFIG_NUMA is not set
+CONFIG_NEED_NODE_MEMMAP_SIZE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+# CONFIG_ARCH_MEMORY_PROBE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+# CONFIG_MEMORY_HOTREMOVE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_HIGHPTE=y
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW_64K=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=1
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_EFI=y
+# CONFIG_SECCOMP is not set
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_KEXEC_JUMP is not set
+CONFIG_PHYSICAL_START=0x400000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x400000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_RUNTIME=y
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+CONFIG_ACPI_POWER_METER=m
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=m
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=1999
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_HOTPLUG_MEMORY=y
+CONFIG_ACPI_SBS=m
+CONFIG_SFI=y
+CONFIG_X86_APM_BOOT=y
+CONFIG_APM=y
+# CONFIG_APM_IGNORE_USER_SUSPEND is not set
+# CONFIG_APM_DO_ENABLE is not set
+CONFIG_APM_CPU_IDLE=y
+# CONFIG_APM_DISPLAY_BLANK is not set
+# CONFIG_APM_ALLOW_INTS is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_DEBUG=y
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+
+#
+# CPUFreq processor drivers
+#
+CONFIG_X86_ACPI_CPUFREQ=m
+# CONFIG_X86_POWERNOW_K6 is not set
+CONFIG_X86_POWERNOW_K7=y
+CONFIG_X86_POWERNOW_K7_ACPI=y
+CONFIG_X86_POWERNOW_K8=m
+# CONFIG_X86_GX_SUSPMOD is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+CONFIG_X86_SPEEDSTEP_ICH=y
+CONFIG_X86_SPEEDSTEP_SMI=y
+CONFIG_X86_P4_CLOCKMOD=m
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+CONFIG_X86_LONGRUN=y
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+CONFIG_X86_SPEEDSTEP_LIB=y
+# CONFIG_X86_SPEEDSTEP_RELAXED_CAP_CHECK is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+# CONFIG_PCI_GOOLPC is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_OLPC=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_DMAR=y
+# CONFIG_DMAR_DEFAULT_ON is not set
+CONFIG_DMAR_FLOPPY_WA=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+CONFIG_PCIE_ECRC=y
+CONFIG_PCIEAER_INJECT=m
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_LEGACY=y
+# CONFIG_PCI_DEBUG is not set
+CONFIG_PCI_STUB=y
+CONFIG_HT_IRQ=y
+CONFIG_PCI_IOV=y
+CONFIG_ISA_DMA_API=y
+CONFIG_ISA=y
+# CONFIG_EISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+CONFIG_OLPC=y
+CONFIG_K8_NB=y
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=m
+CONFIG_YENTA_O2=y
+CONFIG_YENTA_RICOH=y
+CONFIG_YENTA_TI=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_YENTA_TOSHIBA=y
+CONFIG_PD6729=m
+# CONFIG_I82092 is not set
+CONFIG_I82365=m
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_PROBE=y
+CONFIG_PCCARD_NONSTATIC=m
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_FAKE=m
+CONFIG_HOTPLUG_PCI_COMPAQ=m
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+CONFIG_HOTPLUG_PCI_IBM=m
+CONFIG_HOTPLUG_PCI_ACPI=y
+CONFIG_HOTPLUG_PCI_ACPI_IBM=m
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_XFRM_MIGRATE=y
+CONFIG_XFRM_STATISTICS=y
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+# CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT is not set
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_IP_DCCP=m
+CONFIG_INET_DCCP_DIAG=m
+
+#
+# DCCP CCIDs Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP_CCID2_DEBUG is not set
+CONFIG_IP_DCCP_CCID3=y
+# CONFIG_IP_DCCP_CCID3_DEBUG is not set
+CONFIG_IP_DCCP_CCID3_RTO=100
+CONFIG_IP_DCCP_TFRC_LIB=y
+
+#
+# DCCP Kernel Hacking
+#
+# CONFIG_IP_DCCP_DEBUG is not set
+CONFIG_NET_DCCPPROBE=m
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_RDS=m
+CONFIG_RDS_RDMA=m
+CONFIG_RDS_TCP=m
+# CONFIG_RDS_DEBUG is not set
+# CONFIG_TIPC is not set
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+# CONFIG_ATM_CLIP_NO_ICMP is not set
+CONFIG_ATM_LANE=m
+# CONFIG_ATM_MPOA is not set
+CONFIG_ATM_BR2684=m
+# CONFIG_ATM_BR2684_IPFILTER is not set
+CONFIG_STP=m
+CONFIG_GARP=m
+CONFIG_BRIDGE=m
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_NET_DSA_TAG_TRAILER=y
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NET_DSA_MV88E6060=y
+CONFIG_NET_DSA_MV88E6XXX_NEED_PPU=y
+CONFIG_NET_DSA_MV88E6131=y
+CONFIG_NET_DSA_MV88E6123_61_65=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=m
+CONFIG_IEEE802154=m
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_ATM=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_CLS_IND=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_DCB=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_NET_DROP_MONITOR=y
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=m
+CONFIG_CAN_RAW=m
+CONFIG_CAN_BCM=m
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_VCAN=m
+CONFIG_CAN_DEV=m
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_SJA1000=m
+CONFIG_CAN_SJA1000_ISA=m
+CONFIG_CAN_SJA1000_PLATFORM=m
+CONFIG_CAN_EMS_PCI=m
+CONFIG_CAN_KVASER_PCI=m
+
+#
+# CAN USB interfaces
+#
+CONFIG_CAN_EMS_USB=m
+CONFIG_CAN_DEBUG_DEVICES=y
+# CONFIG_IRDA is not set
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+CONFIG_BT_SCO=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_CMTP=m
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIDTL1=m
+CONFIG_BT_HCIBT3C=m
+CONFIG_BT_HCIBLUECARD=m
+CONFIG_BT_HCIBTUART=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=m
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_WIMAX=m
+CONFIG_WIMAX_DEBUG_LEVEL=8
+CONFIG_RFKILL=m
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_NET_9P=m
+CONFIG_NET_9P_VIRTIO=m
+CONFIG_NET_9P_RDMA=m
+# CONFIG_NET_9P_DEBUG is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+CONFIG_SYS_HYPERVISOR=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_CONCAT=m
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD_REDBOOT_PARTS=m
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_AR7_PARTS=m
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLKDEVS=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_FTL=m
+CONFIG_NFTL=m
+CONFIG_NFTL_RW=y
+CONFIG_INFTL=m
+CONFIG_RFD_FTL=m
+CONFIG_SSFDC=m
+CONFIG_MTD_OOPS=m
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=m
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_GEN_PROBE=m
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_MTD_CFI_UTIL=m
+CONFIG_MTD_RAM=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_SC520CDP=m
+CONFIG_MTD_NETSC520=m
+CONFIG_MTD_TS5500=m
+# CONFIG_MTD_SBC_GXX is not set
+# CONFIG_MTD_AMD76XROM is not set
+# CONFIG_MTD_ICHXROM is not set
+CONFIG_MTD_ESB2ROM=m
+CONFIG_MTD_CK804XROM=m
+CONFIG_MTD_SCB2_FLASH=m
+# CONFIG_MTD_NETtel is not set
+# CONFIG_MTD_L440GX is not set
+CONFIG_MTD_PCI=m
+# CONFIG_MTD_GPIO_ADDR is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_PMC551=m
+# CONFIG_MTD_PMC551_BUGFIX is not set
+# CONFIG_MTD_PMC551_DEBUG is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+CONFIG_MTD_MTDRAM=m
+CONFIG_MTDRAM_TOTAL_SIZE=4096
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_MTD_BLOCK2MTD=m
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_ECC_SMC=y
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=m
+CONFIG_MTD_NAND_DISKONCHIP=m
+# CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADVANCED is not set
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS=0
+# CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE is not set
+CONFIG_MTD_NAND_CAFE=m
+CONFIG_MTD_NAND_CS553X=m
+CONFIG_MTD_NAND_NANDSIM=m
+# CONFIG_MTD_NAND_PLATFORM is not set
+CONFIG_MTD_ALAUDA=m
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+CONFIG_MTD_LPDDR=m
+CONFIG_MTD_QINFO_PROBE=m
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+CONFIG_PARPORT_SERIAL=m
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+CONFIG_PARPORT_PC_PCMCIA=m
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_AX88796 is not set
+CONFIG_PARPORT_1284=y
+CONFIG_PARPORT_NOT_PC=y
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_ISAPNP=y
+# CONFIG_PNPBIOS is not set
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_FD=m
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_CISS_SCSI_TAPE=y
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_OSD=m
+CONFIG_BLK_DEV_SX8=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+CONFIG_XEN_BLKDEV_FRONTEND=m
+CONFIG_VIRTIO_BLK=m
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_IBM_ASM=m
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+CONFIG_ICS932S401=m
+CONFIG_ENCLOSURE_SERVICES=m
+CONFIG_HP_ILO=m
+CONFIG_DELL_LAPTOP=m
+CONFIG_ISL29003=m
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_LEGACY=m
+CONFIG_EEPROM_MAX6875=m
+CONFIG_EEPROM_93CX6=m
+CONFIG_CB710_CORE=m
+# CONFIG_CB710_DEBUG is not set
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_ENCLOSURE=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_SCSI_CXGB3_ISCSI=m
+CONFIG_SCSI_BNX2_ISCSI=m
+CONFIG_BE2ISCSI=m
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_SCSI_3W_9XXX=m
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+CONFIG_SCSI_AHA152X=m
+CONFIG_SCSI_AHA1542=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=4
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+# CONFIG_AIC7XXX_REG_PRETTY_PRINT is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=4
+CONFIG_AIC79XX_RESET_DELAY_MS=15000
+# CONFIG_AIC79XX_DEBUG_ENABLE is not set
+CONFIG_AIC79XX_DEBUG_MASK=0
+# CONFIG_AIC79XX_REG_PRETTY_PRINT is not set
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+CONFIG_SCSI_MVSAS=m
+# CONFIG_SCSI_MVSAS_DEBUG is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+CONFIG_SCSI_ARCMSR=m
+CONFIG_SCSI_ARCMSR_AER=y
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+# CONFIG_MEGARAID_LEGACY is not set
+CONFIG_MEGARAID_SAS=m
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_SCSI_MPT2SAS_MAX_SGE=128
+# CONFIG_SCSI_MPT2SAS_LOGGING is not set
+CONFIG_SCSI_HPTIOP=m
+# CONFIG_SCSI_BUSLOGIC is not set
+CONFIG_LIBFC=m
+CONFIG_LIBFCOE=m
+CONFIG_FCOE=m
+CONFIG_FCOE_FNIC=m
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_PPA=m
+CONFIG_SCSI_IMM=m
+# CONFIG_SCSI_IZIP_EPP16 is not set
+# CONFIG_SCSI_IZIP_SLOW_CTR is not set
+# CONFIG_SCSI_NCR53C406A is not set
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_SCSI_LPFC=m
+# CONFIG_SCSI_LPFC_DEBUG_FS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_ULTRASTOR is not set
+# CONFIG_SCSI_NSP32 is not set
+CONFIG_SCSI_DEBUG=m
+CONFIG_SCSI_PMCRAID=m
+CONFIG_SCSI_SRP=m
+CONFIG_SCSI_BFA_FC=m
+CONFIG_SCSI_LOWLEVEL_PCMCIA=y
+# CONFIG_PCMCIA_AHA152X is not set
+CONFIG_PCMCIA_FDOMAIN=m
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+CONFIG_SCSI_OSD_INITIATOR=m
+CONFIG_SCSI_OSD_ULD=m
+CONFIG_SCSI_OSD_DPRINT_SENSE=1
+# CONFIG_SCSI_OSD_DEBUG is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=m
+CONFIG_SATA_SIL24=m
+CONFIG_ATA_SFF=y
+CONFIG_SATA_SVW=m
+CONFIG_ATA_PIIX=m
+CONFIG_SATA_MV=m
+CONFIG_SATA_NV=m
+CONFIG_PDC_ADMA=m
+CONFIG_SATA_QSTOR=m
+CONFIG_SATA_PROMISE=m
+CONFIG_SATA_SX4=m
+CONFIG_SATA_SIL=m
+CONFIG_SATA_SIS=m
+CONFIG_SATA_ULI=m
+CONFIG_SATA_VIA=m
+CONFIG_SATA_VITESSE=m
+CONFIG_SATA_INIC162X=m
+CONFIG_PATA_ACPI=m
+CONFIG_PATA_ALI=m
+CONFIG_PATA_AMD=m
+CONFIG_PATA_ARTOP=m
+CONFIG_PATA_ATP867X=m
+CONFIG_PATA_ATIIXP=m
+# CONFIG_PATA_CMD640_PCI is not set
+CONFIG_PATA_CMD64X=m
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+CONFIG_PATA_CS5535=m
+CONFIG_PATA_CS5536=m
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+CONFIG_ATA_GENERIC=m
+CONFIG_PATA_HPT366=m
+CONFIG_PATA_HPT37X=m
+CONFIG_PATA_HPT3X2N=m
+CONFIG_PATA_HPT3X3=m
+# CONFIG_PATA_HPT3X3_DMA is not set
+# CONFIG_PATA_ISAPNP is not set
+CONFIG_PATA_IT821X=m
+CONFIG_PATA_IT8213=m
+CONFIG_PATA_JMICRON=m
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_PATA_TRIFLEX is not set
+CONFIG_PATA_MARVELL=m
+# CONFIG_PATA_MPIIX is not set
+CONFIG_PATA_OLDPIIX=m
+CONFIG_PATA_NETCELL=m
+CONFIG_PATA_NINJA32=m
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+CONFIG_PATA_PCMCIA=m
+CONFIG_PATA_PDC_OLD=m
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RADISYS is not set
+CONFIG_PATA_RDC=m
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_SIS=m
+CONFIG_PATA_VIA=m
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+CONFIG_PATA_SCH=m
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+# CONFIG_MULTICORE_RAID456 is not set
+CONFIG_MD_RAID6_PQ=m
+CONFIG_ASYNC_RAID6_TEST=m
+# CONFIG_MD_MULTIPATH is not set
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+CONFIG_DM_DELAY=m
+CONFIG_DM_UEVENT=y
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=m
+CONFIG_FUSION_FC=m
+CONFIG_FUSION_SAS=m
+CONFIG_FUSION_MAX_SGE=128
+CONFIG_FUSION_CTL=m
+CONFIG_FUSION_LAN=m
+CONFIG_FUSION_LOGGING=y
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# See the help texts for more information.
+#
+CONFIG_FIREWIRE=m
+CONFIG_FIREWIRE_OHCI=m
+CONFIG_FIREWIRE_OHCI_DEBUG=y
+CONFIG_FIREWIRE_SBP2=m
+CONFIG_FIREWIRE_NET=m
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+CONFIG_MACINTOSH_DRIVERS=y
+CONFIG_MAC_EMUMOUSEBTN=y
+CONFIG_NETDEVICES=y
+CONFIG_IFB=m
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
+CONFIG_MACVLAN=m
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+CONFIG_VETH=m
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SMSC_PHY=m
+CONFIG_BROADCOM_PHY=m
+CONFIG_ICPLUS_PHY=m
+CONFIG_REALTEK_PHY=m
+CONFIG_NATIONAL_PHY=m
+CONFIG_STE10XP=m
+CONFIG_LSI_ET1011C_PHY=m
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=m
+# CONFIG_MDIO_GPIO is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+CONFIG_HAPPYMEAL=m
+CONFIG_SUNGEM=m
+CONFIG_CASSINI=m
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_EL1 is not set
+# CONFIG_EL2 is not set
+# CONFIG_ELPLUS is not set
+# CONFIG_EL16 is not set
+CONFIG_EL3=m
+# CONFIG_3C515 is not set
+CONFIG_VORTEX=m
+CONFIG_TYPHOON=m
+# CONFIG_LANCE is not set
+CONFIG_NET_VENDOR_SMC=y
+# CONFIG_WD80x3 is not set
+CONFIG_ULTRA=m
+# CONFIG_SMC9194 is not set
+CONFIG_ETHOC=m
+# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_DNET=m
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=m
+CONFIG_DE2104X_DSL=0
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+CONFIG_TULIP_MMIO=y
+# CONFIG_TULIP_NAPI is not set
+CONFIG_DE4X5=m
+CONFIG_WINBOND_840=m
+CONFIG_DM9102=m
+CONFIG_ULI526X=m
+CONFIG_PCMCIA_XIRCOM=m
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_ISA=y
+# CONFIG_E2100 is not set
+CONFIG_EWRK3=m
+# CONFIG_EEXPRESS is not set
+# CONFIG_EEXPRESS_PRO is not set
+# CONFIG_HPLAN_PLUS is not set
+# CONFIG_HPLAN is not set
+# CONFIG_LP486E is not set
+# CONFIG_ETH16I is not set
+CONFIG_NE2000=m
+# CONFIG_ZNET is not set
+# CONFIG_SEEQ8005 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+CONFIG_AMD8111_ETH=m
+CONFIG_ADAPTEC_STARFIRE=m
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+CONFIG_B44=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_B44_PCI=y
+CONFIG_FORCEDETH=m
+# CONFIG_FORCEDETH_NAPI is not set
+# CONFIG_CS89x0 is not set
+CONFIG_E100=m
+CONFIG_FEALNX=m
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_R6040=m
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SMSC9420=m
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_TLAN=m
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_VIA_RHINE=m
+CONFIG_VIA_RHINE_MMIO=y
+CONFIG_SC92031=m
+CONFIG_NET_POCKET=y
+# CONFIG_ATP is not set
+# CONFIG_DE600 is not set
+# CONFIG_DE620 is not set
+CONFIG_ATL2=m
+CONFIG_NETDEV_1000=y
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_DL2K=m
+CONFIG_E1000=m
+CONFIG_E1000E=m
+CONFIG_IP1000=m
+CONFIG_IGB=m
+CONFIG_IGB_DCA=y
+CONFIG_IGBVF=m
+CONFIG_NS83820=m
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=m
+# CONFIG_R8169_VLAN is not set
+CONFIG_SIS190=m
+CONFIG_SKGE=m
+# CONFIG_SKGE_DEBUG is not set
+CONFIG_SKY2=m
+# CONFIG_SKY2_DEBUG is not set
+CONFIG_VIA_VELOCITY=m
+CONFIG_TIGON3=m
+CONFIG_BNX2=m
+CONFIG_CNIC=m
+CONFIG_QLA3XXX=m
+CONFIG_ATL1=m
+CONFIG_ATL1E=m
+CONFIG_ATL1C=m
+CONFIG_JME=m
+CONFIG_NETDEV_10000=y
+CONFIG_MDIO=m
+CONFIG_CHELSIO_T1=m
+CONFIG_CHELSIO_T1_1G=y
+CONFIG_CHELSIO_T3_DEPENDS=y
+CONFIG_CHELSIO_T3=m
+CONFIG_ENIC=m
+CONFIG_IXGBE=m
+CONFIG_IXGBE_DCA=y
+CONFIG_IXGBE_DCB=y
+CONFIG_IXGB=m
+CONFIG_S2IO=m
+CONFIG_VXGE=m
+# CONFIG_VXGE_DEBUG_TRACE_ALL is not set
+CONFIG_MYRI10GE=m
+CONFIG_MYRI10GE_DCA=y
+CONFIG_NETXEN_NIC=m
+CONFIG_NIU=m
+CONFIG_MLX4_EN=m
+CONFIG_MLX4_CORE=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_TEHUTI=m
+CONFIG_BNX2X=m
+CONFIG_QLGE=m
+CONFIG_SFC=m
+CONFIG_SFC_MTD=y
+CONFIG_BE2NET=m
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_PCMCIA_RAYCS is not set
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_CS=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_LIBERTAS_DEBUG=y
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_AIRO=m
+CONFIG_ATMEL=m
+CONFIG_PCI_ATMEL=m
+CONFIG_PCMCIA_ATMEL=m
+CONFIG_AT76C50X_USB=m
+CONFIG_AIRO_CS=m
+CONFIG_PCMCIA_WL3501=m
+# CONFIG_PRISM54 is not set
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8180=m
+CONFIG_RTL8187=m
+CONFIG_RTL8187_LEDS=y
+CONFIG_ADM8211=m
+CONFIG_MAC80211_HWSIM=m
+CONFIG_MWL8K=m
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_P54_PCI=m
+CONFIG_P54_LEDS=y
+CONFIG_ATH_COMMON=m
+CONFIG_ATH5K=m
+# CONFIG_ATH5K_DEBUG is not set
+CONFIG_ATH9K=m
+# CONFIG_ATH9K_DEBUG is not set
+# CONFIG_AR9170_USB is not set
+CONFIG_IPW2100=m
+CONFIG_IPW2100_MONITOR=y
+# CONFIG_IPW2100_DEBUG is not set
+CONFIG_IPW2200=m
+CONFIG_IPW2200_MONITOR=y
+CONFIG_IPW2200_RADIOTAP=y
+CONFIG_IPW2200_PROMISCUOUS=y
+CONFIG_IPW2200_QOS=y
+# CONFIG_IPW2200_DEBUG is not set
+CONFIG_LIBIPW=m
+# CONFIG_LIBIPW_DEBUG is not set
+CONFIG_IWLWIFI=m
+CONFIG_IWLWIFI_LEDS=y
+# CONFIG_IWLWIFI_SPECTRUM_MEASUREMENT is not set
+# CONFIG_IWLWIFI_DEBUG is not set
+# CONFIG_IWLAGN is not set
+CONFIG_IWL3945=m
+# CONFIG_IWL3945_SPECTRUM_MEASUREMENT is not set
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+CONFIG_HOSTAP_PLX=m
+CONFIG_HOSTAP_PCI=m
+CONFIG_HOSTAP_CS=m
+CONFIG_B43=m
+CONFIG_B43_PCI_AUTOSELECT=y
+CONFIG_B43_PCICORE_AUTOSELECT=y
+CONFIG_B43_PCMCIA=y
+CONFIG_B43_SDIO=y
+CONFIG_B43_PIO=y
+CONFIG_B43_PHY_LP=y
+CONFIG_B43_LEDS=y
+CONFIG_B43_HWRNG=y
+CONFIG_B43_DEBUG=y
+# CONFIG_B43_FORCE_PIO is not set
+CONFIG_B43LEGACY=m
+CONFIG_B43LEGACY_PCI_AUTOSELECT=y
+CONFIG_B43LEGACY_PCICORE_AUTOSELECT=y
+CONFIG_B43LEGACY_LEDS=y
+CONFIG_B43LEGACY_HWRNG=y
+CONFIG_B43LEGACY_DEBUG=y
+CONFIG_B43LEGACY_DMA=y
+CONFIG_B43LEGACY_PIO=y
+CONFIG_B43LEGACY_DMA_AND_PIO_MODE=y
+# CONFIG_B43LEGACY_DMA_MODE is not set
+# CONFIG_B43LEGACY_PIO_MODE is not set
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+CONFIG_RT2X00=m
+CONFIG_RT2400PCI=m
+CONFIG_RT2500PCI=m
+CONFIG_RT61PCI=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2X00_LIB_PCI=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_HT=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+CONFIG_HERMES=m
+CONFIG_HERMES_CACHE_FW_ON_INIT=y
+CONFIG_PLX_HERMES=m
+CONFIG_TMD_HERMES=m
+CONFIG_NORTEL_HERMES=m
+CONFIG_PCI_HERMES=m
+CONFIG_PCMCIA_HERMES=m
+CONFIG_PCMCIA_SPECTRUM=m
+CONFIG_WL12XX=m
+CONFIG_WL1251=m
+CONFIG_WL1251_SDIO=m
+# CONFIG_IWM is not set
+
+#
+# WiMAX Wireless Broadband devices
+#
+CONFIG_WIMAX_I2400M=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_WIMAX_I2400M_SDIO=m
+CONFIG_WIMAX_I2400M_DEBUG_LEVEL=8
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_CDC_PHONET=m
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_PCMCIA_XIRC2PS=m
+CONFIG_PCMCIA_AXNET=m
+CONFIG_WAN=y
+# CONFIG_HOSTESS_SV11 is not set
+# CONFIG_COSA is not set
+# CONFIG_LANMEDIA is not set
+# CONFIG_SEALEVEL_4021 is not set
+CONFIG_HDLC=m
+CONFIG_HDLC_RAW=m
+# CONFIG_HDLC_RAW_ETH is not set
+CONFIG_HDLC_CISCO=m
+CONFIG_HDLC_FR=m
+CONFIG_HDLC_PPP=m
+
+#
+# X.25/LAPB support is disabled
+#
+# CONFIG_PCI200SYN is not set
+# CONFIG_WANXL is not set
+# CONFIG_PC300TOO is not set
+# CONFIG_N2 is not set
+# CONFIG_C101 is not set
+# CONFIG_FARSYNC is not set
+# CONFIG_DSCC4 is not set
+CONFIG_DLCI=m
+CONFIG_DLCI_MAX=8
+# CONFIG_SDLA is not set
+# CONFIG_SBNI is not set
+CONFIG_ATM_DRIVERS=y
+# CONFIG_ATM_DUMMY is not set
+CONFIG_ATM_TCP=m
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_FORE200E is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_ATM_SOLOS is not set
+CONFIG_IEEE802154_DRIVERS=m
+CONFIG_IEEE802154_FAKEHARD=m
+CONFIG_XEN_NETDEV_FRONTEND=m
+CONFIG_FDDI=y
+# CONFIG_DEFXX is not set
+# CONFIG_SKFP is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPP_MPPE=m
+CONFIG_PPPOE=m
+CONFIG_PPPOATM=m
+CONFIG_PPPOL2TP=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLHC=m
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+CONFIG_NET_FC=y
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_NETPOLL=y
+CONFIG_NETPOLL_TRAP=y
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_VIRTIO_NET=m
+CONFIG_VMXNET3=m
+CONFIG_ISDN=y
+CONFIG_ISDN_I4L=m
+CONFIG_MISDN=m
+CONFIG_MISDN_DSP=m
+CONFIG_MISDN_L1OIP=m
+
+#
+# mISDN hardware drivers
+#
+CONFIG_MISDN_HFCPCI=m
+CONFIG_MISDN_HFCMULTI=m
+CONFIG_MISDN_HFCUSB=m
+CONFIG_MISDN_AVMFRITZ=m
+CONFIG_MISDN_SPEEDFAX=m
+CONFIG_MISDN_INFINEON=m
+CONFIG_MISDN_W6692=m
+CONFIG_MISDN_NETJET=m
+CONFIG_MISDN_IPAC=m
+CONFIG_MISDN_ISAR=m
+CONFIG_ISDN_PPP=y
+CONFIG_ISDN_PPP_VJ=y
+CONFIG_ISDN_MPP=y
+CONFIG_IPPP_FILTER=y
+# CONFIG_ISDN_PPP_BSDCOMP is not set
+CONFIG_ISDN_AUDIO=y
+CONFIG_ISDN_TTY_FAX=y
+
+#
+# ISDN feature submodules
+#
+CONFIG_ISDN_DIVERSION=m
+
+#
+# ISDN4Linux hardware drivers
+#
+
+#
+# Passive cards
+#
+CONFIG_ISDN_DRV_HISAX=m
+
+#
+# D-channel protocol features
+#
+CONFIG_HISAX_EURO=y
+CONFIG_DE_AOC=y
+CONFIG_HISAX_NO_SENDCOMPLETE=y
+CONFIG_HISAX_NO_LLC=y
+CONFIG_HISAX_NO_KEYPAD=y
+CONFIG_HISAX_1TR6=y
+CONFIG_HISAX_NI1=y
+CONFIG_HISAX_MAX_CARDS=8
+
+#
+# HiSax supported cards
+#
+# CONFIG_HISAX_16_0 is not set
+CONFIG_HISAX_16_3=y
+CONFIG_HISAX_TELESPCI=y
+CONFIG_HISAX_S0BOX=y
+# CONFIG_HISAX_AVM_A1 is not set
+CONFIG_HISAX_FRITZPCI=y
+CONFIG_HISAX_AVM_A1_PCMCIA=y
+CONFIG_HISAX_ELSA=y
+# CONFIG_HISAX_IX1MICROR2 is not set
+CONFIG_HISAX_DIEHLDIVA=y
+# CONFIG_HISAX_ASUSCOM is not set
+# CONFIG_HISAX_TELEINT is not set
+# CONFIG_HISAX_HFCS is not set
+CONFIG_HISAX_SEDLBAUER=y
+# CONFIG_HISAX_SPORTSTER is not set
+# CONFIG_HISAX_MIC is not set
+CONFIG_HISAX_NETJET=y
+CONFIG_HISAX_NETJET_U=y
+CONFIG_HISAX_NICCY=y
+# CONFIG_HISAX_ISURF is not set
+# CONFIG_HISAX_HSTSAPHIR is not set
+CONFIG_HISAX_BKM_A4T=y
+CONFIG_HISAX_SCT_QUADRO=y
+CONFIG_HISAX_GAZEL=y
+CONFIG_HISAX_HFC_PCI=y
+CONFIG_HISAX_W6692=y
+CONFIG_HISAX_HFC_SX=y
+CONFIG_HISAX_ENTERNOW_PCI=y
+# CONFIG_HISAX_DEBUG is not set
+
+#
+# HiSax PCMCIA card service modules
+#
+CONFIG_HISAX_SEDLBAUER_CS=m
+CONFIG_HISAX_ELSA_CS=m
+CONFIG_HISAX_AVM_A1_CS=m
+CONFIG_HISAX_TELES_CS=m
+
+#
+# HiSax sub driver modules
+#
+CONFIG_HISAX_ST5481=m
+# CONFIG_HISAX_HFCUSB is not set
+CONFIG_HISAX_HFC4S8S=m
+CONFIG_HISAX_FRITZ_PCIPNP=m
+
+#
+# Active cards
+#
+# CONFIG_ISDN_DRV_ICN is not set
+# CONFIG_ISDN_DRV_PCBIT is not set
+# CONFIG_ISDN_DRV_SC is not set
+# CONFIG_ISDN_DRV_ACT2000 is not set
+CONFIG_HYSDN=m
+CONFIG_HYSDN_CAPI=y
+CONFIG_ISDN_HDLC=m
+CONFIG_ISDN_CAPI=m
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON=y
+# CONFIG_CAPI_TRACE is not set
+CONFIG_ISDN_CAPI_MIDDLEWARE=y
+CONFIG_ISDN_CAPI_CAPI20=m
+CONFIG_ISDN_CAPI_CAPIFS_BOOL=y
+CONFIG_ISDN_CAPI_CAPIFS=m
+CONFIG_ISDN_CAPI_CAPIDRV=m
+
+#
+# CAPI hardware drivers
+#
+CONFIG_CAPI_AVM=y
+# CONFIG_ISDN_DRV_AVMB1_B1ISA is not set
+CONFIG_ISDN_DRV_AVMB1_B1PCI=m
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4=y
+# CONFIG_ISDN_DRV_AVMB1_T1ISA is not set
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA=m
+CONFIG_ISDN_DRV_AVMB1_AVM_CS=m
+CONFIG_ISDN_DRV_AVMB1_T1PCI=m
+CONFIG_ISDN_DRV_AVMB1_C4=m
+# CONFIG_CAPI_EICON is not set
+CONFIG_ISDN_DRV_GIGASET=m
+CONFIG_GIGASET_BASE=m
+CONFIG_GIGASET_M105=m
+CONFIG_GIGASET_M101=m
+# CONFIG_GIGASET_DEBUG is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=m
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_XEN_KBDDEV_FRONTEND=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ADP5588=m
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_QT2160=m
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+CONFIG_KEYBOARD_MAX7359=m
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_KEYBOARD_OPENCORES=m
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_OLPC=y
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+CONFIG_MOUSE_VSXXXAA=m
+# CONFIG_MOUSE_GPIO is not set
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_EETI=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_HTCPEN=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+CONFIG_TOUCHSCREEN_TSC2007=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PCSPKR=m
+CONFIG_INPUT_APANEL=m
+CONFIG_INPUT_WISTRON_BTNS=m
+CONFIG_INPUT_ATLAS_BTNS=m
+CONFIG_INPUT_ATI_REMOTE=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_WINBOND_CIR=m
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_INPUT_WM831X_ON=m
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+CONFIG_CYCLADES=m
+# CONFIG_CYZ_INTR is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+CONFIG_SYNCLINK=m
+CONFIG_SYNCLINKMP=m
+CONFIG_SYNCLINK_GT=m
+CONFIG_N_HDLC=m
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_STALDRV is not set
+CONFIG_NOZOMI=m
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CS=m
+CONFIG_SERIAL_8250_NR_UARTS=64
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+# CONFIG_SERIAL_8250_FOURPORT is not set
+# CONFIG_SERIAL_8250_ACCENT is not set
+# CONFIG_SERIAL_8250_BOCA is not set
+# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+CONFIG_SERIAL_JSM=m
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_PRINTER=m
+# CONFIG_LP_CONSOLE is not set
+CONFIG_PPDEV=m
+CONFIG_HVC_DRIVER=y
+CONFIG_HVC_IRQ=y
+CONFIG_HVC_XEN=y
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=m
+CONFIG_HW_RANDOM_INTEL=m
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_GEODE=m
+CONFIG_HW_RANDOM_VIA=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_NVRAM=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+CONFIG_SONYPI=m
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+CONFIG_CARDMAN_4000=m
+CONFIG_CARDMAN_4040=m
+CONFIG_IPWIRELESS=m
+# CONFIG_MWAVE is not set
+CONFIG_PC8736x_GPIO=m
+CONFIG_NSC_GPIO=m
+CONFIG_CS5535_GPIO=m
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=8192
+CONFIG_HPET=y
+# CONFIG_HPET_MMAP is not set
+CONFIG_HANGCHECK_TIMER=m
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS=y
+CONFIG_TCG_NSC=m
+CONFIG_TCG_ATMEL=m
+CONFIG_TCG_INFINEON=m
+CONFIG_TELCLOCK=m
+CONFIG_DEVPORT=y
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+CONFIG_I2C_ALGOPCA=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=m
+CONFIG_I2C_ALI1563=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_I2C_AMD756=m
+CONFIG_I2C_AMD756_S4882=m
+CONFIG_I2C_AMD8111=m
+CONFIG_I2C_I801=m
+CONFIG_I2C_ISCH=m
+CONFIG_I2C_PIIX4=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_I2C_NFORCE2_S4985=m
+CONFIG_I2C_SIS5595=m
+CONFIG_I2C_SIS630=m
+CONFIG_I2C_SIS96X=m
+CONFIG_I2C_VIA=m
+CONFIG_I2C_VIAPRO=m
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=m
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_SIMTEC=m
+
+#
+# External I2C/SMBus adapter drivers
+#
+CONFIG_I2C_PARPORT=m
+CONFIG_I2C_PARPORT_LIGHT=m
+# CONFIG_I2C_TAOS_EVM is not set
+CONFIG_I2C_TINY_USB=m
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+CONFIG_I2C_VOODOO3=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_ISA is not set
+CONFIG_I2C_PCA_PLATFORM=m
+CONFIG_I2C_STUB=m
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+CONFIG_SENSORS_TSL2550=m
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_WM831X is not set
+
+#
+# PCI GPIO expanders:
+#
+CONFIG_GPIO_LANGWELL=y
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_WM831X_POWER=m
+CONFIG_WM8350_POWER=m
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+CONFIG_BATTERY_OLPC=y
+CONFIG_BATTERY_BQ27x00=m
+CONFIG_BATTERY_MAX17040=m
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=m
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_ABITUGURU=m
+CONFIG_SENSORS_ABITUGURU3=m
+CONFIG_SENSORS_AD7414=m
+CONFIG_SENSORS_AD7418=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_SENSORS_ADM1025=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_SENSORS_ADM1029=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_SENSORS_ADM9240=m
+CONFIG_SENSORS_ADT7462=m
+CONFIG_SENSORS_ADT7470=m
+CONFIG_SENSORS_ADT7473=m
+CONFIG_SENSORS_ADT7475=m
+CONFIG_SENSORS_K8TEMP=m
+CONFIG_SENSORS_ASB100=m
+CONFIG_SENSORS_ATXP1=m
+CONFIG_SENSORS_DS1621=m
+CONFIG_SENSORS_I5K_AMB=m
+CONFIG_SENSORS_F71805F=m
+CONFIG_SENSORS_F71882FG=m
+CONFIG_SENSORS_F75375S=m
+CONFIG_SENSORS_FSCHMD=m
+CONFIG_SENSORS_G760A=m
+CONFIG_SENSORS_GL518SM=m
+CONFIG_SENSORS_GL520SM=m
+CONFIG_SENSORS_CORETEMP=m
+CONFIG_SENSORS_IBMAEM=m
+CONFIG_SENSORS_IBMPEX=m
+CONFIG_SENSORS_IT87=m
+CONFIG_SENSORS_LM63=m
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM77=m
+CONFIG_SENSORS_LM78=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SENSORS_LM83=m
+CONFIG_SENSORS_LM85=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM93=m
+CONFIG_SENSORS_LTC4215=m
+CONFIG_SENSORS_LTC4245=m
+CONFIG_SENSORS_LM95241=m
+CONFIG_SENSORS_MAX1619=m
+CONFIG_SENSORS_MAX6650=m
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_SENSORS_PCF8591=m
+CONFIG_SENSORS_SHT15=m
+CONFIG_SENSORS_SIS5595=m
+CONFIG_SENSORS_DME1737=m
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_SENSORS_SMSC47B397=m
+CONFIG_SENSORS_ADS7828=m
+CONFIG_SENSORS_THMC50=m
+CONFIG_SENSORS_TMP401=m
+CONFIG_SENSORS_TMP421=m
+CONFIG_SENSORS_VIA686A=m
+CONFIG_SENSORS_VT1211=m
+CONFIG_SENSORS_VT8231=m
+CONFIG_SENSORS_W83781D=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_SENSORS_W83792D=m
+CONFIG_SENSORS_W83793=m
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_SENSORS_W83L786NG=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_SENSORS_WM831X=m
+CONFIG_SENSORS_WM8350=m
+CONFIG_SENSORS_HDAPS=m
+CONFIG_SENSORS_APPLESMC=m
+
+#
+# ACPI drivers
+#
+CONFIG_SENSORS_ATK0110=m
+CONFIG_SENSORS_LIS3LV02D=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_WM831X_WATCHDOG=m
+CONFIG_WM8350_WATCHDOG=m
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+CONFIG_ALIM1535_WDT=m
+CONFIG_ALIM7101_WDT=m
+# CONFIG_SC520_WDT is not set
+CONFIG_SBC_FITPC2_WATCHDOG=m
+# CONFIG_EUROTECH_WDT is not set
+CONFIG_IB700_WDT=m
+CONFIG_IBMASR=m
+# CONFIG_WAFER_WDT is not set
+CONFIG_I6300ESB_WDT=m
+CONFIG_ITCO_WDT=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+CONFIG_IT8712F_WDT=m
+CONFIG_IT87_WDT=m
+CONFIG_HP_WATCHDOG=m
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_SBC8360_WDT is not set
+# CONFIG_SBC7240_WDT is not set
+# CONFIG_CPU5_WDT is not set
+CONFIG_SMSC_SCH311X_WDT=m
+# CONFIG_SMSC37B787_WDT is not set
+CONFIG_W83627HF_WDT=m
+CONFIG_W83697HF_WDT=m
+CONFIG_W83697UG_WDT=m
+CONFIG_W83877F_WDT=m
+CONFIG_W83977F_WDT=m
+CONFIG_MACHZ_WDT=m
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+
+#
+# ISA-based Watchdog Cards
+#
+# CONFIG_PCWATCHDOG is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+CONFIG_PCIPCWATCHDOG=m
+CONFIG_WDTPCI=m
+
+#
+# USB-based Watchdog Cards
+#
+CONFIG_USBPCWATCHDOG=m
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_BLOCKIO=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+CONFIG_SSB_B43_PCI_BRIDGE=y
+CONFIG_SSB_PCMCIAHOST_POSSIBLE=y
+CONFIG_SSB_PCMCIAHOST=y
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+CONFIG_SSB_SDIOHOST=y
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=m
+CONFIG_MFD_SM501=m
+CONFIG_MFD_SM501_GPIO=y
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_MFD_TMIO is not set
+CONFIG_MFD_WM8400=m
+CONFIG_MFD_WM831X=m
+CONFIG_MFD_WM8350=m
+CONFIG_MFD_WM8350_I2C=m
+# CONFIG_MFD_PCF50633 is not set
+CONFIG_AB3100_CORE=m
+CONFIG_AB3100_OTP=m
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=m
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+CONFIG_REGULATOR_USERSPACE_CONSUMER=m
+CONFIG_REGULATOR_BQ24022=m
+CONFIG_REGULATOR_MAX1586=m
+CONFIG_REGULATOR_WM831X=m
+CONFIG_REGULATOR_WM8350=m
+CONFIG_REGULATOR_WM8400=m
+CONFIG_REGULATOR_LP3971=m
+CONFIG_REGULATOR_AB3100=m
+CONFIG_REGULATOR_TPS65023=m
+CONFIG_REGULATOR_TPS6507X=m
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_DVB_CORE=m
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+CONFIG_VIDEO_SAA7146=m
+CONFIG_VIDEO_SAA7146_VV=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_V4L1=m
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_DMA_SG=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_VIDEOBUF_DVB=m
+CONFIG_VIDEO_BTCX=m
+CONFIG_VIDEO_IR=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_VIDEO_TUNER=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=m
+CONFIG_VIDEO_TVAUDIO=m
+CONFIG_VIDEO_TDA7432=m
+CONFIG_VIDEO_MSP3400=m
+CONFIG_VIDEO_CS5345=m
+CONFIG_VIDEO_CS53L32A=m
+CONFIG_VIDEO_M52790=m
+CONFIG_VIDEO_WM8775=m
+CONFIG_VIDEO_WM8739=m
+CONFIG_VIDEO_VP27SMPX=m
+CONFIG_VIDEO_SAA6588=m
+CONFIG_VIDEO_OV7670=m
+CONFIG_VIDEO_MT9V011=m
+CONFIG_VIDEO_SAA711X=m
+CONFIG_VIDEO_SAA717X=m
+CONFIG_VIDEO_TVP5150=m
+CONFIG_VIDEO_CX25840=m
+CONFIG_VIDEO_CX2341X=m
+CONFIG_VIDEO_SAA7127=m
+CONFIG_VIDEO_UPD64031A=m
+CONFIG_VIDEO_UPD64083=m
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_BT848=m
+CONFIG_VIDEO_BT848_DVB=y
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_W9966 is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_MEYE is not set
+CONFIG_VIDEO_SAA7134=m
+CONFIG_VIDEO_SAA7134_ALSA=m
+CONFIG_VIDEO_SAA7134_DVB=m
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+CONFIG_VIDEO_CX88=m
+CONFIG_VIDEO_CX88_ALSA=m
+CONFIG_VIDEO_CX88_BLACKBIRD=m
+CONFIG_VIDEO_CX88_DVB=m
+CONFIG_VIDEO_CX88_MPEG=m
+CONFIG_VIDEO_CX88_VP3054=m
+CONFIG_VIDEO_CX23885=m
+CONFIG_VIDEO_AU0828=m
+CONFIG_VIDEO_IVTV=m
+CONFIG_VIDEO_FB_IVTV=m
+CONFIG_VIDEO_CX18=m
+CONFIG_VIDEO_SAA7164=m
+CONFIG_VIDEO_CAFE_CCIC=m
+CONFIG_SOC_CAMERA=m
+CONFIG_SOC_CAMERA_MT9M001=m
+CONFIG_SOC_CAMERA_MT9M111=m
+CONFIG_SOC_CAMERA_MT9T031=m
+CONFIG_SOC_CAMERA_MT9V022=m
+CONFIG_SOC_CAMERA_TW9910=m
+CONFIG_SOC_CAMERA_PLATFORM=m
+CONFIG_SOC_CAMERA_OV772X=m
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SN9C20X=m
+# CONFIG_USB_GSPCA_SN9C20X_EVDEV is not set
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+CONFIG_VIDEO_PVRUSB2_DVB=y
+# CONFIG_VIDEO_PVRUSB2_DEBUGIFC is not set
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_USBVISION=m
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+CONFIG_USB_PWC=m
+# CONFIG_USB_PWC_DEBUG is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+CONFIG_DVB_DYNAMIC_MINORS=y
+CONFIG_DVB_CAPTURE_DRIVERS=y
+
+#
+# Supported SAA7146 based PCI Adapters
+#
+CONFIG_TTPCI_EEPROM=m
+CONFIG_DVB_AV7110=m
+CONFIG_DVB_AV7110_OSD=y
+CONFIG_DVB_BUDGET_CORE=m
+CONFIG_DVB_BUDGET=m
+CONFIG_DVB_BUDGET_CI=m
+CONFIG_DVB_BUDGET_AV=m
+CONFIG_DVB_BUDGET_PATCH=m
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=m
+# CONFIG_DVB_USB_DEBUG is not set
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+# CONFIG_DVB_USB_DIBUSB_MB_FAULTY is not set
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_TTUSB_BUDGET=m
+CONFIG_DVB_TTUSB_DEC=m
+CONFIG_SMS_SIANO_MDTV=m
+
+#
+# Siano module components
+#
+CONFIG_SMS_USB_DRV=m
+CONFIG_SMS_SDIO_DRV=m
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+CONFIG_DVB_B2C2_FLEXCOP=m
+CONFIG_DVB_B2C2_FLEXCOP_PCI=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+# CONFIG_DVB_B2C2_FLEXCOP_DEBUG is not set
+
+#
+# Supported BT878 Adapters
+#
+CONFIG_DVB_BT8XX=m
+
+#
+# Supported Pluto2 Adapters
+#
+CONFIG_DVB_PLUTO2=m
+
+#
+# Supported SDMC DM1105 Adapters
+#
+CONFIG_DVB_DM1105=m
+
+#
+# Supported Earthsoft PT1 Adapters
+#
+CONFIG_DVB_PT1=m
+
+#
+# Supported DVB Frontends
+#
+# CONFIG_DVB_FE_CUSTOMISE is not set
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_ZL10039=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_SP8870=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_AF9013=m
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0297=m
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_S5H1411=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_LGS8GL5=m
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_ALI=y
+CONFIG_AGP_ATI=y
+CONFIG_AGP_AMD=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+CONFIG_AGP_NVIDIA=y
+CONFIG_AGP_SIS=y
+CONFIG_AGP_SWORKS=y
+CONFIG_AGP_VIA=y
+CONFIG_AGP_EFFICEON=y
+CONFIG_VGA_ARB=y
+CONFIG_DRM=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_DRM_TTM=m
+# CONFIG_DRM_TDFX is not set
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I830 is not set
+CONFIG_DRM_I915=m
+# CONFIG_DRM_I915_KMS is not set
+CONFIG_DRM_MGA=m
+CONFIG_DRM_SIS=m
+CONFIG_DRM_VIA=m
+CONFIG_DRM_SAVAGE=m
+CONFIG_VGASTATE=m
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_DDC=m
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_CIRRUS=m
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+CONFIG_FB_VGA16=m
+# CONFIG_FB_UVESA is not set
+CONFIG_FB_VESA=y
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_NVIDIA=m
+CONFIG_FB_NVIDIA_I2C=y
+# CONFIG_FB_NVIDIA_DEBUG is not set
+CONFIG_FB_NVIDIA_BACKLIGHT=y
+CONFIG_FB_RIVA=m
+# CONFIG_FB_RIVA_I2C is not set
+# CONFIG_FB_RIVA_DEBUG is not set
+CONFIG_FB_RIVA_BACKLIGHT=y
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+CONFIG_FB_RADEON=m
+CONFIG_FB_RADEON_I2C=y
+CONFIG_FB_RADEON_BACKLIGHT=y
+# CONFIG_FB_RADEON_DEBUG is not set
+CONFIG_FB_ATY128=m
+CONFIG_FB_ATY128_BACKLIGHT=y
+CONFIG_FB_ATY=m
+CONFIG_FB_ATY_CT=y
+CONFIG_FB_ATY_GENERIC_LCD=y
+CONFIG_FB_ATY_GX=y
+CONFIG_FB_ATY_BACKLIGHT=y
+# CONFIG_FB_S3 is not set
+CONFIG_FB_SAVAGE=m
+CONFIG_FB_SAVAGE_I2C=y
+CONFIG_FB_SAVAGE_ACCEL=y
+# CONFIG_FB_SIS is not set
+CONFIG_FB_VIA=m
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_GEODE=y
+CONFIG_FB_GEODE_LX=y
+CONFIG_FB_GEODE_GX=y
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+CONFIG_FB_SM501=m
+CONFIG_FB_VIRTUAL=m
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PROGEAR=m
+CONFIG_BACKLIGHT_MBP_NVIDIA=m
+# CONFIG_BACKLIGHT_SAHARA is not set
+CONFIG_BACKLIGHT_WM831X=m
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=m
+
+#
+# Display hardware drivers
+#
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=m
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+CONFIG_SND_RAWMIDI_SEQ=m
+CONFIG_SND_OPL3_LIB_SEQ=m
+CONFIG_SND_OPL4_LIB_SEQ=m
+# CONFIG_SND_SBAWE_SEQ is not set
+CONFIG_SND_EMU10K1_SEQ=m
+CONFIG_SND_MPU401_UART=m
+CONFIG_SND_OPL3_LIB=m
+CONFIG_SND_OPL4_LIB=m
+CONFIG_SND_VX_LIB=m
+CONFIG_SND_AC97_CODEC=m
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_PCSP=m
+CONFIG_SND_DUMMY=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+CONFIG_SND_MPU401=m
+# CONFIG_SND_PORTMAN2X4 is not set
+CONFIG_SND_AC97_POWER_SAVE=y
+CONFIG_SND_AC97_POWER_SAVE_DEFAULT=5
+CONFIG_SND_WSS_LIB=m
+CONFIG_SND_SB_COMMON=m
+CONFIG_SND_SB16_DSP=m
+CONFIG_SND_ISA=y
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_AD1816A is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_ALS100 is not set
+# CONFIG_SND_AZT2320 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_DT019X is not set
+# CONFIG_SND_ES968 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_SC6000 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_INTERWAVE is not set
+# CONFIG_SND_INTERWAVE_STB is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+CONFIG_SND_MIRO=m
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SGALAXY is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_WAVEFRONT is not set
+# CONFIG_SND_MSND_PINNACLE is not set
+# CONFIG_SND_MSND_CLASSIC is not set
+CONFIG_SND_PCI=y
+CONFIG_SND_AD1889=m
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+CONFIG_SND_ALI5451=m
+CONFIG_SND_ATIIXP=m
+CONFIG_SND_ATIIXP_MODEM=m
+CONFIG_SND_AU8810=m
+CONFIG_SND_AU8820=m
+CONFIG_SND_AU8830=m
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+CONFIG_SND_BT87X=m
+# CONFIG_SND_BT87X_OVERCLOCK is not set
+CONFIG_SND_CA0106=m
+CONFIG_SND_CMIPCI=m
+CONFIG_SND_OXYGEN_LIB=m
+CONFIG_SND_OXYGEN=m
+# CONFIG_SND_CS4281 is not set
+CONFIG_SND_CS46XX=m
+CONFIG_SND_CS46XX_NEW_DSP=y
+CONFIG_SND_CS5530=m
+CONFIG_SND_CS5535AUDIO=m
+CONFIG_SND_CTXFI=m
+CONFIG_SND_DARLA20=m
+CONFIG_SND_GINA20=m
+CONFIG_SND_LAYLA20=m
+CONFIG_SND_DARLA24=m
+CONFIG_SND_GINA24=m
+CONFIG_SND_LAYLA24=m
+CONFIG_SND_MONA=m
+CONFIG_SND_MIA=m
+CONFIG_SND_ECHO3G=m
+CONFIG_SND_INDIGO=m
+CONFIG_SND_INDIGOIO=m
+CONFIG_SND_INDIGODJ=m
+CONFIG_SND_INDIGOIOX=m
+CONFIG_SND_INDIGODJX=m
+CONFIG_SND_EMU10K1=m
+CONFIG_SND_EMU10K1X=m
+CONFIG_SND_ENS1370=m
+CONFIG_SND_ENS1371=m
+# CONFIG_SND_ES1938 is not set
+CONFIG_SND_ES1968=m
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_HDA_HWDEP=y
+CONFIG_SND_HDA_RECONFIG=y
+CONFIG_SND_HDA_INPUT_BEEP=y
+CONFIG_SND_HDA_INPUT_JACK=y
+CONFIG_SND_HDA_PATCH_LOADER=y
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+CONFIG_SND_HDSP=m
+CONFIG_SND_HDSPM=m
+# CONFIG_SND_HIFIER is not set
+CONFIG_SND_ICE1712=m
+CONFIG_SND_ICE1724=m
+CONFIG_SND_INTEL8X0=m
+CONFIG_SND_INTEL8X0M=m
+CONFIG_SND_KORG1212=m
+CONFIG_SND_LX6464ES=m
+CONFIG_SND_MAESTRO3=m
+CONFIG_SND_MIXART=m
+# CONFIG_SND_NM256 is not set
+CONFIG_SND_PCXHR=m
+# CONFIG_SND_RIPTIDE is not set
+CONFIG_SND_RME32=m
+CONFIG_SND_RME96=m
+CONFIG_SND_RME9652=m
+CONFIG_SND_SIS7019=m
+# CONFIG_SND_SONICVIBES is not set
+CONFIG_SND_TRIDENT=m
+CONFIG_SND_VIA82XX=m
+CONFIG_SND_VIA82XX_MODEM=m
+CONFIG_SND_VIRTUOSO=m
+CONFIG_SND_VX222=m
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_USX2Y=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_SND_USB_US122L=m
+CONFIG_SND_PCMCIA=y
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=m
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=m
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+CONFIG_USB_WUSB=m
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+CONFIG_USB_ISP1362_HCD=m
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_U132_HCD=m
+CONFIG_USB_SL811_HCD=m
+# CONFIG_USB_SL811_CS is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_WHCI_HCD=m
+CONFIG_USB_HWA_HCD=m
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_TMC=m
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_USS720=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+# CONFIG_USB_RIO500 is not set
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_BERRY_CHARGE=m
+CONFIG_USB_LED=m
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+CONFIG_USB_LD=m
+# CONFIG_USB_TRANCEVIBRATOR is not set
+CONFIG_USB_IOWARRIOR=m
+# CONFIG_USB_TEST is not set
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_VST=m
+CONFIG_USB_ATM=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_USB_CXACRU=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_XUSBATM=m
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+CONFIG_NOP_USB_XCEIV=m
+CONFIG_UWB=m
+CONFIG_UWB_HWA=m
+CONFIG_UWB_WHCI=m
+CONFIG_UWB_WLP=m
+CONFIG_UWB_I1480U=m
+CONFIG_UWB_I1480U_WLP=m
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_SDIO_UART=m
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PCI=m
+CONFIG_MMC_RICOH_MMC=m
+CONFIG_MMC_SDHCI_PLTFM=m
+# CONFIG_MMC_WBSD is not set
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+CONFIG_MMC_TIFM_SD=m
+CONFIG_MMC_SDRICOH_CS=m
+CONFIG_MMC_CB710=m
+CONFIG_MMC_VIA_SDMMC=m
+CONFIG_MEMSTICK=m
+# CONFIG_MEMSTICK_DEBUG is not set
+
+#
+# MemoryStick drivers
+#
+# CONFIG_MEMSTICK_UNSAFE_RESUME is not set
+CONFIG_MSPRO_BLOCK=m
+
+#
+# MemoryStick Host Controller Drivers
+#
+CONFIG_MEMSTICK_TIFM_MS=m
+CONFIG_MEMSTICK_JMICRON_38X=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_ALIX2=m
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+CONFIG_LEDS_LP3944=m
+CONFIG_LEDS_CLEVO_MAIL=m
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_WM831X_STATUS=m
+CONFIG_LEDS_WM8350=m
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=m
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+# CONFIG_INFINIBAND_AMSO1100 is not set
+CONFIG_INFINIBAND_CXGB3=m
+# CONFIG_INFINIBAND_CXGB3_DEBUG is not set
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_INFINIBAND_NES=m
+# CONFIG_INFINIBAND_NES_DEBUG is not set
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+# CONFIG_INFINIBAND_IPOIB_DEBUG_DATA is not set
+CONFIG_INFINIBAND_SRP=m
+CONFIG_INFINIBAND_ISER=m
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_DECODE_MCE=m
+CONFIG_EDAC_MM_EDAC=m
+CONFIG_EDAC_AMD76X=m
+CONFIG_EDAC_E7XXX=m
+CONFIG_EDAC_E752X=m
+CONFIG_EDAC_I82875P=m
+CONFIG_EDAC_I82975X=m
+CONFIG_EDAC_I3000=m
+CONFIG_EDAC_I3200=m
+CONFIG_EDAC_X38=m
+CONFIG_EDAC_I5400=m
+CONFIG_EDAC_I82860=m
+CONFIG_EDAC_R82600=m
+CONFIG_EDAC_I5000=m
+CONFIG_EDAC_I5100=m
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_RTC_DRV_DS1672=m
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_RTC_DRV_X1205=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_M41T80_WDT=y
+# CONFIG_RTC_DRV_S35390A is not set
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RX8025=m
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_RTC_DRV_DS1286=m
+CONFIG_RTC_DRV_DS1511=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_STK17TA8=m
+# CONFIG_RTC_DRV_M48T86 is not set
+CONFIG_RTC_DRV_M48T35=m
+CONFIG_RTC_DRV_M48T59=m
+CONFIG_RTC_DRV_BQ4802=m
+CONFIG_RTC_DRV_V3020=m
+CONFIG_RTC_DRV_WM831X=m
+CONFIG_RTC_DRV_WM8350=m
+CONFIG_RTC_DRV_AB3100=m
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_ASYNC_TX_DISABLE_CHANNEL_SWITCH=y
+CONFIG_INTEL_IOATDMA=m
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+CONFIG_NET_DMA=y
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+CONFIG_DCA=m
+CONFIG_AUXDISPLAY=y
+CONFIG_KS0108=m
+CONFIG_KS0108_PORT=0x378
+CONFIG_KS0108_DELAY=2
+CONFIG_CFAG12864B=m
+CONFIG_CFAG12864B_RATE=20
+CONFIG_UIO=m
+CONFIG_UIO_CIF=m
+CONFIG_UIO_PDRV=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_UIO_SMX=m
+CONFIG_UIO_AEC=m
+CONFIG_UIO_SERCOS3=m
+CONFIG_UIO_PCI_GENERIC=m
+
+#
+# TI VLYNQ
+#
+CONFIG_XEN_BALLOON=y
+CONFIG_XEN_SCRUB_PAGES=y
+CONFIG_XEN_DEV_EVTCHN=m
+CONFIG_XENFS=m
+CONFIG_XEN_COMPAT_XENFS=y
+CONFIG_XEN_SYS_HYPERVISOR=y
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_ET131X is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_VIDEO_GO7007 is not set
+# CONFIG_VIDEO_CX25821 is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_POCH is not set
+# CONFIG_OTUS is not set
+# CONFIG_RT2860 is not set
+# CONFIG_RT2870 is not set
+# CONFIG_RT3090 is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_PANEL is not set
+# CONFIG_ALTERA_PCIE_CHDMA is not set
+# CONFIG_RTL8187SE is not set
+# CONFIG_RTL8192SU is not set
+# CONFIG_RTL8192E is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_DST is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_B3DFG is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_PLAN9AUTH is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_DRM_RADEON_KMS is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_FB_UDL is not set
+CONFIG_HYPERV=m
+CONFIG_HYPERV_STORAGE=m
+CONFIG_HYPERV_BLOCK=m
+CONFIG_HYPERV_NET=m
+# CONFIG_VME_BUS is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+CONFIG_ACER_WMI=m
+# CONFIG_ACERHDF is not set
+CONFIG_ASUS_LAPTOP=m
+CONFIG_DELL_WMI=m
+CONFIG_FUJITSU_LAPTOP=m
+# CONFIG_FUJITSU_LAPTOP_DEBUG is not set
+CONFIG_TC1100_WMI=m
+CONFIG_HP_WMI=m
+CONFIG_MSI_LAPTOP=m
+CONFIG_PANASONIC_LAPTOP=m
+CONFIG_COMPAL_LAPTOP=m
+CONFIG_SONY_LAPTOP=m
+CONFIG_SONYPI_COMPAT=y
+CONFIG_THINKPAD_ACPI=m
+# CONFIG_THINKPAD_ACPI_DEBUGFACILITIES is not set
+# CONFIG_THINKPAD_ACPI_DEBUG is not set
+# CONFIG_THINKPAD_ACPI_UNSAFE_LEDS is not set
+CONFIG_THINKPAD_ACPI_VIDEO=y
+CONFIG_THINKPAD_ACPI_HOTKEY_POLL=y
+# CONFIG_INTEL_MENLOW is not set
+CONFIG_EEEPC_LAPTOP=m
+CONFIG_ACPI_WMI=m
+# CONFIG_ACPI_ASUS is not set
+CONFIG_TOPSTAR_LAPTOP=m
+CONFIG_ACPI_TOSHIBA=m
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=m
+# CONFIG_EDD_OFF is not set
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_EFI_VARS=y
+CONFIG_DELL_RBU=m
+CONFIG_DCDBAS=m
+CONFIG_DMIID=y
+CONFIG_ISCSI_IBFT_FIND=y
+CONFIG_ISCSI_IBFT=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT2_FS_XIP=y
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=m
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_FS_XIP=y
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=m
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=m
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+CONFIG_GFS2_FS=m
+CONFIG_GFS2_FS_LOCKING_DLM=y
+# CONFIG_OCFS2_FS is not set
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=m
+CONFIG_FSCACHE_STATS=y
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=m
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=m
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_FS_POSIX_ACL=y
+CONFIG_JFFS2_FS_SECURITY=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=m
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+CONFIG_CRAMFS=m
+CONFIG_SQUASHFS=m
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EXOFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_FSCACHE=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_SUNRPC_XPRT_RDMA=m
+CONFIG_RPCSEC_GSS_KRB5=m
+CONFIG_RPCSEC_GSS_SPKM3=m
+# CONFIG_SMB_FS is not set
+CONFIG_CIFS=m
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_STATS2 is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+CONFIG_CIFS_DFS_UPCALL=y
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+CONFIG_DLM=m
+CONFIG_DLM_DEBUG=y
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+CONFIG_BOOT_PRINTK_DELAY=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+CONFIG_SYSPROF_TRACER=y
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_BOOT_TRACER=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_POWER_TRACER=y
+# CONFIG_STACK_TRACER is not set
+CONFIG_KMEMTRACE=y
+# CONFIG_WORKQUEUE_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+CONFIG_RING_BUFFER_BENCHMARK=m
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_FIREWIRE_OHCI_REMOTE_DMA is not set
+CONFIG_BUILD_DOCSRC=y
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+CONFIG_KGDB_TESTS=y
+# CONFIG_KGDB_TESTS_ON_BOOT is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_KMEMCHECK is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_EARLY_PRINTK_DBGP=y
+CONFIG_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+CONFIG_DEBUG_NX_TEST=m
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_DEBUG_BOOT_PARAMS=y
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SECURITY_NETWORK_XFRM=y
+# CONFIG_SECURITY_PATH is not set
+CONFIG_SECURITY_FILE_CAPABILITIES=y
+# CONFIG_SECURITY_ROOTPLUG is not set
+CONFIG_INTEL_TXT=y
+CONFIG_LSM_MMAP_MIN_ADDR=65535
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+CONFIG_IMA=y
+CONFIG_IMA_MEASURE_PCR_IDX=10
+CONFIG_IMA_AUDIT=y
+CONFIG_IMA_LSM_RULES=y
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA=y
+CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_FIPS=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_CTR=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_CRYPTO_GHASH=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_AES_586=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SALSA20_586=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_CRYPTO_TWOFISH_586=m
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_PADLOCK=m
+CONFIG_CRYPTO_DEV_PADLOCK_AES=m
+CONFIG_CRYPTO_DEV_PADLOCK_SHA=m
+CONFIG_CRYPTO_DEV_GEODE=m
+CONFIG_CRYPTO_DEV_HIFN_795X=m
+CONFIG_CRYPTO_DEV_HIFN_795X_RNG=y
+CONFIG_HAVE_KVM=y
+CONFIG_VIRTUALIZATION=y
+# CONFIG_KVM is not set
+# CONFIG_LGUEST is not set
+CONFIG_VIRTIO=m
+CONFIG_VIRTIO_RING=m
+CONFIG_VIRTIO_PCI=m
+CONFIG_VIRTIO_BALLOON=m
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=m
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=m
+CONFIG_REED_SOLOMON_DEC16=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_NLATTR=y
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/r100_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r100_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/r100_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r100_reg_safe.h	2019-04-14 13:23:41.072152088 -0500
@@ -0,0 +1,28 @@
+static const unsigned r100_reg_safe_bm[102] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFCF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFF9F, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x38E7FE1F, 0xFFC3FF8E, 0x7FF8FFFF, 0xFFFF803C,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFEFFFF, 0xFFFFFFFF,
+	0x00000000, 0xFFFFFFFD, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFCFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFEF,
+};
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/r200_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r200_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/r200_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r200_reg_safe.h	2019-04-14 13:23:41.079981145 -0500
@@ -0,0 +1,28 @@
+static const unsigned r200_reg_safe_bm[102] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFE7FE1F, 0xF003FFFF, 0x7EFFFFFF, 0xFFFF803C,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFEFCE, 0xFFFEFFFF, 0xFFFFFFFE,
+	0x020E0FF0, 0xFFFC83FD, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFBFFFF, 0xEFFCFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xDFDFDFDF, 0x3FFDDFDF, 0xFFFFFFFF, 0xFFFFFF7F,
+	0xFFFFFFFF, 0x00FFFFFF, 0x00000000, 0x00000000,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFE3F, 0xFFFFFFEF,
+};
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/r300_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r300_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/r300_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/r300_reg_safe.h	2019-04-14 13:23:41.084943504 -0500
@@ -0,0 +1,42 @@
+static const unsigned r300_reg_safe_bm[159] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFF03F,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFEFCE, 0xF00EBFFF, 0x007C0000,
+	0xF0000078, 0xFF000009, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFF7FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFC78, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF,
+	0x38FF8F50, 0xFFF88082, 0xF000000C, 0xFAE009FF,
+	0x0000FFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
+	0x00000000, 0x0000C100, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0xFFFF0000, 0xFFFFFFFF, 0xFF80FFFF,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0003FC01, 0xFFFFFCF8, 0xFF800B19,
+};
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/rn50_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rn50_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/rn50_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rn50_reg_safe.h	2019-04-14 13:23:41.175882550 -0500
@@ -0,0 +1,28 @@
+static const unsigned rn50_reg_safe_bm[102] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF,
+};
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/rs600_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rs600_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/rs600_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rs600_reg_safe.h	2019-04-14 13:23:41.182840683 -0500
@@ -0,0 +1,57 @@
+static const unsigned rs600_reg_safe_bm[219] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFF03F,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFEFCE, 0xF00EBFFF, 0x007C0000,
+	0xF0000078, 0xFF000009, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFF7FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFC78, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF,
+	0x38FF8F50, 0xFFF88082, 0xF000000C, 0xFAE009FF,
+	0x0000FFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
+	0x00000000, 0x0000C100, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0xFFFF0000, 0xFFFFFFFF, 0xFF80FFFF,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0003FC01, 0xFFFFFCF8, 0xFF800B19, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+};
diff -uNr linux-2.6.32/drivers/gpu/drm/radeon/rv515_reg_safe.h clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rv515_reg_safe.h
--- linux-2.6.32/drivers/gpu/drm/radeon/rv515_reg_safe.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/drivers/gpu/drm/radeon/rv515_reg_safe.h	2019-04-14 13:23:41.186622846 -0500
@@ -0,0 +1,57 @@
+static const unsigned rv515_reg_safe_bm[219] = {
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x17FF1FFF, 0xFFFFFFFC, 0xFFFFFFFF, 0xFF30FFBF,
+	0xFFFFFFF8, 0xC3E6FFFF, 0xFFFFF6DF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFF03F,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFEFCE, 0xF00EBFFF, 0x007C0000,
+	0xF0000038, 0xFF000009, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFF7FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0x1FFFFC78, 0xFFFFE000, 0xFFFFFFFE, 0xFFFFFFFF,
+	0x38CF8F50, 0xFFF88082, 0xFF0000FC, 0xFAE009FF,
+	0x0000FFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
+	0xFFFF8CFC, 0xFFFFC1FF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFF80FFFF,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0003FC01, 0x3FFFFCF8, 0xFF800B19, 0xFFDFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+};
diff -uNr linux-2.6.32/include/asm-x86/asm-offsets.h clean_modified/linux-2.6.32/include/asm-x86/asm-offsets.h
--- linux-2.6.32/include/asm-x86/asm-offsets.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/asm-x86/asm-offsets.h	2019-04-14 13:23:50.732971952 -0500
@@ -0,0 +1,92 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define IA32_SIGCONTEXT_ax 44 /* offsetof(struct sigcontext, ax)	# */
+#define IA32_SIGCONTEXT_bx 32 /* offsetof(struct sigcontext, bx)	# */
+#define IA32_SIGCONTEXT_cx 40 /* offsetof(struct sigcontext, cx)	# */
+#define IA32_SIGCONTEXT_dx 36 /* offsetof(struct sigcontext, dx)	# */
+#define IA32_SIGCONTEXT_si 20 /* offsetof(struct sigcontext, si)	# */
+#define IA32_SIGCONTEXT_di 16 /* offsetof(struct sigcontext, di)	# */
+#define IA32_SIGCONTEXT_bp 24 /* offsetof(struct sigcontext, bp)	# */
+#define IA32_SIGCONTEXT_sp 28 /* offsetof(struct sigcontext, sp)	# */
+#define IA32_SIGCONTEXT_ip 56 /* offsetof(struct sigcontext, ip)	# */
+
+#define CPUINFO_x86 0 /* offsetof(struct cpuinfo_x86, x86)	# */
+#define CPUINFO_x86_vendor 1 /* offsetof(struct cpuinfo_x86, x86_vendor)	# */
+#define CPUINFO_x86_model 2 /* offsetof(struct cpuinfo_x86, x86_model)	# */
+#define CPUINFO_x86_mask 3 /* offsetof(struct cpuinfo_x86, x86_mask)	# */
+#define CPUINFO_hard_math 6 /* offsetof(struct cpuinfo_x86, hard_math)	# */
+#define CPUINFO_cpuid_level 20 /* offsetof(struct cpuinfo_x86, cpuid_level)	# */
+#define CPUINFO_x86_capability 24 /* offsetof(struct cpuinfo_x86, x86_capability)	# */
+#define CPUINFO_x86_vendor_id 60 /* offsetof(struct cpuinfo_x86, x86_vendor_id)	# */
+
+#define TI_task 0 /* offsetof(struct thread_info, task)	# */
+#define TI_exec_domain 4 /* offsetof(struct thread_info, exec_domain)	# */
+#define TI_flags 8 /* offsetof(struct thread_info, flags)	# */
+#define TI_status 12 /* offsetof(struct thread_info, status)	# */
+#define TI_preempt_count 20 /* offsetof(struct thread_info, preempt_count)	# */
+#define TI_addr_limit 24 /* offsetof(struct thread_info, addr_limit)	# */
+#define TI_restart_block 28 /* offsetof(struct thread_info, restart_block)	# */
+#define TI_sysenter_return 60 /* offsetof(struct thread_info, sysenter_return)	# */
+#define TI_cpu 16 /* offsetof(struct thread_info, cpu)	# */
+
+#define GDS_size 0 /* offsetof(struct desc_ptr, size)	# */
+#define GDS_address 2 /* offsetof(struct desc_ptr, address)	# */
+
+#define PT_EBX 0 /* offsetof(struct pt_regs, bx)	# */
+#define PT_ECX 4 /* offsetof(struct pt_regs, cx)	# */
+#define PT_EDX 8 /* offsetof(struct pt_regs, dx)	# */
+#define PT_ESI 12 /* offsetof(struct pt_regs, si)	# */
+#define PT_EDI 16 /* offsetof(struct pt_regs, di)	# */
+#define PT_EBP 20 /* offsetof(struct pt_regs, bp)	# */
+#define PT_EAX 24 /* offsetof(struct pt_regs, ax)	# */
+#define PT_DS 28 /* offsetof(struct pt_regs, ds)	# */
+#define PT_ES 32 /* offsetof(struct pt_regs, es)	# */
+#define PT_FS 36 /* offsetof(struct pt_regs, fs)	# */
+#define PT_GS 40 /* offsetof(struct pt_regs, gs)	# */
+#define PT_ORIG_EAX 44 /* offsetof(struct pt_regs, orig_ax)	# */
+#define PT_EIP 48 /* offsetof(struct pt_regs, ip)	# */
+#define PT_CS 52 /* offsetof(struct pt_regs, cs)	# */
+#define PT_EFLAGS 56 /* offsetof(struct pt_regs, flags)	# */
+#define PT_OLDESP 60 /* offsetof(struct pt_regs, sp)	# */
+#define PT_OLDSS 64 /* offsetof(struct pt_regs, ss)	# */
+
+#define EXEC_DOMAIN_handler 4 /* offsetof(struct exec_domain, handler)	# */
+#define IA32_RT_SIGFRAME_sigcontext 164 /* offsetof(struct rt_sigframe, uc.uc_mcontext)	# */
+
+#define pbe_address 0 /* offsetof(struct pbe, address)	# */
+#define pbe_orig_address 4 /* offsetof(struct pbe, orig_address)	# */
+#define pbe_next 8 /* offsetof(struct pbe, next)	# */
+#define TSS_sysenter_sp0 -8572 /* offsetof(struct tss_struct, x86_tss.sp0) - sizeof(struct tss_struct)	# */
+#define PAGE_SIZE_asm 4096 /* PAGE_SIZE	# */
+#define PAGE_SHIFT_asm 12 /* PAGE_SHIFT	# */
+#define PTRS_PER_PTE 512 /* PTRS_PER_PTE	# */
+#define PTRS_PER_PMD 512 /* PTRS_PER_PMD	# */
+#define PTRS_PER_PGD 4 /* PTRS_PER_PGD	# */
+#define crypto_tfm_ctx_offset 48 /* offsetof(struct crypto_tfm, __crt_ctx)	# */
+
+#define PARAVIRT_enabled 8 /* offsetof(struct pv_info, paravirt_enabled)	# */
+#define PARAVIRT_PATCH_pv_cpu_ops 12 /* offsetof(struct paravirt_patch_template, pv_cpu_ops)	# */
+#define PARAVIRT_PATCH_pv_irq_ops 172 /* offsetof(struct paravirt_patch_template, pv_irq_ops)	# */
+#define PV_IRQ_irq_disable 8 /* offsetof(struct pv_irq_ops, irq_disable)	# */
+#define PV_IRQ_irq_enable 12 /* offsetof(struct pv_irq_ops, irq_enable)	# */
+#define PV_CPU_iret 144 /* offsetof(struct pv_cpu_ops, iret)	# */
+#define PV_CPU_irq_enable_sysexit 132 /* offsetof(struct pv_cpu_ops, irq_enable_sysexit)	# */
+#define PV_CPU_read_cr0 12 /* offsetof(struct pv_cpu_ops, read_cr0)	# */
+
+#define XEN_vcpu_info_mask 1 /* offsetof(struct vcpu_info, evtchn_upcall_mask)	# */
+#define XEN_vcpu_info_pending 0 /* offsetof(struct vcpu_info, evtchn_upcall_pending)	# */
+
+#define BP_scratch 484 /* offsetof(struct boot_params, scratch)	# */
+#define BP_loadflags 529 /* offsetof(struct boot_params, hdr.loadflags)	# */
+#define BP_hardware_subarch 572 /* offsetof(struct boot_params, hdr.hardware_subarch)	# */
+#define BP_version 518 /* offsetof(struct boot_params, hdr.version)	# */
+#define BP_kernel_alignment 560 /* offsetof(struct boot_params, hdr.kernel_alignment)	# */
+
+#endif
diff -uNr linux-2.6.32/include/config/auto.conf clean_modified/linux-2.6.32/include/config/auto.conf
--- linux-2.6.32/include/config/auto.conf	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/config/auto.conf	2019-04-14 13:23:50.736823631 -0500
@@ -0,0 +1,2941 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32
+# Sat Apr 13 14:09:53 2019
+#
+CONFIG_USB_SISUSBVGA=m
+CONFIG_DVB_STV6110=m
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_SENSORS_WM8350=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_BLK_DEV_FD=m
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_SECURITY_NETWORK=y
+CONFIG_OSF_PARTITION=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_HID_CHERRY=y
+CONFIG_SND_SB_COMMON=m
+CONFIG_FB_RIVA_BACKLIGHT=y
+CONFIG_DVB_PLUTO2=m
+CONFIG_DVB_STV0900=m
+CONFIG_HISAX_ELSA=y
+CONFIG_RT2X00_LIB_PCI=m
+CONFIG_BONDING=m
+CONFIG_MTD_ABSENT=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_KRETPROBES=y
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_DEBUG_LIST=y
+CONFIG_FRAME_WARN=1024
+CONFIG_JBD2=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_HYSDN_CAPI=y
+CONFIG_HERMES_CACHE_FW_ON_INIT=y
+CONFIG_P54_USB=m
+CONFIG_MACVLAN=m
+CONFIG_NET_DROP_MONITOR=y
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_EDAC_AMD76X=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_IT8712F_WDT=m
+CONFIG_CAN_BCM=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_X86_POWERNOW_K7_ACPI=y
+CONFIG_AUXDISPLAY=y
+CONFIG_SND_SIS7019=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_SOC_CAMERA_MT9M001=m
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_SENSORS_VT8231=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_TCP_CONG_VENO=m
+CONFIG_CARDBUS=y
+CONFIG_CRYPTO_MD4=m
+CONFIG_SONYPI_COMPAT=y
+CONFIG_USB_SERIAL_TI=m
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_INPUT_POLLDEV=m
+CONFIG_ISDN_DRV_AVMB1_C4=m
+CONFIG_ATH_COMMON=m
+CONFIG_SMSC9420=m
+CONFIG_BT_HCIUART=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_X86_SPEEDSTEP_ICH=y
+CONFIG_TASK_XACCT=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_ASYNC_CORE=m
+CONFIG_SOC_CAMERA_MT9M111=m
+CONFIG_VIDEO_FB_IVTV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_IPW2200_QOS=y
+CONFIG_E1000=m
+CONFIG_GPIOLIB=y
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRASH_DUMP=y
+CONFIG_X86_MCE_THRESHOLD=y
+CONFIG_AUDIT_TREE=y
+CONFIG_RTC_DRV_WM8350=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_VIDEO_BTCX=m
+CONFIG_IPWIRELESS=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_BLK_DEV_MD=y
+CONFIG_SCSI_LOWLEVEL_PCMCIA=y
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_PROC_KCORE=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_RTC_DRV_M48T35=m
+CONFIG_SND_EMU10K1=m
+CONFIG_DVB_TDA10021=m
+CONFIG_SYNCLINKMP=m
+CONFIG_MISDN_W6692=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_TMD_HERMES=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_CRYPTO_CBC=m
+CONFIG_X86_SPEEDSTEP_LIB=y
+CONFIG_TRACING=y
+CONFIG_USB_SERIAL=m
+CONFIG_AGP_AMD=y
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_SERIAL_JSM=m
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_MISDN_ISAR=m
+CONFIG_USB_RTL8150=m
+CONFIG_MTD_MTDRAM=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_HIGHPTE=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_KGDB_TESTS=y
+CONFIG_GFS2_FS=m
+CONFIG_UWB_I1480U_WLP=m
+CONFIG_SND_DARLA20=m
+CONFIG_DVB_STV0297=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0288=m
+CONFIG_HISAX_W6692=y
+CONFIG_HOSTAP_PCI=m
+CONFIG_CASSINI=m
+CONFIG_PCMCIA_FDOMAIN=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_X86_PAT=y
+CONFIG_TOSHIBA=m
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_DEBUG_NX_TEST=m
+CONFIG_SUNRPC_XPRT_RDMA=m
+CONFIG_KS0108_PORT=0x378
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_REGULATOR_TPS65023=m
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_NETXEN_NIC=m
+CONFIG_PATA_SIL680=m
+CONFIG_PATA_ARTOP=m
+CONFIG_PNPACPI=y
+CONFIG_NET_9P_VIRTIO=m
+CONFIG_BT_HCIBLUECARD=m
+CONFIG_IP_DCCP_CCID3_RTO=100
+CONFIG_IP6_NF_RAW=m
+CONFIG_TIMERFD=y
+CONFIG_IMA_LSM_RULES=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_RTC_DRV_RX8025=m
+CONFIG_RTC_INTF_PROC=y
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_TDA826X=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_HVC_DRIVER=y
+CONFIG_ZD1211RW=m
+CONFIG_NET_POCKET=y
+CONFIG_WINBOND_840=m
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_CAN_SJA1000_ISA=m
+CONFIG_EVENTFD=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_NOP_TRACER=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_STAGING=y
+CONFIG_EDAC=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_AGP_ALI=y
+CONFIG_USB_KAWETH=m
+CONFIG_DL2K=m
+CONFIG_BLK_DEV_SD=m
+CONFIG_HAS_DMA=y
+CONFIG_RAID_ATTRS=m
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_THERMAL=y
+CONFIG_X86_CPU=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_RTC_DRV_M48T59=m
+CONFIG_SND_DARLA24=m
+CONFIG_FB_VIRTUAL=m
+CONFIG_SOC_CAMERA_MT9T031=m
+CONFIG_FUSION_LAN=m
+CONFIG_CFG80211_DEFAULT_PS_VALUE=1
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_SUN_PARTITION=y
+CONFIG_NFS_COMMON=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_USB_CXACRU=m
+CONFIG_SND_VIA82XX_MODEM=m
+CONFIG_CRC7=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_NET_PKTGEN=m
+CONFIG_X86_TSC=y
+CONFIG_DVB_PT1=m
+CONFIG_SOC_CAMERA_MT9V022=m
+CONFIG_VIDEO_BT848=m
+CONFIG_SERIO_SERPORT=y
+CONFIG_PATA_HPT366=m
+CONFIG_CAN_DEV=m
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_HID_PID=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_DVB_TDA10048=m
+CONFIG_SECURITYFS=y
+CONFIG_HW_CONSOLE=y
+CONFIG_NATSEMI=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_HOTPLUG_PCI_ACPI_IBM=m
+CONFIG_VM86=y
+CONFIG_HPET_TIMER=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_VGA_ARB=y
+CONFIG_SENSORS_TMP401=m
+CONFIG_SENSORS_SMSC47B397=m
+CONFIG_ISDN_CAPI_CAPIDRV=m
+CONFIG_HDLC_FR=m
+CONFIG_ATL1=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_IP_DCCP=m
+CONFIG_X86_CYCLONE_TIMER=y
+CONFIG_CRYPTO_CCM=m
+CONFIG_CIFS_STATS=y
+CONFIG_NFSD_V3=y
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_EDAC_I82875P=m
+CONFIG_SND_ATIIXP=m
+CONFIG_DVB_TDA10086=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_ATL2=m
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NF_NAT_IRC=m
+CONFIG_FREEZER=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_NFSD_V4=y
+CONFIG_NOP_USB_XCEIV=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_SENSORS_TMP421=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_ATA_SFF=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_UIO_AEC=m
+CONFIG_AGP_ATI=y
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_RAW_DRIVER=y
+CONFIG_VMXNET3=m
+CONFIG_PPP_FILTER=y
+CONFIG_USB_NET_PLUSB=m
+CONFIG_PATA_IT821X=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_VIRTIO_BLK=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_NF_NAT_H323=m
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_PCIEAER_INJECT=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_XOR_BLOCKS=m
+CONFIG_USB_SEVSEG=m
+CONFIG_SND_USB_US122L=m
+CONFIG_SND_AC97_POWER_SAVE_DEFAULT=5
+CONFIG_FB_VESA=y
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_HW_RANDOM_TIMERIOMEM=m
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_NETDEV_10000=y
+CONFIG_FUSION_CTL=m
+CONFIG_MTD_CFI=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_X86_MCE_INJECT=m
+CONFIG_KPROBES=y
+CONFIG_RCU_FANOUT=32
+CONFIG_CRYPTO_GCM=m
+CONFIG_CIFS_POSIX=y
+CONFIG_CIFS_XATTR=y
+CONFIG_INFINIBAND_NES=m
+CONFIG_DRM_MGA=m
+CONFIG_AGP_VIA=y
+CONFIG_HISAX_EURO=y
+CONFIG_FDDI=y
+CONFIG_PCMCIA_XIRC2PS=m
+CONFIG_PLX_HERMES=m
+CONFIG_MLX4_EN=m
+CONFIG_BLK_DEV=y
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_X86_MSR=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_VIRTIO_PCI=m
+CONFIG_CRYPTO_SALSA20_586=m
+CONFIG_KGDB=y
+CONFIG_NLS_KOI8_R=m
+CONFIG_MSI_LAPTOP=m
+CONFIG_NET_DMA=y
+CONFIG_SND_USB_USX2Y=m
+CONFIG_HAS_IOPORT=y
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_IBM_ASM=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_INET_AH=m
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_QUOTA_TREE=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_SND_MIXART=m
+CONFIG_SND_LAYLA20=m
+CONFIG_FB_RIVA=m
+CONFIG_I2C_AMD756_S4882=m
+CONFIG_CARDMAN_4000=m
+CONFIG_INPUT_CM109=m
+CONFIG_QLA3XXX=m
+CONFIG_CRYPTO_AES=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_MODULES=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_CRYPTO_TEA=m
+CONFIG_USB_ACM=m
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_B43LEGACY_PCICORE_AUTOSELECT=y
+CONFIG_USB_USBNET=m
+CONFIG_BNX2=m
+CONFIG_FUSION_SAS=m
+CONFIG_PARPORT_PC=m
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_BNEP=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_X86_SPEEDSTEP_SMI=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_CRYPTO_AES_586=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_EXT2_FS=m
+CONFIG_SND_MIA=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_INPUT_MISC=y
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_HDLC=m
+CONFIG_IWLWIFI=m
+CONFIG_PATA_CMD64X=m
+CONFIG_SCSI_MVSAS=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_MTD_SCB2_FLASH=m
+CONFIG_CAN_RAW=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_EXT3_FS=m
+CONFIG_EDAC_I82975X=m
+CONFIG_USB_LCD=m
+CONFIG_VIDEO_CX88_DVB=m
+CONFIG_I2C_PARPORT_LIGHT=m
+CONFIG_VT_CONSOLE=y
+CONFIG_DLCI=m
+CONFIG_LIBERTAS_DEBUG=y
+CONFIG_R6040=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_CRYPTO_DES=m
+CONFIG_DEBUG_BOOT_PARAMS=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_DNOTIFY=y
+CONFIG_EXT4_FS=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_HID_KYE=y
+CONFIG_SND_LAYLA24=m
+CONFIG_SND_MIXER_OSS=m
+CONFIG_FB_SM501=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_SENSORS_THMC50=m
+CONFIG_SENSORS_F71805F=m
+CONFIG_CARDMAN_4040=m
+CONFIG_S2IO=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH=y
+CONFIG_FCOE=m
+CONFIG_CNIC=m
+CONFIG_INET_DCCP_DIAG=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_ACPI=y
+CONFIG_UIO_CIF=m
+CONFIG_USB_LED=m
+CONFIG_USB_HID=y
+CONFIG_SND_CS5535AUDIO=m
+CONFIG_SND_OXYGEN=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_VES1X93=m
+CONFIG_NETPOLL=y
+CONFIG_SLIP_SMART=y
+CONFIG_SCSI_MPT2SAS_MAX_SGE=128
+CONFIG_NET_DSA=y
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_RELOCATABLE=y
+CONFIG_QFMT_V2=y
+CONFIG_FB_DEFERRED_IO=y
+CONFIG_VIDEO_IVTV=m
+CONFIG_DVB_NXT200X=m
+CONFIG_RTC_LIB=y
+CONFIG_ENIC=m
+CONFIG_TULIP_MMIO=y
+CONFIG_I2C_ALGOBIT=m
+CONFIG_FUSION_SPI=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_DEBUG_RODATA_TEST=y
+CONFIG_SND_PCI=y
+CONFIG_AGP_SWORKS=y
+CONFIG_AIRO_CS=m
+CONFIG_SFC_MTD=y
+CONFIG_ICPLUS_PHY=m
+CONFIG_MTD_PCI=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_X86_TRAMPOLINE=y
+CONFIG_SND_ISA=y
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_TCG_NSC=m
+CONFIG_PPPOATM=m
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SATA_QSTOR=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_RFD_FTL=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRM_VIA=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_HOSTAP_PLX=m
+CONFIG_NET_PCI=y
+CONFIG_EEPROM_AT24=m
+CONFIG_SUSPEND=y
+CONFIG_X86_GENERIC=y
+CONFIG_SLAB=y
+CONFIG_INOTIFY=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_USB_OTG_UTILS=y
+CONFIG_DVB_PLL=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+CONFIG_VIRTIO_NET=m
+CONFIG_NET_ISA=y
+CONFIG_WIMAX_DEBUG_LEVEL=8
+CONFIG_HOTPLUG=y
+CONFIG_CGROUPS=y
+CONFIG_HYPERV_NET=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_SND_PCM=m
+CONFIG_WM8350_WATCHDOG=m
+CONFIG_SENSORS_WM831X=m
+CONFIG_DEVPORT=y
+CONFIG_PRINTER=m
+CONFIG_B43LEGACY_DEBUG=y
+CONFIG_MACINTOSH_DRIVERS=y
+CONFIG_MTD_UBI=m
+CONFIG_MTD_RAM=m
+CONFIG_NET_CLS_FW=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_PCI_MSI=y
+CONFIG_DMAR=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_CIFS=m
+CONFIG_DVB_USB=m
+CONFIG_VIDEO_PVRUSB2_DVB=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_IP_VS_IPV6=y
+CONFIG_IPV6=m
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_INFINIBAND_SRP=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_AGP_SIS=y
+CONFIG_SENSORS_ADM1025=m
+CONFIG_I2C_VOODOO3=m
+CONFIG_PARPORT_PC_PCMCIA=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_SCSI_AHA1542=m
+CONFIG_PHYSICAL_ALIGN=0x400000
+CONFIG_CPUSETS=y
+CONFIG_OPTIMIZE_INLINING=y
+CONFIG_SND_VX_LIB=m
+CONFIG_ATM_TCP=m
+CONFIG_PCMCIA_3C589=m
+CONFIG_PARPORT=m
+CONFIG_NET_CLS=y
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_CRYPTO_CTR=m
+CONFIG_VFAT_FS=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_QLGE=m
+CONFIG_MDIO=m
+CONFIG_SKY2=m
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_BT_CMTP=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_PCI_IOV=y
+CONFIG_RD_LZMA=y
+CONFIG_CRYPTO_CTS=m
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_JFFS2_FS_SECURITY=y
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_DRM_I915=m
+CONFIG_VIDEO_M52790=m
+CONFIG_SENSORS_LM95241=m
+CONFIG_SENSORS_ADM1029=m
+CONFIG_IPMI_SI=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_MISDN_SPEEDFAX=m
+CONFIG_SLHC=m
+CONFIG_IXGB=m
+CONFIG_SKGE=m
+CONFIG_R8169=m
+CONFIG_GARP=m
+CONFIG_NFSD=m
+CONFIG_UDF_NLS=y
+CONFIG_FUSE_FS=m
+CONFIG_RTC_DRV_WM831X=m
+CONFIG_USB_ATM=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_HVC_XEN=y
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_AIRO=m
+CONFIG_DNET=m
+CONFIG_SATA_MV=m
+CONFIG_X86_MCE_AMD=y
+CONFIG_GENERIC_ACL=y
+CONFIG_FB_VGA16=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_HVC_IRQ=y
+CONFIG_SATA_NV=m
+CONFIG_PROC_FS=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_USB_TMC=m
+CONFIG_UWB_HWA=m
+CONFIG_SND_HDA_CODEC_ATIHDMI=y
+CONFIG_VIDEO_VP27SMPX=m
+CONFIG_SENSORS_ADM9240=m
+CONFIG_TCG_TIS=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_SND_USB=y
+CONFIG_SENSORS_ATK0110=m
+CONFIG_TCG_TPM=y
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_ISDN=y
+CONFIG_MYRI10GE=m
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_OLPC=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_EDAC_X38=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_ISP1362_HCD=m
+CONFIG_DRM_R128=m
+CONFIG_TLAN=m
+CONFIG_PATA_HPT3X3=m
+CONFIG_RDS_TCP=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_NET_KEY=m
+CONFIG_X86_CMPXCHG=y
+CONFIG_RD_GZIP=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_EARLY_PRINTK_DBGP=y
+CONFIG_CUSE=m
+CONFIG_SENSORS_F75375S=m
+CONFIG_MISDN_INFINEON=m
+CONFIG_B43_LEDS=y
+CONFIG_DM_ZERO=m
+CONFIG_INET=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_RT_MUTEXES=y
+CONFIG_USB_WDM=m
+CONFIG_LOGO=y
+CONFIG_DRM_SIS=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_HPET=y
+CONFIG_TYPHOON=m
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+CONFIG_NET_DSA_MV88E6123_61_65=y
+CONFIG_SYSVIPC=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_SENSORS_W83781D=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_SSB_PCMCIAHOST=y
+CONFIG_WLAN=y
+CONFIG_PATA_PCMCIA=m
+CONFIG_ATA_GENERIC=m
+CONFIG_SCSI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_ROM=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_IP_SCTP=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_LSM_MMAP_MIN_ADDR=65535
+CONFIG_RING_BUFFER_BENCHMARK=m
+CONFIG_NFS_FSCACHE=y
+CONFIG_USB_MON=y
+CONFIG_USB_PWC=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_SERIAL_8250_RSA=y
+CONFIG_USB_HSO=m
+CONFIG_PATA_HPT37X=m
+CONFIG_MEGARAID_MM=m
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_HIBERNATION=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_SENSORS_W83792D=m
+CONFIG_SENSORS_DME1737=m
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_BE2ISCSI=m
+CONFIG_NFTL=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_PARAVIRT_CLOCK=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CRYPTO_LZO=m
+CONFIG_KS0108_DELAY=2
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_REGULATOR_TPS6507X=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_HISAX_TELESPCI=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_ACPI_PROCFS_POWER=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_VIDEO_MEDIA=m
+CONFIG_MISDN_HFCMULTI=m
+CONFIG_LSI_ET1011C_PHY=m
+CONFIG_BT_MRVL=m
+CONFIG_DOUBLEFAULT=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_DRM_TTM=m
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_SENSORS_IBMAEM=m
+CONFIG_SENSORS_ADT7470=m
+CONFIG_B43_SDIO=y
+CONFIG_SSB_B43_PCI_BRIDGE=y
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_VETH=m
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_SENSORS_ADT7462=m
+CONFIG_SLIP=m
+CONFIG_REED_SOLOMON_DEC16=y
+CONFIG_CAN_KVASER_PCI=m
+CONFIG_IOSCHED_CFQ=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_X86_IO_APIC=y
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_I6300ESB_WDT=m
+CONFIG_ALIM7101_WDT=m
+CONFIG_SENSORS_ADT7473=m
+CONFIG_IPW2100_MONITOR=y
+CONFIG_VXGE=m
+CONFIG_FUSION_LOGGING=y
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_NR_CPUS=32
+CONFIG_X86_EXTENDED_PLATFORM=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_GENERIC_BUG=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_SENSORS_LTC4215=m
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_IPW2200_MONITOR=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_BT_HCIBFUSB=m
+CONFIG_CPU_FREQ_DEBUG=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_SWAP=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_SENSORS_PCF8591=m
+CONFIG_SENSORS_ADT7475=m
+CONFIG_B43_PCI_AUTOSELECT=y
+CONFIG_NFTL_RW=y
+CONFIG_MTD_REDBOOT_PARTS=m
+CONFIG_KEYS=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_MMC_SDRICOH_CS=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_SND_KORG1212=m
+CONFIG_VIDEO_CS5345=m
+CONFIG_W83627HF_WDT=m
+CONFIG_SENSORS_ADS7828=m
+CONFIG_INPUT_WINBOND_CIR=m
+CONFIG_AC97_BUS=m
+CONFIG_B44_PCI_AUTOSELECT=y
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_XFRM=y
+CONFIG_CRC32=y
+CONFIG_X86_MPPARSE=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_SND_VIA82XX=m
+CONFIG_VIDEO_AU0828=m
+CONFIG_SENSORS_LTC4245=m
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_MTD_ESB2ROM=m
+CONFIG_DEFAULT_CFQ=y
+CONFIG_CRYPTO_XTS=m
+CONFIG_USB_SISUSBVGA_CON=y
+CONFIG_ALIM1535_WDT=m
+CONFIG_MISDN_L1OIP=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_CRC16=y
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_USER_NS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_UWB_WLP=m
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_ISDN_DIVERSION=m
+CONFIG_USB_CDC_PHONET=m
+CONFIG_P54_LEDS=y
+CONFIG_MD_RAID0=m
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_NFSD_V2_ACL=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_HID_CHICONY=y
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_SENSORS_FSCHMD=m
+CONFIG_WIMAX_I2400M=m
+CONFIG_MD_RAID1=m
+CONFIG_SCSI_ENCLOSURE=m
+CONFIG_NET_CLS_U32=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_NFSD_V3_ACL=y
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_USB_ZR364XX=m
+CONFIG_GIGASET_M101=m
+CONFIG_SCSI_BFA_FC=m
+CONFIG_MTDRAM_TOTAL_SIZE=4096
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_PACKET_MMAP=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_VIRTIO_BALLOON=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SENSORS_MAX6650=m
+CONFIG_SENSORS_MAX1619=m
+CONFIG_B43LEGACY_HWRNG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_UIO_SMX=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_EDAC_DECODE_MCE=m
+CONFIG_W83697HF_WDT=m
+CONFIG_SENSORS_ABITUGURU=m
+CONFIG_I2C_ISCH=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_UNIX=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_CRYPTO_DEV_HIFN_795X_RNG=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_SND_HDA_ELD=y
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_SENSORS_K8TEMP=m
+CONFIG_I2C_PARPORT=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_MTRR=y
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_USB_VST=m
+CONFIG_GIGASET_M105=m
+CONFIG_VIA_RHINE_MMIO=y
+CONFIG_MD_RAID6_PQ=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_PCI_DOMAINS=y
+CONFIG_X86_XADD=y
+CONFIG_HISAX_FRITZPCI=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_PARPORT_SERIAL=m
+CONFIG_BT_L2CAP=m
+CONFIG_NETLABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_CPU_SUP_UMC_32=y
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_HID_TOPSEED=y
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_HP_WATCHDOG=m
+CONFIG_WM831X_WATCHDOG=m
+CONFIG_SERIAL_CORE=y
+CONFIG_CYCLADES=m
+CONFIG_HISAX_S0BOX=y
+CONFIG_RT2400PCI=m
+CONFIG_LXT_PHY=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_MTD_SC520CDP=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_SIGNALFD=y
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_FB_GEODE_GX=y
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_I2C_SCMI=m
+CONFIG_RT2500PCI=m
+CONFIG_PDC_ADMA=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_BT_HCIBTUSB=m
+CONFIG_ACPI_PROCFS=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_RING_BUFFER=y
+CONFIG_UID16=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_MOUSE_PS2_OLPC=y
+CONFIG_ISDN_CAPI_CAPIFS_BOOL=y
+CONFIG_SSB_BLOCKIO=y
+CONFIG_DE4X5=m
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_X86_LONGRUN=y
+CONFIG_PHYSICAL_START=0x400000
+CONFIG_CRYPTO_AEAD=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_FB_GEODE=y
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_VIDEO_BT848_DVB=y
+CONFIG_SENSORS_TSL2550=m
+CONFIG_AT76C50X_USB=m
+CONFIG_LIBERTAS_CS=m
+CONFIG_E1000E=m
+CONFIG_NE2K_PCI=m
+CONFIG_SCSI_AHA152X=m
+CONFIG_RFKILL_LEDS=y
+CONFIG_BINFMT_MISC=y
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_DRM_KMS_HELPER=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_IEEE802154=m
+CONFIG_IP_FIB_HASH=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_TRACEPOINTS=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_HID_TWINHAN=y
+CONFIG_MEDIA_TUNER=m
+CONFIG_MISDN_AVMFRITZ=m
+CONFIG_RT2X00_LIB_LEDS=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ANON_INODES=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_UIO_SERCOS3=m
+CONFIG_FB_GEODE_LX=y
+CONFIG_BATTERY_BQ27x00=m
+CONFIG_HISAX_TELES_CS=m
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_INET6_AH=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_SLABINFO=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA=y
+CONFIG_RTC_DRV_M41T80_WDT=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_VIDEO_OV7670=m
+CONFIG_HISAX_GAZEL=y
+CONFIG_CHELSIO_T3_DEPENDS=y
+CONFIG_MTD_NAND_CS553X=m
+CONFIG_MTD_BLKDEVS=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_VIRTIO_CONSOLE=m
+CONFIG_XEN_DEV_EVTCHN=m
+CONFIG_SND_EMU10K1_SEQ=m
+CONFIG_VGA_CONSOLE=y
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_DELL_LAPTOP=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+CONFIG_PCIEPORTBUS=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_PARAVIRT_GUEST=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_XEN_BALLOON=y
+CONFIG_SND_RAWMIDI=m
+CONFIG_WATCHDOG=y
+CONFIG_SENSORS_VIA686A=m
+CONFIG_SENSORS_IBMPEX=m
+CONFIG_TELCLOCK=m
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_RTL8187_LEDS=y
+CONFIG_SUNDANCE=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_MTD_PARTITIONS=y
+CONFIG_CAN_EMS_PCI=m
+CONFIG_I82365=m
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_ACPI_FAN=y
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_HYPERV_STORAGE=m
+CONFIG_HID_SAMSUNG=y
+CONFIG_W83697UG_WDT=m
+CONFIG_HISAX_NICCY=y
+CONFIG_ATA_ACPI=y
+CONFIG_NET_9P_RDMA=m
+CONFIG_PCIEASPM=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_BLK_DEV_BSG=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_JFFS2_FS=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_SENSORS_SIS5595=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_GROUP_SCHED=y
+CONFIG_BOOT_TRACER=y
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_SND_LX6464ES=m
+CONFIG_SND_OXYGEN_LIB=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_PATA_ATIIXP=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_DMAR_FLOPPY_WA=y
+CONFIG_X86_P4_CLOCKMOD=m
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FB_SAVAGE_ACCEL=y
+CONFIG_VIDEO_WM8739=m
+CONFIG_VIDEO_WM8775=m
+CONFIG_TOUCHSCREEN_TSC2007=m
+CONFIG_HISAX_ST5481=m
+CONFIG_ISDN_DRV_HISAX=m
+CONFIG_MYRI10GE_DCA=y
+CONFIG_ATL1C=m
+CONFIG_NE2000=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_BT_HCIBPA10X=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_YENTA_RICOH=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_HAVE_IDE=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_SYSPROF_TRACER=y
+CONFIG_LOCKD_V4=y
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_VIDEO_CAFE_CCIC=m
+CONFIG_SENSORS_GL520SM=m
+CONFIG_ISDN_I4L=m
+CONFIG_LIBERTAS=m
+CONFIG_NET_VENDOR_SMC=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_PARPORT_1284=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_SCHED_MC=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_USB_HWA_HCD=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_RT2500USB=m
+CONFIG_ATL1E=m
+CONFIG_FUSION_MAX_SGE=128
+CONFIG_DM_DEBUG=y
+CONFIG_PATA_AMD=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_LIBCRC32C=m
+CONFIG_INET_IPCOMP=m
+CONFIG_NEED_NODE_MEMMAP_SIZE=y
+CONFIG_CFAG12864B=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_FB_ATY128_BACKLIGHT=y
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_REALTEK_PHY=m
+CONFIG_CHR_DEV_SCH=m
+CONFIG_MTD_NETSC520=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_ACPI_BUTTON=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_FUJITSU_LAPTOP=m
+CONFIG_MMC_CB710=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_SCSI_ARCMSR=m
+CONFIG_BLK_DEV_SX8=m
+CONFIG_CAN_VCAN=m
+CONFIG_NET_SCH_CBQ=m
+CONFIG_CRYPTO_HMAC=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_LBDAF=y
+CONFIG_MODVERSIONS=y
+CONFIG_VIDEO_HDPVR=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_IT87_WDT=m
+CONFIG_HISAX_NETJET_U=y
+CONFIG_RT2800USB=m
+CONFIG_IP1000=m
+CONFIG_PATA_NINJA32=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_X86_CMOV=y
+CONFIG_KERNEL_GZIP=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_MSPRO_BLOCK=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_REGULATOR_AB3100=m
+CONFIG_I2C_STUB=m
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_HISAX_NO_SENDCOMPLETE=y
+CONFIG_PATA_ALI=m
+CONFIG_SCSI_SAS_LIBSAS_DEBUG=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_LIB80211_CRYPT_TKIP=m
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_TOPSTAR_LAPTOP=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_USB_STV06XX=m
+CONFIG_BATTERY_MAX17040=m
+CONFIG_HANGCHECK_TIMER=m
+CONFIG_BLK_DEV_OSD=m
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_RD_BZIP2=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_MEMSTICK=m
+CONFIG_HID_CYPRESS=y
+CONFIG_SND_JACK=y
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_USB_A800=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_SENSORS_GL518SM=m
+CONFIG_ATH5K=m
+CONFIG_DM9102=m
+CONFIG_FIREWIRE=m
+CONFIG_SCSI_INITIO=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_MTRR_SANITIZER=y
+CONFIG_USB_STORAGE=m
+CONFIG_SND_TRIDENT=m
+CONFIG_KEYBOARD_OPENCORES=m
+CONFIG_IPPP_FILTER=y
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_B43LEGACY=m
+CONFIG_PATA_RDC=m
+CONFIG_NET_SCH_RED=m
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HAVE_INTEL_TXT=y
+CONFIG_PROC_VMCORE=y
+CONFIG_USB_IDMOUSE=m
+CONFIG_SND_HRTIMER=m
+CONFIG_VGASTATE=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MFD_CORE=m
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_KEYBOARD_ADP5588=m
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_DM_DELAY=m
+CONFIG_CAN_EMS_USB=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_ELF_CORE=y
+CONFIG_DEBUG_FS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_NFS_V4_1=y
+CONFIG_SND_EMU10K1X=m
+CONFIG_WM8350_POWER=m
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_CAPI_AVM=y
+CONFIG_ATM_DRIVERS=y
+CONFIG_DM_SNAPSHOT=m
+CONFIG_LIBFC=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_IPV6_MROUTE=y
+CONFIG_OPROFILE=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_VIDEO_CX88_ALSA=m
+CONFIG_PPPOL2TP=m
+CONFIG_DLCI_MAX=8
+CONFIG_USB_PEGASUS=m
+CONFIG_ATH9K=m
+CONFIG_SSB_PCIHOST=y
+CONFIG_NET_SCH_HTB=m
+CONFIG_ATM_LANE=m
+CONFIG_YENTA_O2=y
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PERF_EVENTS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LEDS_WM831X_STATUS=m
+CONFIG_MMC_TIFM_SD=m
+CONFIG_USB_U132_HCD=m
+CONFIG_MTD_CHAR=m
+CONFIG_NET_CLS_IND=y
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_SND_DRIVERS=y
+CONFIG_FB_ATY_GENERIC_LCD=y
+CONFIG_USB_M5602=m
+CONFIG_MARVELL_PHY=m
+CONFIG_PATA_SCH=m
+CONFIG_SCSI_DMA=y
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_HASH=y
+CONFIG_INFINIBAND_ISER=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+CONFIG_VIDEO_TUNER=m
+CONFIG_DVB_CORE=m
+CONFIG_UNIX98_PTYS=y
+CONFIG_TOUCHSCREEN_HTCPEN=m
+CONFIG_HDLC_RAW=m
+CONFIG_USB_CATC=m
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_EEPROM_93CX6=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_IP_PIMSM_V1=y
+CONFIG_XFRM_IPCOMP=m
+CONFIG_ACPI_SBS=m
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_OPROFILE_EVENT_MULTIPLEX=y
+CONFIG_ASYNC_TX_DISABLE_CHANNEL_SWITCH=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_SYNCLINK_GT=m
+CONFIG_B43_PCICORE_AUTOSELECT=y
+CONFIG_PATA_VIA=m
+CONFIG_SCSI_HPTIOP=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_ICS932S401=m
+CONFIG_MTD_NAND=m
+CONFIG_NET_SCH_ATM=m
+CONFIG_IP_PIMSM_V2=y
+CONFIG_INET_TUNNEL=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_IDLE=y
+CONFIG_CRYPTO_TWOFISH_586=m
+CONFIG_SND_MPU401_UART=m
+CONFIG_SND_VMASTER=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_SMS_SIANO_MDTV=m
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_HISAX_DIEHLDIVA=y
+CONFIG_B44_PCICORE_AUTOSELECT=y
+CONFIG_SYN_COOKIES=y
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_CRYPTO_VMAC=m
+CONFIG_DMIID=y
+CONFIG_ACER_WMI=m
+CONFIG_KS0108=m
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_ISDN_DRV_AVMB1_AVM_CS=m
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4=y
+CONFIG_IPW2200_RADIOTAP=y
+CONFIG_PATA_ATP867X=m
+CONFIG_SATA_SX4=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_HISAX_SEDLBAUER_CS=m
+CONFIG_8139CP=m
+CONFIG_SATA_VIA=m
+CONFIG_PROC_EVENTS=y
+CONFIG_IP_VS_TAB_BITS=12
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_PCI_BIOS=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_DELL_RBU=m
+CONFIG_ACPI_WMI=m
+CONFIG_VIDEO_CX88_MPEG=m
+CONFIG_SENSORS_F71882FG=m
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_USB_NET_INT51X1=m
+CONFIG_DEVTMPFS=y
+CONFIG_ATM_CLIP=m
+CONFIG_PCI_OLPC=y
+CONFIG_PARAVIRT=y
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_USB_S2255=m
+CONFIG_HDLC_PPP=m
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_PARPORT_NOT_PC=y
+CONFIG_NET_ACT_IPT=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_EXT2_FS_XIP=y
+CONFIG_ASUS_LAPTOP=m
+CONFIG_USB_SUSPEND=y
+CONFIG_SYNCLINK=m
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_X86_MRST=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_MFD_SM501=m
+CONFIG_WL1251=m
+CONFIG_EWRK3=m
+CONFIG_RDS_RDMA=m
+CONFIG_PD6729=m
+CONFIG_VIRTIO_RING=m
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_LOCKD=m
+CONFIG_QUOTACTL=y
+CONFIG_DELL_WMI=m
+CONFIG_USB_XUSBATM=m
+CONFIG_USB_PRINTER=m
+CONFIG_SND_HDA_GENERIC=y
+CONFIG_NET_SCH_SFQ=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_ZONE_DMA=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_SQUASHFS=m
+CONFIG_HID_SUNPLUS=y
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_KEYBOARD_MAX7359=m
+CONFIG_QT2160=m
+CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+CONFIG_IGBVF=m
+CONFIG_WIRELESS=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_TIMER_STATS=y
+CONFIG_EFI_VARS=y
+CONFIG_SND_MONA=m
+CONFIG_B43_DEBUG=y
+CONFIG_IXGBE=m
+CONFIG_ATA_PIIX=m
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_IP_VS_LBLCR=m
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_FB_ATY128=m
+CONFIG_IB700_WDT=m
+CONFIG_XEN_FBDEV_FRONTEND=y
+CONFIG_FB_BACKLIGHT=y
+CONFIG_SATA_SIL=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_KEXEC=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_KALLSYMS=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_UBIFS_FS=m
+CONFIG_HID_SUPPORT=y
+CONFIG_VIDEO_IR=m
+CONFIG_PC8736x_GPIO=m
+CONFIG_MD_RAID10=m
+CONFIG_NEW_LEDS=y
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_HAVE_KVM=y
+CONFIG_CRYPTO_FIPS=y
+CONFIG_FSNOTIFY=y
+CONFIG_EDAC_MM_EDAC=m
+CONFIG_FB_TILEBLITTING=y
+CONFIG_DVB_MT312=m
+CONFIG_NSC_GPIO=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_BNX2X=m
+CONFIG_SATA_ULI=m
+CONFIG_SCSI_PPA=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_K8_NB=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_NLS_UTF8=m
+CONFIG_SND_HDSP=m
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+CONFIG_HISAX_SEDLBAUER=y
+CONFIG_MWL8K=m
+CONFIG_ATMEL=m
+CONFIG_ETHOC=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_ENCLOSURE_SERVICES=m
+CONFIG_SSFDC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_AGP_AMD64=y
+CONFIG_JFFS2_FS_POSIX_ACL=y
+CONFIG_VIDEO_CX25840=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+CONFIG_PATA_SIS=m
+CONFIG_SCSI_IMM=m
+CONFIG_IPV6_SIT=m
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_SATA_PMP=y
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ=y
+CONFIG_PM_SLEEP=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_AGP_EFFICEON=y
+CONFIG_DVB_MT352=m
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_HID_PANTHERLORD=y
+CONFIG_SND_WSS_LIB=m
+CONFIG_DVB_DYNAMIC_MINORS=y
+CONFIG_SENSORS_ABITUGURU3=m
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_SATA_SIS=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_INET_ESP=m
+CONFIG_AUDIT=y
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_AMIGA_PARTITION=y
+CONFIG_EDAC_I3000=m
+CONFIG_UWB_WHCI=m
+CONFIG_SND_HDA_INPUT_JACK=y
+CONFIG_SND_PCM_OSS=m
+CONFIG_SONY_LAPTOP=m
+CONFIG_INPUT_MOUSE=y
+CONFIG_PCMCIA_WL3501=m
+CONFIG_SECURITY=y
+CONFIG_NET_IPIP=m
+CONFIG_BTRFS_FS=m
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_SYS_HYPERVISOR=y
+CONFIG_NF_NAT_PPTP=m
+CONFIG_PCI_STUB=y
+CONFIG_TREE_RCU=y
+CONFIG_EDAC_I5000=m
+CONFIG_EDAC_I3200=m
+CONFIG_SND_PCSP=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_USB_GL860=m
+CONFIG_VIDEO_SAA7134=m
+CONFIG_ISDN_MPP=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_SHMEM=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_EXPORTFS=m
+CONFIG_EDAC_I5100=m
+CONFIG_LEDS_TRIGGER_TIMER=m
+CONFIG_SND_HDA_INPUT_BEEP=y
+CONFIG_SND_MIRO=m
+CONFIG_VIDEO_CX23885=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_MISDN=m
+CONFIG_SCSI_AIC94XX=m
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_CRYPTO_DEV_PADLOCK=m
+CONFIG_VIDEO_SAA7127=m
+CONFIG_ISDN_PPP_VJ=y
+CONFIG_IPW2200_PROMISCUOUS=y
+CONFIG_PATA_HPT3X2N=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_INET_LRO=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_EPOLL=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_HID_SONY=y
+CONFIG_FB_SYS_FOPS=y
+CONFIG_VIDEO_SAA7164=m
+CONFIG_VIDEO_SAA7146=m
+CONFIG_ITCO_WDT=m
+CONFIG_ISDN_PPP=y
+CONFIG_SCSI_IPS=m
+CONFIG_INFTL=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_YENTA_TI=y
+CONFIG_RELAY=y
+CONFIG_MSDOS_FS=m
+CONFIG_EDAC_I5400=m
+CONFIG_FONT_8x8=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_DVB_BUDGET_CORE=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_VIDEOBUF_DMA_SG=m
+CONFIG_GIGASET_BASE=m
+CONFIG_ASYNC_PQ=m
+CONFIG_SCSI_AIC79XX=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_HOTPLUG_PCI_COMPAQ=m
+CONFIG_ACPI_PROCESSOR_AGGREGATOR=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_RPCSEC_GSS_KRB5=m
+CONFIG_ISCSI_IBFT_FIND=y
+CONFIG_VIDEO_TDA7432=m
+CONFIG_PPDEV=m
+CONFIG_PCMCIA_SPECTRUM=m
+CONFIG_PCMCIA_ATMEL=m
+CONFIG_MDIO_BITBANG=m
+CONFIG_PATA_PDC2027X=m
+CONFIG_XEN_MAX_DOMAIN_MEMORY=128
+CONFIG_CRYPTO_TEST=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_SND_INTEL8X0=m
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_BACKLIGHT_WM831X=m
+CONFIG_MEGARAID_SAS=m
+CONFIG_SCSI_TGT=m
+CONFIG_DEBUG_RODATA=y
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_CIFS_DFS_UPCALL=y
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_PPP_MPPE=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_YENTA=m
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_LEDS_CLEVO_MAIL=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_HW_RANDOM_GEODE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_SERIO=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_DM_CRYPT=m
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_HID_LOGITECH=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_CS46XX_NEW_DSP=y
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_INPUT_WM831X_ON=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_XENFS=m
+CONFIG_UIO_PCI_GENERIC=m
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_REGULATOR_LP3971=m
+CONFIG_REGULATOR_WM8400=m
+CONFIG_SENSORS_I5K_AMB=m
+CONFIG_WM831X_POWER=m
+CONFIG_PPPOE=m
+CONFIG_MAC_EMUMOUSEBTN=y
+CONFIG_SCSI_OSD_DPRINT_SENSE=1
+CONFIG_NVRAM=y
+CONFIG_PCMCIA_PROBE=y
+CONFIG_X86_32_NON_STANDARD=y
+CONFIG_MM_OWNER=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_KARMA_PARTITION=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_SCSI_BNX2_ISCSI=m
+CONFIG_MTD_OOPS=m
+CONFIG_CLS_U32_MARK=y
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_FILE_LOCKING=y
+CONFIG_ACPI_TOSHIBA=m
+CONFIG_USB_SUPPORT=y
+CONFIG_SND_SB16_DSP=m
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_VIDEO_SAA6588=m
+CONFIG_HYSDN=m
+CONFIG_HISAX_AVM_A1_CS=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_SMSC_PHY=m
+CONFIG_SCSI_SRP=m
+CONFIG_WIMAX=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_SCHED_TRACER=y
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_HUGETLB_PAGE=y
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_SMS_USB_DRV=m
+CONFIG_MISDN_HFCPCI=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_X86_POWERNOW_K7=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_UIO_PDRV=m
+CONFIG_INFINIBAND_CXGB3=m
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_SND_VX222=m
+CONFIG_FB_RADEON_BACKLIGHT=y
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_VIDEO_SAA7146_VV=m
+CONFIG_REGULATOR_WM8350=m
+CONFIG_ISDN_CAPI_CAPI20=m
+CONFIG_SIS900=m
+CONFIG_ULTRA=m
+CONFIG_FB=y
+CONFIG_SATA_SVW=m
+CONFIG_BT_HCIBCM203X=m
+CONFIG_X86_POWERNOW_K8=m
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_SOUND=m
+CONFIG_HISAX_ENTERNOW_PCI=y
+CONFIG_SIS190=m
+CONFIG_SCSI_OSD_INITIATOR=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_ACPI_THERMAL=y
+CONFIG_HWMON=y
+CONFIG_HIBERNATION_NVS=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_QUOTA=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+CONFIG_USB_WUSB=m
+CONFIG_FB_NVIDIA_BACKLIGHT=y
+CONFIG_REGULATOR_USERSPACE_CONSUMER=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_TMPFS=y
+CONFIG_ASK_IP_FIB_HASH=y
+CONFIG_X86_32=y
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_I2C_PIIX4=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_SCHED_HRTICK=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_SND_INDIGODJ=m
+CONFIG_IPMI_HANDLER=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_PCMCIA_AXNET=m
+CONFIG_B43LEGACY_DMA_AND_PIO_MODE=y
+CONFIG_DUMMY=m
+CONFIG_PATA_NETCELL=m
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_IP_VS_DH=m
+CONFIG_FUTEX=y
+CONFIG_BUILD_DOCSRC=y
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_SND_RME32=m
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_VIDEO_MSP3400=m
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SERIO_LIBPS2=y
+CONFIG_WLAN_80211=y
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_VIDEO_IR_I2C=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM63=m
+CONFIG_HISAX_MAX_CARDS=8
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_B43_HWRNG=y
+CONFIG_TULIP=m
+CONFIG_MISC_DEVICES=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_SND_CA0106=m
+CONFIG_DVB_AF9013=m
+CONFIG_VIDEOBUF_DVB=m
+CONFIG_SBC_FITPC2_WATCHDOG=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_B43LEGACY_DMA=y
+CONFIG_IP_VS_LC=m
+CONFIG_NETWORK_SECMARK=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM83=m
+CONFIG_RT2X00=m
+CONFIG_SCSI_ARCMSR_AER=y
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_INPUT=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_EEEPC_LAPTOP=m
+CONFIG_DVB_L64781=m
+CONFIG_SENSORS_LM93=m
+CONFIG_SENSORS_LM75=m
+CONFIG_I2C_AMD756=m
+CONFIG_TABLET_USB_GTCO=m
+CONFIG_MD=y
+CONFIG_SCSI_PMCRAID=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_CPQ_CISS_DA=m
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_LOCALVERSION=""
+CONFIG_USB_DEVICEFS=y
+CONFIG_SND_MAESTRO3=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_SENSORS_LM85=m
+CONFIG_X86_POPAD_OK=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_DVB_DM1105=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_VIDEO_CX2341X=m
+CONFIG_SENSORS_LM77=m
+CONFIG_TCG_INFINEON=m
+CONFIG_MOUSE_BCM5974=m
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_DVB_B2C2_FLEXCOP=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM78=m
+CONFIG_HISAX_FRITZ_PCIPNP=m
+CONFIG_FORCEDETH=m
+CONFIG_CAN_SJA1000_PLATFORM=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_MISDN_HFCUSB=m
+CONFIG_SC92031=m
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_HOTPLUG_PCI_IBM=m
+CONFIG_MICROCODE=m
+CONFIG_CRYPTO_HASH2=y
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_SND_INDIGOIO=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_HISAX_NO_KEYPAD=y
+CONFIG_IXGBE_DCA=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_BT=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_X86_APM_BOOT=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_SND_RME96=m
+CONFIG_LCD_PLATFORM=m
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_IXGBE_DCB=y
+CONFIG_BROADCOM_PHY=m
+CONFIG_PATA_JMICRON=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_THINKPAD_ACPI_HOTKEY_POLL=y
+CONFIG_XEN_SCRUB_PAGES=y
+CONFIG_SND_OPL3_LIB=m
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VIDEO_USBVISION=m
+CONFIG_VIDEO_MT9V011=m
+CONFIG_SENSORS_IT87=m
+CONFIG_I2C_NFORCE2_S4985=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+CONFIG_PATA_MARVELL=m
+CONFIG_SCSI_LOGGING=y
+CONFIG_MTD_QINFO_PROBE=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_SYSFS=y
+CONFIG_KMEMTRACE=y
+CONFIG_SND_OPL4_LIB=m
+CONFIG_SND_RAWMIDI_SEQ=m
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_AB3100_OTP=m
+CONFIG_IP6_NF_SECURITY=m
+CONFIG_X86_CMPXCHG64=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_HW_RANDOM_INTEL=m
+CONFIG_PATA_PDC_OLD=m
+CONFIG_TCP_CONG_BIC=m
+CONFIG_X86_CPUID=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_STOP_MACHINE=y
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_DVB_AV7110=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_VIDEO_TVP5150=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_SCSI_MPT2SAS=m
+CONFIG_BT_HCIBTUART=m
+CONFIG_IP_VS_SH=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_VIDEO_SAA711X=m
+CONFIG_SATA_INIC162X=m
+CONFIG_FCOE_FNIC=m
+CONFIG_AIC79XX_RESET_DELAY_MS=15000
+CONFIG_NET_ACT_GACT=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_SECURITY_NETWORK_XFRM=y
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_HISAX_AVM_A1_PCMCIA=y
+CONFIG_SATA_AHCI=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_PCIE_ECRC=y
+CONFIG_ACPI_DOCK=y
+CONFIG_PM=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_FB_SAVAGE=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_ADM8211=m
+CONFIG_PATA_OLDPIIX=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_NO_HZ=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_LIBERTAS_USB=m
+CONFIG_SCSI_DH_ALUA=m
+CONFIG_IP_VS_NQ=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_UHCI_HCD=y
+CONFIG_FB_RADEON=m
+CONFIG_INPUT_APANEL=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_BE2NET=m
+CONFIG_NET_DSA_MV88E6131=y
+CONFIG_IPV6_MIP6=m
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_CRYPTO_CAST6=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_HID_GYRATION=y
+CONFIG_SND_BT87X=m
+CONFIG_REGULATOR_BQ24022=m
+CONFIG_HAPPYMEAL=m
+CONFIG_DCDBAS=m
+CONFIG_NET_DSA_MV88E6060=y
+CONFIG_IP_VS=m
+CONFIG_USB_WHCI_HCD=m
+CONFIG_FB_NVIDIA=m
+CONFIG_DVB_AU8522=m
+CONFIG_VIDEO_SAA717X=m
+CONFIG_IWLWIFI_LEDS=y
+CONFIG_PATA_ACPI=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_APM_CPU_IDLE=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_HZ=1000
+CONFIG_X86_BSWAP=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_DLM_DEBUG=y
+CONFIG_USB_XHCI_HCD=m
+CONFIG_SND_AD1889=m
+CONFIG_INPUT_POWERMATE=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_USB_KC2190=y
+CONFIG_USB_AN2720=y
+CONFIG_ACENIC=m
+CONFIG_FIREWIRE_NET=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_HUGETLBFS=y
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_HISAX_NI1=y
+CONFIG_MISDN_NETJET=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_MTD_NAND_IDS=m
+CONFIG_IP_VS_RR=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_INET_DIAG=m
+CONFIG_TRACING_SUPPORT=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_THINKPAD_ACPI_VIDEO=y
+CONFIG_TC1100_WMI=m
+CONFIG_I2C_SIS630=m
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_B43LEGACY_PIO=y
+CONFIG_NET_ETHERNET=y
+CONFIG_FIREWIRE_OHCI_DEBUG=y
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_CB710_CORE=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_XFRM_MIGRATE=y
+CONFIG_ACPI_BLACKLIST_YEAR=1999
+CONFIG_NLS_ISO8859_2=m
+CONFIG_HID_APPLE=y
+CONFIG_MFD_WM8400=m
+CONFIG_HISAX_NETJET=y
+CONFIG_NS83820=m
+CONFIG_NATIONAL_PHY=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_REED_SOLOMON=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_X86_RESERVE_LOW_64K=y
+CONFIG_NLS_ISO8859_3=m
+CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA=y
+CONFIG_EDAC_E752X=m
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_BLOCK=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_HID_MONTEREY=y
+CONFIG_SND_CS5530=m
+CONFIG_SATA_PROMISE=m
+CONFIG_TIFM_7XX1=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_FIFO=y
+CONFIG_XFRM_STATISTICS=y
+CONFIG_NLS_ISO8859_4=m
+CONFIG_HYPERV_BLOCK=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_BATTERY_OLPC=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_MOUSE_SERIAL=m
+CONFIG_ISDN_HDLC=m
+CONFIG_USB_EPSON2888=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_DE2104X=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_NLS_ISO8859_5=m
+CONFIG_HID_PETALYNX=y
+CONFIG_CONSOLE_POLL=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+CONFIG_B43=m
+CONFIG_ATM_BR2684=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_XEN_DEBUG_FS=y
+CONFIG_NLS_ISO8859_6=m
+CONFIG_MFD_WM8350=m
+CONFIG_I2C_TINY_USB=m
+CONFIG_VT=y
+CONFIG_B44=m
+CONFIG_ISDN_CAPI=m
+CONFIG_MIGRATION=y
+CONFIG_TICK_ONESHOT=y
+CONFIG_PROFILING=y
+CONFIG_CRYPTO_GHASH=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HID_WACOM=m
+CONFIG_SND_AU8810=m
+CONFIG_TTPCI_EEPROM=m
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_INPUT_TABLET=y
+CONFIG_USB_ZD1201=m
+CONFIG_MD_LINEAR=m
+CONFIG_SATA_VITESSE=m
+CONFIG_CONNECTOR=y
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_GFS2_FS_LOCKING_DLM=y
+CONFIG_SND_AU8820=m
+CONFIG_REGULATOR_WM831X=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_VLAN_8021Q=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IMA_AUDIT=y
+CONFIG_POWER_TRACER=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_NLS_ISO8859_9=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_SND_AU8830=m
+CONFIG_FONT_8x16=y
+CONFIG_MLX4_CORE=m
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_NET_SCHED=y
+CONFIG_BRIDGE=m
+CONFIG_NETFILTER=y
+CONFIG_INET6_ESP=m
+CONFIG_PCMCIA=y
+CONFIG_PCCARD=y
+CONFIG_SPARSEMEM=y
+CONFIG_BASE_FULL=y
+CONFIG_RTC_DRV_V3020=m
+CONFIG_INFINIBAND_USER_MEM=y
+CONFIG_USB_ISIGHTFW=m
+CONFIG_SMSC_SCH311X_WDT=m
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA=m
+CONFIG_PCI_ATMEL=m
+CONFIG_VIA_VELOCITY=m
+CONFIG_DM_MULTIPATH_ST=m
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_CRC_CCITT=m
+CONFIG_IP_MULTICAST=y
+CONFIG_MD_RAID456=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_MTD_BLOCK=m
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_USB_SL811_HCD=m
+CONFIG_TCG_ATMEL=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MTD_NAND_DISKONCHIP=m
+CONFIG_HIGHMEM64G=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SOC_CAMERA_PLATFORM=m
+CONFIG_SENSORS_G760A=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_ATA_OVER_ETH=m
+CONFIG_GACT_PROB=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_SND_AC97_POWER_SAVE=y
+CONFIG_DISPLAY_SUPPORT=m
+CONFIG_FB_DDC=m
+CONFIG_VIDEO_CX88_VP3054=m
+CONFIG_EPIC100=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_HAS_IOMEM=y
+CONFIG_RTC_DRV_X1205=m
+CONFIG_AGP_INTEL=y
+CONFIG_HISAX_NO_LLC=y
+CONFIG_IPW2100=m
+CONFIG_MTD_CFI_UTIL=m
+CONFIG_RFKILL_INPUT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_FW_LOADER=y
+CONFIG_CRYPTO_DEV_PADLOCK_AES=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_EARLY_PRINTK=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SND_ES1968=m
+CONFIG_NETPOLL_TRAP=y
+CONFIG_SSB_SDIOHOST=y
+CONFIG_IPW2200=m
+CONFIG_MAC80211_HWSIM=m
+CONFIG_TIGON3=m
+CONFIG_MTD_CK804XROM=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_IO_DELAY_0X80=y
+CONFIG_FTRACE=y
+CONFIG_NLS_ASCII=y
+CONFIG_USB_MDC800=m
+CONFIG_DVB_SP8870=m
+CONFIG_VIDEO_SAA7134_DVB=m
+CONFIG_VIDEO_DEV=m
+CONFIG_REGULATOR=y
+CONFIG_I2C_PCA_PLATFORM=m
+CONFIG_B43_PCMCIA=y
+CONFIG_VIA_RHINE=m
+CONFIG_MTD_TS5500=m
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_DVB_USB_GL861=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_WL12XX=m
+CONFIG_SCSI_LPFC=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_CRYPTO_DEV_PADLOCK_SHA=m
+CONFIG_RTC_INTF_DEV=y
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_LCD_CLASS_DEVICE=m
+CONFIG_VIDEO_CX231XX=m
+CONFIG_USB_GSPCA=m
+CONFIG_HISAX_HFC_SX=y
+CONFIG_IP_DCCP_CCID3=y
+CONFIG_X86_ACPI_CPUFREQ=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_ISO9660_FS=y
+CONFIG_UWB_I1480U=m
+CONFIG_HID_ZEROPLUS=y
+CONFIG_HID_NTRIG=y
+CONFIG_TIFM_CORE=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_PACKET=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CRYPTO_SHA256=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DVB_BT8XX=m
+CONFIG_XEN_KBDDEV_FRONTEND=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_BT_RFCOMM=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_PCI_GOANY=y
+CONFIG_KVM_CLOCK=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_CONSTRUCTORS=y
+CONFIG_CRYPTO_RMD160=m
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_RTC_DRV_STK17TA8=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_I2C_AMD8111=m
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_MTD_LPDDR=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_SCHED_SMT=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_FB_SAVAGE_I2C=y
+CONFIG_FB_EFI=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_INPUT_WISTRON_BTNS=m
+CONFIG_DE_AOC=y
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_SCSI_3W_9XXX=m
+CONFIG_SCSI_OSD_ULD=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_FIB_RULES=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_CRAMFS=m
+CONFIG_HID_EZKEY=y
+CONFIG_SND_HWDEP=m
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_FUSION_FC=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_BOUNCE=y
+CONFIG_HAVE_AOUT=y
+CONFIG_EDAC_I82860=m
+CONFIG_SND_HDA_RECONFIG=y
+CONFIG_FB_ATY_BACKLIGHT=y
+CONFIG_FB_RADEON_I2C=y
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_MOUSE_PS2=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NET_IPGRE=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_EDAC_R82600=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_VIDEO_CX88_BLACKBIRD=m
+CONFIG_IBMASR=m
+CONFIG_FEALNX=m
+CONFIG_I2C=m
+CONFIG_WIRELESS_EXT=y
+CONFIG_RTC_CLASS=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_HIDRAW=y
+CONFIG_FB_NVIDIA_I2C=y
+CONFIG_FB_CIRRUS=m
+CONFIG_ISDN_CAPI_CAPIFS=m
+CONFIG_HISAX_HFC4S8S=m
+CONFIG_HW_RANDOM=y
+CONFIG_CRC_T10DIF=m
+CONFIG_MTD_PMC551=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_PCCARD_NONSTATIC=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_SECURITY_FILE_CAPABILITIES=y
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_LZO_COMPRESS=m
+CONFIG_INOTIFY_USER=y
+CONFIG_SND_HDSPM=m
+CONFIG_PCIPCWATCHDOG=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_MAX_RAW_DEVS=8192
+CONFIG_FIXED_PHY=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_IOMMU_API=y
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_MACHZ_WDT=m
+CONFIG_I2C_ALI1535=m
+CONFIG_MISDN_DSP=m
+CONFIG_RT2X00_LIB_HT=y
+CONFIG_IWL3945=m
+CONFIG_ISCSI_TCP=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_XEN_BLKDEV_FRONTEND=m
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_X86_HT=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_SND_CTXFI=m
+CONFIG_I2C_ALI1563=m
+CONFIG_INPUT_PCSPKR=m
+CONFIG_CHELSIO_T1_1G=y
+CONFIG_SCSI_CXGB3_ISCSI=m
+CONFIG_HZ_1000=y
+CONFIG_TASKSTATS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_XEN_SYS_HYPERVISOR=y
+CONFIG_HID_GREENASIA=y
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_RTL8180=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_DVB_USB_M920X=m
+CONFIG_VIDEO_UPD64083=m
+CONFIG_HERMES=m
+CONFIG_HOSTAP_CS=m
+CONFIG_EL3=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_RFKILL=m
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_SND_GINA20=m
+CONFIG_SND_TIMER=m
+CONFIG_DVB_BUDGET_PATCH=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_MD_FAULTY=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_VIDEO_CS53L32A=m
+CONFIG_RT2X00_LIB=m
+CONFIG_MTD_BLOCK2MTD=m
+CONFIG_MICROCODE_AMD=y
+CONFIG_X86=y
+CONFIG_JOLIET=y
+CONFIG_CACHEFILES=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_FB_VIA=m
+CONFIG_MFD_WM8350_I2C=m
+CONFIG_LIBIPW=m
+CONFIG_8139TOO=m
+CONFIG_DM_UEVENT=y
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=1
+CONFIG_CRYPTO_SEQIV=m
+CONFIG_N_HDLC=m
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_DCA=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=4
+CONFIG_PHYLIB=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_CRYPTO_TGR192=m
+CONFIG_SND_PCXHR=m
+CONFIG_SND_GINA24=m
+CONFIG_TOUCHSCREEN_EETI=m
+CONFIG_DCB=y
+CONFIG_SDIO_UART=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_SOC_CAMERA_TW9910=m
+CONFIG_DVB_LNBP21=m
+CONFIG_IEEE802154_DRIVERS=m
+CONFIG_RTL8187=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_PANASONIC_LAPTOP=m
+CONFIG_SND_HDA_CODEC_INTELHDMI=y
+CONFIG_SND_MPU401=m
+CONFIG_FB_ATY_CT=y
+CONFIG_WDTPCI=m
+CONFIG_HWMON_VID=m
+CONFIG_SERIO_RAW=m
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON=y
+CONFIG_DM_MIRROR=m
+CONFIG_ISAPNP=y
+CONFIG_NET_DSA_TAG_TRAILER=y
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_SND_MTPAV=m
+CONFIG_SMS_SDIO_DRV=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_ISDN_TTY_FAX=y
+CONFIG_CFG80211=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_I8K=m
+CONFIG_EDD=m
+CONFIG_HID_A4TECH=y
+CONFIG_SND_INTEL8X0M=m
+CONFIG_DVB_CAPTURE_DRIVERS=y
+CONFIG_PPP_ASYNC=m
+CONFIG_MAC80211=m
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_DVB_CX24110=m
+CONFIG_REGULATOR_MAX1586=m
+CONFIG_USBPCWATCHDOG=m
+CONFIG_MFD_WM831X=m
+CONFIG_MTD_NAND_NANDSIM=m
+CONFIG_PHONET=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_NFS_V3=y
+CONFIG_ECRYPT_FS=m
+CONFIG_THINKPAD_ACPI=m
+CONFIG_USB_SERIAL_DEBUG=m
+CONFIG_SND_VIRTUOSO=m
+CONFIG_DVB_B2C2_FLEXCOP_PCI=m
+CONFIG_AB3100_CORE=m
+CONFIG_XEN_NETDEV_FRONTEND=m
+CONFIG_WIMAX_I2400M_SDIO=m
+CONFIG_HOSTAP=m
+CONFIG_SUNGEM=m
+CONFIG_QSEMI_PHY=m
+CONFIG_NET_FC=y
+CONFIG_NET_9P=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_IMA_MEASURE_PCR_IDX=10
+CONFIG_NFS_V4=y
+CONFIG_JBD=m
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_DUMMY=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_PCMCIA_HERMES=m
+CONFIG_CAN_SJA1000=m
+CONFIG_CGROUP_NS=y
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_DVB_CX22700=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_IFB=m
+CONFIG_MTD_NAND_ECC_SMC=y
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_USB_EZUSB=y
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_S5H1420=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_DVB_S5H1411=m
+CONFIG_DVB_CX24123=m
+CONFIG_IGB=m
+CONFIG_ASYNC_RAID6_TEST=m
+CONFIG_CAN=m
+CONFIG_NET_CLS_RSVP=m
+CONFIG_INFINIBAND=m
+CONFIG_GENERIC_IOMAP=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_FAT_FS=m
+CONFIG_FB_ATY_GX=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_DVB_CX22702=m
+CONFIG_I2C_SIS96X=m
+CONFIG_TEHUTI=m
+CONFIG_FIREWIRE_SBP2=m
+CONFIG_MTD_NAND_CAFE=m
+CONFIG_LIB80211=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_DVB_MAX_ADAPTERS=8
+CONFIG_DVB_CX24116=m
+CONFIG_SENSORS_W83L786NG=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_NET_TULIP=y
+CONFIG_FUSION=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_IP_MROUTE=y
+CONFIG_HOTPLUG_PCI_FAKE=m
+CONFIG_EFI=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_DMADEVICES=y
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_FB_ATY=m
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_HISAX_16_3=y
+CONFIG_SCSI_STEX=m
+CONFIG_BT_HCIBT3C=m
+CONFIG_HID=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_IP_NF_RAW=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NLATTR=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_KVM_GUEST=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_USB_BERRY_CHARGE=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_BCM3510=m
+CONFIG_E100=m
+CONFIG_ASYNC_XOR=m
+CONFIG_SATA_SIL24=m
+CONFIG_ATA=y
+CONFIG_IP_DCCP_TFRC_LIB=y
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_NF_NAT=m
+CONFIG_IMA=y
+CONFIG_UDF_FS=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_ACPI_HOTPLUG_MEMORY=y
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_NLS_ISO8859_13=m
+CONFIG_AGP=y
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_DVB_OR51132=m
+CONFIG_SSB_SPROM=y
+CONFIG_NET_DCCPPROBE=m
+CONFIG_PRINTK=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_NLS_ISO8859_14=m
+CONFIG_RPCSEC_GSS_SPKM3=m
+CONFIG_USB_LD=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_DVB_S5H1409=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AIO=y
+CONFIG_X86_32_SMP=y
+CONFIG_NLS_ISO8859_15=m
+CONFIG_INTEL_IOATDMA=m
+CONFIG_RTC_DRV_AB3100=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_VIDEO_CX18=m
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_BT_SCO=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+CONFIG_DMI=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_INTEL_TXT=y
+CONFIG_SUNRPC=m
+CONFIG_FSCACHE_STATS=y
+CONFIG_FS_MBCACHE=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_DVB_ZL10036=m
+CONFIG_SERIAL_8250_NR_UARTS=64
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_HP_ILO=m
+CONFIG_LLC=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_XFRM_USER=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_NOZOMI=m
+CONFIG_ISDN_DRV_GIGASET=m
+CONFIG_SFC=m
+CONFIG_JME=m
+CONFIG_CRC_ITU_T=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_EEPROM_LEGACY=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_PCI=y
+CONFIG_IPC_NS=y
+CONFIG_DLM=m
+CONFIG_USB_USS720=m
+CONFIG_SND_ECHO3G=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+CONFIG_DVB_ZL10353=m
+CONFIG_VIDEO_V4L1=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_ISDN_DRV_AVMB1_B1PCI=m
+CONFIG_AMD8111_ETH=m
+CONFIG_MMC=m
+CONFIG_ISA=y
+CONFIG_VIRTIO=m
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_PID_NS=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_ZISOFS=y
+CONFIG_HYPERV=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_DVB_ZL10039=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_HISAX_BKM_A4T=y
+CONFIG_WIMAX_I2400M_DEBUG_LEVEL=8
+CONFIG_PCMCIA_XIRCOM=m
+CONFIG_BT_HCIDTL1=m
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_APM=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_BUG=y
+CONFIG_CRYPTO_HW=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_NFS_FS=m
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_PCNET32=m
+CONFIG_ULI526X=m
+CONFIG_MII=m
+CONFIG_FIREWIRE_OHCI=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_CGROUP_DEVICE=y
+CONFIG_SND_ICE1712=m
+CONFIG_SND_OPL3_LIB_SEQ=m
+CONFIG_DVB_AV7110_OSD=y
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_NAMESPACES=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_SND_OPL4_LIB_SEQ=m
+CONFIG_BACKLIGHT_MBP_NVIDIA=m
+CONFIG_DVB_BUDGET_CI=m
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+CONFIG_VIDEO_CX88=m
+CONFIG_SENSORS_APPLESMC=m
+CONFIG_SENSORS_SHT15=m
+CONFIG_SENSORS_AD7414=m
+CONFIG_I2C_COMPAT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_IEEE802154_FAKEHARD=m
+CONFIG_P54_COMMON=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_CRYPTO=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_CRYPTO_DEV_GEODE=m
+CONFIG_MMC_SDHCI_PCI=m
+CONFIG_I2C_SIMTEC=m
+CONFIG_SONYPI=m
+CONFIG_MD_AUTODETECT=y
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_NET_DSA_MV88E6XXX_NEED_PPU=y
+CONFIG_ATM=m
+CONFIG_SFI=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_SYSCTL=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_CFAG12864B_RATE=20
+CONFIG_SND_ICE1724=m
+CONFIG_DRM=m
+CONFIG_SERIAL_8250_CS=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HP_WMI=m
+CONFIG_SND_INDIGODJX=m
+CONFIG_SND_ATIIXP_MODEM=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_GPIO_LANGWELL=y
+CONFIG_I2C_SIS5595=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_STACKTRACE=y
+CONFIG_DVB_TDA8261=m
+CONFIG_SND=m
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_SENSORS_AD7418=m
+CONFIG_B43LEGACY_LEDS=y
+CONFIG_B44_PCI=y
+CONFIG_CICADA_PHY=m
+CONFIG_MTD=y
+CONFIG_ACPI_POWER_METER=m
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_WAN=y
+CONFIG_NETDEV_1000=y
+CONFIG_ISL29003=m
+CONFIG_FTL=m
+CONFIG_IP_VS_WLC=m
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_LEDS_ALIX2=m
+CONFIG_DMA_ENGINE=y
+CONFIG_DVB_TTUSB_BUDGET=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_TDA8083=m
+CONFIG_ISDN_CAPI_MIDDLEWARE=y
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=4
+CONFIG_EEPROM_MAX6875=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_X86_BIGSMP=y
+CONFIG_HT_IRQ=y
+CONFIG_SLOW_WORK=y
+CONFIG_NET_NS=y
+CONFIG_NET=y
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_SND_HDA_HWDEP=y
+CONFIG_HISAX_HFC_PCI=y
+CONFIG_SSB=m
+CONFIG_VORTEX=m
+CONFIG_MODULE_UNLOAD=y
+CONFIG_FS_XIP=y
+CONFIG_HID_BELKIN=y
+CONFIG_SND_ALI5451=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_SOC_CAMERA_OV772X=m
+CONFIG_HISAX_1TR6=y
+CONFIG_RT61PCI=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_RDS=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_STANDALONE=y
+CONFIG_EVENT_TRACING=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_MAC_PARTITION=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_DVB_SI21XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_DVB_STB6000=m
+CONFIG_DE2104X_DSL=0
+CONFIG_NETDEVICES=y
+CONFIG_USB=y
+CONFIG_IP_VS_FTP=m
+CONFIG_INET_TCP_DIAG=m
+CONFIG_YENTA_TOSHIBA=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_COMPAL_LAPTOP=m
+CONFIG_MEMSTICK_TIFM_MS=m
+CONFIG_DVB_STB6100=m
+CONFIG_SENSORS_CORETEMP=m
+CONFIG_HDLC_CISCO=m
+CONFIG_MLX4_DEBUG=y
+CONFIG_CHELSIO_T1=m
+CONFIG_KSM=y
+CONFIG_XEN=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_X86_PLATFORM_DEVICES=y
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_DMA_SGBUF=y
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_BUDGET_AV=m
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_NIU=m
+CONFIG_MTD_ALAUDA=m
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS=0
+CONFIG_EFI_PARTITION=y
+CONFIG_FSCACHE=m
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_MMC_RICOH_MMC=m
+CONFIG_NLS=y
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_SOC_CAMERA=m
+CONFIG_SENSORS_DS1621=m
+CONFIG_UIO=m
+CONFIG_PATA_CS5535=m
+CONFIG_CHELSIO_T3=m
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_UWB=m
+CONFIG_SND_INDIGOIOX=m
+CONFIG_I2C_VIAPRO=m
+CONFIG_SERIAL_8250=y
+CONFIG_PATA_CS5536=m
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_PNP=y
+CONFIG_MMC_VIA_SDMMC=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SENSORS_LIS3LV02D=m
+CONFIG_ISDN_DRV_AVMB1_T1PCI=m
+CONFIG_MTD_CFI_I1=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_MMU=y
+CONFIG_EDAC_E7XXX=m
+CONFIG_MEMSTICK_JMICRON_38X=m
+CONFIG_DVB_ISL6421=m
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_USB_NET_DM9601=m
+CONFIG_B43_PIO=y
+CONFIG_PATA_IT8213=m
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MTD_CFI_I2=y
+CONFIG_PPP=m
+CONFIG_PCI_LEGACY=y
+CONFIG_SMP=y
+CONFIG_XEN_COMPAT_XENFS=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SND_PCMCIA=y
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_SENSORS_W83793=m
+CONFIG_HISAX_SCT_QUADRO=y
+CONFIG_B43LEGACY_PCI_AUTOSELECT=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_M686=y
+CONFIG_DEBUG_INFO=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_RTC_DRV_DS1511=m
+CONFIG_AGP_NVIDIA=y
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_DVB_ISL6405=m
+CONFIG_VIDEO_TVAUDIO=m
+CONFIG_SSB_PCMCIAHOST_POSSIBLE=y
+CONFIG_PATA_SERVERWORKS=m
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_IOSCHED_AS=y
+CONFIG_EVENT_PROFILE=y
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_SND_HDA_CODEC_NVHDMI=y
+CONFIG_SENSORS_ASB100=m
+CONFIG_PPS=m
+CONFIG_NET_PCMCIA=y
+CONFIG_BT_HCIVHCI=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_ACPI_VIDEO=m
+CONFIG_BASE_SMALL=0
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_RTC_DRV_BQ4802=m
+CONFIG_SND_CS46XX=m
+CONFIG_DVB_VES1820=m
+CONFIG_B43_PHY_LP=y
+CONFIG_P54_PCI=m
+CONFIG_LIBFCOE=m
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_USB_WUSB_CBAF=m
+CONFIG_SND_ENS1370=m
+CONFIG_SND_AC97_CODEC=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=m
+CONFIG_THERMAL_HWMON=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_STE10XP=m
+CONFIG_MTD_GEN_PROBE=m
+CONFIG_X86_INVLPG=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_SCHEDSTATS=y
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_SND_HDA_PATCH_LOADER=y
+CONFIG_SND_ENS1371=m
+CONFIG_DVB_BUDGET=m
+CONFIG_CS5535_GPIO=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HISAX_ELSA_CS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_BINFMT_ELF=y
+CONFIG_PCI_DIRECT=y
+CONFIG_BINARY_PRINTF=y
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_LEDS_LP3944=m
+CONFIG_MISDN_IPAC=m
+CONFIG_NORTEL_HERMES=m
+CONFIG_TUN=m
+CONFIG_MTD_AR7_PARTS=m
+CONFIG_STP=m
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_BACKLIGHT_PROGEAR=m
+CONFIG_DVB_TTUSB_DEC=m
+CONFIG_ITCO_VENDOR_SUPPORT=y
+CONFIG_INPUT_ATI_REMOTE=m
+CONFIG_SERIO_I8042=y
+CONFIG_SCSI_DEBUG=m
+CONFIG_NET_EMATCH=y
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_SND_CMIPCI=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_DRM_SAVAGE=m
+CONFIG_IGB_DCA=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_PCIEAER=y
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_RTC_DRV_DS1672=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_VIDEO_SAA7134_ALSA=m
+CONFIG_MFD_SM501_GPIO=y
+CONFIG_SENSORS_ATXP1=m
+CONFIG_INPUT_ATLAS_BTNS=m
+CONFIG_NETCONSOLE=m
+CONFIG_WL1251_SDIO=m
+CONFIG_RT73USB=m
+CONFIG_8139TOO_8129=y
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_X86_MCE=y
+CONFIG_RTC_DRV_DS1286=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+CONFIG_LEDS_WM8350=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_DRM_RADEON=m
+CONFIG_DVB_NXT6000=m
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_SENSORS_VT1211=m
+CONFIG_HW_RANDOM_VIRTIO=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_BITREVERSE=y
+CONFIG_IP_VS_WRR=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_TEXTSEARCH=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_X86_PAE=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_SGI_PARTITION=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_W83877F_WDT=m
+CONFIG_SENSORS_HDAPS=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_MTD_CONCAT=m
+CONFIG_BT_HCIUART_LL=y
+CONFIG_NET_SCH_NETEM=m
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_XEN_SAVE_RESTORE=y
+CONFIG_UTS_NS=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_USB_HIDDEV=y
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_W83977F_WDT=m
+CONFIG_I2C_VIA=m
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_LEDS_CLASS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_SND_RME9652=m
+CONFIG_SND_INDIGO=m
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DVB_STB0899=m
+CONFIG_VIDEO_UPD64031A=m
+CONFIG_HW_RANDOM_VIA=m
+CONFIG_USB_BELKIN=y
+CONFIG_NF_CT_NETLINK=m
+CONFIG_CRYPTO_DEV_HIFN_795X=m
+CONFIG_ISCSI_IBFT=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_I2C_I801=m
+CONFIG_ISDN_AUDIO=y
+CONFIG_PCI_HERMES=m
+CONFIG_HIGHMEM=y
+CONFIG_PERF_COUNTERS=y
+CONFIG_SECURITY_SELINUX=y
diff -uNr linux-2.6.32/include/config/auto.conf.cmd clean_modified/linux-2.6.32/include/config/auto.conf.cmd
--- linux-2.6.32/include/config/auto.conf.cmd	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/config/auto.conf.cmd	2019-04-14 13:23:50.737817906 -0500
@@ -0,0 +1,513 @@
+deps_config := \
+	lib/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/lguest/Kconfig \
+	virt/kvm/Kconfig \
+	arch/x86/kvm/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/x86/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/smbfs/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/autofs/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/firmware/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/rar/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/udlfb/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/p9auth/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/b3dfg/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/dst/Kconfig \
+	drivers/staging/dream/camera/Kconfig \
+	drivers/staging/dream/smd/Kconfig \
+	drivers/staging/dream/Kconfig \
+	drivers/staging/android/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/mimio/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192su/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/altpciechdma/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/rt3090/Kconfig \
+	drivers/staging/rt2870/Kconfig \
+	drivers/staging/rt2860/Kconfig \
+	drivers/staging/otus/Kconfig \
+	drivers/staging/poch/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/s3c24xx/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/zc0301/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvideo/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/chips/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/ath/ar9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/ieee1394/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgb3i/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig.debug \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/pci/hotplug/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/mca/Kconfig \
+	drivers/eisa/Kconfig \
+	drivers/pci/Kconfig \
+	drivers/pci/pcie/aer/Kconfig.debug \
+	drivers/pci/pcie/aer/Kconfig \
+	drivers/pci/pcie/Kconfig \
+	drivers/idle/Kconfig \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig \
+	arch/x86/kernel/cpu/cpufreq/Kconfig \
+	drivers/sfi/Kconfig \
+	drivers/acpi/Kconfig \
+	kernel/power/Kconfig \
+	kernel/Kconfig.hz \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	arch/x86/Kconfig.cpu \
+	arch/x86/lguest/Kconfig \
+	arch/x86/xen/Kconfig \
+	kernel/time/Kconfig \
+	kernel/Kconfig.freezer \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	init/Kconfig \
+	arch/x86/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "2.6.32"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "i386"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -uNr linux-2.6.32/include/config/kernel.release clean_modified/linux-2.6.32/include/config/kernel.release
--- linux-2.6.32/include/config/kernel.release	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/config/kernel.release	2019-04-14 13:23:50.742685336 -0500
@@ -0,0 +1 @@
+2.6.32
diff -uNr linux-2.6.32/include/linux/autoconf.h clean_modified/linux-2.6.32/include/linux/autoconf.h
--- linux-2.6.32/include/linux/autoconf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/linux/autoconf.h	2019-04-14 13:23:50.747890808 -0500
@@ -0,0 +1,2942 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.32
+ * Sat Apr 13 14:09:53 2019
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_USB_SISUSBVGA_MODULE 1
+#define CONFIG_DVB_STV6110_MODULE 1
+#define CONFIG_VIDEO_V4L1_COMPAT 1
+#define CONFIG_SENSORS_WM8350_MODULE 1
+#define CONFIG_PCMCIA_FMVJ18X_MODULE 1
+#define CONFIG_BLK_DEV_FD_MODULE 1
+#define CONFIG_ACPI_AC 1
+#define CONFIG_ACPI_SYSFS_POWER 1
+#define CONFIG_PM_STD_PARTITION ""
+#define CONFIG_SECURITY_NETWORK 1
+#define CONFIG_OSF_PARTITION 1
+#define CONFIG_UBIFS_FS_ZLIB 1
+#define CONFIG_RTC_DRV_M41T80_MODULE 1
+#define CONFIG_USB_LEGOTOWER_MODULE 1
+#define CONFIG_HID_CHERRY 1
+#define CONFIG_SND_SB_COMMON_MODULE 1
+#define CONFIG_FB_RIVA_BACKLIGHT 1
+#define CONFIG_DVB_PLUTO2_MODULE 1
+#define CONFIG_DVB_STV0900_MODULE 1
+#define CONFIG_HISAX_ELSA 1
+#define CONFIG_RT2X00_LIB_PCI_MODULE 1
+#define CONFIG_BONDING_MODULE 1
+#define CONFIG_MTD_ABSENT_MODULE 1
+#define CONFIG_INET_XFRM_TUNNEL_MODULE 1
+#define CONFIG_KRETPROBES 1
+#define CONFIG_CRYPTO_ANUBIS_MODULE 1
+#define CONFIG_DEBUG_LIST 1
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_JBD2_MODULE 1
+#define CONFIG_VIDEO_EM28XX_ALSA_MODULE 1
+#define CONFIG_HYSDN_CAPI 1
+#define CONFIG_HERMES_CACHE_FW_ON_INIT 1
+#define CONFIG_P54_USB_MODULE 1
+#define CONFIG_MACVLAN_MODULE 1
+#define CONFIG_NET_DROP_MONITOR 1
+#define CONFIG_NETFILTER_TPROXY_MODULE 1
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_ARCH_DEFCONFIG "arch/x86/configs/i386_defconfig"
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM 1
+#define CONFIG_EDAC_AMD76X_MODULE 1
+#define CONFIG_USB_SERIAL_IR_MODULE 1
+#define CONFIG_IT8712F_WDT_MODULE 1
+#define CONFIG_CAN_BCM_MODULE 1
+#define CONFIG_TCP_CONG_SCALABLE_MODULE 1
+#define CONFIG_X86_POWERNOW_K7_ACPI 1
+#define CONFIG_AUXDISPLAY 1
+#define CONFIG_SND_SIS7019_MODULE 1
+#define CONFIG_DVB_USB_AF9005_REMOTE_MODULE 1
+#define CONFIG_USB_GSPCA_T613_MODULE 1
+#define CONFIG_SOC_CAMERA_MT9M001_MODULE 1
+#define CONFIG_VIDEO_HELPER_CHIPS_AUTO 1
+#define CONFIG_SENSORS_VT8231_MODULE 1
+#define CONFIG_IP6_NF_TARGET_REJECT_MODULE 1
+#define CONFIG_NF_CT_ACCT 1
+#define CONFIG_TCP_CONG_VENO_MODULE 1
+#define CONFIG_CARDBUS 1
+#define CONFIG_CRYPTO_MD4_MODULE 1
+#define CONFIG_SONYPI_COMPAT 1
+#define CONFIG_USB_SERIAL_TI_MODULE 1
+#define CONFIG_SND_HDA_CODEC_CIRRUS 1
+#define CONFIG_INPUT_POLLDEV_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_C4_MODULE 1
+#define CONFIG_ATH_COMMON_MODULE 1
+#define CONFIG_SMSC9420_MODULE 1
+#define CONFIG_BT_HCIUART_MODULE 1
+#define CONFIG_IP_NF_TARGET_TTL_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_QUEUE_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_BEET_MODULE 1
+#define CONFIG_X86_SPEEDSTEP_ICH 1
+#define CONFIG_TASK_XACCT 1
+#define CONFIG_POSIX_MQUEUE_SYSCTL 1
+#define CONFIG_ARCH_MAY_HAVE_PC_FDC 1
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_ASYNC_CORE_MODULE 1
+#define CONFIG_SOC_CAMERA_MT9M111_MODULE 1
+#define CONFIG_VIDEO_FB_IVTV_MODULE 1
+#define CONFIG_VIDEO_V4L2_COMMON_MODULE 1
+#define CONFIG_TOUCHSCREEN_AD7879_MODULE 1
+#define CONFIG_RT2X00_LIB_CRYPTO 1
+#define CONFIG_IPW2200_QOS 1
+#define CONFIG_E1000_MODULE 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_NF_NAT_PROTO_GRE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_CRASH_DUMP 1
+#define CONFIG_X86_MCE_THRESHOLD 1
+#define CONFIG_AUDIT_TREE 1
+#define CONFIG_RTC_DRV_WM8350_MODULE 1
+#define CONFIG_USB_IOWARRIOR_MODULE 1
+#define CONFIG_VIDEO_BTCX_MODULE 1
+#define CONFIG_IPWIRELESS_MODULE 1
+#define CONFIG_PCMCIA_SMC91C92_MODULE 1
+#define CONFIG_BLK_DEV_DM_MODULE 1
+#define CONFIG_BLK_DEV_MD 1
+#define CONFIG_SCSI_LOWLEVEL_PCMCIA 1
+#define CONFIG_SCSI_FC_ATTRS_MODULE 1
+#define CONFIG_PROC_KCORE 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_RTC_DRV_M48T35_MODULE 1
+#define CONFIG_SND_EMU10K1_MODULE 1
+#define CONFIG_DVB_TDA10021_MODULE 1
+#define CONFIG_SYNCLINKMP_MODULE 1
+#define CONFIG_MISDN_W6692_MODULE 1
+#define CONFIG_PPP_MULTILINK 1
+#define CONFIG_TMD_HERMES_MODULE 1
+#define CONFIG_NET_CLS_RSVP6_MODULE 1
+#define CONFIG_CRYPTO_CBC_MODULE 1
+#define CONFIG_X86_SPEEDSTEP_LIB 1
+#define CONFIG_TRACING 1
+#define CONFIG_USB_SERIAL_MODULE 1
+#define CONFIG_AGP_AMD 1
+#define CONFIG_DVB_USB_CXUSB_MODULE 1
+#define CONFIG_SERIAL_JSM_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_IRTOUCH 1
+#define CONFIG_MISDN_ISAR_MODULE 1
+#define CONFIG_USB_RTL8150_MODULE 1
+#define CONFIG_MTD_MTDRAM_MODULE 1
+#define CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE 1
+#define CONFIG_HIGHPTE 1
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define CONFIG_KGDB_TESTS 1
+#define CONFIG_GFS2_FS_MODULE 1
+#define CONFIG_UWB_I1480U_WLP_MODULE 1
+#define CONFIG_SND_DARLA20_MODULE 1
+#define CONFIG_DVB_STV0297_MODULE 1
+#define CONFIG_DVB_TDA10023_MODULE 1
+#define CONFIG_DVB_STV0288_MODULE 1
+#define CONFIG_HISAX_W6692 1
+#define CONFIG_HOSTAP_PCI_MODULE 1
+#define CONFIG_CASSINI_MODULE 1
+#define CONFIG_PCMCIA_FDOMAIN_MODULE 1
+#define CONFIG_CRYPTO_ECB_MODULE 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_X86_PAT 1
+#define CONFIG_TOSHIBA_MODULE 1
+#define CONFIG_USE_GENERIC_SMP_HELPERS 1
+#define CONFIG_HAVE_KERNEL_BZIP2 1
+#define CONFIG_DEBUG_NX_TEST_MODULE 1
+#define CONFIG_SUNRPC_XPRT_RDMA_MODULE 1
+#define CONFIG_KS0108_PORT 0x378
+#define CONFIG_USB_SERIAL_WHITEHEAT_MODULE 1
+#define CONFIG_SND_SEQ_HRTIMER_DEFAULT 1
+#define CONFIG_REGULATOR_TPS65023_MODULE 1
+#define CONFIG_SERIAL_8250_SHARE_IRQ 1
+#define CONFIG_NETXEN_NIC_MODULE 1
+#define CONFIG_PATA_SIL680_MODULE 1
+#define CONFIG_PATA_ARTOP_MODULE 1
+#define CONFIG_PNPACPI 1
+#define CONFIG_NET_9P_VIRTIO_MODULE 1
+#define CONFIG_BT_HCIBLUECARD_MODULE 1
+#define CONFIG_IP_DCCP_CCID3_RTO 100
+#define CONFIG_IP6_NF_RAW_MODULE 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_IMA_LSM_RULES 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_RTC_DRV_RX8025_MODULE 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_DVB_STV0299_MODULE 1
+#define CONFIG_DVB_TDA826X_MODULE 1
+#define CONFIG_MEDIA_TUNER_XC5000_MODULE 1
+#define CONFIG_I2C_NFORCE2_MODULE 1
+#define CONFIG_HVC_DRIVER 1
+#define CONFIG_ZD1211RW_MODULE 1
+#define CONFIG_NET_POCKET 1
+#define CONFIG_WINBOND_840_MODULE 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define CONFIG_CAN_SJA1000_ISA_MODULE 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_X86_LOCAL_APIC 1
+#define CONFIG_NOP_TRACER 1
+#define CONFIG_EXT2_FS_XATTR 1
+#define CONFIG_STAGING 1
+#define CONFIG_EDAC 1
+#define CONFIG_SND_HDA_CODEC_VIA 1
+#define CONFIG_AGP_ALI 1
+#define CONFIG_USB_KAWETH_MODULE 1
+#define CONFIG_DL2K_MODULE 1
+#define CONFIG_BLK_DEV_SD_MODULE 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_RAID_ATTRS_MODULE 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define CONFIG_IP6_NF_MATCH_FRAG_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE 1
+#define CONFIG_THERMAL 1
+#define CONFIG_X86_CPU 1
+#define CONFIG_EXT3_FS_XATTR 1
+#define CONFIG_RTC_DRV_M48T59_MODULE 1
+#define CONFIG_SND_DARLA24_MODULE 1
+#define CONFIG_FB_VIRTUAL_MODULE 1
+#define CONFIG_SOC_CAMERA_MT9T031_MODULE 1
+#define CONFIG_FUSION_LAN_MODULE 1
+#define CONFIG_CFG80211_DEFAULT_PS_VALUE 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK_MODULE 1
+#define CONFIG_SUN_PARTITION 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_EXT4_FS_XATTR 1
+#define CONFIG_USB_CXACRU_MODULE 1
+#define CONFIG_SND_VIA82XX_MODEM_MODULE 1
+#define CONFIG_CRC7_MODULE 1
+#define CONFIG_RT2X00_LIB_USB_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS 16
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_LIB80211_CRYPT_WEP_MODULE 1
+#define CONFIG_NET_PKTGEN_MODULE 1
+#define CONFIG_X86_TSC 1
+#define CONFIG_DVB_PT1_MODULE 1
+#define CONFIG_SOC_CAMERA_MT9V022_MODULE 1
+#define CONFIG_VIDEO_BT848_MODULE 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_PATA_HPT366_MODULE 1
+#define CONFIG_CAN_DEV_MODULE 1
+#define CONFIG_CPU_FREQ_STAT_MODULE 1
+#define CONFIG_USB_SERIAL_ARK3116_MODULE 1
+#define CONFIG_HID_PID 1
+#define CONFIG_SOUND_OSS_CORE_PRECLAIM 1
+#define CONFIG_DVB_TDA10048_MODULE 1
+#define CONFIG_SECURITYFS 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_NATSEMI_MODULE 1
+#define CONFIG_ASYNC_RAID6_RECOV_MODULE 1
+#define CONFIG_NET_EMATCH_U32_MODULE 1
+#define CONFIG_HOTPLUG_PCI_ACPI_IBM_MODULE 1
+#define CONFIG_VM86 1
+#define CONFIG_HPET_TIMER 1
+#define CONFIG_CPU_SUP_TRANSMETA_32 1
+#define CONFIG_VGA_ARB 1
+#define CONFIG_SENSORS_TMP401_MODULE 1
+#define CONFIG_SENSORS_SMSC47B397_MODULE 1
+#define CONFIG_ISDN_CAPI_CAPIDRV_MODULE 1
+#define CONFIG_HDLC_FR_MODULE 1
+#define CONFIG_ATL1_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_TIME_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_LED_MODULE 1
+#define CONFIG_IP_DCCP_MODULE 1
+#define CONFIG_X86_CYCLONE_TIMER 1
+#define CONFIG_CRYPTO_CCM_MODULE 1
+#define CONFIG_CIFS_STATS 1
+#define CONFIG_NFSD_V3 1
+#define CONFIG_RTC_DRV_RX8581_MODULE 1
+#define CONFIG_EDAC_I82875P_MODULE 1
+#define CONFIG_SND_ATIIXP_MODULE 1
+#define CONFIG_DVB_TDA10086_MODULE 1
+#define CONFIG_MEDIA_TUNER_QT1010_MODULE 1
+#define CONFIG_MEDIA_TUNER_XC2028_MODULE 1
+#define CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE 1
+#define CONFIG_ATL2_MODULE 1
+#define CONFIG_NET_DSA_MV88E6XXX 1
+#define CONFIG_NF_NAT_IRC_MODULE 1
+#define CONFIG_FREEZER 1
+#define CONFIG_MODULE_FORCE_LOAD 1
+#define CONFIG_NFSD_V4 1
+#define CONFIG_NOP_USB_XCEIV_MODULE 1
+#define CONFIG_MEDIA_TUNER_MT2131_MODULE 1
+#define CONFIG_SENSORS_TMP421_MODULE 1
+#define CONFIG_I2C_ALGOPCA_MODULE 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_ATA_SFF 1
+#define CONFIG_CHR_DEV_SG_MODULE 1
+#define CONFIG_IP_NF_MATCH_ADDRTYPE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE 1
+#define CONFIG_UIO_AEC_MODULE 1
+#define CONFIG_AGP_ATI 1
+#define CONFIG_MEDIA_TUNER_MT2060_MODULE 1
+#define CONFIG_RAW_DRIVER 1
+#define CONFIG_VMXNET3_MODULE 1
+#define CONFIG_PPP_FILTER 1
+#define CONFIG_USB_NET_PLUSB_MODULE 1
+#define CONFIG_PATA_IT821X_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE 1
+#define CONFIG_VIRTIO_BLK_MODULE 1
+#define CONFIG_BRIDGE_EBT_IP6_MODULE 1
+#define CONFIG_NF_NAT_H323_MODULE 1
+#define CONFIG_HAVE_ATOMIC_IOMAP 1
+#define CONFIG_PCIEAER_INJECT_MODULE 1
+#define CONFIG_CRYPTO_SALSA20_MODULE 1
+#define CONFIG_CRYPTO_CRYPTD_MODULE 1
+#define CONFIG_XOR_BLOCKS_MODULE 1
+#define CONFIG_USB_SEVSEG_MODULE 1
+#define CONFIG_SND_USB_US122L_MODULE 1
+#define CONFIG_SND_AC97_POWER_SAVE_DEFAULT 5
+#define CONFIG_FB_VESA 1
+#define CONFIG_SENSORS_SMSC47M192_MODULE 1
+#define CONFIG_HW_RANDOM_TIMERIOMEM_MODULE 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_LIBERTAS_THINFIRM_MODULE 1
+#define CONFIG_NETDEV_10000 1
+#define CONFIG_FUSION_CTL_MODULE 1
+#define CONFIG_MTD_CFI_MODULE 1
+#define CONFIG_NET_CLS_ROUTE 1
+#define CONFIG_NF_CT_PROTO_SCTP_MODULE 1
+#define CONFIG_X86_MCE_INJECT_MODULE 1
+#define CONFIG_KPROBES 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_CRYPTO_GCM_MODULE 1
+#define CONFIG_CIFS_POSIX 1
+#define CONFIG_CIFS_XATTR 1
+#define CONFIG_INFINIBAND_NES_MODULE 1
+#define CONFIG_DRM_MGA_MODULE 1
+#define CONFIG_AGP_VIA 1
+#define CONFIG_HISAX_EURO 1
+#define CONFIG_FDDI 1
+#define CONFIG_PCMCIA_XIRC2PS_MODULE 1
+#define CONFIG_PLX_HERMES_MODULE 1
+#define CONFIG_MLX4_EN_MODULE 1
+#define CONFIG_BLK_DEV 1
+#define CONFIG_MTD_JEDECPROBE_MODULE 1
+#define CONFIG_BRIDGE_EBT_BROUTE_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE 1
+#define CONFIG_X86_MSR 1
+#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
+#define CONFIG_VIRTIO_PCI_MODULE 1
+#define CONFIG_CRYPTO_SALSA20_586_MODULE 1
+#define CONFIG_KGDB 1
+#define CONFIG_NLS_KOI8_R_MODULE 1
+#define CONFIG_MSI_LAPTOP_MODULE 1
+#define CONFIG_NET_DMA 1
+#define CONFIG_SND_USB_USX2Y_MODULE 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_SND_SEQ_DUMMY_MODULE 1
+#define CONFIG_TOUCHSCREEN_PENMOUNT_MODULE 1
+#define CONFIG_IBM_ASM_MODULE 1
+#define CONFIG_CRYPTO_FCRYPT_MODULE 1
+#define CONFIG_NF_CONNTRACK_IPV4_MODULE 1
+#define CONFIG_INET_AH_MODULE 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_JFFS2_FS_DEBUG 0
+#define CONFIG_QUOTA_TREE 1
+#define CONFIG_USB_EHCI_TT_NEWSCHED 1
+#define CONFIG_SND_MIXART_MODULE 1
+#define CONFIG_SND_LAYLA20_MODULE 1
+#define CONFIG_FB_RIVA_MODULE 1
+#define CONFIG_I2C_AMD756_S4882_MODULE 1
+#define CONFIG_CARDMAN_4000_MODULE 1
+#define CONFIG_INPUT_CM109_MODULE 1
+#define CONFIG_QLA3XXX_MODULE 1
+#define CONFIG_CRYPTO_AES_MODULE 1
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_PHYS_ADDR_T_64BIT 1
+#define CONFIG_SPARSE_IRQ 1
+#define CONFIG_MODULES 1
+#define CONFIG_HAVE_SETUP_PER_CPU_AREA 1
+#define CONFIG_OUTPUT_FORMAT "elf32-i386"
+#define CONFIG_CRYPTO_TEA_MODULE 1
+#define CONFIG_USB_ACM_MODULE 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_DVB_USB_DIB0700_MODULE 1
+#define CONFIG_I2C_CHARDEV_MODULE 1
+#define CONFIG_B43LEGACY_PCICORE_AUTOSELECT 1
+#define CONFIG_USB_USBNET_MODULE 1
+#define CONFIG_BNX2_MODULE 1
+#define CONFIG_FUSION_SAS_MODULE 1
+#define CONFIG_PARPORT_PC_MODULE 1
+#define CONFIG_MTD_COMPLEX_MAPPINGS 1
+#define CONFIG_BT_HIDP_MODULE 1
+#define CONFIG_BT_BNEP_MODULE 1
+#define CONFIG_NF_CONNTRACK_IPV6_MODULE 1
+#define CONFIG_X86_SPEEDSTEP_SMI 1
+#define CONFIG_CPU_SUP_INTEL 1
+#define CONFIG_PCI_QUIRKS 1
+#define CONFIG_CRYPTO_AES_586_MODULE 1
+#define CONFIG_NLS_KOI8_U_MODULE 1
+#define CONFIG_EXT2_FS_MODULE 1
+#define CONFIG_SND_MIA_MODULE 1
+#define CONFIG_DVB_USB_VP702X_MODULE 1
+#define CONFIG_USB_GSPCA_JEILINJ_MODULE 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_MOUSE_VSXXXAA_MODULE 1
+#define CONFIG_MOUSE_PS2_TRACKPOINT 1
+#define CONFIG_HDLC_MODULE 1
+#define CONFIG_IWLWIFI_MODULE 1
+#define CONFIG_PATA_CMD64X_MODULE 1
+#define CONFIG_SCSI_MVSAS_MODULE 1
+#define CONFIG_BLK_DEV_SR_MODULE 1
+#define CONFIG_MTD_SCB2_FLASH_MODULE 1
+#define CONFIG_CAN_RAW_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION_MODULE 1
+#define CONFIG_EXT3_FS_MODULE 1
+#define CONFIG_EDAC_I82975X_MODULE 1
+#define CONFIG_USB_LCD_MODULE 1
+#define CONFIG_VIDEO_CX88_DVB_MODULE 1
+#define CONFIG_I2C_PARPORT_LIGHT_MODULE 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_DLCI_MODULE 1
+#define CONFIG_LIBERTAS_DEBUG 1
+#define CONFIG_R6040_MODULE 1
+#define CONFIG_NF_CONNTRACK_SANE_MODULE 1
+#define CONFIG_CRYPTO_DES_MODULE 1
+#define CONFIG_DEBUG_BOOT_PARAMS 1
+#define CONFIG_GENERIC_TRACER 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_EXT4_FS_MODULE 1
+#define CONFIG_USB_SERIAL_BELKIN_MODULE 1
+#define CONFIG_HID_KYE 1
+#define CONFIG_SND_LAYLA24_MODULE 1
+#define CONFIG_SND_MIXER_OSS_MODULE 1
+#define CONFIG_FB_SM501_MODULE 1
+#define CONFIG_MEDIA_TUNER_MT2266_MODULE 1
+#define CONFIG_SENSORS_THMC50_MODULE 1
+#define CONFIG_SENSORS_F71805F_MODULE 1
+#define CONFIG_CARDMAN_4040_MODULE 1
+#define CONFIG_S2IO_MODULE 1
+#define CONFIG_SCSI_DH_HP_SW_MODULE 1
+#define CONFIG_SCSI_DH 1
+#define CONFIG_FCOE_MODULE 1
+#define CONFIG_CNIC_MODULE 1
+#define CONFIG_INET_DCCP_DIAG_MODULE 1
+#define CONFIG_IP_VS_LBLC_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE 1
+#define CONFIG_CC_STACKPROTECTOR 1
+#define CONFIG_ACPI 1
+#define CONFIG_UIO_CIF_MODULE 1
+#define CONFIG_USB_LED_MODULE 1
+#define CONFIG_USB_HID 1
+#define CONFIG_SND_CS5535AUDIO_MODULE 1
+#define CONFIG_SND_OXYGEN_MODULE 1
+#define CONFIG_DVB_DIB7000M_MODULE 1
+#define CONFIG_DVB_VES1X93_MODULE 1
+#define CONFIG_NETPOLL 1
+#define CONFIG_SLIP_SMART 1
+#define CONFIG_SCSI_MPT2SAS_MAX_SGE 128
+#define CONFIG_NET_DSA 1
+#define CONFIG_NF_DEFRAG_IPV4_MODULE 1
+#define CONFIG_RELOCATABLE 1
+#define CONFIG_QFMT_V2 1
+#define CONFIG_FB_DEFERRED_IO 1
+#define CONFIG_VIDEO_IVTV_MODULE 1
+#define CONFIG_DVB_NXT200X_MODULE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_ENIC_MODULE 1
+#define CONFIG_TULIP_MMIO 1
+#define CONFIG_I2C_ALGOBIT_MODULE 1
+#define CONFIG_FUSION_SPI_MODULE 1
+#define CONFIG_NF_NAT_FTP_MODULE 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_ACPI_CONTAINER 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_USER_STACKTRACE_SUPPORT 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_DEBUG_RODATA_TEST 1
+#define CONFIG_SND_PCI 1
+#define CONFIG_AGP_SWORKS 1
+#define CONFIG_AIRO_CS_MODULE 1
+#define CONFIG_SFC_MTD 1
+#define CONFIG_ICPLUS_PHY_MODULE 1
+#define CONFIG_MTD_PCI_MODULE 1
+#define CONFIG_NF_CONNTRACK_MARK 1
+#define CONFIG_PM_RUNTIME 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_X86_TRAMPOLINE 1
+#define CONFIG_SND_ISA 1
+#define CONFIG_DVB_LGS8GL5_MODULE 1
+#define CONFIG_DVB_DIB7000P_MODULE 1
+#define CONFIG_TCG_NSC_MODULE 1
+#define CONFIG_PPPOATM_MODULE 1
+#define CONFIG_SSB_PCIHOST_POSSIBLE 1
+#define CONFIG_SATA_QSTOR_MODULE 1
+#define CONFIG_CHR_DEV_ST_MODULE 1
+#define CONFIG_RFD_FTL_MODULE 1
+#define CONFIG_NF_NAT_SIP_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_MODULE 1
+#define CONFIG_DETECT_SOFTLOCKUP 1
+#define CONFIG_USB_SERIAL_KOBIL_SCT_MODULE 1
+#define CONFIG_USB_STORAGE_ONETOUCH_MODULE 1
+#define CONFIG_HID_DRAGONRISE 1
+#define CONFIG_DRM_VIA_MODULE 1
+#define CONFIG_SENSORS_ADM1021_MODULE 1
+#define CONFIG_TABLET_USB_AIPTEK_MODULE 1
+#define CONFIG_PCMCIA_3C574_MODULE 1
+#define CONFIG_HOSTAP_PLX_MODULE 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_EEPROM_AT24_MODULE 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_X86_GENERIC 1
+#define CONFIG_SLAB 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_USB_OTG_UTILS 1
+#define CONFIG_DVB_PLL_MODULE 1
+#define CONFIG_SENSORS_ADM1031_MODULE 1
+#define CONFIG_TOUCHSCREEN_AD7879_I2C_MODULE 1
+#define CONFIG_VIRTIO_NET_MODULE 1
+#define CONFIG_NET_ISA 1
+#define CONFIG_WIMAX_DEBUG_LEVEL 8
+#define CONFIG_HOTPLUG 1
+#define CONFIG_CGROUPS 1
+#define CONFIG_HYPERV_NET_MODULE 1
+#define CONFIG_USB_ADUTUX_MODULE 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_PCM_MODULE 1
+#define CONFIG_WM8350_WATCHDOG_MODULE 1
+#define CONFIG_SENSORS_WM831X_MODULE 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_PRINTER_MODULE 1
+#define CONFIG_B43LEGACY_DEBUG 1
+#define CONFIG_MACINTOSH_DRIVERS 1
+#define CONFIG_MTD_UBI_MODULE 1
+#define CONFIG_MTD_RAM_MODULE 1
+#define CONFIG_NET_CLS_FW_MODULE 1
+#define CONFIG_BRIDGE_EBT_MARK_T_MODULE 1
+#define CONFIG_PCI_MSI 1
+#define CONFIG_DMAR 1
+#define CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK 1
+#define CONFIG_CIFS_MODULE 1
+#define CONFIG_DVB_USB_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_DVB 1
+#define CONFIG_MAC80211_RC_DEFAULT "minstrel"
+#define CONFIG_IP_VS_IPV6 1
+#define CONFIG_IPV6_MODULE 1
+#define CONFIG_SECURITY_SELINUX_AVC_STATS 1
+#define CONFIG_INFINIBAND_SRP_MODULE 1
+#define CONFIG_USB_SERIAL_GARMIN_MODULE 1
+#define CONFIG_AGP_SIS 1
+#define CONFIG_SENSORS_ADM1025_MODULE 1
+#define CONFIG_I2C_VOODOO3_MODULE 1
+#define CONFIG_PARPORT_PC_PCMCIA_MODULE 1
+#define CONFIG_CRYPTO_RNG_MODULE 1
+#define CONFIG_SUNRPC_GSS_MODULE 1
+#define CONFIG_USB_SERIAL_MOS7720_MODULE 1
+#define CONFIG_SENSORS_PC87360_MODULE 1
+#define CONFIG_SENSORS_ADM1026_MODULE 1
+#define CONFIG_SCSI_AHA1542_MODULE 1
+#define CONFIG_PHYSICAL_ALIGN 0x400000
+#define CONFIG_CPUSETS 1
+#define CONFIG_OPTIMIZE_INLINING 1
+#define CONFIG_SND_VX_LIB_MODULE 1
+#define CONFIG_ATM_TCP_MODULE 1
+#define CONFIG_PCMCIA_3C589_MODULE 1
+#define CONFIG_PARPORT_MODULE 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_BRIDGE_EBT_LOG_MODULE 1
+#define CONFIG_CRYPTO_CTR_MODULE 1
+#define CONFIG_VFAT_FS_MODULE 1
+#define CONFIG_USB_SERIAL_NAVMAN_MODULE 1
+#define CONFIG_USB_STORAGE_KARMA_MODULE 1
+#define CONFIG_USB_GSPCA_FINEPIX_MODULE 1
+#define CONFIG_QLGE_MODULE 1
+#define CONFIG_MDIO_MODULE 1
+#define CONFIG_SKY2_MODULE 1
+#define CONFIG_SERIAL_8250_PCI 1
+#define CONFIG_MTD_CMDLINE_PARTS 1
+#define CONFIG_BT_CMTP_MODULE 1
+#define CONFIG_BRIDGE_EBT_ARP_MODULE 1
+#define CONFIG_IP6_NF_TARGET_LOG_MODULE 1
+#define CONFIG_PCI_IOV 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_CRYPTO_CTS_MODULE 1
+#define CONFIG_IO_DELAY_TYPE_UDELAY 2
+#define CONFIG_JFFS2_FS_SECURITY 1
+#define CONFIG_USB_SERIAL_MOS7840_MODULE 1
+#define CONFIG_DRM_I915_MODULE 1
+#define CONFIG_VIDEO_M52790_MODULE 1
+#define CONFIG_SENSORS_LM95241_MODULE 1
+#define CONFIG_SENSORS_ADM1029_MODULE 1
+#define CONFIG_IPMI_SI_MODULE 1
+#define CONFIG_INPUT_ATI_REMOTE2_MODULE 1
+#define CONFIG_MISDN_SPEEDFAX_MODULE 1
+#define CONFIG_SLHC_MODULE 1
+#define CONFIG_IXGB_MODULE 1
+#define CONFIG_SKGE_MODULE 1
+#define CONFIG_R8169_MODULE 1
+#define CONFIG_GARP_MODULE 1
+#define CONFIG_NFSD_MODULE 1
+#define CONFIG_UDF_NLS 1
+#define CONFIG_FUSE_FS_MODULE 1
+#define CONFIG_RTC_DRV_WM831X_MODULE 1
+#define CONFIG_USB_ATM_MODULE 1
+#define CONFIG_DVB_USB_DIBUSB_MB_MODULE 1
+#define CONFIG_SENSORS_PC87427_MODULE 1
+#define CONFIG_HVC_XEN 1
+#define CONFIG_TOUCHSCREEN_GUNZE_MODULE 1
+#define CONFIG_AIRO_MODULE 1
+#define CONFIG_DNET_MODULE 1
+#define CONFIG_SATA_MV_MODULE 1
+#define CONFIG_X86_MCE_AMD 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_FB_VGA16_MODULE 1
+#define CONFIG_DVB_USB_OPERA1_MODULE 1
+#define CONFIG_DVB_USB_DIBUSB_MC_MODULE 1
+#define CONFIG_HVC_IRQ 1
+#define CONFIG_SATA_NV_MODULE 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_USB_TMC_MODULE 1
+#define CONFIG_UWB_HWA_MODULE 1
+#define CONFIG_SND_HDA_CODEC_ATIHDMI 1
+#define CONFIG_VIDEO_VP27SMPX_MODULE 1
+#define CONFIG_SENSORS_ADM9240_MODULE 1
+#define CONFIG_TCG_TIS 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_ARCH_HAS_CACHE_LINE_SIZE 1
+#define CONFIG_SND_USB 1
+#define CONFIG_SENSORS_ATK0110_MODULE 1
+#define CONFIG_TCG_TPM 1
+#define CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_IDEALTEK 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_ISDN 1
+#define CONFIG_MYRI10GE_MODULE 1
+#define CONFIG_MTDRAM_ERASE_SIZE 128
+#define CONFIG_BT_BNEP_MC_FILTER 1
+#define CONFIG_OLPC 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE 1
+#define CONFIG_EDAC_X38_MODULE 1
+#define CONFIG_USB_SERIAL_OTI6858_MODULE 1
+#define CONFIG_USB_STORAGE_ISD200_MODULE 1
+#define CONFIG_USB_ISP1362_HCD_MODULE 1
+#define CONFIG_DRM_R128_MODULE 1
+#define CONFIG_TLAN_MODULE 1
+#define CONFIG_PATA_HPT3X3_MODULE 1
+#define CONFIG_RDS_TCP_MODULE 1
+#define CONFIG_TCP_CONG_ILLINOIS_MODULE 1
+#define CONFIG_NET_KEY_MODULE 1
+#define CONFIG_X86_CMPXCHG 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_KEYS_DEBUG_PROC_KEYS 1
+#define CONFIG_EARLY_PRINTK_DBGP 1
+#define CONFIG_CUSE_MODULE 1
+#define CONFIG_SENSORS_F75375S_MODULE 1
+#define CONFIG_MISDN_INFINEON_MODULE 1
+#define CONFIG_B43_LEDS 1
+#define CONFIG_DM_ZERO_MODULE 1
+#define CONFIG_INET 1
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_USB_WDM_MODULE 1
+#define CONFIG_LOGO 1
+#define CONFIG_DRM_SIS_MODULE 1
+#define CONFIG_DVB_LGDT3305_MODULE 1
+#define CONFIG_DVB_TDA1004X_MODULE 1
+#define CONFIG_HPET 1
+#define CONFIG_TYPHOON_MODULE 1
+#define CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK -1
+#define CONFIG_NET_DSA_MV88E6123_61_65 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY 1
+#define CONFIG_VGACON_SOFT_SCROLLBACK_SIZE 64
+#define CONFIG_SENSORS_W83781D_MODULE 1
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_SSB_PCMCIAHOST 1
+#define CONFIG_WLAN 1
+#define CONFIG_PATA_PCMCIA_MODULE 1
+#define CONFIG_ATA_GENERIC_MODULE 1
+#define CONFIG_SCSI 1
+#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+#define CONFIG_MTD_ROM_MODULE 1
+#define CONFIG_MTD_CFI_AMDSTD_MODULE 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+#define CONFIG_IP_SCTP_MODULE 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_X86_L1_CACHE_SHIFT 5
+#define CONFIG_CGROUP_CPUACCT 1
+#define CONFIG_LSM_MMAP_MIN_ADDR 65535
+#define CONFIG_RING_BUFFER_BENCHMARK_MODULE 1
+#define CONFIG_NFS_FSCACHE 1
+#define CONFIG_USB_MON 1
+#define CONFIG_USB_PWC_MODULE 1
+#define CONFIG_SENSORS_W83791D_MODULE 1
+#define CONFIG_SERIAL_8250_RSA 1
+#define CONFIG_USB_HSO_MODULE 1
+#define CONFIG_PATA_HPT37X_MODULE 1
+#define CONFIG_MEGARAID_MM_MODULE 1
+#define CONFIG_INFINIBAND_ADDR_TRANS 1
+#define CONFIG_IP6_NF_MATCH_OPTS_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE 1
+#define CONFIG_NF_CONNTRACK_TFTP_MODULE 1
+#define CONFIG_HIBERNATION 1
+#define CONFIG_HID_KENSINGTON 1
+#define CONFIG_SENSORS_W83792D_MODULE 1
+#define CONFIG_SENSORS_DME1737_MODULE 1
+#define CONFIG_ATA_VERBOSE_ERROR 1
+#define CONFIG_BE2ISCSI_MODULE 1
+#define CONFIG_NFTL_MODULE 1
+#define CONFIG_NF_NAT_SNMP_BASIC_MODULE 1
+#define CONFIG_PARAVIRT_CLOCK 1
+#define CONFIG_HAVE_IOREMAP_PROT 1
+#define CONFIG_CRYPTO_LRW_MODULE 1
+#define CONFIG_CIFS_WEAK_PW_HASH 1
+#define CONFIG_CRYPTO_LZO_MODULE 1
+#define CONFIG_KS0108_DELAY 2
+#define CONFIG_SND_HDA_CODEC_REALTEK 1
+#define CONFIG_REGULATOR_TPS6507X_MODULE 1
+#define CONFIG_INPUT_KEYSPAN_REMOTE_MODULE 1
+#define CONFIG_HISAX_TELESPCI 1
+#define CONFIG_CRYPTO_DEFLATE_MODULE 1
+#define CONFIG_ACPI_PROCFS_POWER 1
+#define CONFIG_BLK_DEV_INTEGRITY 1
+#define CONFIG_VIDEO_MEDIA_MODULE 1
+#define CONFIG_MISDN_HFCMULTI_MODULE 1
+#define CONFIG_LSI_ET1011C_PHY_MODULE 1
+#define CONFIG_BT_MRVL_MODULE 1
+#define CONFIG_DOUBLEFAULT 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_USB_STORAGE_JUMPSHOT_MODULE 1
+#define CONFIG_DRM_TTM_MODULE 1
+#define CONFIG_VIDEO_CX231XX_ALSA_MODULE 1
+#define CONFIG_SENSORS_IBMAEM_MODULE 1
+#define CONFIG_SENSORS_ADT7470_MODULE 1
+#define CONFIG_B43_SDIO 1
+#define CONFIG_SSB_B43_PCI_BRIDGE 1
+#define CONFIG_SSB_DRIVER_PCICORE_POSSIBLE 1
+#define CONFIG_VETH_MODULE 1
+#define CONFIG_NET_EMATCH_CMP_MODULE 1
+#define CONFIG_INET6_XFRM_TUNNEL_MODULE 1
+#define CONFIG_DVB_USB_DTV5100_MODULE 1
+#define CONFIG_SENSORS_ADT7462_MODULE 1
+#define CONFIG_SLIP_MODULE 1
+#define CONFIG_REED_SOLOMON_DEC16 1
+#define CONFIG_CAN_KVASER_PCI_MODULE 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_BOOT_PRINTK_DELAY 1
+#define CONFIG_NET_ACT_POLICE_MODULE 1
+#define CONFIG_NF_CONNTRACK_PPTP_MODULE 1
+#define CONFIG_X86_IO_APIC 1
+#define CONFIG_USB_SERIAL_XIRCOM_MODULE 1
+#define CONFIG_I6300ESB_WDT_MODULE 1
+#define CONFIG_ALIM7101_WDT_MODULE 1
+#define CONFIG_SENSORS_ADT7473_MODULE 1
+#define CONFIG_IPW2100_MONITOR 1
+#define CONFIG_VXGE_MODULE 1
+#define CONFIG_FUSION_LOGGING 1
+#define CONFIG_IP6_NF_MATCH_EUI64_MODULE 1
+#define CONFIG_NR_CPUS 32
+#define CONFIG_X86_EXTENDED_PLATFORM 1
+#define CONFIG_RESOURCE_COUNTERS 1
+#define CONFIG_ARCH_HAS_DEFAULT_IDLE 1
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_JFFS2_RTIME 1
+#define CONFIG_SENSORS_LTC4215_MODULE 1
+#define CONFIG_SERIAL_8250_PNP 1
+#define CONFIG_IPW2200_MONITOR 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_BT_HCIBFUSB_MODULE 1
+#define CONFIG_CPU_FREQ_DEBUG 1
+#define CONFIG_X86_L1_CACHE_BYTES 64
+#define CONFIG_SWAP 1
+#define CONFIG_EXT2_FS_POSIX_ACL 1
+#define CONFIG_USB_STORAGE_USBAT_MODULE 1
+#define CONFIG_SENSORS_PCF8591_MODULE 1
+#define CONFIG_SENSORS_ADT7475_MODULE 1
+#define CONFIG_B43_PCI_AUTOSELECT 1
+#define CONFIG_NFTL_RW 1
+#define CONFIG_MTD_REDBOOT_PARTS_MODULE 1
+#define CONFIG_KEYS 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE 1
+#define CONFIG_TCP_CONG_HYBLA_MODULE 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_ACPI_PROCESSOR 1
+#define CONFIG_HAVE_MLOCKED_PAGE_BIT 1
+#define CONFIG_EXT3_FS_POSIX_ACL 1
+#define CONFIG_MMC_SDRICOH_CS_MODULE 1
+#define CONFIG_USB_SPEEDTOUCH_MODULE 1
+#define CONFIG_SND_KORG1212_MODULE 1
+#define CONFIG_VIDEO_CS5345_MODULE 1
+#define CONFIG_W83627HF_WDT_MODULE 1
+#define CONFIG_SENSORS_ADS7828_MODULE 1
+#define CONFIG_INPUT_WINBOND_CIR_MODULE 1
+#define CONFIG_AC97_BUS_MODULE 1
+#define CONFIG_B44_PCI_AUTOSELECT 1
+#define CONFIG_BRIDGE_EBT_STP_MODULE 1
+#define CONFIG_XFRM 1
+#define CONFIG_CRC32 1
+#define CONFIG_X86_MPPARSE 1
+#define CONFIG_EXT4_FS_POSIX_ACL 1
+#define CONFIG_USB_SERIAL_SYMBOL_MODULE 1
+#define CONFIG_SND_VIA82XX_MODULE 1
+#define CONFIG_VIDEO_AU0828_MODULE 1
+#define CONFIG_SENSORS_LTC4245_MODULE 1
+#define CONFIG_AIC79XX_DEBUG_MASK 0
+#define CONFIG_BLK_DEV_3W_XXXX_RAID_MODULE 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_MTD_ESB2ROM_MODULE 1
+#define CONFIG_DEFAULT_CFQ 1
+#define CONFIG_CRYPTO_XTS_MODULE 1
+#define CONFIG_USB_SISUSBVGA_CON 1
+#define CONFIG_ALIM1535_WDT_MODULE 1
+#define CONFIG_MISDN_L1OIP_MODULE 1
+#define CONFIG_USB_NET_NET1080_MODULE 1
+#define CONFIG_CRC16 1
+#define CONFIG_NF_NAT_PROTO_UDPLITE_MODULE 1
+#define CONFIG_IP_NF_IPTABLES_MODULE 1
+#define CONFIG_USER_NS 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "ascii"
+#define CONFIG_UWB_WLP_MODULE 1
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_ISDN_DIVERSION_MODULE 1
+#define CONFIG_USB_CDC_PHONET_MODULE 1
+#define CONFIG_P54_LEDS 1
+#define CONFIG_MD_RAID0_MODULE 1
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_NET_ACT_MIRRED_MODULE 1
+#define CONFIG_IP_NF_MATCH_AH_MODULE 1
+#define CONFIG_TEXTSEARCH_FSM_MODULE 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_NFSD_V2_ACL 1
+#define CONFIG_EXT3_DEFAULTS_TO_ORDERED 1
+#define CONFIG_USB_SERIAL_OPTION_MODULE 1
+#define CONFIG_HID_CHICONY 1
+#define CONFIG_DVB_USB_GP8PSK_MODULE 1
+#define CONFIG_SENSORS_FSCHMD_MODULE 1
+#define CONFIG_WIMAX_I2400M_MODULE 1
+#define CONFIG_MD_RAID1_MODULE 1
+#define CONFIG_SCSI_ENCLOSURE_MODULE 1
+#define CONFIG_NET_CLS_U32_MODULE 1
+#define CONFIG_BRIDGE_NF_EBTABLES_MODULE 1
+#define CONFIG_NFSD_V3_ACL 1
+#define CONFIG_RTC_DRV_PCF8563_MODULE 1
+#define CONFIG_USB_ZR364XX_MODULE 1
+#define CONFIG_GIGASET_M101_MODULE 1
+#define CONFIG_SCSI_BFA_FC_MODULE 1
+#define CONFIG_MTDRAM_TOTAL_SIZE 4096
+#define CONFIG_NF_NAT_PROTO_DCCP_MODULE 1
+#define CONFIG_TEXTSEARCH_KMP_MODULE 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_TCP_CONG_VEGAS_MODULE 1
+#define CONFIG_PACKET_MMAP 1
+#define CONFIG_CGROUP_FREEZER 1
+#define CONFIG_HAVE_DMA_ATTRS 1
+#define CONFIG_VIRTIO_BALLOON_MODULE 1
+#define CONFIG_SND_SEQUENCER_OSS 1
+#define CONFIG_SENSORS_MAX6650_MODULE 1
+#define CONFIG_SENSORS_MAX1619_MODULE 1
+#define CONFIG_B43LEGACY_HWRNG 1
+#define CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_CRYPTO_ANSI_CPRNG_MODULE 1
+#define CONFIG_UIO_SMX_MODULE 1
+#define CONFIG_RTC_DRV_PCF8583_MODULE 1
+#define CONFIG_EDAC_DECODE_MCE_MODULE 1
+#define CONFIG_W83697HF_WDT_MODULE 1
+#define CONFIG_SENSORS_ABITUGURU_MODULE 1
+#define CONFIG_I2C_ISCH_MODULE 1
+#define CONFIG_PPP_DEFLATE_MODULE 1
+#define CONFIG_USB_NET_MCS7830_MODULE 1
+#define CONFIG_UNIX 1
+#define CONFIG_CPU_IDLE_GOV_MENU 1
+#define CONFIG_VIRTUALIZATION 1
+#define CONFIG_CRYPTO_DEV_HIFN_795X_RNG 1
+#define CONFIG_CIFS_UPCALL 1
+#define CONFIG_JFFS2_FS_XATTR 1
+#define CONFIG_SND_HDA_ELD 1
+#define CONFIG_FB_BOOT_VESA_SUPPORT 1
+#define CONFIG_SENSORS_K8TEMP_MODULE 1
+#define CONFIG_I2C_PARPORT_MODULE 1
+#define CONFIG_NET_SCH_DSMARK_MODULE 1
+#define CONFIG_ARCH_SELECT_MEMORY_MODEL 1
+#define CONFIG_MTRR 1
+#define CONFIG_RTC_DRV_ISL1208_MODULE 1
+#define CONFIG_USB_VST_MODULE 1
+#define CONFIG_GIGASET_M105_MODULE 1
+#define CONFIG_VIA_RHINE_MMIO 1
+#define CONFIG_MD_RAID6_PQ_MODULE 1
+#define CONFIG_LIB80211_CRYPT_CCMP_MODULE 1
+#define CONFIG_PCI_DOMAINS 1
+#define CONFIG_X86_XADD 1
+#define CONFIG_HISAX_FRITZPCI 1
+#define CONFIG_CONFIGFS_FS_MODULE 1
+#define CONFIG_PARPORT_SERIAL_MODULE 1
+#define CONFIG_BT_L2CAP_MODULE 1
+#define CONFIG_NETLABEL 1
+#define CONFIG_ISA_DMA_API 1
+#define CONFIG_VIDEO_OUTPUT_CONTROL_MODULE 1
+#define CONFIG_CPU_SUP_UMC_32 1
+#define CONFIG_RTC_DRV_MAX6900_MODULE 1
+#define CONFIG_HID_TOPSEED 1
+#define CONFIG_DVB_USB_TTUSB2_MODULE 1
+#define CONFIG_VIDEO_TVEEPROM_MODULE 1
+#define CONFIG_HP_WATCHDOG_MODULE 1
+#define CONFIG_WM831X_WATCHDOG_MODULE 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_CYCLADES_MODULE 1
+#define CONFIG_HISAX_S0BOX 1
+#define CONFIG_RT2400PCI_MODULE 1
+#define CONFIG_LXT_PHY_MODULE 1
+#define CONFIG_BLK_DEV_SR_VENDOR 1
+#define CONFIG_MTD_SC520CDP_MODULE 1
+#define CONFIG_IP_NF_TARGET_ULOG_MODULE 1
+#define CONFIG_TCP_CONG_WESTWOOD_MODULE 1
+#define CONFIG_CRYPTO_AUTHENC_MODULE 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_LZO_DECOMPRESS_MODULE 1
+#define CONFIG_FB_GEODE_GX 1
+#define CONFIG_DVB_USB_ANYSEE_MODULE 1
+#define CONFIG_USB_GSPCA_MARS_MODULE 1
+#define CONFIG_I2C_SCMI_MODULE 1
+#define CONFIG_RT2500PCI_MODULE 1
+#define CONFIG_PDC_ADMA_MODULE 1
+#define CONFIG_SCSI_QLA_ISCSI_MODULE 1
+#define CONFIG_BT_HCIBTUSB_MODULE 1
+#define CONFIG_ACPI_PROCFS 1
+#define CONFIG_SCHED_OMIT_FRAME_POINTER 1
+#define CONFIG_RING_BUFFER 1
+#define CONFIG_UID16 1
+#define CONFIG_LOCK_KERNEL 1
+#define CONFIG_HAVE_SYSCALL_TRACEPOINTS 1
+#define CONFIG_USB_EHCI_ROOT_HUB_TT 1
+#define CONFIG_TOUCHSCREEN_MCS5000_MODULE 1
+#define CONFIG_MOUSE_PS2_OLPC 1
+#define CONFIG_ISDN_CAPI_CAPIFS_BOOL 1
+#define CONFIG_SSB_BLOCKIO 1
+#define CONFIG_DE4X5_MODULE 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_CRYPTO_ARC4_MODULE 1
+#define CONFIG_CAN_CALC_BITTIMING 1
+#define CONFIG_NET_CLS_ROUTE4_MODULE 1
+#define CONFIG_VLAN_8021Q_GVRP 1
+#define CONFIG_X86_LONGRUN 1
+#define CONFIG_PHYSICAL_START 0x400000
+#define CONFIG_CRYPTO_AEAD_MODULE 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_FB_GEODE 1
+#define CONFIG_DVB_USB_DIGITV_MODULE 1
+#define CONFIG_VIDEO_BT848_DVB 1
+#define CONFIG_SENSORS_TSL2550_MODULE 1
+#define CONFIG_AT76C50X_USB_MODULE 1
+#define CONFIG_LIBERTAS_CS_MODULE 1
+#define CONFIG_E1000E_MODULE 1
+#define CONFIG_NE2K_PCI_MODULE 1
+#define CONFIG_SCSI_AHA152X_MODULE 1
+#define CONFIG_RFKILL_LEDS 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_RTC_DRV_RS5C372_MODULE 1
+#define CONFIG_DRM_KMS_HELPER_MODULE 1
+#define CONFIG_MOUSE_PS2_ALPS 1
+#define CONFIG_CISS_SCSI_TAPE 1
+#define CONFIG_IEEE802154_MODULE 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_TRACEPOINTS 1
+#define CONFIG_DEBUG_SHIRQ 1
+#define CONFIG_HID_TWINHAN 1
+#define CONFIG_MEDIA_TUNER_MODULE 1
+#define CONFIG_MISDN_AVMFRITZ_MODULE 1
+#define CONFIG_RT2X00_LIB_LEDS 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_ARCH_USES_PG_UNCACHED 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_GENERIC_FIND_LAST_BIT 1
+#define CONFIG_UIO_SERCOS3_MODULE 1
+#define CONFIG_FB_GEODE_LX 1
+#define CONFIG_BATTERY_BQ27x00_MODULE 1
+#define CONFIG_HISAX_TELES_CS_MODULE 1
+#define CONFIG_SCSI_CONSTANTS 1
+#define CONFIG_INET6_AH_MODULE 1
+#define CONFIG_TCP_CONG_HSTCP_MODULE 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_ASYNC_TX_DISABLE_PQ_VAL_DMA 1
+#define CONFIG_RTC_DRV_M41T80_WDT 1
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define CONFIG_VIDEO_OV7670_MODULE 1
+#define CONFIG_HISAX_GAZEL 1
+#define CONFIG_CHELSIO_T3_DEPENDS 1
+#define CONFIG_MTD_NAND_CS553X_MODULE 1
+#define CONFIG_MTD_BLKDEVS_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_NOTRACK_MODULE 1
+#define CONFIG_VIRTIO_CONSOLE_MODULE 1
+#define CONFIG_XEN_DEV_EVTCHN_MODULE 1
+#define CONFIG_SND_EMU10K1_SEQ_MODULE 1
+#define CONFIG_VGA_CONSOLE 1
+#define CONFIG_USB_GSPCA_SUNPLUS_MODULE 1
+#define CONFIG_DELL_LAPTOP_MODULE 1
+#define CONFIG_CDROM_PKTCDVD_BUFFERS 8
+#define CONFIG_PCIEPORTBUS 1
+#define CONFIG_PREEMPT_VOLUNTARY 1
+#define CONFIG_PARAVIRT_GUEST 1
+#define CONFIG_NLS_DEFAULT "utf8"
+#define CONFIG_XEN_BALLOON 1
+#define CONFIG_SND_RAWMIDI_MODULE 1
+#define CONFIG_WATCHDOG 1
+#define CONFIG_SENSORS_VIA686A_MODULE 1
+#define CONFIG_SENSORS_IBMPEX_MODULE 1
+#define CONFIG_TELCLOCK_MODULE 1
+#define CONFIG_SERIAL_8250_DETECT_IRQ 1
+#define CONFIG_RTL8187_LEDS 1
+#define CONFIG_SUNDANCE_MODULE 1
+#define CONFIG_SCSI_DH_EMC_MODULE 1
+#define CONFIG_MTD_PARTITIONS 1
+#define CONFIG_CAN_EMS_PCI_MODULE 1
+#define CONFIG_I82365_MODULE 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_ACPI_FAN 1
+#define CONFIG_SECURITY_SELINUX_DISABLE 1
+#define CONFIG_HYPERV_STORAGE_MODULE 1
+#define CONFIG_HID_SAMSUNG 1
+#define CONFIG_W83697UG_WDT_MODULE 1
+#define CONFIG_HISAX_NICCY 1
+#define CONFIG_ATA_ACPI 1
+#define CONFIG_NET_9P_RDMA_MODULE 1
+#define CONFIG_PCIEASPM 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_BLK_DEV_BSG 1
+#define CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ 1
+#define CONFIG_JFFS2_FS_MODULE 1
+#define CONFIG_USB_STORAGE_SDDR09_MODULE 1
+#define CONFIG_SENSORS_SIS5595_MODULE 1
+#define CONFIG_DAVICOM_PHY_MODULE 1
+#define CONFIG_YENTA_ENE_TUNE 1
+#define CONFIG_GROUP_SCHED 1
+#define CONFIG_BOOT_TRACER 1
+#define CONFIG_USB_STORAGE_SDDR55_MODULE 1
+#define CONFIG_SND_LX6464ES_MODULE 1
+#define CONFIG_SND_OXYGEN_LIB_MODULE 1
+#define CONFIG_DVB_LGDT330X_MODULE 1
+#define CONFIG_PATA_ATIIXP_MODULE 1
+#define CONFIG_MAC80211_LEDS 1
+#define CONFIG_NETFILTER_XT_MATCH_REALM_MODULE 1
+#define CONFIG_DMAR_FLOPPY_WA 1
+#define CONFIG_X86_P4_CLOCKMOD_MODULE 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_ARCH_WANT_FRAME_POINTERS 1
+#define CONFIG_FB_SAVAGE_ACCEL 1
+#define CONFIG_VIDEO_WM8739_MODULE 1
+#define CONFIG_VIDEO_WM8775_MODULE 1
+#define CONFIG_TOUCHSCREEN_TSC2007_MODULE 1
+#define CONFIG_HISAX_ST5481_MODULE 1
+#define CONFIG_ISDN_DRV_HISAX_MODULE 1
+#define CONFIG_MYRI10GE_DCA 1
+#define CONFIG_ATL1C_MODULE 1
+#define CONFIG_NE2000_MODULE 1
+#define CONFIG_SCSI_FC_TGT_ATTRS 1
+#define CONFIG_BT_HCIBPA10X_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE 1
+#define CONFIG_YENTA_RICOH 1
+#define CONFIG_ARCH_SUPPORTS_MSI 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_CRYPTO_GF128MUL_MODULE 1
+#define CONFIG_IO_DELAY_TYPE_0X80 0
+#define CONFIG_SYSPROF_TRACER 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_MLX4_INFINIBAND_MODULE 1
+#define CONFIG_VIDEO_CAFE_CCIC_MODULE 1
+#define CONFIG_SENSORS_GL520SM_MODULE 1
+#define CONFIG_ISDN_I4L_MODULE 1
+#define CONFIG_LIBERTAS_MODULE 1
+#define CONFIG_NET_VENDOR_SMC 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_PARPORT_1284 1
+#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE 1
+#define CONFIG_SCHED_MC 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_USB_HWA_HCD_MODULE 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_DVB_USB_DTT200U_MODULE 1
+#define CONFIG_USB_GSPCA_OV534_MODULE 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_RT2500USB_MODULE 1
+#define CONFIG_ATL1E_MODULE 1
+#define CONFIG_FUSION_MAX_SGE 128
+#define CONFIG_DM_DEBUG 1
+#define CONFIG_PATA_AMD_MODULE 1
+#define CONFIG_SCSI_QLA_FC_MODULE 1
+#define CONFIG_NET_CLS_CGROUP 1
+#define CONFIG_LIBCRC32C_MODULE 1
+#define CONFIG_INET_IPCOMP_MODULE 1
+#define CONFIG_NEED_NODE_MEMMAP_SIZE 1
+#define CONFIG_CFAG12864B_MODULE 1
+#define CONFIG_USB_SERIAL_IPW_MODULE 1
+#define CONFIG_SND_VIRMIDI_MODULE 1
+#define CONFIG_FB_ATY128_BACKLIGHT 1
+#define CONFIG_USB_GSPCA_SQ905_MODULE 1
+#define CONFIG_MEDIA_TUNER_TDA8290_MODULE 1
+#define CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE 1
+#define CONFIG_USB_NET_AX8817X_MODULE 1
+#define CONFIG_REALTEK_PHY_MODULE 1
+#define CONFIG_CHR_DEV_SCH_MODULE 1
+#define CONFIG_MTD_NETSC520_MODULE 1
+#define CONFIG_CRYPTO_PCBC_MODULE 1
+#define CONFIG_ACPI_BUTTON 1
+#define CONFIG_RT_GROUP_SCHED 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_FUJITSU_LAPTOP_MODULE 1
+#define CONFIG_MMC_CB710_MODULE 1
+#define CONFIG_MEDIA_TUNER_TEA5761_MODULE 1
+#define CONFIG_SCSI_ARCMSR_MODULE 1
+#define CONFIG_BLK_DEV_SX8_MODULE 1
+#define CONFIG_CAN_VCAN_MODULE 1
+#define CONFIG_NET_SCH_CBQ_MODULE 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_GENERIC_FIND_NEXT_BIT 1
+#define CONFIG_LBDAF 1
+#define CONFIG_MODVERSIONS 1
+#define CONFIG_VIDEO_HDPVR_MODULE 1
+#define CONFIG_USB_GSPCA_OV519_MODULE 1
+#define CONFIG_IT87_WDT_MODULE 1
+#define CONFIG_HISAX_NETJET_U 1
+#define CONFIG_RT2800USB_MODULE 1
+#define CONFIG_IP1000_MODULE 1
+#define CONFIG_PATA_NINJA32_MODULE 1
+#define CONFIG_IPV6_TUNNEL_MODULE 1
+#define CONFIG_X86_CMOV 1
+#define CONFIG_KERNEL_GZIP 1
+#define CONFIG_SOLARIS_X86_PARTITION 1
+#define CONFIG_MSPRO_BLOCK_MODULE 1
+#define CONFIG_USB_SERIAL_IUU_MODULE 1
+#define CONFIG_REGULATOR_AB3100_MODULE 1
+#define CONFIG_I2C_STUB_MODULE 1
+#define CONFIG_SERIAL_NONSTANDARD 1
+#define CONFIG_HISAX_NO_SENDCOMPLETE 1
+#define CONFIG_PATA_ALI_MODULE 1
+#define CONFIG_SCSI_SAS_LIBSAS_DEBUG 1
+#define CONFIG_DEVTMPFS_MOUNT 1
+#define CONFIG_LIB80211_CRYPT_TKIP_MODULE 1
+#define CONFIG_MEMORY_HOTPLUG 1
+#define CONFIG_TOPSTAR_LAPTOP_MODULE 1
+#define CONFIG_DVB_DIB3000MB_MODULE 1
+#define CONFIG_USB_STV06XX_MODULE 1
+#define CONFIG_BATTERY_MAX17040_MODULE 1
+#define CONFIG_HANGCHECK_TIMER_MODULE 1
+#define CONFIG_BLK_DEV_OSD_MODULE 1
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_UNIXWARE_DISKLABEL 1
+#define CONFIG_MEMSTICK_MODULE 1
+#define CONFIG_HID_CYPRESS 1
+#define CONFIG_SND_JACK 1
+#define CONFIG_DVB_DIB3000MC_MODULE 1
+#define CONFIG_DVB_USB_A800_MODULE 1
+#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
+#define CONFIG_SENSORS_GL518SM_MODULE 1
+#define CONFIG_ATH5K_MODULE 1
+#define CONFIG_DM9102_MODULE 1
+#define CONFIG_FIREWIRE_MODULE 1
+#define CONFIG_SCSI_INITIO_MODULE 1
+#define CONFIG_MEGARAID_NEWGEN 1
+#define CONFIG_AIC7XXX_DEBUG_MASK 0
+#define CONFIG_MTRR_SANITIZER 1
+#define CONFIG_USB_STORAGE_MODULE 1
+#define CONFIG_SND_TRIDENT_MODULE 1
+#define CONFIG_KEYBOARD_OPENCORES_MODULE 1
+#define CONFIG_IPPP_FILTER 1
+#define CONFIG_NETCONSOLE_DYNAMIC 1
+#define CONFIG_B43LEGACY_MODULE 1
+#define CONFIG_PATA_RDC_MODULE 1
+#define CONFIG_NET_SCH_RED_MODULE 1
+#define CONFIG_HOTPLUG_PCI 1
+#define CONFIG_HAVE_INTEL_TXT 1
+#define CONFIG_PROC_VMCORE 1
+#define CONFIG_USB_IDMOUSE_MODULE 1
+#define CONFIG_SND_HRTIMER_MODULE 1
+#define CONFIG_VGASTATE_MODULE 1
+#define CONFIG_MEDIA_TUNER_TEA5767_MODULE 1
+#define CONFIG_MEDIA_TUNER_MT20XX_MODULE 1
+#define CONFIG_MFD_CORE_MODULE 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_KEYBOARD_ADP5588_MODULE 1
+#define CONFIG_LIBERTAS_THINFIRM_USB_MODULE 1
+#define CONFIG_DM_DELAY_MODULE 1
+#define CONFIG_CAN_EMS_USB_MODULE 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_NET_SCH_TBF_MODULE 1
+#define CONFIG_NET_SCH_MULTIQ_MODULE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_CRYPTO_XCBC_MODULE 1
+#define CONFIG_NFS_V4_1 1
+#define CONFIG_SND_EMU10K1X_MODULE 1
+#define CONFIG_WM8350_POWER_MODULE 1
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_MOUSE_PS2_ELANTECH 1
+#define CONFIG_CAPI_AVM 1
+#define CONFIG_ATM_DRIVERS 1
+#define CONFIG_DM_SNAPSHOT_MODULE 1
+#define CONFIG_LIBFC_MODULE 1
+#define CONFIG_NET_ACT_NAT_MODULE 1
+#define CONFIG_IPV6_MROUTE 1
+#define CONFIG_OPROFILE_MODULE 1
+#define CONFIG_CRYPTO_SERPENT_MODULE 1
+#define CONFIG_CRYPTO_SEED_MODULE 1
+#define CONFIG_VIDEO_CX88_ALSA_MODULE 1
+#define CONFIG_PPPOL2TP_MODULE 1
+#define CONFIG_DLCI_MAX 8
+#define CONFIG_USB_PEGASUS_MODULE 1
+#define CONFIG_ATH9K_MODULE 1
+#define CONFIG_SSB_PCIHOST 1
+#define CONFIG_NET_SCH_HTB_MODULE 1
+#define CONFIG_ATM_LANE_MODULE 1
+#define CONFIG_YENTA_O2 1
+#define CONFIG_X86_DEBUGCTLMSR 1
+#define CONFIG_PERF_EVENTS 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_LEDS_WM831X_STATUS_MODULE 1
+#define CONFIG_MMC_TIFM_SD_MODULE 1
+#define CONFIG_USB_U132_HCD_MODULE 1
+#define CONFIG_MTD_CHAR_MODULE 1
+#define CONFIG_NET_CLS_IND 1
+#define CONFIG_NF_NAT_PROTO_SCTP_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_LOG_MODULE 1
+#define CONFIG_UBIFS_FS_XATTR 1
+#define CONFIG_USB_SERIAL_SPCP8X5_MODULE 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_FB_ATY_GENERIC_LCD 1
+#define CONFIG_USB_M5602_MODULE 1
+#define CONFIG_MARVELL_PHY_MODULE 1
+#define CONFIG_PATA_SCH_MODULE 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_IP_NF_SECURITY_MODULE 1
+#define CONFIG_IP_NF_TARGET_REDIRECT_MODULE 1
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define CONFIG_CRYPTO_TWOFISH_MODULE 1
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_INFINIBAND_ISER_MODULE 1
+#define CONFIG_INFINIBAND_MTHCA_DEBUG 1
+#define CONFIG_VIDEO_TUNER_MODULE 1
+#define CONFIG_DVB_CORE_MODULE 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_TOUCHSCREEN_HTCPEN_MODULE 1
+#define CONFIG_HDLC_RAW_MODULE 1
+#define CONFIG_USB_CATC_MODULE 1
+#define CONFIG_SCSI_SAS_HOST_SMP 1
+#define CONFIG_EEPROM_93CX6_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE_MODULE 1
+#define CONFIG_IP_PIMSM_V1 1
+#define CONFIG_XFRM_IPCOMP_MODULE 1
+#define CONFIG_ACPI_SBS_MODULE 1
+#define CONFIG_X86_THERMAL_VECTOR 1
+#define CONFIG_X86_USE_PPRO_CHECKSUM 1
+#define CONFIG_OPROFILE_EVENT_MULTIPLEX 1
+#define CONFIG_ASYNC_TX_DISABLE_CHANNEL_SWITCH 1
+#define CONFIG_USB_SERIAL_GENERIC 1
+#define CONFIG_USB_STORAGE_ALAUDA_MODULE 1
+#define CONFIG_SOUND_OSS_CORE 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MEDIA_TUNER_TDA9887_MODULE 1
+#define CONFIG_SYNCLINK_GT_MODULE 1
+#define CONFIG_B43_PCICORE_AUTOSELECT 1
+#define CONFIG_PATA_VIA_MODULE 1
+#define CONFIG_SCSI_HPTIOP_MODULE 1
+#define CONFIG_SCSI_SAS_ATTRS_MODULE 1
+#define CONFIG_ICS932S401_MODULE 1
+#define CONFIG_MTD_NAND_MODULE 1
+#define CONFIG_NET_SCH_ATM_MODULE 1
+#define CONFIG_IP_PIMSM_V2 1
+#define CONFIG_INET_TUNNEL_MODULE 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND_MODULE 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_CRYPTO_TWOFISH_586_MODULE 1
+#define CONFIG_SND_MPU401_UART_MODULE 1
+#define CONFIG_SND_VMASTER 1
+#define CONFIG_FRAMEBUFFER_CONSOLE_ROTATION 1
+#define CONFIG_SMS_SIANO_MDTV_MODULE 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_HISAX_DIEHLDIVA 1
+#define CONFIG_B44_PCICORE_AUTOSELECT 1
+#define CONFIG_SYN_COOKIES 1
+#define CONFIG_X86_INTERNODE_CACHE_BYTES 64
+#define CONFIG_CRYPTO_VMAC_MODULE 1
+#define CONFIG_DMIID 1
+#define CONFIG_ACER_WMI_MODULE 1
+#define CONFIG_KS0108_MODULE 1
+#define CONFIG_MOUSE_PS2_LIFEBOOK 1
+#define CONFIG_ISDN_DRV_AVMB1_AVM_CS_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCIV4 1
+#define CONFIG_IPW2200_RADIOTAP 1
+#define CONFIG_PATA_ATP867X_MODULE 1
+#define CONFIG_SATA_SX4_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_HISAX_SEDLBAUER_CS_MODULE 1
+#define CONFIG_8139CP_MODULE 1
+#define CONFIG_SATA_VIA_MODULE 1
+#define CONFIG_PROC_EVENTS 1
+#define CONFIG_IP_VS_TAB_BITS 12
+#define CONFIG_NETFILTER_XT_TARGET_MARK_MODULE 1
+#define CONFIG_TCP_CONG_LP_MODULE 1
+#define CONFIG_PCI_BIOS 1
+#define CONFIG_X86_NEED_RELOCS 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_DELL_RBU_MODULE 1
+#define CONFIG_ACPI_WMI_MODULE 1
+#define CONFIG_VIDEO_CX88_MPEG_MODULE 1
+#define CONFIG_SENSORS_F71882FG_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_DMC_TSC10 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_USB_NET_INT51X1_MODULE 1
+#define CONFIG_DEVTMPFS 1
+#define CONFIG_ATM_CLIP_MODULE 1
+#define CONFIG_PCI_OLPC 1
+#define CONFIG_PARAVIRT 1
+#define CONFIG_INFINIBAND_IPOIB_DEBUG 1
+#define CONFIG_DVB_USB_UMT_010_MODULE 1
+#define CONFIG_USB_S2255_MODULE 1
+#define CONFIG_HDLC_PPP_MODULE 1
+#define CONFIG_SCSI_SPI_ATTRS_MODULE 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_PARPORT_NOT_PC 1
+#define CONFIG_NET_ACT_IPT_MODULE 1
+#define CONFIG_PCMCIA_LOAD_CIS 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_GENERIC_ISA_DMA 1
+#define CONFIG_DEFAULT_IO_DELAY_TYPE 0
+#define CONFIG_EXT2_FS_XIP 1
+#define CONFIG_ASUS_LAPTOP_MODULE 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_SYNCLINK_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_3M 1
+#define CONFIG_CRYPTO_MICHAEL_MIC_MODULE 1
+#define CONFIG_NET_SCH_DRR_MODULE 1
+#define CONFIG_X86_MRST 1
+#define CONFIG_MODULE_SRCVERSION_ALL 1
+#define CONFIG_BLOCK 1
+#define CONFIG_SND_OSSEMUL 1
+#define CONFIG_MFD_SM501_MODULE 1
+#define CONFIG_WL1251_MODULE 1
+#define CONFIG_EWRK3_MODULE 1
+#define CONFIG_RDS_RDMA_MODULE 1
+#define CONFIG_PD6729_MODULE 1
+#define CONFIG_VIRTIO_RING_MODULE 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_SECURITY_SELINUX_DEVELOP 1
+#define CONFIG_LOCKD_MODULE 1
+#define CONFIG_QUOTACTL 1
+#define CONFIG_DELL_WMI_MODULE 1
+#define CONFIG_USB_XUSBATM_MODULE 1
+#define CONFIG_USB_PRINTER_MODULE 1
+#define CONFIG_SND_HDA_GENERIC 1
+#define CONFIG_NET_SCH_SFQ_MODULE 1
+#define CONFIG_BRIDGE_EBT_DNAT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
+#define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
+#define CONFIG_SQUASHFS_MODULE 1
+#define CONFIG_HID_SUNPLUS 1
+#define CONFIG_TOUCHSCREEN_INEXIO_MODULE 1
+#define CONFIG_KEYBOARD_MAX7359_MODULE 1
+#define CONFIG_QT2160_MODULE 1
+#define CONFIG_HOSTAP_FIRMWARE_NVRAM 1
+#define CONFIG_IGBVF_MODULE 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_TIMER_STATS 1
+#define CONFIG_EFI_VARS 1
+#define CONFIG_SND_MONA_MODULE 1
+#define CONFIG_B43_DEBUG 1
+#define CONFIG_IXGBE_MODULE 1
+#define CONFIG_ATA_PIIX_MODULE 1
+#define CONFIG_CHECK_SIGNATURE 1
+#define CONFIG_IP_VS_LBLCR_MODULE 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_FB_ATY128_MODULE 1
+#define CONFIG_IB700_WDT_MODULE 1
+#define CONFIG_XEN_FBDEV_FRONTEND 1
+#define CONFIG_FB_BACKLIGHT 1
+#define CONFIG_SATA_SIL_MODULE 1
+#define CONFIG_IP_NF_QUEUE_MODULE 1
+#define CONFIG_KEXEC 1
+#define CONFIG_MICROCODE_INTEL 1
+#define CONFIG_CPU_SUP_AMD 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_ARCH_HIBERNATION_POSSIBLE 1
+#define CONFIG_CRYPTO_ZLIB_MODULE 1
+#define CONFIG_UBIFS_FS_MODULE 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_VIDEO_IR_MODULE 1
+#define CONFIG_PC8736x_GPIO_MODULE 1
+#define CONFIG_MD_RAID10_MODULE 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_BRIDGE_EBT_MARK_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE 1
+#define CONFIG_HAVE_KVM 1
+#define CONFIG_CRYPTO_FIPS 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_EDAC_MM_EDAC_MODULE 1
+#define CONFIG_FB_TILEBLITTING 1
+#define CONFIG_DVB_MT312_MODULE 1
+#define CONFIG_NSC_GPIO_MODULE 1
+#define CONFIG_TOUCHSCREEN_MTOUCH_MODULE 1
+#define CONFIG_BNX2X_MODULE 1
+#define CONFIG_SATA_ULI_MODULE 1
+#define CONFIG_SCSI_PPA_MODULE 1
+#define CONFIG_BRIDGE_EBT_802_3_MODULE 1
+#define CONFIG_K8_NB 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_HAVE_UNSTABLE_SCHED_CLOCK 1
+#define CONFIG_NLS_UTF8_MODULE 1
+#define CONFIG_SND_HDSP_MODULE 1
+#define CONFIG_SND_HDA_CODEC_CA0110 1
+#define CONFIG_MOUSE_PS2_SENTELIC 1
+#define CONFIG_HISAX_SEDLBAUER 1
+#define CONFIG_MWL8K_MODULE 1
+#define CONFIG_ATMEL_MODULE 1
+#define CONFIG_ETHOC_MODULE 1
+#define CONFIG_VITESSE_PHY_MODULE 1
+#define CONFIG_SCSI_SRP_ATTRS_MODULE 1
+#define CONFIG_ENCLOSURE_SERVICES_MODULE 1
+#define CONFIG_SSFDC_MODULE 1
+#define CONFIG_NF_NAT_TFTP_MODULE 1
+#define CONFIG_AGP_AMD64 1
+#define CONFIG_JFFS2_FS_POSIX_ACL 1
+#define CONFIG_VIDEO_CX25840_MODULE 1
+#define CONFIG_MEDIA_ATTACH 1
+#define CONFIG_VT_HW_CONSOLE_BINDING 1
+#define CONFIG_TOUCHSCREEN_USB_GOTOP 1
+#define CONFIG_TOUCHSCREEN_USB_GUNZE 1
+#define CONFIG_SSB_SDIOHOST_POSSIBLE 1
+#define CONFIG_PATA_SIS_MODULE 1
+#define CONFIG_SCSI_IMM_MODULE 1
+#define CONFIG_IPV6_SIT_MODULE 1
+#define CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE 1
+#define CONFIG_TASK_IO_ACCOUNTING 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_USB_SERIAL_CYPRESS_M8_MODULE 1
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_SATA_PMP 1
+#define CONFIG_IP6_NF_IPTABLES_MODULE 1
+#define CONFIG_CPU_FREQ_STAT_DETAILS 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_CONTEXT_SWITCH_TRACER 1
+#define CONFIG_AGP_EFFICEON 1
+#define CONFIG_DVB_MT352_MODULE 1
+#define CONFIG_MEDIA_TUNER_SIMPLE_MODULE 1
+#define CONFIG_SCSI_AACRAID_MODULE 1
+#define CONFIG_IP6_NF_MATCH_AH_MODULE 1
+#define CONFIG_IO_DELAY_TYPE_0XED 1
+#define CONFIG_HID_PANTHERLORD 1
+#define CONFIG_SND_WSS_LIB_MODULE 1
+#define CONFIG_DVB_DYNAMIC_MINORS 1
+#define CONFIG_SENSORS_ABITUGURU3_MODULE 1
+#define CONFIG_SSB_DRIVER_PCICORE 1
+#define CONFIG_SATA_SIS_MODULE 1
+#define CONFIG_BRIDGE_EBT_VLAN_MODULE 1
+#define CONFIG_BRIDGE_EBT_PKTTYPE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_HL_MODULE 1
+#define CONFIG_INET_ESP_MODULE 1
+#define CONFIG_AUDIT 1
+#define CONFIG_CRYPTO_CAMELLIA_MODULE 1
+#define CONFIG_AMIGA_PARTITION 1
+#define CONFIG_EDAC_I3000_MODULE 1
+#define CONFIG_UWB_WHCI_MODULE 1
+#define CONFIG_SND_HDA_INPUT_JACK 1
+#define CONFIG_SND_PCM_OSS_MODULE 1
+#define CONFIG_SONY_LAPTOP_MODULE 1
+#define CONFIG_INPUT_MOUSE 1
+#define CONFIG_PCMCIA_WL3501_MODULE 1
+#define CONFIG_SECURITY 1
+#define CONFIG_NET_IPIP_MODULE 1
+#define CONFIG_BTRFS_FS_MODULE 1
+#define CONFIG_FIRMWARE_MEMMAP 1
+#define CONFIG_SERIAL_8250_MANY_PORTS 1
+#define CONFIG_USB_NET_ZAURUS_MODULE 1
+#define CONFIG_SYS_HYPERVISOR 1
+#define CONFIG_NF_NAT_PPTP_MODULE 1
+#define CONFIG_PCI_STUB 1
+#define CONFIG_TREE_RCU 1
+#define CONFIG_EDAC_I5000_MODULE 1
+#define CONFIG_EDAC_I3200_MODULE 1
+#define CONFIG_SND_PCSP_MODULE 1
+#define CONFIG_DVB_USB_CINERGY_T2_MODULE 1
+#define CONFIG_USB_GL860_MODULE 1
+#define CONFIG_VIDEO_SAA7134_MODULE 1
+#define CONFIG_ISDN_MPP 1
+#define CONFIG_X86_INTEL_USERCOPY 1
+#define CONFIG_SHMEM 1
+#define CONFIG_CRYPTO_NULL_MODULE 1
+#define CONFIG_EXPORTFS_MODULE 1
+#define CONFIG_EDAC_I5100_MODULE 1
+#define CONFIG_LEDS_TRIGGER_TIMER_MODULE 1
+#define CONFIG_SND_HDA_INPUT_BEEP 1
+#define CONFIG_SND_MIRO_MODULE 1
+#define CONFIG_VIDEO_CX23885_MODULE 1
+#define CONFIG_SENSORS_W83627HF_MODULE 1
+#define CONFIG_MISDN_MODULE 1
+#define CONFIG_SCSI_AIC94XX_MODULE 1
+#define CONFIG_TASK_DELAY_ACCT 1
+#define CONFIG_ARCH_HAS_CPU_RELAX 1
+#define CONFIG_CRYPTO_DEV_PADLOCK_MODULE 1
+#define CONFIG_VIDEO_SAA7127_MODULE 1
+#define CONFIG_ISDN_PPP_VJ 1
+#define CONFIG_IPW2200_PROMISCUOUS 1
+#define CONFIG_PATA_HPT3X2N_MODULE 1
+#define CONFIG_BRIDGE_EBT_SNAT_MODULE 1
+#define CONFIG_IP_VS_PROTO_AH 1
+#define CONFIG_INET_LRO 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT_MODULE 1
+#define CONFIG_EPOLL 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_STRIP_ASM_SYMS 1
+#define CONFIG_HID_SONY 1
+#define CONFIG_FB_SYS_FOPS 1
+#define CONFIG_VIDEO_SAA7164_MODULE 1
+#define CONFIG_VIDEO_SAA7146_MODULE 1
+#define CONFIG_ITCO_WDT_MODULE 1
+#define CONFIG_ISDN_PPP 1
+#define CONFIG_SCSI_IPS_MODULE 1
+#define CONFIG_INFTL_MODULE 1
+#define CONFIG_BRIDGE_EBT_ULOG_MODULE 1
+#define CONFIG_YENTA_TI 1
+#define CONFIG_RELAY 1
+#define CONFIG_MSDOS_FS_MODULE 1
+#define CONFIG_EDAC_I5400_MODULE 1
+#define CONFIG_FONT_8x8 1
+#define CONFIG_FB_MODE_HELPERS 1
+#define CONFIG_DVB_BUDGET_CORE_MODULE 1
+#define CONFIG_MEDIA_TUNER_TDA827X_MODULE 1
+#define CONFIG_VIDEOBUF_DMA_SG_MODULE 1
+#define CONFIG_GIGASET_BASE_MODULE 1
+#define CONFIG_ASYNC_PQ_MODULE 1
+#define CONFIG_SCSI_AIC79XX_MODULE 1
+#define CONFIG_NET_EMATCH_META_MODULE 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_HOTPLUG_PCI_COMPAQ_MODULE 1
+#define CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE 1
+#define CONFIG_CRYPTO_WP512_MODULE 1
+#define CONFIG_RPCSEC_GSS_KRB5_MODULE 1
+#define CONFIG_ISCSI_IBFT_FIND 1
+#define CONFIG_VIDEO_TDA7432_MODULE 1
+#define CONFIG_PPDEV_MODULE 1
+#define CONFIG_PCMCIA_SPECTRUM_MODULE 1
+#define CONFIG_PCMCIA_ATMEL_MODULE 1
+#define CONFIG_MDIO_BITBANG_MODULE 1
+#define CONFIG_PATA_PDC2027X_MODULE 1
+#define CONFIG_XEN_MAX_DOMAIN_MEMORY 128
+#define CONFIG_CRYPTO_TEST_MODULE 1
+#define CONFIG_NLS_CODEPAGE_850_MODULE 1
+#define CONFIG_SND_INTEL8X0_MODULE 1
+#define CONFIG_SND_DYNAMIC_MINORS 1
+#define CONFIG_BACKLIGHT_WM831X_MODULE 1
+#define CONFIG_MEGARAID_SAS_MODULE 1
+#define CONFIG_SCSI_TGT_MODULE 1
+#define CONFIG_DEBUG_RODATA 1
+#define CONFIG_NLS_CODEPAGE_932_MODULE 1
+#define CONFIG_NLS_CODEPAGE_950_MODULE 1
+#define CONFIG_NLS_CODEPAGE_860_MODULE 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_CIFS_DFS_UPCALL 1
+#define CONFIG_INFINIBAND_USER_ACCESS_MODULE 1
+#define CONFIG_PPP_MPPE_MODULE 1
+#define CONFIG_IP6_NF_MATCH_HL_MODULE 1
+#define CONFIG_YENTA_MODULE 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_FTRACE_SYSCALLS 1
+#define CONFIG_NLS_CODEPAGE_861_MODULE 1
+#define CONFIG_NLS_CODEPAGE_852_MODULE 1
+#define CONFIG_LEDS_CLEVO_MAIL_MODULE 1
+#define CONFIG_USB_SERIAL_OMNINET_MODULE 1
+#define CONFIG_VIDEO_EM28XX_MODULE 1
+#define CONFIG_HW_RANDOM_GEODE_MODULE 1
+#define CONFIG_TOUCHSCREEN_ELO_MODULE 1
+#define CONFIG_SERIO 1
+#define CONFIG_RT2X00_LIB_FIRMWARE 1
+#define CONFIG_DM_CRYPT_MODULE 1
+#define CONFIG_UEVENT_HELPER_PATH ""
+#define CONFIG_IP6_NF_MATCH_MH_MODULE 1
+#define CONFIG_NLS_CODEPAGE_862_MODULE 1
+#define CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_MODULE 1
+#define CONFIG_HID_LOGITECH 1
+#define CONFIG_SND_HDA_CODEC_SIGMATEL 1
+#define CONFIG_SND_CS46XX_NEW_DSP 1
+#define CONFIG_USB_GSPCA_PAC207_MODULE 1
+#define CONFIG_INPUT_WM831X_ON_MODULE 1
+#define CONFIG_NET_ACT_SKBEDIT_MODULE 1
+#define CONFIG_NLS_CODEPAGE_863_MODULE 1
+#define CONFIG_NLS_CODEPAGE_737_MODULE 1
+#define CONFIG_XENFS_MODULE 1
+#define CONFIG_UIO_PCI_GENERIC_MODULE 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_USB_SERIAL_OPTICON_MODULE 1
+#define CONFIG_REGULATOR_LP3971_MODULE 1
+#define CONFIG_REGULATOR_WM8400_MODULE 1
+#define CONFIG_SENSORS_I5K_AMB_MODULE 1
+#define CONFIG_WM831X_POWER_MODULE 1
+#define CONFIG_PPPOE_MODULE 1
+#define CONFIG_MAC_EMUMOUSEBTN 1
+#define CONFIG_SCSI_OSD_DPRINT_SENSE 1
+#define CONFIG_NVRAM 1
+#define CONFIG_PCMCIA_PROBE 1
+#define CONFIG_X86_32_NON_STANDARD 1
+#define CONFIG_MM_OWNER 1
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_NLS_CODEPAGE_936_MODULE 1
+#define CONFIG_NLS_CODEPAGE_864_MODULE 1
+#define CONFIG_NLS_CODEPAGE_855_MODULE 1
+#define CONFIG_KARMA_PARTITION 1
+#define CONFIG_ZLIB_DEFLATE_MODULE 1
+#define CONFIG_NET_VENDOR_3COM 1
+#define CONFIG_SCSI_BNX2_ISCSI_MODULE 1
+#define CONFIG_MTD_OOPS_MODULE 1
+#define CONFIG_CLS_U32_MARK 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL_MODULE 1
+#define CONFIG_CGROUP_MEM_RES_CTLR_SWAP 1
+#define CONFIG_NLS_CODEPAGE_874_MODULE 1
+#define CONFIG_NLS_CODEPAGE_865_MODULE 1
+#define CONFIG_NLS_CODEPAGE_775_MODULE 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_ACPI_TOSHIBA_MODULE 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_SB16_DSP_MODULE 1
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_VIDEO_SAA6588_MODULE 1
+#define CONFIG_HYSDN_MODULE 1
+#define CONFIG_HISAX_AVM_A1_CS_MODULE 1
+#define CONFIG_PCMCIA_PCNET_MODULE 1
+#define CONFIG_SMSC_PHY_MODULE 1
+#define CONFIG_SCSI_SRP_MODULE 1
+#define CONFIG_WIMAX_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE 1
+#define CONFIG_SCHED_TRACER 1
+#define CONFIG_NLS_CODEPAGE_866_MODULE 1
+#define CONFIG_NLS_CODEPAGE_857_MODULE 1
+#define CONFIG_HUGETLB_PAGE 1
+#define CONFIG_USB_SERIAL_SAFE_MODULE 1
+#define CONFIG_SMS_USB_DRV_MODULE 1
+#define CONFIG_MISDN_HFCPCI_MODULE 1
+#define CONFIG_CLS_U32_PERF 1
+#define CONFIG_PCMCIA_IOCTL 1
+#define CONFIG_X86_POWERNOW_K7 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_MINIX_SUBPARTITION 1
+#define CONFIG_UIO_PDRV_MODULE 1
+#define CONFIG_INFINIBAND_CXGB3_MODULE 1
+#define CONFIG_USB_SERIAL_SAFE_PADDED 1
+#define CONFIG_SND_VX222_MODULE 1
+#define CONFIG_FB_RADEON_BACKLIGHT 1
+#define CONFIG_MEDIA_TUNER_TDA18271_MODULE 1
+#define CONFIG_VIDEO_SAA7146_VV_MODULE 1
+#define CONFIG_REGULATOR_WM8350_MODULE 1
+#define CONFIG_ISDN_CAPI_CAPI20_MODULE 1
+#define CONFIG_SIS900_MODULE 1
+#define CONFIG_ULTRA_MODULE 1
+#define CONFIG_FB 1
+#define CONFIG_SATA_SVW_MODULE 1
+#define CONFIG_BT_HCIBCM203X_MODULE 1
+#define CONFIG_X86_POWERNOW_K8_MODULE 1
+#define CONFIG_MEMORY_HOTPLUG_SPARSE 1
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_HAVE_ARCH_KMEMCHECK 1
+#define CONFIG_NLS_CODEPAGE_949_MODULE 1
+#define CONFIG_MMC_SDHCI_PLTFM_MODULE 1
+#define CONFIG_SOUND_MODULE 1
+#define CONFIG_HISAX_ENTERNOW_PCI 1
+#define CONFIG_SIS190_MODULE 1
+#define CONFIG_SCSI_OSD_INITIATOR_MODULE 1
+#define CONFIG_IP_NF_ARPTABLES_MODULE 1
+#define CONFIG_ACPI_THERMAL 1
+#define CONFIG_HWMON 1
+#define CONFIG_HIBERNATION_NVS 1
+#define CONFIG_ARCH_FLATMEM_ENABLE 1
+#define CONFIG_NLS_CODEPAGE_869_MODULE 1
+#define CONFIG_QUOTA 1
+#define CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE 1
+#define CONFIG_USB_WUSB_MODULE 1
+#define CONFIG_FB_NVIDIA_BACKLIGHT 1
+#define CONFIG_REGULATOR_USERSPACE_CONSUMER_MODULE 1
+#define CONFIG_WIMAX_I2400M_USB_MODULE 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ASK_IP_FIB_HASH 1
+#define CONFIG_X86_32 1
+#define CONFIG_USB_SERIAL_CH341_MODULE 1
+#define CONFIG_I2C_PIIX4_MODULE 1
+#define CONFIG_HOSTAP_FIRMWARE 1
+#define CONFIG_PCI_MMCONFIG 1
+#define CONFIG_SCHED_HRTICK 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_GENERIC_TIME 1
+#define CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST 1
+#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define CONFIG_CRYPTO_TWOFISH_COMMON_MODULE 1
+#define CONFIG_USB_EMI26_MODULE 1
+#define CONFIG_USB_EMI62_MODULE 1
+#define CONFIG_USB_SERIAL_HP4X_MODULE 1
+#define CONFIG_SND_INDIGODJ_MODULE 1
+#define CONFIG_IPMI_HANDLER_MODULE 1
+#define CONFIG_SLIP_COMPRESSED 1
+#define CONFIG_PCMCIA_AXNET_MODULE 1
+#define CONFIG_B43LEGACY_DMA_AND_PIO_MODE 1
+#define CONFIG_DUMMY_MODULE 1
+#define CONFIG_PATA_NETCELL_MODULE 1
+#define CONFIG_BT_HCIUART_BCSP 1
+#define CONFIG_IP_VS_DH_MODULE 1
+#define CONFIG_FUTEX 1
+#define CONFIG_BUILD_DOCSRC 1
+#define CONFIG_USB_SERIAL_FUNSOFT_MODULE 1
+#define CONFIG_SND_RME32_MODULE 1
+#define CONFIG_SND_HDA_CODEC_CONEXANT 1
+#define CONFIG_VIDEO_MSP3400_MODULE 1
+#define CONFIG_VIDEOBUF_GEN_MODULE 1
+#define CONFIG_SENSORS_LM80_MODULE 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_WLAN_80211 1
+#define CONFIG_IP_NF_MATCH_ECN_MODULE 1
+#define CONFIG_INET6_IPCOMP_MODULE 1
+#define CONFIG_VIDEO_IR_I2C_MODULE 1
+#define CONFIG_SENSORS_LM90_MODULE 1
+#define CONFIG_SENSORS_LM63_MODULE 1
+#define CONFIG_HISAX_MAX_CARDS 8
+#define CONFIG_USB_NET_CDC_SUBSET_MODULE 1
+#define CONFIG_B43_HWRNG 1
+#define CONFIG_TULIP_MODULE 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_MAC80211_RC_MINSTREL 1
+#define CONFIG_BT_HCIBTSDIO_MODULE 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_SND_CA0106_MODULE 1
+#define CONFIG_DVB_AF9013_MODULE 1
+#define CONFIG_VIDEOBUF_DVB_MODULE 1
+#define CONFIG_SBC_FITPC2_WATCHDOG_MODULE 1
+#define CONFIG_USB_NET_CDC_EEM_MODULE 1
+#define CONFIG_B43LEGACY_DMA 1
+#define CONFIG_IP_VS_LC_MODULE 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_KTIME_SCALAR 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_SENSORS_LM92_MODULE 1
+#define CONFIG_SENSORS_LM83_MODULE 1
+#define CONFIG_RT2X00_MODULE 1
+#define CONFIG_SCSI_ARCMSR_AER 1
+#define CONFIG_NET_DSA_TAG_DSA 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE 1
+#define CONFIG_INPUT 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_EEEPC_LAPTOP_MODULE 1
+#define CONFIG_DVB_L64781_MODULE 1
+#define CONFIG_SENSORS_LM93_MODULE 1
+#define CONFIG_SENSORS_LM75_MODULE 1
+#define CONFIG_I2C_AMD756_MODULE 1
+#define CONFIG_TABLET_USB_GTCO_MODULE 1
+#define CONFIG_MD 1
+#define CONFIG_SCSI_PMCRAID_MODULE 1
+#define CONFIG_BLK_DEV_CRYPTOLOOP_MODULE 1
+#define CONFIG_BLK_CPQ_CISS_DA_MODULE 1
+#define CONFIG_ACPI_PROC_EVENT 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_SND_MAESTRO3_MODULE 1
+#define CONFIG_USB_GSPCA_TV8532_MODULE 1
+#define CONFIG_MEDIA_TUNER_MC44S803_MODULE 1
+#define CONFIG_SENSORS_LM85_MODULE 1
+#define CONFIG_X86_POPAD_OK 1
+#define CONFIG_AUDITSYSCALL 1
+#define CONFIG_INFINIBAND_IPOIB_CM 1
+#define CONFIG_USB_SERIAL_IPAQ_MODULE 1
+#define CONFIG_DVB_DM1105_MODULE 1
+#define CONFIG_USB_GSPCA_CONEX_MODULE 1
+#define CONFIG_VIDEO_CX2341X_MODULE 1
+#define CONFIG_SENSORS_LM77_MODULE 1
+#define CONFIG_TCG_INFINEON_MODULE 1
+#define CONFIG_MOUSE_BCM5974_MODULE 1
+#define CONFIG_SCSI_SCAN_ASYNC 1
+#define CONFIG_IP6_NF_MATCH_RT_MODULE 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_DVB_B2C2_FLEXCOP_MODULE 1
+#define CONFIG_SENSORS_LM87_MODULE 1
+#define CONFIG_SENSORS_LM78_MODULE 1
+#define CONFIG_HISAX_FRITZ_PCIPNP_MODULE 1
+#define CONFIG_FORCEDETH_MODULE 1
+#define CONFIG_CAN_SJA1000_PLATFORM_MODULE 1
+#define CONFIG_IP_NF_ARPFILTER_MODULE 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_SND_HDA_CODEC_SI3054 1
+#define CONFIG_USB_VIDEO_CLASS_MODULE 1
+#define CONFIG_MISDN_HFCUSB_MODULE 1
+#define CONFIG_SC92031_MODULE 1
+#define CONFIG_SCSI_SAS_LIBSAS_MODULE 1
+#define CONFIG_HOTPLUG_PCI_IBM_MODULE 1
+#define CONFIG_MICROCODE_MODULE 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_IO_DELAY_TYPE_NONE 3
+#define CONFIG_SND_INDIGOIO_MODULE 1
+#define CONFIG_USB_GSPCA_ZC3XX_MODULE 1
+#define CONFIG_HISAX_NO_KEYPAD 1
+#define CONFIG_IXGBE_DCA 1
+#define CONFIG_SCSI_DH_RDAC_MODULE 1
+#define CONFIG_BT_MODULE 1
+#define CONFIG_NET_CLS_TCINDEX_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE 1
+#define CONFIG_NF_CONNTRACK_MODULE 1
+#define CONFIG_X86_APM_BOOT 1
+#define CONFIG_ARCH_PHYS_ADDR_T_64BIT 1
+#define CONFIG_CGROUP_SCHED 1
+#define CONFIG_USB_SERIAL_MCT_U232_MODULE 1
+#define CONFIG_SND_RME96_MODULE 1
+#define CONFIG_LCD_PLATFORM_MODULE 1
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define CONFIG_IXGBE_DCB 1
+#define CONFIG_BROADCOM_PHY_MODULE 1
+#define CONFIG_PATA_JMICRON_MODULE 1
+#define CONFIG_NF_CONNTRACK_AMANDA_MODULE 1
+#define CONFIG_NET_KEY_MIGRATE 1
+#define CONFIG_ACPI_BATTERY 1
+#define CONFIG_PCSPKR_PLATFORM 1
+#define CONFIG_THINKPAD_ACPI_HOTKEY_POLL 1
+#define CONFIG_XEN_SCRUB_PAGES 1
+#define CONFIG_SND_OPL3_LIB_MODULE 1
+#define CONFIG_VGACON_SOFT_SCROLLBACK 1
+#define CONFIG_VIDEO_USBVISION_MODULE 1
+#define CONFIG_VIDEO_MT9V011_MODULE 1
+#define CONFIG_SENSORS_IT87_MODULE 1
+#define CONFIG_I2C_NFORCE2_S4985_MODULE 1
+#define CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE 1
+#define CONFIG_PATA_MARVELL_MODULE 1
+#define CONFIG_SCSI_LOGGING 1
+#define CONFIG_MTD_QINFO_PROBE_MODULE 1
+#define CONFIG_BRIDGE_EBT_REDIRECT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE 1
+#define CONFIG_SYSFS 1
+#define CONFIG_KMEMTRACE 1
+#define CONFIG_SND_OPL4_LIB_MODULE 1
+#define CONFIG_SND_RAWMIDI_SEQ_MODULE 1
+#define CONFIG_FB_SYS_COPYAREA 1
+#define CONFIG_AB3100_OTP_MODULE 1
+#define CONFIG_IP6_NF_SECURITY_MODULE 1
+#define CONFIG_X86_CMPXCHG64 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_BTRFS_FS_POSIX_ACL 1
+#define CONFIG_USB_OHCI_HCD 1
+#define CONFIG_FB_SYS_FILLRECT 1
+#define CONFIG_HW_RANDOM_INTEL_MODULE 1
+#define CONFIG_PATA_PDC_OLD_MODULE 1
+#define CONFIG_TCP_CONG_BIC_MODULE 1
+#define CONFIG_X86_CPUID 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_CRYPTO_CRC32C_INTEL_MODULE 1
+#define CONFIG_USB_SERIAL_KLSI_MODULE 1
+#define CONFIG_USB_SERIAL_AIRCABLE_MODULE 1
+#define CONFIG_DVB_AV7110_MODULE 1
+#define CONFIG_USB_GSPCA_SQ905C_MODULE 1
+#define CONFIG_VIDEO_TVP5150_MODULE 1
+#define CONFIG_USB_ALI_M5632 1
+#define CONFIG_SCSI_MPT2SAS_MODULE 1
+#define CONFIG_BT_HCIBTUART_MODULE 1
+#define CONFIG_IP_VS_SH_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE 1
+#define CONFIG_INET6_TUNNEL_MODULE 1
+#define CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE 1
+#define CONFIG_USB_GSPCA_VC032X_MODULE 1
+#define CONFIG_VIDEO_SAA711X_MODULE 1
+#define CONFIG_SATA_INIC162X_MODULE 1
+#define CONFIG_FCOE_FNIC_MODULE 1
+#define CONFIG_AIC79XX_RESET_DELAY_MS 15000
+#define CONFIG_NET_ACT_GACT_MODULE 1
+#define CONFIG_NET_EMATCH_TEXT_MODULE 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_SECURITY_NETWORK_XFRM 1
+#define CONFIG_USB_GSPCA_STK014_MODULE 1
+#define CONFIG_V4L_USB_DRIVERS 1
+#define CONFIG_TOUCHSCREEN_USB_EGALAX 1
+#define CONFIG_HISAX_AVM_A1_PCMCIA 1
+#define CONFIG_SATA_AHCI_MODULE 1
+#define CONFIG_SCSI_AIC7XXX_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_U32_MODULE 1
+#define CONFIG_PCIE_ECRC 1
+#define CONFIG_ACPI_DOCK 1
+#define CONFIG_PM 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_CRYPTO_BLOWFISH_MODULE 1
+#define CONFIG_INFINIBAND_MTHCA_MODULE 1
+#define CONFIG_FB_SAVAGE_MODULE 1
+#define CONFIG_USB_GSPCA_ETOMS_MODULE 1
+#define CONFIG_SERIAL_8250_EXTENDED 1
+#define CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE 1
+#define CONFIG_ADM8211_MODULE 1
+#define CONFIG_PATA_OLDPIIX_MODULE 1
+#define CONFIG_MTD_CFI_STAA_MODULE 1
+#define CONFIG_NET_SCH_INGRESS_MODULE 1
+#define CONFIG_IPV6_ROUTE_INFO 1
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_LIBERTAS_USB_MODULE 1
+#define CONFIG_SCSI_DH_ALUA_MODULE 1
+#define CONFIG_IP_VS_NQ_MODULE 1
+#define CONFIG_IP_NF_MANGLE_MODULE 1
+#define CONFIG_CRYPTO_CAST5_MODULE 1
+#define CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE 1
+#define CONFIG_USB_STORAGE_DATAFAB_MODULE 1
+#define CONFIG_USB_UHCI_HCD 1
+#define CONFIG_FB_RADEON_MODULE 1
+#define CONFIG_INPUT_APANEL_MODULE 1
+#define CONFIG_USB_NET_RNDIS_WLAN_MODULE 1
+#define CONFIG_BE2NET_MODULE 1
+#define CONFIG_NET_DSA_MV88E6131 1
+#define CONFIG_IPV6_MIP6_MODULE 1
+#define CONFIG_HAVE_ARCH_TRACEHOOK 1
+#define CONFIG_CRYPTO_CAST6_MODULE 1
+#define CONFIG_INFINIBAND_USER_MAD_MODULE 1
+#define CONFIG_HID_GYRATION 1
+#define CONFIG_SND_BT87X_MODULE 1
+#define CONFIG_REGULATOR_BQ24022_MODULE 1
+#define CONFIG_HAPPYMEAL_MODULE 1
+#define CONFIG_DCDBAS_MODULE 1
+#define CONFIG_NET_DSA_MV88E6060 1
+#define CONFIG_IP_VS_MODULE 1
+#define CONFIG_USB_WHCI_HCD_MODULE 1
+#define CONFIG_FB_NVIDIA_MODULE 1
+#define CONFIG_DVB_AU8522_MODULE 1
+#define CONFIG_VIDEO_SAA717X_MODULE 1
+#define CONFIG_IWLWIFI_LEDS 1
+#define CONFIG_PATA_ACPI_MODULE 1
+#define CONFIG_IPV6_PRIVACY 1
+#define CONFIG_APM_CPU_IDLE 1
+#define CONFIG_X86_PM_TIMER 1
+#define CONFIG_HZ 1000
+#define CONFIG_X86_BSWAP 1
+#define CONFIG_GENERIC_FIND_FIRST_BIT 1
+#define CONFIG_DLM_DEBUG 1
+#define CONFIG_USB_XHCI_HCD_MODULE 1
+#define CONFIG_SND_AD1889_MODULE 1
+#define CONFIG_INPUT_POWERMATE_MODULE 1
+#define CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE 1
+#define CONFIG_USB_KC2190 1
+#define CONFIG_USB_AN2720 1
+#define CONFIG_ACENIC_MODULE 1
+#define CONFIG_FIREWIRE_NET_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE 1
+#define CONFIG_PROC_PID_CPUSET 1
+#define CONFIG_HUGETLBFS 1
+#define CONFIG_INFINIBAND_IPOIB_MODULE 1
+#define CONFIG_HISAX_NI1 1
+#define CONFIG_MISDN_NETJET_MODULE 1
+#define CONFIG_DM_MULTIPATH_QL_MODULE 1
+#define CONFIG_MTD_NAND_IDS_MODULE 1
+#define CONFIG_IP_VS_RR_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE 1
+#define CONFIG_INET_DIAG_MODULE 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_NLS_ISO8859_1_MODULE 1
+#define CONFIG_THINKPAD_ACPI_VIDEO 1
+#define CONFIG_TC1100_WMI_MODULE 1
+#define CONFIG_I2C_SIS630_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_JASTEC 1
+#define CONFIG_B43LEGACY_PIO 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_FIREWIRE_OHCI_DEBUG 1
+#define CONFIG_MEGARAID_MAILBOX_MODULE 1
+#define CONFIG_CB710_CORE_MODULE 1
+#define CONFIG_NET_SCH_GRED_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE 1
+#define CONFIG_XFRM_MIGRATE 1
+#define CONFIG_ACPI_BLACKLIST_YEAR 1999
+#define CONFIG_NLS_ISO8859_2_MODULE 1
+#define CONFIG_HID_APPLE 1
+#define CONFIG_MFD_WM8400_MODULE 1
+#define CONFIG_HISAX_NETJET 1
+#define CONFIG_NS83820_MODULE 1
+#define CONFIG_NATIONAL_PHY_MODULE 1
+#define CONFIG_SCSI_NETLINK 1
+#define CONFIG_REED_SOLOMON_MODULE 1
+#define CONFIG_IP6_NF_QUEUE_MODULE 1
+#define CONFIG_X86_RESERVE_LOW_64K 1
+#define CONFIG_NLS_ISO8859_3_MODULE 1
+#define CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA 1
+#define CONFIG_EDAC_E752X_MODULE 1
+#define CONFIG_MMC_SDHCI_MODULE 1
+#define CONFIG_MMC_BLOCK_MODULE 1
+#define CONFIG_USB_MICROTEK_MODULE 1
+#define CONFIG_USB_OHCI_LITTLE_ENDIAN 1
+#define CONFIG_HID_MONTEREY 1
+#define CONFIG_SND_CS5530_MODULE 1
+#define CONFIG_SATA_PROMISE_MODULE 1
+#define CONFIG_TIFM_7XX1_MODULE 1
+#define CONFIG_NET_SCH_HFSC_MODULE 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_XFRM_STATISTICS 1
+#define CONFIG_NLS_ISO8859_4_MODULE 1
+#define CONFIG_HYPERV_BLOCK_MODULE 1
+#define CONFIG_SMARTJOYPLUS_FF 1
+#define CONFIG_BATTERY_OLPC 1
+#define CONFIG_DEVPTS_MULTIPLE_INSTANCES 1
+#define CONFIG_MOUSE_SERIAL_MODULE 1
+#define CONFIG_ISDN_HDLC_MODULE 1
+#define CONFIG_USB_EPSON2888 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_DE2104X_MODULE 1
+#define CONFIG_DM_MULTIPATH_MODULE 1
+#define CONFIG_ASYNC_MEMCPY_MODULE 1
+#define CONFIG_CB710_DEBUG_ASSUMPTIONS 1
+#define CONFIG_KALLSYMS_ALL 1
+#define CONFIG_NLS_ISO8859_5_MODULE 1
+#define CONFIG_HID_PETALYNX 1
+#define CONFIG_CONSOLE_POLL 1
+#define CONFIG_KGDB_SERIAL_CONSOLE 1
+#define CONFIG_B43_MODULE 1
+#define CONFIG_ATM_BR2684_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE 1
+#define CONFIG_X86_MINIMUM_CPU_FAMILY 5
+#define CONFIG_XEN_DEBUG_FS 1
+#define CONFIG_NLS_ISO8859_6_MODULE 1
+#define CONFIG_MFD_WM8350_MODULE 1
+#define CONFIG_I2C_TINY_USB_MODULE 1
+#define CONFIG_VT 1
+#define CONFIG_B44_MODULE 1
+#define CONFIG_ISDN_CAPI_MODULE 1
+#define CONFIG_MIGRATION 1
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_PROFILING 1
+#define CONFIG_CRYPTO_GHASH_MODULE 1
+#define CONFIG_NLS_ISO8859_7_MODULE 1
+#define CONFIG_NLS_CODEPAGE_1250_MODULE 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_HID_WACOM_MODULE 1
+#define CONFIG_SND_AU8810_MODULE 1
+#define CONFIG_TTPCI_EEPROM_MODULE 1
+#define CONFIG_SENSORS_SMSC47M1_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_E2I 1
+#define CONFIG_INPUT_TABLET 1
+#define CONFIG_USB_ZD1201_MODULE 1
+#define CONFIG_MD_LINEAR_MODULE 1
+#define CONFIG_SATA_VITESSE_MODULE 1
+#define CONFIG_CONNECTOR 1
+#define CONFIG_IP_NF_MATCH_TTL_MODULE 1
+#define CONFIG_NLS_CODEPAGE_1251_MODULE 1
+#define CONFIG_NLS_ISO8859_8_MODULE 1
+#define CONFIG_GFS2_FS_LOCKING_DLM 1
+#define CONFIG_SND_AU8820_MODULE 1
+#define CONFIG_REGULATOR_WM831X_MODULE 1
+#define CONFIG_USB_NET_RNDIS_HOST_MODULE 1
+#define CONFIG_VLAN_8021Q_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE 1
+#define CONFIG_GENERIC_PENDING_IRQ 1
+#define CONFIG_IMA_AUDIT 1
+#define CONFIG_POWER_TRACER 1
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define CONFIG_NLS_ISO8859_9_MODULE 1
+#define CONFIG_UIO_PDRV_GENIRQ_MODULE 1
+#define CONFIG_SND_AU8830_MODULE 1
+#define CONFIG_FONT_8x16 1
+#define CONFIG_MLX4_CORE_MODULE 1
+#define CONFIG_SCSI_SAS_ATA 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_BRIDGE_MODULE 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_INET6_ESP_MODULE 1
+#define CONFIG_PCMCIA 1
+#define CONFIG_PCCARD 1
+#define CONFIG_SPARSEMEM 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_RTC_DRV_V3020_MODULE 1
+#define CONFIG_INFINIBAND_USER_MEM 1
+#define CONFIG_USB_ISIGHTFW_MODULE 1
+#define CONFIG_SMSC_SCH311X_WDT_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCMCIA_MODULE 1
+#define CONFIG_PCI_ATMEL_MODULE 1
+#define CONFIG_VIA_VELOCITY_MODULE 1
+#define CONFIG_DM_MULTIPATH_ST_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_MMIO 1
+#define CONFIG_SCSI_SYM53C8XX_2_MODULE 1
+#define CONFIG_CRC_CCITT_MODULE 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_MD_RAID456_MODULE 1
+#define CONFIG_MTD_BLOCK_RO_MODULE 1
+#define CONFIG_MTD_BLOCK_MODULE 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_NET_IPGRE_BROADCAST 1
+#define CONFIG_DEBUG_STACKOVERFLOW 1
+#define CONFIG_USB_SL811_HCD_MODULE 1
+#define CONFIG_TCG_ATMEL_MODULE 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_MTD_NAND_DISKONCHIP_MODULE 1
+#define CONFIG_HIGHMEM64G 1
+#define CONFIG_CPU_SUP_CENTAUR 1
+#define CONFIG_GENERIC_CMOS_UPDATE 1
+#define CONFIG_SOC_CAMERA_PLATFORM_MODULE 1
+#define CONFIG_SENSORS_G760A_MODULE 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_TOUCHSCREEN_USB_PANJIT 1
+#define CONFIG_ADAPTEC_STARFIRE_MODULE 1
+#define CONFIG_ATA_OVER_ETH_MODULE 1
+#define CONFIG_GACT_PROB 1
+#define CONFIG_IP_NF_FILTER_MODULE 1
+#define CONFIG_IPV6_OPTIMISTIC_DAD 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_NFS_ACL_SUPPORT_MODULE 1
+#define CONFIG_SND_AC97_POWER_SAVE 1
+#define CONFIG_DISPLAY_SUPPORT_MODULE 1
+#define CONFIG_FB_DDC_MODULE 1
+#define CONFIG_VIDEO_CX88_VP3054_MODULE 1
+#define CONFIG_EPIC100_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT_MODULE 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_RTC_DRV_X1205_MODULE 1
+#define CONFIG_AGP_INTEL 1
+#define CONFIG_HISAX_NO_LLC 1
+#define CONFIG_IPW2100_MODULE 1
+#define CONFIG_MTD_CFI_UTIL_MODULE 1
+#define CONFIG_RFKILL_INPUT 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE 1
+#define CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE 1
+#define CONFIG_CRYPTO_SHA512_MODULE 1
+#define CONFIG_EARLY_PRINTK 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_SND_ES1968_MODULE 1
+#define CONFIG_NETPOLL_TRAP 1
+#define CONFIG_SSB_SDIOHOST 1
+#define CONFIG_IPW2200_MODULE 1
+#define CONFIG_MAC80211_HWSIM_MODULE 1
+#define CONFIG_TIGON3_MODULE 1
+#define CONFIG_MTD_CK804XROM_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_MAC_MODULE 1
+#define CONFIG_IO_DELAY_0X80 1
+#define CONFIG_FTRACE 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_USB_MDC800_MODULE 1
+#define CONFIG_DVB_SP8870_MODULE 1
+#define CONFIG_VIDEO_SAA7134_DVB_MODULE 1
+#define CONFIG_VIDEO_DEV_MODULE 1
+#define CONFIG_REGULATOR 1
+#define CONFIG_I2C_PCA_PLATFORM_MODULE 1
+#define CONFIG_B43_PCMCIA 1
+#define CONFIG_VIA_RHINE_MODULE 1
+#define CONFIG_MTD_TS5500_MODULE 1
+#define CONFIG_WIRELESS_EXT_SYSFS 1
+#define CONFIG_BRIDGE_EBT_ARPREPLY_MODULE 1
+#define CONFIG_XFRM_SUB_POLICY 1
+#define CONFIG_DVB_USB_GL861_MODULE 1
+#define CONFIG_USB_GSPCA_PAC7311_MODULE 1
+#define CONFIG_WL12XX_MODULE 1
+#define CONFIG_SCSI_LPFC_MODULE 1
+#define CONFIG_NET_ACT_SIMP_MODULE 1
+#define CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE 1
+#define CONFIG_LCD_CLASS_DEVICE_MODULE 1
+#define CONFIG_VIDEO_CX231XX_MODULE 1
+#define CONFIG_USB_GSPCA_MODULE 1
+#define CONFIG_HISAX_HFC_SX 1
+#define CONFIG_IP_DCCP_CCID3 1
+#define CONFIG_X86_ACPI_CPUFREQ_MODULE 1
+#define CONFIG_CRYPTO_RMD320_MODULE 1
+#define CONFIG_ISO9660_FS 1
+#define CONFIG_UWB_I1480U_MODULE 1
+#define CONFIG_HID_ZEROPLUS 1
+#define CONFIG_HID_NTRIG 1
+#define CONFIG_TIFM_CORE_MODULE 1
+#define CONFIG_BRIDGE_EBT_AMONG_MODULE 1
+#define CONFIG_PACKET 1
+#define CONFIG_CPU_FREQ_GOV_CONSERVATIVE_MODULE 1
+#define CONFIG_CRYPTO_SHA256 1
+#define CONFIG_HEADERS_CHECK 1
+#define CONFIG_DVB_BT8XX_MODULE 1
+#define CONFIG_XEN_KBDDEV_FRONTEND 1
+#define CONFIG_USB_ARMLINUX 1
+#define CONFIG_BT_RFCOMM_MODULE 1
+#define CONFIG_NET_SCH_TEQL_MODULE 1
+#define CONFIG_BRIDGE_NETFILTER 1
+#define CONFIG_PCI_GOANY 1
+#define CONFIG_KVM_CLOCK 1
+#define CONFIG_BSD_PROCESS_ACCT_V3 1
+#define CONFIG_CONSTRUCTORS 1
+#define CONFIG_CRYPTO_RMD160_MODULE 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_ASYNC_TX_DMA 1
+#define CONFIG_RTC_DRV_STK17TA8_MODULE 1
+#define CONFIG_MEDIA_TUNER_MXL5005S_MODULE 1
+#define CONFIG_I2C_AMD8111_MODULE 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_MTD_LPDDR_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_STRING_MODULE 1
+#define CONFIG_NF_CT_PROTO_GRE_MODULE 1
+#define CONFIG_SCHED_SMT 1
+#define CONFIG_X86_WP_WORKS_OK 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC 1
+#define CONFIG_FB_SAVAGE_I2C 1
+#define CONFIG_FB_EFI 1
+#define CONFIG_VIDEO_ALLOW_V4L1 1
+#define CONFIG_INPUT_WISTRON_BTNS_MODULE 1
+#define CONFIG_DE_AOC 1
+#define CONFIG_AIC7XXX_RESET_DELAY_MS 15000
+#define CONFIG_SCSI_3W_9XXX_MODULE 1
+#define CONFIG_SCSI_OSD_ULD_MODULE 1
+#define CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL_MODULE 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_CRAMFS_MODULE 1
+#define CONFIG_HID_EZKEY 1
+#define CONFIG_SND_HWDEP_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_ETURBO 1
+#define CONFIG_MOUSE_PS2_LOGIPS2PP 1
+#define CONFIG_FUSION_FC_MODULE 1
+#define CONFIG_BRIDGE_EBT_NFLOG_MODULE 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_EDAC_I82860_MODULE 1
+#define CONFIG_SND_HDA_RECONFIG 1
+#define CONFIG_FB_ATY_BACKLIGHT 1
+#define CONFIG_FB_RADEON_I2C 1
+#define CONFIG_VIDEO_EM28XX_DVB_MODULE 1
+#define CONFIG_MEDIA_TUNER_MXL5007T_MODULE 1
+#define CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE 1
+#define CONFIG_MOUSE_PS2 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_NET_SCH_PRIO_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE 1
+#define CONFIG_NET_IPGRE_MODULE 1
+#define CONFIG_CRYPTO_RMD128_MODULE 1
+#define CONFIG_EDAC_R82600_MODULE 1
+#define CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE 1
+#define CONFIG_USB_STORAGE_FREECOM_MODULE 1
+#define CONFIG_DVB_TUNER_CX24113_MODULE 1
+#define CONFIG_DVB_TUNER_DIB0070_MODULE 1
+#define CONFIG_VIDEO_CX88_BLACKBIRD_MODULE 1
+#define CONFIG_IBMASR_MODULE 1
+#define CONFIG_FEALNX_MODULE 1
+#define CONFIG_I2C_MODULE 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_CRYPTO_PCOMP 1
+#define CONFIG_HIDRAW 1
+#define CONFIG_FB_NVIDIA_I2C 1
+#define CONFIG_FB_CIRRUS_MODULE 1
+#define CONFIG_ISDN_CAPI_CAPIFS_MODULE 1
+#define CONFIG_HISAX_HFC4S8S_MODULE 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_CRC_T10DIF_MODULE 1
+#define CONFIG_MTD_PMC551_MODULE 1
+#define CONFIG_NET_CLS_FLOW_MODULE 1
+#define CONFIG_BRIDGE_EBT_T_FILTER_MODULE 1
+#define CONFIG_PCCARD_NONSTATIC_MODULE 1
+#define CONFIG_CRYPTO_RMD256_MODULE 1
+#define CONFIG_SECURITY_FILE_CAPABILITIES 1
+#define CONFIG_HAVE_MMIOTRACE_SUPPORT 1
+#define CONFIG_LZO_COMPRESS_MODULE 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_SND_HDSPM_MODULE 1
+#define CONFIG_PCIPCWATCHDOG_MODULE 1
+#define CONFIG_SENSORS_W83627EHF_MODULE 1
+#define CONFIG_MAX_RAW_DEVS 8192
+#define CONFIG_FIXED_PHY 1
+#define CONFIG_CRYPTO_CRC32C 1
+#define CONFIG_IOMMU_API 1
+#define CONFIG_USB_SERIAL_SIEMENS_MPI_MODULE 1
+#define CONFIG_VIDEOBUF_VMALLOC_MODULE 1
+#define CONFIG_MACHZ_WDT_MODULE 1
+#define CONFIG_I2C_ALI1535_MODULE 1
+#define CONFIG_MISDN_DSP_MODULE 1
+#define CONFIG_RT2X00_LIB_HT 1
+#define CONFIG_IWL3945_MODULE 1
+#define CONFIG_ISCSI_TCP_MODULE 1
+#define CONFIG_SCSI_SRP_TGT_ATTRS 1
+#define CONFIG_XEN_BLKDEV_FRONTEND_MODULE 1
+#define CONFIG_RING_BUFFER_ALLOW_SWAP 1
+#define CONFIG_X86_HT 1
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define CONFIG_USB_SERIAL_EDGEPORT_MODULE 1
+#define CONFIG_SND_CTXFI_MODULE 1
+#define CONFIG_I2C_ALI1563_MODULE 1
+#define CONFIG_INPUT_PCSPKR_MODULE 1
+#define CONFIG_CHELSIO_T1_1G 1
+#define CONFIG_SCSI_CXGB3_ISCSI_MODULE 1
+#define CONFIG_HZ_1000 1
+#define CONFIG_TASKSTATS 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_BSD_DISKLABEL 1
+#define CONFIG_XEN_SYS_HYPERVISOR 1
+#define CONFIG_HID_GREENASIA 1
+#define CONFIG_MOUSE_SYNAPTICS_I2C_MODULE 1
+#define CONFIG_RTL8180_MODULE 1
+#define CONFIG_CHR_DEV_OSST_MODULE 1
+#define CONFIG_IP_VS_PROTO_AH_ESP 1
+#define CONFIG_MICROCODE_OLD_INTERFACE 1
+#define CONFIG_DVB_USB_M920X_MODULE 1
+#define CONFIG_VIDEO_UPD64083_MODULE 1
+#define CONFIG_HERMES_MODULE 1
+#define CONFIG_HOSTAP_CS_MODULE 1
+#define CONFIG_EL3_MODULE 1
+#define CONFIG_BT_MRVL_SDIO_MODULE 1
+#define CONFIG_RFKILL_MODULE 1
+#define CONFIG_PM_SLEEP_SMP 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE 1
+#define CONFIG_DEBUG_HIGHMEM 1
+#define CONFIG_UBIFS_FS_LZO 1
+#define CONFIG_SND_GINA20_MODULE 1
+#define CONFIG_SND_TIMER_MODULE 1
+#define CONFIG_DVB_BUDGET_PATCH_MODULE 1
+#define CONFIG_PCMCIA_NMCLAN_MODULE 1
+#define CONFIG_MD_FAULTY_MODULE 1
+#define CONFIG_BRIDGE_EBT_LIMIT_MODULE 1
+#define CONFIG_RTC_DRV_CMOS 1
+#define CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE 1
+#define CONFIG_VIDEO_CS53L32A_MODULE 1
+#define CONFIG_RT2X00_LIB_MODULE 1
+#define CONFIG_MTD_BLOCK2MTD_MODULE 1
+#define CONFIG_MICROCODE_AMD 1
+#define CONFIG_X86 1
+#define CONFIG_JOLIET 1
+#define CONFIG_CACHEFILES_MODULE 1
+#define CONFIG_USB_SERIAL_QUALCOMM_MODULE 1
+#define CONFIG_FB_VIA_MODULE 1
+#define CONFIG_MFD_WM8350_I2C_MODULE 1
+#define CONFIG_LIBIPW_MODULE 1
+#define CONFIG_8139TOO_MODULE 1
+#define CONFIG_DM_UEVENT 1
+#define CONFIG_MTD_UBI_BEB_RESERVE 1
+#define CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT 1
+#define CONFIG_CRYPTO_SEQIV_MODULE 1
+#define CONFIG_N_HDLC_MODULE 1
+#define CONFIG_TABLET_USB_KBTAB_MODULE 1
+#define CONFIG_DCA_MODULE 1
+#define CONFIG_AIC79XX_CMDS_PER_DEVICE 4
+#define CONFIG_PHYLIB 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_CRYPTO_TGR192_MODULE 1
+#define CONFIG_SND_PCXHR_MODULE 1
+#define CONFIG_SND_GINA24_MODULE 1
+#define CONFIG_TOUCHSCREEN_EETI_MODULE 1
+#define CONFIG_DCB 1
+#define CONFIG_SDIO_UART_MODULE 1
+#define CONFIG_DVB_TUNER_ITD1000_MODULE 1
+#define CONFIG_SOC_CAMERA_TW9910_MODULE 1
+#define CONFIG_DVB_LNBP21_MODULE 1
+#define CONFIG_IEEE802154_DRIVERS_MODULE 1
+#define CONFIG_RTL8187_MODULE 1
+#define CONFIG_NF_CONNTRACK_EVENTS 1
+#define CONFIG_DEFAULT_CUBIC 1
+#define CONFIG_CPU_FREQ_GOV_USERSPACE 1
+#define CONFIG_SPARSEMEM_MANUAL 1
+#define CONFIG_DYNAMIC_DEBUG 1
+#define CONFIG_PANASONIC_LAPTOP_MODULE 1
+#define CONFIG_SND_HDA_CODEC_INTELHDMI 1
+#define CONFIG_SND_MPU401_MODULE 1
+#define CONFIG_FB_ATY_CT 1
+#define CONFIG_WDTPCI_MODULE 1
+#define CONFIG_HWMON_VID_MODULE 1
+#define CONFIG_SERIO_RAW_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH 1
+#define CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON 1
+#define CONFIG_DM_MIRROR_MODULE 1
+#define CONFIG_ISAPNP 1
+#define CONFIG_NET_DSA_TAG_TRAILER 1
+#define CONFIG_NETFILTER_XT_MATCH_OSF_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_ESP_MODULE 1
+#define CONFIG_USB_SERIAL_PL2303_MODULE 1
+#define CONFIG_SND_MTPAV_MODULE 1
+#define CONFIG_SMS_SDIO_DRV_MODULE 1
+#define CONFIG_TOUCHSCREEN_FUJITSU_MODULE 1
+#define CONFIG_ISDN_TTY_FAX 1
+#define CONFIG_CFG80211_MODULE 1
+#define CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE 1
+#define CONFIG_I8K_MODULE 1
+#define CONFIG_EDD_MODULE 1
+#define CONFIG_HID_A4TECH 1
+#define CONFIG_SND_INTEL8X0M_MODULE 1
+#define CONFIG_DVB_CAPTURE_DRIVERS 1
+#define CONFIG_PPP_ASYNC_MODULE 1
+#define CONFIG_MAC80211_MODULE 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_DVB_CX24110_MODULE 1
+#define CONFIG_REGULATOR_MAX1586_MODULE 1
+#define CONFIG_USBPCWATCHDOG_MODULE 1
+#define CONFIG_MFD_WM831X_MODULE 1
+#define CONFIG_MTD_NAND_NANDSIM_MODULE 1
+#define CONFIG_PHONET_MODULE 1
+#define CONFIG_IP_NF_TARGET_REJECT_MODULE 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_ECRYPT_FS_MODULE 1
+#define CONFIG_THINKPAD_ACPI_MODULE 1
+#define CONFIG_USB_SERIAL_DEBUG_MODULE 1
+#define CONFIG_SND_VIRTUOSO_MODULE 1
+#define CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE 1
+#define CONFIG_AB3100_CORE_MODULE 1
+#define CONFIG_XEN_NETDEV_FRONTEND_MODULE 1
+#define CONFIG_WIMAX_I2400M_SDIO_MODULE 1
+#define CONFIG_HOSTAP_MODULE 1
+#define CONFIG_SUNGEM_MODULE 1
+#define CONFIG_QSEMI_PHY_MODULE 1
+#define CONFIG_NET_FC 1
+#define CONFIG_NET_9P_MODULE 1
+#define CONFIG_INET_XFRM_MODE_BEET_MODULE 1
+#define CONFIG_IMA_MEASURE_PCR_IDX 10
+#define CONFIG_NFS_V4 1
+#define CONFIG_JBD_MODULE 1
+#define CONFIG_SND_HDA_CODEC_CMEDIA 1
+#define CONFIG_SND_DUMMY_MODULE 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_PCMCIA_HERMES_MODULE 1
+#define CONFIG_CAN_SJA1000_MODULE 1
+#define CONFIG_CGROUP_NS 1
+#define CONFIG_USB_APPLEDISPLAY_MODULE 1
+#define CONFIG_DVB_CX22700_MODULE 1
+#define CONFIG_USB_NET_CDCETHER_MODULE 1
+#define CONFIG_IFB_MODULE 1
+#define CONFIG_MTD_NAND_ECC_SMC 1
+#define CONFIG_NETFILTER_XT_TARGET_HL_MODULE 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_USB_EZUSB 1
+#define CONFIG_DVB_DIB8000_MODULE 1
+#define CONFIG_DVB_S5H1420_MODULE 1
+#define CONFIG_USB_GSPCA_SPCA500_MODULE 1
+#define CONFIG_DVB_S5H1411_MODULE 1
+#define CONFIG_DVB_CX24123_MODULE 1
+#define CONFIG_IGB_MODULE 1
+#define CONFIG_ASYNC_RAID6_TEST_MODULE 1
+#define CONFIG_CAN_MODULE 1
+#define CONFIG_NET_CLS_RSVP_MODULE 1
+#define CONFIG_INFINIBAND_MODULE 1
+#define CONFIG_GENERIC_IOMAP 1
+#define CONFIG_AUDIT_GENERIC 1
+#define CONFIG_FAT_FS_MODULE 1
+#define CONFIG_FB_ATY_GX 1
+#define CONFIG_FB_SYS_IMAGEBLIT 1
+#define CONFIG_USB_GSPCA_SPCA501_MODULE 1
+#define CONFIG_DVB_CX22702_MODULE 1
+#define CONFIG_I2C_SIS96X_MODULE 1
+#define CONFIG_TEHUTI_MODULE 1
+#define CONFIG_FIREWIRE_SBP2_MODULE 1
+#define CONFIG_MTD_NAND_CAFE_MODULE 1
+#define CONFIG_LIB80211_MODULE 1
+#define CONFIG_NF_CONNTRACK_IRC_MODULE 1
+#define CONFIG_TRACER_MAX_TRACE 1
+#define CONFIG_DVB_MAX_ADAPTERS 8
+#define CONFIG_DVB_CX24116_MODULE 1
+#define CONFIG_SENSORS_W83L786NG_MODULE 1
+#define CONFIG_INPUT_UINPUT_MODULE 1
+#define CONFIG_NET_TULIP 1
+#define CONFIG_FUSION 1
+#define CONFIG_CRYPTO_BLKCIPHER_MODULE 1
+#define CONFIG_IP_MROUTE 1
+#define CONFIG_HOTPLUG_PCI_FAKE_MODULE 1
+#define CONFIG_EFI 1
+#define CONFIG_SPARSEMEM_STATIC 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_DMADEVICES 1
+#define CONFIG_USB_SERIAL_MOTOROLA_MODULE 1
+#define CONFIG_FB_ATY_MODULE 1
+#define CONFIG_TOUCHSCREEN_USB_ITM 1
+#define CONFIG_HISAX_16_3 1
+#define CONFIG_SCSI_STEX_MODULE 1
+#define CONFIG_BT_HCIBT3C_MODULE 1
+#define CONFIG_HID 1
+#define CONFIG_NET_DSA_TAG_EDSA 1
+#define CONFIG_IP_NF_RAW_MODULE 1
+#define CONFIG_IP6_NF_MANGLE_MODULE 1
+#define CONFIG_NF_CONNTRACK_H323_MODULE 1
+#define CONFIG_NLATTR 1
+#define CONFIG_X86_MCE_INTEL 1
+#define CONFIG_KVM_GUEST 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_USB_BERRY_CHARGE_MODULE 1
+#define CONFIG_USB_SERIAL_EMPEG_MODULE 1
+#define CONFIG_DVB_OR51211_MODULE 1
+#define CONFIG_DVB_BCM3510_MODULE 1
+#define CONFIG_E100_MODULE 1
+#define CONFIG_ASYNC_XOR_MODULE 1
+#define CONFIG_SATA_SIL24_MODULE 1
+#define CONFIG_ATA 1
+#define CONFIG_IP_DCCP_TFRC_LIB 1
+#define CONFIG_IP_NF_TARGET_NETMAP_MODULE 1
+#define CONFIG_NF_NAT_MODULE 1
+#define CONFIG_IMA 1
+#define CONFIG_UDF_FS_MODULE 1
+#define CONFIG_DVB_USB_CE6230_MODULE 1
+#define CONFIG_USB_GSPCA_SPCA505_MODULE 1
+#define CONFIG_SCTP_HMAC_MD5 1
+#define CONFIG_NF_NAT_AMANDA_MODULE 1
+#define CONFIG_ACPI_HOTPLUG_MEMORY 1
+#define CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_NLS_ISO8859_13_MODULE 1
+#define CONFIG_AGP 1
+#define CONFIG_USB_GSPCA_SPCA506_MODULE 1
+#define CONFIG_DVB_OR51132_MODULE 1
+#define CONFIG_SSB_SPROM 1
+#define CONFIG_NET_DCCPPROBE_MODULE 1
+#define CONFIG_PRINTK 1
+#define CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING 1
+#define CONFIG_NLS_ISO8859_14_MODULE 1
+#define CONFIG_RPCSEC_GSS_SPKM3_MODULE 1
+#define CONFIG_USB_LD_MODULE 1
+#define CONFIG_USB_SERIAL_FTDI_SIO_MODULE 1
+#define CONFIG_DVB_USB_AF9005_MODULE 1
+#define CONFIG_USB_GSPCA_SPCA561_MODULE 1
+#define CONFIG_DVB_S5H1409_MODULE 1
+#define CONFIG_NET_EMATCH_NBYTE_MODULE 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_AIO 1
+#define CONFIG_X86_32_SMP 1
+#define CONFIG_NLS_ISO8859_15_MODULE 1
+#define CONFIG_INTEL_IOATDMA_MODULE 1
+#define CONFIG_RTC_DRV_AB3100_MODULE 1
+#define CONFIG_DVB_USB_AF9015_MODULE 1
+#define CONFIG_USB_GSPCA_SPCA508_MODULE 1
+#define CONFIG_VIDEO_CX18_MODULE 1
+#define CONFIG_MOUSE_PS2_SYNAPTICS 1
+#define CONFIG_BT_SCO_MODULE 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_IP_VS_PROTO_TCP 1
+#define CONFIG_HOTPLUG_PCI_ACPI 1
+#define CONFIG_DMI 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define CONFIG_INTEL_TXT 1
+#define CONFIG_SUNRPC_MODULE 1
+#define CONFIG_FSCACHE_STATS 1
+#define CONFIG_FS_MBCACHE_MODULE 1
+#define CONFIG_SND_USB_CAIAQ_INPUT 1
+#define CONFIG_DVB_ZL10036_MODULE 1
+#define CONFIG_SERIAL_8250_NR_UARTS 64
+#define CONFIG_TABLET_USB_WACOM_MODULE 1
+#define CONFIG_HP_ILO_MODULE 1
+#define CONFIG_LLC_MODULE 1
+#define CONFIG_IP6_NF_TARGET_HL_MODULE 1
+#define CONFIG_IP_VS_PROTO_ESP 1
+#define CONFIG_XFRM_USER 1
+#define CONFIG_CPU_FREQ_GOV_POWERSAVE_MODULE 1
+#define CONFIG_BLK_DEV_IO_TRACE 1
+#define CONFIG_DETECT_HUNG_TASK 1
+#define CONFIG_NOZOMI_MODULE 1
+#define CONFIG_ISDN_DRV_GIGASET_MODULE 1
+#define CONFIG_SFC_MODULE 1
+#define CONFIG_JME_MODULE 1
+#define CONFIG_CRC_ITU_T_MODULE 1
+#define CONFIG_DM_LOG_USERSPACE_MODULE 1
+#define CONFIG_EEPROM_LEGACY_MODULE 1
+#define CONFIG_BRIDGE_EBT_T_NAT_MODULE 1
+#define CONFIG_IP_VS_SED_MODULE 1
+#define CONFIG_IP_VS_PROTO_UDP 1
+#define CONFIG_HAVE_MEMORY_PRESENT 1
+#define CONFIG_PCI 1
+#define CONFIG_IPC_NS 1
+#define CONFIG_DLM_MODULE 1
+#define CONFIG_USB_USS720_MODULE 1
+#define CONFIG_SND_ECHO3G_MODULE 1
+#define CONFIG_DVB_SP887X_MODULE 1
+#define CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE 1
+#define CONFIG_DVB_ZL10353_MODULE 1
+#define CONFIG_VIDEO_V4L1_MODULE 1
+#define CONFIG_MOUSE_APPLETOUCH_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCI_MODULE 1
+#define CONFIG_AMD8111_ETH_MODULE 1
+#define CONFIG_MMC_MODULE 1
+#define CONFIG_ISA 1
+#define CONFIG_VIRTIO_MODULE 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_PID_NS 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_ZISOFS 1
+#define CONFIG_HYPERV_MODULE 1
+#define CONFIG_USB_UEAGLEATM_MODULE 1
+#define CONFIG_DVB_ZL10039_MODULE 1
+#define CONFIG_VIDEO_V4L2_MODULE 1
+#define CONFIG_HISAX_BKM_A4T 1
+#define CONFIG_WIMAX_I2400M_DEBUG_LEVEL 8
+#define CONFIG_PCMCIA_XIRCOM_MODULE 1
+#define CONFIG_BT_HCIDTL1_MODULE 1
+#define CONFIG_HOTPLUG_PCI_PCIE 1
+#define CONFIG_APM 1
+#define CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG 1
+#define CONFIG_BUG 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE 1
+#define CONFIG_NFS_FS_MODULE 1
+#define CONFIG_SND_HDA_CODEC_ANALOG 1
+#define CONFIG_IPMI_WATCHDOG_MODULE 1
+#define CONFIG_PCNET32_MODULE 1
+#define CONFIG_ULI526X_MODULE 1
+#define CONFIG_MII_MODULE 1
+#define CONFIG_FIREWIRE_OHCI_MODULE 1
+#define CONFIG_BRIDGE_EBT_IP_MODULE 1
+#define CONFIG_NF_CONNTRACK_FTP_MODULE 1
+#define CONFIG_CGROUP_DEVICE 1
+#define CONFIG_SND_ICE1712_MODULE 1
+#define CONFIG_SND_OPL3_LIB_SEQ_MODULE 1
+#define CONFIG_DVB_AV7110_OSD 1
+#define CONFIG_NET_POLL_CONTROLLER 1
+#define CONFIG_BT_HCIUART_H4 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_SND_OPL4_LIB_SEQ_MODULE 1
+#define CONFIG_BACKLIGHT_MBP_NVIDIA_MODULE 1
+#define CONFIG_DVB_BUDGET_CI_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_SYSFS 1
+#define CONFIG_VIDEO_CX88_MODULE 1
+#define CONFIG_SENSORS_APPLESMC_MODULE 1
+#define CONFIG_SENSORS_SHT15_MODULE 1
+#define CONFIG_SENSORS_AD7414_MODULE 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_FIX_EARLYCON_MEM 1
+#define CONFIG_IEEE802154_FAKEHARD_MODULE 1
+#define CONFIG_P54_COMMON_MODULE 1
+#define CONFIG_IP_NF_ARP_MANGLE_MODULE 1
+#define CONFIG_NF_CONNTRACK_SIP_MODULE 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB 1
+#define CONFIG_CRYPTO_DEV_GEODE_MODULE 1
+#define CONFIG_MMC_SDHCI_PCI_MODULE 1
+#define CONFIG_I2C_SIMTEC_MODULE 1
+#define CONFIG_SONYPI_MODULE 1
+#define CONFIG_MD_AUTODETECT 1
+#define CONFIG_MTD_CFI_INTELEXT_MODULE 1
+#define CONFIG_NET_DSA_MV88E6XXX_NEED_PPU 1
+#define CONFIG_ATM_MODULE 1
+#define CONFIG_SFI 1
+#define CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_CFAG12864B_RATE 20
+#define CONFIG_SND_ICE1724_MODULE 1
+#define CONFIG_DRM_MODULE 1
+#define CONFIG_SERIAL_8250_CS_MODULE 1
+#define CONFIG_USB_NET_SMSC95XX_MODULE 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_HP_WMI_MODULE 1
+#define CONFIG_SND_INDIGODJX_MODULE 1
+#define CONFIG_SND_ATIIXP_MODEM_MODULE 1
+#define CONFIG_DVB_USB_DW2102_MODULE 1
+#define CONFIG_GPIO_LANGWELL 1
+#define CONFIG_I2C_SIS5595_MODULE 1
+#define CONFIG_I2C_ALI15X3_MODULE 1
+#define CONFIG_LIBERTAS_SDIO_MODULE 1
+#define CONFIG_CDROM_PKTCDVD_MODULE 1
+#define CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK 1
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_STACKTRACE 1
+#define CONFIG_DVB_TDA8261_MODULE 1
+#define CONFIG_SND_MODULE 1
+#define CONFIG_SENSORS_W83L785TS_MODULE 1
+#define CONFIG_SENSORS_AD7418_MODULE 1
+#define CONFIG_B43LEGACY_LEDS 1
+#define CONFIG_B44_PCI 1
+#define CONFIG_CICADA_PHY_MODULE 1
+#define CONFIG_MTD 1
+#define CONFIG_ACPI_POWER_METER_MODULE 1
+#define CONFIG_HPET_EMULATE_RTC 1
+#define CONFIG_USB_SERIAL_CP210X_MODULE 1
+#define CONFIG_DVB_USB_NOVA_T_USB2_MODULE 1
+#define CONFIG_WAN 1
+#define CONFIG_NETDEV_1000 1
+#define CONFIG_ISL29003_MODULE 1
+#define CONFIG_FTL_MODULE 1
+#define CONFIG_IP_VS_WLC_MODULE 1
+#define CONFIG_ACPI_HOTPLUG_CPU 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_RWSEM_XCHGADD_ALGORITHM 1
+#define CONFIG_LEDS_ALIX2_MODULE 1
+#define CONFIG_DMA_ENGINE 1
+#define CONFIG_DVB_TTUSB_BUDGET_MODULE 1
+#define CONFIG_DVB_USB_AU6610_MODULE 1
+#define CONFIG_DVB_TDA8083_MODULE 1
+#define CONFIG_ISDN_CAPI_MIDDLEWARE 1
+#define CONFIG_AIC7XXX_CMDS_PER_DEVICE 4
+#define CONFIG_EEPROM_MAX6875_MODULE 1
+#define CONFIG_IP6_NF_FILTER_MODULE 1
+#define CONFIG_IP_NF_TARGET_ECN_MODULE 1
+#define CONFIG_X86_BIGSMP 1
+#define CONFIG_HT_IRQ 1
+#define CONFIG_SLOW_WORK 1
+#define CONFIG_NET_NS 1
+#define CONFIG_NET 1
+#define CONFIG_JFFS2_SUMMARY 1
+#define CONFIG_SND_HDA_HWDEP 1
+#define CONFIG_HISAX_HFC_PCI 1
+#define CONFIG_SSB_MODULE 1
+#define CONFIG_VORTEX_MODULE 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_FS_XIP 1
+#define CONFIG_HID_BELKIN 1
+#define CONFIG_SND_ALI5451_MODULE 1
+#define CONFIG_USB_GSPCA_SONIXB_MODULE 1
+#define CONFIG_SOC_CAMERA_OV772X_MODULE 1
+#define CONFIG_HISAX_1TR6 1
+#define CONFIG_RT61PCI_MODULE 1
+#define CONFIG_NET_CLS_BASIC_MODULE 1
+#define CONFIG_RDS_MODULE 1
+#define CONFIG_TEXTSEARCH_BM_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_EVENT_TRACING 1
+#define CONFIG_KALLSYMS_EXTRA_PASS 1
+#define CONFIG_MAC_PARTITION 1
+#define CONFIG_HID_THRUSTMASTER 1
+#define CONFIG_HID_MICROSOFT 1
+#define CONFIG_DVB_SI21XX_MODULE 1
+#define CONFIG_USB_STKWEBCAM_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_MODULE 1
+#define CONFIG_DVB_STB6000_MODULE 1
+#define CONFIG_DE2104X_DSL 0
+#define CONFIG_NETDEVICES 1
+#define CONFIG_USB 1
+#define CONFIG_IP_VS_FTP_MODULE 1
+#define CONFIG_INET_TCP_DIAG_MODULE 1
+#define CONFIG_YENTA_TOSHIBA 1
+#define CONFIG_JFFS2_ZLIB 1
+#define CONFIG_PRINT_QUOTA_WARNING 1
+#define CONFIG_COMPAL_LAPTOP_MODULE 1
+#define CONFIG_MEMSTICK_TIFM_MS_MODULE 1
+#define CONFIG_DVB_STB6100_MODULE 1
+#define CONFIG_SENSORS_CORETEMP_MODULE 1
+#define CONFIG_HDLC_CISCO_MODULE 1
+#define CONFIG_MLX4_DEBUG 1
+#define CONFIG_CHELSIO_T1_MODULE 1
+#define CONFIG_KSM 1
+#define CONFIG_XEN 1
+#define CONFIG_CGROUP_MEM_RES_CTLR 1
+#define CONFIG_X86_PLATFORM_DEVICES 1
+#define CONFIG_SND_USB_CAIAQ_MODULE 1
+#define CONFIG_SND_HDA_INTEL_MODULE 1
+#define CONFIG_SND_DMA_SGBUF 1
+#define CONFIG_DVB_TUA6100_MODULE 1
+#define CONFIG_DVB_BUDGET_AV_MODULE 1
+#define CONFIG_SOFT_WATCHDOG_MODULE 1
+#define CONFIG_PPP_SYNC_TTY_MODULE 1
+#define CONFIG_NIU_MODULE 1
+#define CONFIG_MTD_ALAUDA_MODULE 1
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0x0
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_FSCACHE_MODULE 1
+#define CONFIG_RTC_DRV_FM3130_MODULE 1
+#define CONFIG_MMC_RICOH_MMC_MODULE 1
+#define CONFIG_NLS 1
+#define CONFIG_USB_GSPCA_SN9C20X_MODULE 1
+#define CONFIG_SOC_CAMERA_MODULE 1
+#define CONFIG_SENSORS_DS1621_MODULE 1
+#define CONFIG_UIO_MODULE 1
+#define CONFIG_PATA_CS5535_MODULE 1
+#define CONFIG_CHELSIO_T3_MODULE 1
+#define CONFIG_CLOCKSOURCE_WATCHDOG 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_QUOTA_NETLINK_INTERFACE 1
+#define CONFIG_UWB_MODULE 1
+#define CONFIG_SND_INDIGOIOX_MODULE 1
+#define CONFIG_I2C_VIAPRO_MODULE 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_PATA_CS5536_MODULE 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_PNP 1
+#define CONFIG_MMC_VIA_SDMMC_MODULE 1
+#define CONFIG_USB_FTDI_ELAN_MODULE 1
+#define CONFIG_SND_SEQUENCER_MODULE 1
+#define CONFIG_SENSORS_LIS3LV02D_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_T1PCI_MODULE 1
+#define CONFIG_MTD_CFI_I1 1
+#define CONFIG_TCP_MD5SIG 1
+#define CONFIG_MMU 1
+#define CONFIG_EDAC_E7XXX_MODULE 1
+#define CONFIG_MEMSTICK_JMICRON_38X_MODULE 1
+#define CONFIG_DVB_ISL6421_MODULE 1
+#define CONFIG_HW_RANDOM_AMD_MODULE 1
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define CONFIG_USB_NET_DM9601_MODULE 1
+#define CONFIG_B43_PIO 1
+#define CONFIG_PATA_IT8213_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_MAX_TAGS 64
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_MTD_CFI_I2 1
+#define CONFIG_PPP_MODULE 1
+#define CONFIG_PCI_LEGACY 1
+#define CONFIG_SMP 1
+#define CONFIG_XEN_COMPAT_XENFS 1
+#define CONFIG_HID_SMARTJOYPLUS 1
+#define CONFIG_SND_PCMCIA 1
+#define CONFIG_USB_GSPCA_SONIXJ_MODULE 1
+#define CONFIG_SENSORS_W83793_MODULE 1
+#define CONFIG_HISAX_SCT_QUADRO 1
+#define CONFIG_B43LEGACY_PCI_AUTOSELECT 1
+#define CONFIG_IPV6_PIMSM_V2 1
+#define CONFIG_IPV6_ROUTER_PREF 1
+#define CONFIG_CPU_SUP_CYRIX_32 1
+#define CONFIG_M686 1
+#define CONFIG_DEBUG_INFO 1
+#define CONFIG_EXT2_FS_SECURITY 1
+#define CONFIG_RTC_DRV_DS1511_MODULE 1
+#define CONFIG_AGP_NVIDIA 1
+#define CONFIG_VIDEO_CX231XX_DVB_MODULE 1
+#define CONFIG_DVB_ISL6405_MODULE 1
+#define CONFIG_VIDEO_TVAUDIO_MODULE 1
+#define CONFIG_SSB_PCMCIAHOST_POSSIBLE 1
+#define CONFIG_PATA_SERVERWORKS_MODULE 1
+#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_EVENT_PROFILE 1
+#define CONFIG_CRYPTO_KHAZAD_MODULE 1
+#define CONFIG_EXT3_FS_SECURITY 1
+#define CONFIG_SND_HDA_CODEC_NVHDMI 1
+#define CONFIG_SENSORS_ASB100_MODULE 1
+#define CONFIG_PPS_MODULE 1
+#define CONFIG_NET_PCMCIA 1
+#define CONFIG_BT_HCIVHCI_MODULE 1
+#define CONFIG_NET_ACT_PEDIT_MODULE 1
+#define CONFIG_IP_NF_TARGET_LOG_MODULE 1
+#define CONFIG_NF_CT_PROTO_UDPLITE_MODULE 1
+#define CONFIG_TCP_CONG_YEAH_MODULE 1
+#define CONFIG_ACPI_VIDEO_MODULE 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_EXT4_FS_SECURITY 1
+#define CONFIG_RTC_DRV_BQ4802_MODULE 1
+#define CONFIG_SND_CS46XX_MODULE 1
+#define CONFIG_DVB_VES1820_MODULE 1
+#define CONFIG_B43_PHY_LP 1
+#define CONFIG_P54_PCI_MODULE 1
+#define CONFIG_LIBFCOE_MODULE 1
+#define CONFIG_RTC_DRV_DS1307_MODULE 1
+#define CONFIG_USB_WUSB_CBAF_MODULE 1
+#define CONFIG_SND_ENS1370_MODULE 1
+#define CONFIG_SND_AC97_CODEC_MODULE 1
+#define CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE 1
+#define CONFIG_THERMAL_HWMON 1
+#define CONFIG_TABLET_USB_ACECAD_MODULE 1
+#define CONFIG_STE10XP_MODULE 1
+#define CONFIG_MTD_GEN_PROBE_MODULE 1
+#define CONFIG_X86_INVLPG 1
+#define CONFIG_ACPI_SLEEP 1
+#define CONFIG_STRICT_DEVMEM 1
+#define CONFIG_SCHEDSTATS 1
+#define CONFIG_USB_SERIAL_CYBERJACK_MODULE 1
+#define CONFIG_SND_HDA_PATCH_LOADER 1
+#define CONFIG_SND_ENS1371_MODULE 1
+#define CONFIG_DVB_BUDGET_MODULE 1
+#define CONFIG_CS5535_GPIO_MODULE 1
+#define CONFIG_IPMI_POWEROFF_MODULE 1
+#define CONFIG_HISAX_ELSA_CS_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE 1
+#define CONFIG_NF_CT_PROTO_DCCP_MODULE 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_PCI_DIRECT 1
+#define CONFIG_BINARY_PRINTF 1
+#define CONFIG_JFFS2_FS_WRITEBUFFER 1
+#define CONFIG_LEDS_LP3944_MODULE 1
+#define CONFIG_MISDN_IPAC_MODULE 1
+#define CONFIG_NORTEL_HERMES_MODULE 1
+#define CONFIG_TUN_MODULE 1
+#define CONFIG_MTD_AR7_PARTS_MODULE 1
+#define CONFIG_STP_MODULE 1
+#define CONFIG_RTC_DRV_DS1742_MODULE 1
+#define CONFIG_RTC_DRV_DS1553_MODULE 1
+#define CONFIG_BACKLIGHT_PROGEAR_MODULE 1
+#define CONFIG_DVB_TTUSB_DEC_MODULE 1
+#define CONFIG_ITCO_VENDOR_SUPPORT 1
+#define CONFIG_INPUT_ATI_REMOTE_MODULE 1
+#define CONFIG_SERIO_I8042 1
+#define CONFIG_SCSI_DEBUG_MODULE 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_RTC_DRV_DS1374_MODULE 1
+#define CONFIG_SND_CMIPCI_MODULE 1
+#define CONFIG_SND_PCM_OSS_PLUGINS 1
+#define CONFIG_DRM_SAVAGE_MODULE 1
+#define CONFIG_IGB_DCA 1
+#define CONFIG_SCSI_ISCSI_ATTRS_MODULE 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE_MODULE 1
+#define CONFIG_PCIEAER 1
+#define CONFIG_ACPI_PCI_SLOT 1
+#define CONFIG_HAVE_MLOCK 1
+#define CONFIG_RTC_DRV_DS1672_MODULE 1
+#define CONFIG_DVB_USB_VP7045_MODULE 1
+#define CONFIG_USB_GSPCA_MR97310A_MODULE 1
+#define CONFIG_VIDEO_SAA7134_ALSA_MODULE 1
+#define CONFIG_MFD_SM501_GPIO 1
+#define CONFIG_SENSORS_ATXP1_MODULE 1
+#define CONFIG_INPUT_ATLAS_BTNS_MODULE 1
+#define CONFIG_NETCONSOLE_MODULE 1
+#define CONFIG_WL1251_SDIO_MODULE 1
+#define CONFIG_RT73USB_MODULE 1
+#define CONFIG_8139TOO_8129 1
+#define CONFIG_CAN_DEBUG_DEVICES 1
+#define CONFIG_X86_MCE 1
+#define CONFIG_RTC_DRV_DS1286_MODULE 1
+#define CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE 1
+#define CONFIG_LEDS_WM8350_MODULE 1
+#define CONFIG_USB_SERIAL_VISOR_MODULE 1
+#define CONFIG_DRM_RADEON_MODULE 1
+#define CONFIG_DVB_NXT6000_MODULE 1
+#define CONFIG_USB_PWC_INPUT_EVDEV 1
+#define CONFIG_SENSORS_VT1211_MODULE 1
+#define CONFIG_HW_RANDOM_VIRTIO_MODULE 1
+#define CONFIG_USB_NET_GL620A_MODULE 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_IP_VS_WRR_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE 1
+#define CONFIG_TEXTSEARCH 1
+#define CONFIG_NF_CONNTRACK_SECMARK 1
+#define CONFIG_TCP_CONG_HTCP_MODULE 1
+#define CONFIG_X86_PAE 1
+#define CONFIG_LOG_BUF_SHIFT 19
+#define CONFIG_SGI_PARTITION 1
+#define CONFIG_MEDIA_SUPPORT_MODULE 1
+#define CONFIG_W83877F_WDT_MODULE 1
+#define CONFIG_SENSORS_HDAPS_MODULE 1
+#define CONFIG_INPUT_YEALINK_MODULE 1
+#define CONFIG_MTD_CONCAT_MODULE 1
+#define CONFIG_BT_HCIUART_LL 1
+#define CONFIG_NET_SCH_NETEM_MODULE 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_XEN_SAVE_RESTORE 1
+#define CONFIG_UTS_NS 1
+#define CONFIG_ARCH_POPULATES_NODE_MAP 1
+#define CONFIG_USB_HIDDEV 1
+#define CONFIG_DVB_USB_FRIIO_MODULE 1
+#define CONFIG_W83977F_WDT_MODULE 1
+#define CONFIG_I2C_VIA_MODULE 1
+#define CONFIG_GENERIC_ALLOCATOR 1
+#define CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE 1
+#define CONFIG_LEDS_CLASS 1
+#define CONFIG_NFS_V3_ACL 1
+#define CONFIG_AUTOFS4_FS_MODULE 1
+#define CONFIG_SND_RME9652_MODULE 1
+#define CONFIG_SND_INDIGO_MODULE 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_DVB_STB0899_MODULE 1
+#define CONFIG_VIDEO_UPD64031A_MODULE 1
+#define CONFIG_HW_RANDOM_VIA_MODULE 1
+#define CONFIG_USB_BELKIN 1
+#define CONFIG_NF_CT_NETLINK_MODULE 1
+#define CONFIG_CRYPTO_DEV_HIFN_795X_MODULE 1
+#define CONFIG_ISCSI_IBFT_MODULE 1
+#define CONFIG_SND_USB_AUDIO_MODULE 1
+#define CONFIG_I2C_I801_MODULE 1
+#define CONFIG_ISDN_AUDIO 1
+#define CONFIG_PCI_HERMES_MODULE 1
+#define CONFIG_HIGHMEM 1
+#define CONFIG_PERF_COUNTERS 1
+#define CONFIG_SECURITY_SELINUX 1
diff -uNr linux-2.6.32/include/linux/utsrelease.h clean_modified/linux-2.6.32/include/linux/utsrelease.h
--- linux-2.6.32/include/linux/utsrelease.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/linux/utsrelease.h	2019-04-14 13:23:50.750039703 -0500
@@ -0,0 +1 @@
+#define UTS_RELEASE "2.6.32"
diff -uNr linux-2.6.32/include/linux/version.h clean_modified/linux-2.6.32/include/linux/version.h
--- linux-2.6.32/include/linux/version.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/include/linux/version.h	2019-04-14 13:23:50.750039703 -0500
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132640
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -uNr linux-2.6.32/Makefile clean_modified/linux-2.6.32/Makefile
--- linux-2.6.32/Makefile	2009-12-02 21:51:21.000000000 -0600
+++ clean_modified/linux-2.6.32/Makefile	2019-04-14 13:23:51.223784926 -0500
@@ -644,7 +644,7 @@
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/ my_source/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
diff -uNr linux-2.6.32/Module.symvers clean_modified/linux-2.6.32/Module.symvers
--- linux-2.6.32/Module.symvers	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/Module.symvers	2019-04-14 13:23:51.358195059 -0500
@@ -0,0 +1,9105 @@
+0xb112264b	cfg80211_send_rx_assoc	net/wireless/cfg80211	EXPORT_SYMBOL
+0x673bc30e	iscsi_host_add	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xc47c22e8	mpt_deregister	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x147a8098	pcmcia_reset_card	vmlinux	EXPORT_SYMBOL
+0x88e8aaf8	sata_pmp_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x9ba0501e	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x76f69026	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x3425435d	set_anon_super	vmlinux	EXPORT_SYMBOL
+0xd8b08694	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x70523a7a	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x79491134	ieee80211_wake_queues	net/mac80211/mac80211	EXPORT_SYMBOL
+0xcba36c62	ir_codes_videomate_tv_pvr_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xac15f6c8	ir_codes_kaiomy_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x2d383e4b	i2c_put_adapter	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x14102f23	ks0108_displaystate	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0xb6a6b4f5	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
+0x96cd2b04	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x46ac1cf2	request_firmware	vmlinux	EXPORT_SYMBOL
+0x0a2487e0	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0xa4d5919a	t3_register_cpl_handler	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xb6e63aa9	cx8802_buf_queue	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0xe94e36e9	ib_init_ah_from_path	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x9344109b	ib_destroy_cm_id	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xc14fa945	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x2b278b7f	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x0deb0ade	register_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x246f4153	pv_time_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x07d50a24	csum_partial	vmlinux	EXPORT_SYMBOL
+0xab525b13	cfg80211_wext_siwscan	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xa257a663	cfg80211_wext_giwscan	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xac897ede	ieee80211_queue_stopped	net/mac80211/mac80211	EXPORT_SYMBOL
+0xb663a8a0	wpan_phy_find	net/ieee802154/wpan-class	EXPORT_SYMBOL
+0xf06c1cc7	unregister_timer_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x69575269	kmap_atomic	vmlinux	EXPORT_SYMBOL
+0x47090e99	snd_wss_free	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xe70f3698	iscsi_tcp_r2tpool_free	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xd53514a5	videobuf_queue_cancel	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xd3ec494c	avmcard_dma_free	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x083105e6	nf_log_register	vmlinux	EXPORT_SYMBOL
+0x26db974d	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0xc2983c26	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x9657427b	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x746d1786	osd_PageAlloc	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0xa93a9fde	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0xb96a4101	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x6457d9ec	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0xd9091363	acpi_install_notify_handler	vmlinux	EXPORT_SYMBOL
+0x6b104b57	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x3c942368	profile_event_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xa5bf5c3e	pm_qos_add_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x773ca527	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x58314a94	snd_pt2258_reset	sound/i2c/other/snd-pt2258	EXPORT_SYMBOL
+0xd22ac2d5	fw_send_request	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x410395e1	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x3358cf2c	dst_release	vmlinux	EXPORT_SYMBOL
+0x5d0906cd	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0xed7a3dba	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
+0x33ed742e	acpi_bus_start	vmlinux	EXPORT_SYMBOL
+0xfdb9b629	ioread32be	vmlinux	EXPORT_SYMBOL
+0x7bddceef	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x98c89ade	security_xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x669e411e	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0xf110bb6b	usb_serial_generic_write_bulk_callback	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x9d6b2c75	wm8400_block_read	drivers/mfd/wm8400-core	EXPORT_SYMBOL_GPL
+0xde85799c	wm8350_block_read	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x915d4987	wm8350_reg_unlock	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xdc04aec8	em28xx_isoc_dvb_max_packetsize	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x5d632b92	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x54e6fcdd	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x53f91d68	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0xe73b5510	ata_sff_tf_read	vmlinux	EXPORT_SYMBOL_GPL
+0x208739f6	acpi_load_table	vmlinux	EXPORT_SYMBOL
+0x26db5cf5	fb_validate_mode	vmlinux	EXPORT_SYMBOL
+0x6bc3fbc0	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x5efbb1bd	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x49da9a9a	_read_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x60db55fb	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0xb5dea7ef	g_token_size	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x7a328c07	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x9c9b7281	tpm_gen_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0xeb4c1fc8	__tracepoint_block_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x616d8c48	bio_integrity_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x7ff10ccf	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x9b243dbe	sas_eh_device_reset_handler	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xa0b2d959	rt2x00pci_uninitialize	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0x31851a49	hostap_handle_sta_tx_exc	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x8e8f6427	mlx4_unregister_mac	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xb397a55c	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x39006c47	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x5af03a28	gnttab_claim_grant_reference	vmlinux	EXPORT_SYMBOL_GPL
+0x6d288375	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x1b02a8e4	snd_emux_terminate_all	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0x7ce3fecf	dccp_ctl_make_reset	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x486b8eba	jbd2_journal_try_to_free_buffers	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x65ff49e5	iscsi_conn_setup	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x04ea3c6e	fcoe_ctlr_destroy	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0x123576c2	mpt_free_fw_memory	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xb0890fd1	dm_get_device	drivers/md/dm-mod	EXPORT_SYMBOL
+0xfe6d2561	dm_put_device	drivers/md/dm-mod	EXPORT_SYMBOL
+0xdbf54413	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xc52f5714	fb_videomode_to_var	vmlinux	EXPORT_SYMBOL
+0x2da418b5	copy_to_user	vmlinux	EXPORT_SYMBOL
+0xffd5a395	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x4492501f	nf_nat_sdp_port_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0x096d3a16	usb_serial_generic_resubmit_read_urb	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x3a1169d2	fc_remote_port_add	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x539b38ef	videobuf_dma_init_overlay	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x3114971e	dm_rh_start_recovery	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x2348cc3c	mISDN_FsmFree	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x5999c3a4	drm_mm_clean	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x733e1def	dev_attr_link_power_management_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x3c59e1ec	agp_free_page_array	vmlinux	EXPORT_SYMBOL
+0xb718f2f9	sfi_table_parse	vmlinux	EXPORT_SYMBOL_GPL
+0x15a29c99	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL
+0x95983c49	iget_locked	vmlinux	EXPORT_SYMBOL
+0xe809e559	snd_akm4xxx_init	sound/i2c/other/snd-ak4xxx-adda	EXPORT_SYMBOL
+0x51517932	hostap_info_process	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x6d2e6d0a	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0xc3a5b419	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0xa4b94fea	iowrite8_rep	vmlinux	EXPORT_SYMBOL
+0x5ab59dad	key_type_keyring	vmlinux	EXPORT_SYMBOL
+0xacfa62d2	sas_release_transport	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x16c10217	pcmcia_modify_configuration	vmlinux	EXPORT_SYMBOL
+0xbaf73179	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xa9c530b8	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xf80a63cb	snd_power_wait	sound/core/snd	EXPORT_SYMBOL
+0x2eec63c9	xdr_encode_netobj	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x4ebffed9	xdr_decode_word	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x2539bbbc	wl1251_free_hw	drivers/net/wireless/wl12xx/wl1251	EXPORT_SYMBOL_GPL
+0x251a3861	alloc_sja1000dev	drivers/net/can/sja1000/sja1000	EXPORT_SYMBOL_GPL
+0xedf60db3	mptscsih_scandv_complete	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xf784170a	tcp_v4_md5_lookup	vmlinux	EXPORT_SYMBOL
+0xe5202665	tpm_write	vmlinux	EXPORT_SYMBOL_GPL
+0xae776ab8	tty_register_device	vmlinux	EXPORT_SYMBOL
+0xc2e587d1	reset_devices	vmlinux	EXPORT_SYMBOL
+0xaa4113b6	uwb_rc_rm	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x7897abbe	soc_camera_apply_sensor_flags	drivers/media/video/soc_camera	EXPORT_SYMBOL
+0xc01e48be	cx88_get_stereo	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x4267d749	ir_codes_budget_ci_old_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x1d0ff136	usb_bus_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x8b35e873	sg_last	vmlinux	EXPORT_SYMBOL
+0x8235805b	memmove	vmlinux	EXPORT_SYMBOL
+0x33cf0e6d	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x49e182c0	param_get_string	vmlinux	EXPORT_SYMBOL
+0x3953fc4c	ieee802154_nl_scan_confirm	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x8953efd4	jbd2_journal_start_commit	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x6dabaa5e	osd_execute_request_async	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xd3d44d39	stv0288_attach	drivers/media/dvb/frontends/stv0288	EXPORT_SYMBOL
+0x00a7efc5	dibusb_i2c_algo	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xbf0985fa	dmam_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x618eeb4b	tpm_pm_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x5f8972ac	dquot_alloc_space	vmlinux	EXPORT_SYMBOL
+0x76d3cd60	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x19490ee4	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x04080eab	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x50f5e532	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x16fb313e	usbnet_cdc_unbind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL
+0xa26cd29d	drm_agp_enable	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x98b6fc7e	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x871c0a7e	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x01714cbe	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x5d730e7b	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x7f55a924	hostap_set_multicast_list_queue	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x3f61727d	sdhci_suspend_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0x9b140fff	cx88_sram_channels	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xe4140c60	ir_codes_genius_tvgo_a11mce_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x0d542439	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0xf733267d	unregister_qdisc	vmlinux	EXPORT_SYMBOL
+0x9afd8050	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x80adfddc	pcmcia_get_mem_page	vmlinux	EXPORT_SYMBOL
+0x2c805a3a	pcmcia_map_mem_page	vmlinux	EXPORT_SYMBOL
+0x65364a86	phy_device_register	vmlinux	EXPORT_SYMBOL
+0xbad184b6	acpi_pci_find_root	vmlinux	EXPORT_SYMBOL_GPL
+0x34f43cdc	pci_map_rom	vmlinux	EXPORT_SYMBOL
+0x9bb8dc61	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
+0xf76d49ef	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x1bd92d0b	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
+0xf3baa415	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x32924a4d	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0xff7c5324	snd_hda_get_sub_nodes	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x8a78d24a	cfg80211_wext_siwfreq	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x29b96523	cfg80211_wext_giwfreq	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xf9d1164c	rpc_free	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x7f33b451	can_rx_unregister	net/can/can	EXPORT_SYMBOL
+0x828f8e72	fc_vport_terminate	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x222e0854	mlx4_multicast_detach	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x3f7567fd	ib_rate_to_mult	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xf88e0ee2	acpi_get_table_header	vmlinux	EXPORT_SYMBOL
+0xa73a58a3	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x1bd3ee87	register_console	vmlinux	EXPORT_SYMBOL
+0x0fa5869a	nf_conntrack_l4proto_tcp4	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xc9cebfe0	free_orinocodev	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x4f068d89	b1dma_reset_ctr	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x38f8d368	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x25c61baf	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x9ef471d8	xenbus_unmap_ring	vmlinux	EXPORT_SYMBOL_GPL
+0xafc58ea1	vfs_dq_transfer	vmlinux	EXPORT_SYMBOL
+0x1d77418a	arpt_do_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL
+0x2250c66e	mraid_mm_adapter_app_handle	drivers/scsi/megaraid/megaraid_mm	EXPORT_SYMBOL
+0x6141c8c5	cx88_tuner_callback	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xfc0638eb	async_tx_submit	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL
+0xca60c5cc	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0xf21570eb	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x2bfeb410	acpi_get_handle	vmlinux	EXPORT_SYMBOL
+0x80ee55c3	selinux_secmark_refcount_inc	vmlinux	EXPORT_SYMBOL_GPL
+0xa4b27cdb	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0xba09deaa	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x90f5b210	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x5f35afc3	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0xe0878bfe	__krealloc	vmlinux	EXPORT_SYMBOL
+0x1cee5720	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x995d1071	prof_on	vmlinux	EXPORT_SYMBOL_GPL
+0x7eec87c0	task_nice	vmlinux	EXPORT_SYMBOL
+0x12abb9d2	snd_vx_resume	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xf88fe82e	iwl_setup_scan_deferred_work	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa91c9dea	hostap_check_sta_fw_version	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x71e8d5ba	capilib_data_b3_req	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x3f45d0c9	kernel_accept	vmlinux	EXPORT_SYMBOL
+0xc898625d	atomic64_inc_and_test	vmlinux	EXPORT_SYMBOL
+0x2d0305ec	pcim_iounmap	vmlinux	EXPORT_SYMBOL
+0xecaa1f75	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0xf32265ca	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x323f9281	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x01a4aab6	set_irq_chip_data	vmlinux	EXPORT_SYMBOL
+0xd1fb24d1	sysctl_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x07dfc205	mlx4_mr_enable	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xcbc4633c	xt_proto_fini	vmlinux	EXPORT_SYMBOL_GPL
+0x31d78754	sata_scr_write_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x91703d35	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0xda2b1bba	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0xf478db3b	lock_may_read	vmlinux	EXPORT_SYMBOL
+0xbb58b814	iomap_free	vmlinux	EXPORT_SYMBOL_GPL
+0x1a8a845e	idle_nomwait	vmlinux	EXPORT_SYMBOL
+0x0a523f0b	snd_card_free	sound/core/snd	EXPORT_SYMBOL
+0x66acced9	cfg80211_wext_siwap	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x1b1bd3bb	cfg80211_wext_giwap	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x2fae4230	whci_wait_for	drivers/uwb/whci	EXPORT_SYMBOL_GPL
+0x3a84be27	ir_codes_avermedia_a16d_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x0cb810fd	iw_create_cm_id	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x3ee23193	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x293019ce	pnp_stop_dev	vmlinux	EXPORT_SYMBOL
+0xd746c691	fb_class	vmlinux	EXPORT_SYMBOL
+0xc3fda0bf	load_nls	vmlinux	EXPORT_SYMBOL
+0x94113efb	rfkill_set_hw_state	net/rfkill/rfkill	EXPORT_SYMBOL
+0xfecca762	bttv_sub_register	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0xcf30925c	dm_exception_store_destroy	drivers/md/dm-snapshot	EXPORT_SYMBOL
+0x55a639c5	input_unregister_polled_device	drivers/input/input-polldev	EXPORT_SYMBOL
+0x96ce6c46	rdma_node_get_transport	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x24566ef0	drm_mode_connector_detach_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4859b8bb	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x86b10394	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL
+0xa0ee249c	ata_link_offline	vmlinux	EXPORT_SYMBOL_GPL
+0xe36fa434	ata_host_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x0c65e73c	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x3dd5d829	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0xe4e618e1	snd_hda_mixer_amp_volume_get	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x80152490	ip6_local_out	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x0403991a	wusbhc_giveback_urb	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x12d91e00	register_pppox_proto	drivers/net/pppox	EXPORT_SYMBOL
+0x63d14d2f	eeprom_93cx6_read	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL
+0x0f73520f	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x88425164	pcmcia_unregister_socket	vmlinux	EXPORT_SYMBOL
+0x2c4fb642	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x215ebd78	bitrev16	vmlinux	EXPORT_SYMBOL
+0x160dfbe7	delayed_slow_work_enqueue	vmlinux	EXPORT_SYMBOL
+0x72b243d4	free_dma	vmlinux	EXPORT_SYMBOL
+0x568d2c1d	xdr_init_decode	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x9977899a	jbd2_journal_load	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xbfc7303d	scsi_is_sas_rphy	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xc60b5e9e	hermes_bap_pwrite	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x62b42b85	iwl_rxq_stop	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7c71d07f	cx231xx_dev_uninit	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x5af92690	cx24123_attach	drivers/media/dvb/frontends/cx24123	EXPORT_SYMBOL
+0x2b881dac	queue_ch_frame	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xaa0c0a1c	ib_sa_path_rec_get	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x219501f4	md_check_no_bitmap	vmlinux	EXPORT_SYMBOL
+0xfed11ed1	usb_mon_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x4d7c289f	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x7486cdb3	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x9cca0689	ezusb_set_reset	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xf818af2d	mmc_cleanup_queue	drivers/mmc/card/mmc_block	EXPORT_SYMBOL
+0x4ff48879	videobuf_mmap_free	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x5b3555fd	iw_handler_set_thrspy	vmlinux	EXPORT_SYMBOL
+0x8c4a88fe	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0xff5a8cfe	cn_del_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x813cc1d5	regulator_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x830d9cc6	nf_ct_l3proto_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x7340ea0f	uwb_pal_init	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x55fd8e3b	dvb_register_device	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xb45317a8	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0xad4b7ae7	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x7200a02e	vfs_quota_disable	vmlinux	EXPORT_SYMBOL
+0xad224d38	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x74abdafa	task_handoff_register	vmlinux	EXPORT_SYMBOL_GPL
+0x003ed6a6	hpet_unregister_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x6bfac920	rt2x00usb_vendor_request	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x7948c222	budget_debug	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0x4826143e	skb_dma_map	vmlinux	EXPORT_SYMBOL
+0xf73e9371	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x68e69ef9	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x3441c3d6	gpio_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x4f1cd128	security_tun_dev_create	vmlinux	EXPORT_SYMBOL
+0xa369e5c3	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0xd1e91372	phy_stop_interrupts	vmlinux	EXPORT_SYMBOL
+0x02ae52bb	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0xe7330510	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x65bbbc78	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x8d4badb9	jbd2_journal_flush	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x04f54ba1	sas_phy_add	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x5f04bbdf	rt2x00usb_vendor_request_large_buff	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xb83e2f78	gigaset_start	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xb4ee7568	ttm_bo_reserve	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xc3bfaedf	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0xfa8dae24	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL
+0xb570baec	usb_buffer_unmap_sg	vmlinux	EXPORT_SYMBOL_GPL
+0xb4ff6a37	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x5d74dbcf	pnp_range_reserved	vmlinux	EXPORT_SYMBOL
+0x23614b78	crypto_register_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0xb742ac21	qtree_release_dquot	vmlinux	EXPORT_SYMBOL
+0x8ffa7742	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x19ccc8da	ring_buffer_iter_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x21709d49	snd_hda_delete_codec_preset	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc3da173b	rt2x00usb_disable_radio	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x0f934475	mdio45_ethtool_gset_npage	drivers/net/mdio	EXPORT_SYMBOL
+0xdd638fc8	mmc_try_claim_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xd9a92a75	mpt_reset_deregister	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xb66ba45e	acpi_smbus_write	drivers/acpi/sbshc	EXPORT_SYMBOL_GPL
+0xed6f3afa	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x11267875	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x6c61ce70	num_registered_fb	vmlinux	EXPORT_SYMBOL
+0xb0a390cf	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x13cad559	xdr_buf_from_iov	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x32120729	xfrm_tmpl_sort	vmlinux	EXPORT_SYMBOL
+0x88a61d4a	pccard_get_first_tuple	vmlinux	EXPORT_SYMBOL
+0xc148b878	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL
+0x16444644	parport_wait_peripheral	drivers/parport/parport	EXPORT_SYMBOL
+0xc170d57c	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0xc8ca3e25	acpi_get_child	vmlinux	EXPORT_SYMBOL
+0x9c89329c	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x1a06611a	generic_setlease	vmlinux	EXPORT_SYMBOL
+0xe0741d53	wiphy_to_ieee80211_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0x6b7b49cd	ipv6_getsockopt	net/ipv6/ipv6	EXPORT_SYMBOL
+0xc824436f	usb_ftdi_elan_edset_setup	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x425de163	mpt_GetIocState	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x9994c0ca	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0xdc047fc4	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x5b51c6a7	acpi_walk_resources	vmlinux	EXPORT_SYMBOL
+0x5dfac7d2	pcim_enable_device	vmlinux	EXPORT_SYMBOL
+0x85d7edfd	hpet_set_periodic_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x053779ff	v4l2_i2c_new_subdev_board	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0xd85d6e6a	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL
+0xf6e874f5	ata_timing_merge	vmlinux	EXPORT_SYMBOL_GPL
+0xd9d1cadf	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x46ef4cb2	write_one_page	vmlinux	EXPORT_SYMBOL
+0x15892417	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0xa7a642a0	nlmsvc_ops	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x6c33e494	lis3lv02d_joystick_disable	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0xb663a35b	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0xbbc665cb	ata_host_activate	vmlinux	EXPORT_SYMBOL_GPL
+0xb48508ab	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x113d156e	pnp_find_dev	vmlinux	EXPORT_SYMBOL
+0xefe099c3	acpi_get_event_status	vmlinux	EXPORT_SYMBOL
+0x6be167b5	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0xf6cc930c	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x0057f010	rfkill_set_states	net/rfkill/rfkill	EXPORT_SYMBOL
+0x3d472713	wusbhc_handle_dn	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xeb1f7dee	can_put_echo_skb	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x1c422f63	sdhci_alloc_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0x5a74c246	dibusb_rc_query	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x784e176d	ir_codes_asus_pc39_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x5dc7400a	mISDN_clock_update	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x6e720ff2	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x1c57b45c	sock_rfree	vmlinux	EXPORT_SYMBOL
+0xe8388c71	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x26df6f56	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x5d366dec	gnttab_cancel_free_callback	vmlinux	EXPORT_SYMBOL_GPL
+0xc0a3d105	find_next_bit	vmlinux	EXPORT_SYMBOL
+0xf749c987	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x44143d65	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x4fabddf7	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0xa1596d98	acpi_processor_ffh_cstate_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x2cc2d52d	vcc_hash	net/atm/atm	EXPORT_SYMBOL
+0xef80fe8d	wlp_wss_setup	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xe111be84	iwl_eeprom_free	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7cec7100	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
+0x957e92aa	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x035f14d0	kfree_skb	vmlinux	EXPORT_SYMBOL
+0xa287c728	iommu_map_range	vmlinux	EXPORT_SYMBOL_GPL
+0x9a54e8cd	bd_release	vmlinux	EXPORT_SYMBOL
+0x2bdc0a53	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x1a938737	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x8bd5b603	param_get_long	vmlinux	EXPORT_SYMBOL
+0x300d7e57	free_rs	lib/reed_solomon/reed_solomon	EXPORT_SYMBOL_GPL
+0xc0512e0f	ssb_admatch_base	drivers/ssb/ssb	EXPORT_SYMBOL
+0xd481192b	ssb_admatch_size	drivers/ssb/ssb	EXPORT_SYMBOL
+0x336e46b9	saa7146_wait_for_debi_done	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x45d587e9	ib_send_cm_mra	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x076b04aa	drm_mm_takedown	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2c881deb	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0xea18802e	regulator_get_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0x0f1ef871	posix_acl_alloc	vmlinux	EXPORT_SYMBOL
+0x3a57f235	snd_seq_autoload_unlock	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0xb73b953c	svc_set_num_threads	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbb8da174	nfnetlink_parse_nat_setup_hook	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x444e2e82	fuse_do_open	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x175cd183	iwl_send_cmd_sync	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5b05556c	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x80519bf4	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x5c8247ca	get_mtd_device_nm	vmlinux	EXPORT_SYMBOL_GPL
+0x87cec70a	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL
+0x0933aae1	efi_enabled	vmlinux	EXPORT_SYMBOL
+0xf65f7069	rds_send_drop_acked	net/rds/rds	EXPORT_SYMBOL_GPL
+0x0be952f9	iwl_txq_update_write_ptr	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x32806055	mptscsih_proc_info	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x88985b65	snd_i2c_device_free	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0xec2ee32c	saa7134_pgtable_build	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x36632290	mISDN_unregister_Bprotocol	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x88feb0ec	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x99e54b30	register_qdisc	vmlinux	EXPORT_SYMBOL
+0x4da33966	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0xe96981c0	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x9342dfdb	fbcon_rotate_ccw	vmlinux	EXPORT_SYMBOL
+0x243ffddc	idr_destroy	vmlinux	EXPORT_SYMBOL
+0xae75f004	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00ec1a79	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x93cbd1ec	_spin_lock_bh	vmlinux	EXPORT_SYMBOL
+0xfdb9fcff	xprt_wait_for_buffer_space	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x27c1e0ae	osduld_register_test	drivers/scsi/osd/osd	EXPORT_SYMBOL
+0x0e1f1ca7	free_netdev	vmlinux	EXPORT_SYMBOL
+0x170c25ee	acpi_get_next_object	vmlinux	EXPORT_SYMBOL
+0xc9ec4e21	free_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0xe1596872	per_cpu__irq_stat	vmlinux	EXPORT_SYMBOL
+0xf7aebcf0	gss_mech_get_by_pseudoflavor	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x380ab051	uwb_notifs_deregister	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x1314fbac	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0xf3a8bebf	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x66e1458a	regulator_bulk_get	vmlinux	EXPORT_SYMBOL_GPL
+0x668da8d5	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0xd996d859	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0xf4ae9d51	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x28d664ff	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x4d3c153f	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x6938b458	parport_ieee1284_ecp_write_addr	drivers/parport/parport	EXPORT_SYMBOL
+0xb286e2cc	parport_ieee1284_epp_write_addr	drivers/parport/parport	EXPORT_SYMBOL
+0x3163395d	mtd_concat_destroy	drivers/mtd/mtdconcat	EXPORT_SYMBOL
+0x4283137d	drm_vblank_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9e13f6f6	gf128mul_lle	crypto/gf128mul	EXPORT_SYMBOL
+0xf267f5f3	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x9144a8e2	ec_burst_disable	vmlinux	EXPORT_SYMBOL
+0x814e9c87	do_mmap_pgoff	vmlinux	EXPORT_SYMBOL
+0x72a6f913	umc_driver_unregister	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0x836bdb72	nand_flash_ids	drivers/mtd/nand/nand_ids	EXPORT_SYMBOL
+0x2adeb2c8	dib0070_wbd_offset	drivers/media/dvb/frontends/dib0070	EXPORT_SYMBOL
+0xc3fba810	flexcop_pass_dmx_packets	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x19b4d61c	ir_codes_nebula_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x943b6d67	i2c_master_recv	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x55642407	__async_tx_find_channel	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL
+0x8d551bef	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0xe6d2be50	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0xe1dcc8ee	pcmcia_replace_cis	vmlinux	EXPORT_SYMBOL
+0xb7f44559	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0xc622fb29	snd_seq_device_unregister_driver	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0x4d96a5ee	ieee80211_stop_tx_ba_cb_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL
+0xc33520f3	scsi_tgt_it_nexus_create	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0xd5168829	hermes_allocate	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0xd54ddd14	lro_flush_all	vmlinux	EXPORT_SYMBOL
+0x3bf02a80	ata_acpi_gtm	vmlinux	EXPORT_SYMBOL_GPL
+0xa18a36db	ata_acpi_stm	vmlinux	EXPORT_SYMBOL_GPL
+0xc5f5b70e	key_revoke	vmlinux	EXPORT_SYMBOL
+0x57c085cf	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x631c95df	xprt_reserve_xprt_cong	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe4182597	rds_message_addref	net/rds/rds	EXPORT_SYMBOL_GPL
+0x6d9b6a0e	rt2x00lib_remove_dev	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x9b6f00c6	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x260b93d5	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x784f3adc	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x3baf0713	backlight_force_update	vmlinux	EXPORT_SYMBOL
+0xd12c482f	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0xff7559e4	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x0eeac75d	__fscache_maybe_release_page	fs/fscache/fscache	EXPORT_SYMBOL
+0x46736d38	uwb_rc_cmd	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xcc474901	uwb_rc_add	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xc6487643	uwb_rc_put	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xbe261862	p54_free_common	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0xeec89db8	ir_codes_empty_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xc7a4fbed	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x178fb028	dev_unicast_add	vmlinux	EXPORT_SYMBOL
+0x94a68723	ata_scsi_slave_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x7a95d8a8	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
+0x42fbcddf	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0xc4479bed	ring_buffer_reset_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x38a7f9dd	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x897473df	mktime	vmlinux	EXPORT_SYMBOL
+0x2288378f	system_state	vmlinux	EXPORT_SYMBOL
+0x349e36b8	llc_add_pack	net/llc/llc	EXPORT_SYMBOL
+0x9cd013f2	xfrm6_tunnel_alloc_spi	net/ipv6/xfrm6_tunnel	EXPORT_SYMBOL
+0xfb2b0761	v4l2_int_ioctl_0	drivers/media/video/v4l2-int-device	EXPORT_SYMBOL_GPL
+0x2dbafbe3	pcibios_align_resource	vmlinux	EXPORT_SYMBOL
+0x386ef4d2	hidinput_connect	vmlinux	EXPORT_SYMBOL_GPL
+0xfaa78ef0	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x0e83fea1	del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x5957c9b6	dccp_setsockopt	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x1514f25e	stv6110_attach	drivers/media/dvb/frontends/stv6110	EXPORT_SYMBOL
+0x2d0e9a49	ir_codes_em_terratec_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x00e8097b	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0xf709122d	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x87a90b07	acpi_is_video_device	vmlinux	EXPORT_SYMBOL
+0xd1c91aa0	fb_deferred_io_open	vmlinux	EXPORT_SYMBOL_GPL
+0xec99a478	srp_remove_host	drivers/scsi/scsi_transport_srp	EXPORT_SYMBOL_GPL
+0x0f1b7a39	mtd_do_chip_probe	drivers/mtd/chips/gen_probe	EXPORT_SYMBOL
+0x0f7877af	wm831x_reg_unlock	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0xc368f8e6	btcx_align	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0xe27ade35	drm_core_get_reg_ofs	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x8c94aef8	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0xec1a75a9	__dev_addr_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x462a2e75	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0xca2a02a4	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x75ee8869	configfs_unregister_subsystem	fs/configfs/configfs	EXPORT_SYMBOL
+0xf6182427	osd_finalize_request	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xc33d5dcb	mmc_power_restore_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x9eec3249	init_net	vmlinux	EXPORT_SYMBOL
+0x0479d68a	regulator_force_disable	vmlinux	EXPORT_SYMBOL_GPL
+0xb66aedaa	textsearch_find_continuous	vmlinux	EXPORT_SYMBOL
+0x0343a1a8	__list_add	vmlinux	EXPORT_SYMBOL
+0xc64c21ea	__next_cpu	vmlinux	EXPORT_SYMBOL
+0xa78d69d6	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x7fc5ef0d	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x3824b400	keyring_search	vmlinux	EXPORT_SYMBOL
+0x253677d1	key_unlink	vmlinux	EXPORT_SYMBOL
+0x86750751	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0xc3bf7613	osd_req_create_object	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x83e00605	i2c_pca_add_bus	drivers/i2c/algos/i2c-algo-pca	EXPORT_SYMBOL
+0x3df02a7e	nf_nat_pptp_hook_expectfn	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL
+0x0e1b08f1	orinoco_if_del	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x51444c76	mmc_wait_for_req	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x06a6acc3	radeonfb_remove	drivers/gpu/drm/radeon/radeon	EXPORT_SYMBOL
+0x2678a086	regulator_set_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0xcff53400	kref_put	vmlinux	EXPORT_SYMBOL
+0x662f8525	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0xaba26d90	do_sync_mapping_range	vmlinux	EXPORT_SYMBOL_GPL
+0x1a940397	hci_register_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x377a85b7	deregister_atm_ioctl	net/atm/atm	EXPORT_SYMBOL
+0xaf64ad0d	zlib_deflate	lib/zlib_deflate/zlib_deflate	EXPORT_SYMBOL
+0x99424d85	fc_frame_crc_check	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x42c8e001	v4l2_ctrl_next	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x388a043d	i2c_smbus_write_i2c_block_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xa6193a3e	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x24fdac79	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0xfac0e9dc	snd_rawmidi_drain_output	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x8a25888a	fuse_request_send_background	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x232f0fe0	iwl_free_isr_ict	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x54888e64	init_airo_card	drivers/net/wireless/airo	EXPORT_SYMBOL
+0x2002fb77	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0xb6a61a86	qdisc_get_rtab	vmlinux	EXPORT_SYMBOL
+0x6028464d	hid_set_field	vmlinux	EXPORT_SYMBOL_GPL
+0x8ea4a973	ata_sff_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0xbdffb899	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x344ad375	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x181b6ff2	mempool_resize	vmlinux	EXPORT_SYMBOL
+0xc60f75ec	__ftrace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x2ee4e1c0	snd_ac97_pcm_open	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x65d1898d	ei_netdev_ops	drivers/net/8390	EXPORT_SYMBOL
+0x3909f4ad	ir_codes_terratec_cinergy_xs_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x3e99a338	lis3_dev	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0xebcf4da4	ttm_buffer_object_init	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x78092f97	drm_agp_unbind	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x6b80fa05	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0xf6715ad8	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0xecf99c4c	hid_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x0521445b	list_del	vmlinux	EXPORT_SYMBOL
+0x3fec048f	sg_next	vmlinux	EXPORT_SYMBOL
+0x8039d043	selinux_secmark_relabel_packet_permission	vmlinux	EXPORT_SYMBOL_GPL
+0x8083d1f2	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x0b07abe2	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0xe714375c	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x5b8cef8e	cfg80211_wext_siwrts	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xf84d58e7	cfg80211_wext_giwrts	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xafffe276	__nf_conntrack_confirm	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x15526f21	usbnet_suspend	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x62e45073	mdiobus_scan	vmlinux	EXPORT_SYMBOL
+0xbc89a95f	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x31abfa01	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x5478d5ac	__brelse	vmlinux	EXPORT_SYMBOL
+0x2b392c43	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x7de53067	rpc_init_rtt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf7f0c6d4	wlp_dev_model_name_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x00136228	scsi_host_get_command	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0xa40baa2e	ib_register_mad_agent	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x99c583e3	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0xdba64f1c	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0xb7fdd0df	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0xc0ab93fd	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0xa44ad274	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x6faaa50f	lbtf_send_tx_feedback	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x11743e93	mmc_add_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x28e23139	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x99ef2f4e	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
+0xc60e03aa	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0xec6b5ed2	nf_reinject	vmlinux	EXPORT_SYMBOL
+0x820d225f	print_mac	vmlinux	EXPORT_SYMBOL
+0xd8fd89f9	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x3a9b6fb9	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0xaac64316	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x69f14915	ring_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x2a1a735d	md_integrity_register	vmlinux	EXPORT_SYMBOL
+0xc9fd63d7	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0xc17515d7	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL
+0x800c29fe	ata_sff_irq_clear	vmlinux	EXPORT_SYMBOL_GPL
+0x14da2bc1	snd_ctl_unregister_ioctl	sound/core/snd	EXPORT_SYMBOL
+0x9bc040d3	ssb_bus_resume	drivers/ssb/ssb	EXPORT_SYMBOL
+0x5e248cb7	parport_claim	drivers/parport/parport	EXPORT_SYMBOL
+0x468eec20	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x59b8994c	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0xc288f8ce	malloc_sizes	vmlinux	EXPORT_SYMBOL
+0x3c311ce4	per_cpu__cpu_core_map	vmlinux	EXPORT_SYMBOL
+0x3589bca8	dccp_insert_option_elapsed_time	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x10bd08ba	dlm_posix_unlock	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0xf5ccc8ae	usbnet_get_msglevel	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xb126e262	usbnet_set_msglevel	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x71d10e0b	saa7146_vmalloc_build_pgtable	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x26a87e39	ib_dealloc_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x01902adf	netpoll_trap	vmlinux	EXPORT_SYMBOL
+0xf0a25e12	pcmcia_error_ret	vmlinux	EXPORT_SYMBOL
+0x44d85897	agp_remove_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x8063f83d	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x55b57bfc	register_nls	vmlinux	EXPORT_SYMBOL
+0xb121390a	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x2af90271	speedstep_get_frequency	vmlinux	EXPORT_SYMBOL_GPL
+0xc4a672ca	snd_hda_codec_cleanup_stream	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc4bf05e6	svc_prepare_thread	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xef85cab6	nf_ct_unlink_expect	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x4780e3cf	fscache_mark_pages_cached	fs/fscache/fscache	EXPORT_SYMBOL
+0xd81673c5	usb_stor_suspend	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x98fab617	wm831x_disable_irq	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x5ba1d467	btcx_riscmem_free	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0x9039a809	i2c_smbus_write_block_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xe979c806	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x2aa81274	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x7cb4695b	rpc_unlink	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xee8ac976	svc_gss_principal	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x6f959b35	locks_in_grace	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x02a381a2	ssb_device_is_enabled	drivers/ssb/ssb	EXPORT_SYMBOL
+0xf30d915c	edac_mc_find_csrow_by_page	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x9d33ef5e	acpi_enable	vmlinux	EXPORT_SYMBOL
+0xc574b57e	inotify_inode_is_dead	vmlinux	EXPORT_SYMBOL_GPL
+0xbe6f92d2	module_refcount	vmlinux	EXPORT_SYMBOL
+0x96d45890	display_device_register	drivers/video/display/display	EXPORT_SYMBOL
+0x509d6436	edac_pci_reset_delay_period	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x4152dd69	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x8691eefc	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x1b92ab09	pccard_read_tuple	vmlinux	EXPORT_SYMBOL
+0x27b9a547	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x31424769	ip_vs_conn_in_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xa1b8d1ad	osd_WaitEventWaitEx	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0x45c87ffa	ttusbdecfe_dvbt_attach	drivers/media/dvb/ttusb-dec/ttusbdecfe	EXPORT_SYMBOL
+0x6e0f7e30	ttusbdecfe_dvbs_attach	drivers/media/dvb/ttusb-dec/ttusbdecfe	EXPORT_SYMBOL
+0x5f0ae733	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0xd41ad6b5	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
+0xc7b4a8b2	mdiobus_alloc	vmlinux	EXPORT_SYMBOL
+0x6ec5eb98	snd_timer_global_new	sound/core/snd-timer	EXPORT_SYMBOL
+0x3fddd2b4	usb_ftdi_elan_edset_empty	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x333af589	iwl_init_sensitivity	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x4ac2e1ea	i2400m_tx_msg_sent	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x20385c58	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x97852e9c	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0xb45d9ef7	ata_std_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x990bf016	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x4108e69a	fb_match_mode	vmlinux	EXPORT_SYMBOL
+0x963cc152	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL
+0xe2d5255a	strcmp	vmlinux	EXPORT_SYMBOL
+0x85df9b6c	strsep	vmlinux	EXPORT_SYMBOL
+0x69a358a6	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x6729d3df	__get_user_4	vmlinux	EXPORT_SYMBOL
+0xb2fd5ceb	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x49e1ea09	snd_ctl_add	sound/core/snd	EXPORT_SYMBOL
+0xb4f4e90e	ieee80211_queue_delayed_work	net/mac80211/mac80211	EXPORT_SYMBOL
+0xf3f8874c	register_virtio_driver	drivers/virtio/virtio	EXPORT_SYMBOL_GPL
+0xaa2faed6	usb_serial_register	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x59a6bb4c	osd_end_request	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xf71e0960	dvb_ca_en50221_release	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xd51e9c3b	drm_fb_helper_pan_display	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x2f47d8c7	cpufreq_frequency_get_table	vmlinux	EXPORT_SYMBOL_GPL
+0xd02e26eb	sata_scr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x4d7b1e7d	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0xdff277d5	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0xea15ee36	vfs_create	vmlinux	EXPORT_SYMBOL
+0x4db449ed	dccp_done	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x04e83446	saa7134_tuner_callback	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x1ade92ca	mtd_erase_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x9143b9bf	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0xff66a5b7	sas_phy_alloc	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x11ea03de	v4l2_device_set_name	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0x723c0a4f	dm_kcopyd_client_destroy	drivers/md/dm-mod	EXPORT_SYMBOL
+0xd3c64790	regulator_get_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x59d696b6	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x4243f57e	snd_cs8427_reg_write	sound/i2c/snd-cs8427	EXPORT_SYMBOL
+0x41de6a8a	iwl_irq_handle_error	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xee66d79e	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x2dd2d053	bitmap_start_sync	vmlinux	EXPORT_SYMBOL
+0xc7208c3a	serial8250_resume_port	vmlinux	EXPORT_SYMBOL
+0x6b9ed52d	hid_input_report	vmlinux	EXPORT_SYMBOL_GPL
+0x7c1ffc0e	pcmcia_request_irq	vmlinux	EXPORT_SYMBOL
+0x41d493ae	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL
+0xd33973a1	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0xa16ca1dc	rdma_set_service_type	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x03d8627f	acpi_smbus_unregister_callback	drivers/acpi/sbshc	EXPORT_SYMBOL_GPL
+0x8cfe3be5	del_gendisk	vmlinux	EXPORT_SYMBOL
+0xd8863b8c	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0xc254af48	dcache_lock	vmlinux	EXPORT_SYMBOL
+0xa61aa028	snd_pcm_format_unsigned	sound/core/snd-pcm	EXPORT_SYMBOL
+0x0c30b624	nf_ct_invert_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xf6933c48	lockd_up	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x75df0f5c	fat_sync_inode	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x14eb1229	usbnet_stop	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xffc2e028	zl10036_attach	drivers/media/dvb/frontends/zl10036	EXPORT_SYMBOL
+0x47ef4ae3	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x9305f8e6	cpufreq_get	vmlinux	EXPORT_SYMBOL
+0xfb428378	put_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x439d2a34	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x89e95c70	____pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0xfcccecda	kunmap_atomic	vmlinux	EXPORT_SYMBOL
+0xa4117155	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x6521ea0c	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0xab01acbe	gnttab_request_free_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x7bb42294	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x26bd06d0	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x626055f0	migrate_page	vmlinux	EXPORT_SYMBOL
+0xee5023e5	snd_wss_interrupt	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xa3d96594	ip6_route_me_harder	net/ipv6/ipv6	EXPORT_SYMBOL
+0x69238626	usb_ftdi_elan_write_pcimem	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x0eec7d91	sas_rphy_delete	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x349a7eff	cb710_set_irq_handler	drivers/misc/cb710/cb710	EXPORT_SYMBOL_GPL
+0xe901175f	__dev_addr_unsync	vmlinux	EXPORT_SYMBOL_GPL
+0xc7e2257a	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL
+0xe7ea98e7	snd_device_new	sound/core/snd	EXPORT_SYMBOL
+0x790ce03a	nf_nat_proto_range_to_nlattr	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0x7954b1ea	fc_get_event_number	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x8902609c	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x5fb01842	lro_receive_skb	vmlinux	EXPORT_SYMBOL
+0x05fd4cf6	napi_complete	vmlinux	EXPORT_SYMBOL
+0xdf0a4a71	phy_attach_direct	vmlinux	EXPORT_SYMBOL
+0xdfb7bada	acpi_check_resource_conflict	vmlinux	EXPORT_SYMBOL
+0x47229b5c	gpio_request	vmlinux	EXPORT_SYMBOL_GPL
+0x93997d1e	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x868784cb	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0xc55f7dc7	_write_trylock	vmlinux	EXPORT_SYMBOL
+0xe17aa174	snd_pcm_hw_constraint_list	sound/core/snd-pcm	EXPORT_SYMBOL
+0xa38bc6cf	p9_client_disconnect	net/9p/9pnet	EXPORT_SYMBOL
+0xe74f4161	libipw_get_channel_flags	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x322d9270	smscore_getbuffer	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x50bfd649	smscore_putbuffer	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xf1db1704	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0xbe0e5118	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x358dc78a	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0xe5942277	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x85b2e26b	kmem_cache_name	vmlinux	EXPORT_SYMBOL_GPL
+0xf35f0bab	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x46efb24d	ieee80211_data_from_8023	net/wireless/cfg80211	EXPORT_SYMBOL
+0x16a024b9	iwl_tx_queue_reclaim	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7d51f041	ipmi_request_supply_msgs	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x923b1276	dmaengine_get	vmlinux	EXPORT_SYMBOL
+0xc273989b	pci_restore_msi_state	vmlinux	EXPORT_SYMBOL_GPL
+0x5edd0762	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x33d92f9a	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x1fedf0f4	__request_region	vmlinux	EXPORT_SYMBOL
+0x593797b2	snd_cs8427_create	sound/i2c/snd-cs8427	EXPORT_SYMBOL
+0x9c124dfe	dvb_frontend_reinitialise	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x945d30ca	pcmcia_find_mem_region	vmlinux	EXPORT_SYMBOL
+0x01b96585	fixed_phy_set_link_update	vmlinux	EXPORT_SYMBOL_GPL
+0x141ee6ca	ata_host_detach	vmlinux	EXPORT_SYMBOL_GPL
+0xe089cfcc	agp_memory_reserved	vmlinux	EXPORT_SYMBOL_GPL
+0x843d70ef	acpi_is_root_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x0ce739dd	acpi_ec_add_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x6bb812e7	atomic64_add_return	vmlinux	EXPORT_SYMBOL
+0x5e675e37	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0xf0009fee	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x415c679d	wlp_dev_manufacturer_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x904670c7	s5h1411_attach	drivers/media/dvb/frontends/s5h1411	EXPORT_SYMBOL
+0xcf7bc89f	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x239b2fb3	xenbus_alloc_evtchn	vmlinux	EXPORT_SYMBOL_GPL
+0x51508194	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0xf8cf9ee5	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x091eb9b4	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0xdfafb983	per_cpu__gdt_page	vmlinux	EXPORT_SYMBOL_GPL
+0xf555d993	snd_ac97_pcm_assign	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xa303f85d	iwl_reset_ict	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xac4e53b9	cx88_user_ctrls	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0xb233ec8b	dm_exception_store_create	drivers/md/dm-snapshot	EXPORT_SYMBOL
+0xac43378f	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x5594be03	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x30eb0014	dquot_commit	vmlinux	EXPORT_SYMBOL
+0x9e9fcae4	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x50caf294	snd_util_mem_alloc	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0xb5edd416	cx88_video_mux	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0xe6f43680	dvb_frontend_detach	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x0422fe4a	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0xbaa53234	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x81c16d64	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x0948cde9	num_physpages	vmlinux	EXPORT_SYMBOL
+0x260d65dc	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x9a1dfd65	strpbrk	vmlinux	EXPORT_SYMBOL
+0xb2702ddd	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x2d253dc7	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x9e6d79f8	snd_info_get_str	sound/core/snd	EXPORT_SYMBOL
+0x6df91530	ip6_frag_match	net/ipv6/ipv6	EXPORT_SYMBOL
+0xccbc3a9f	uwb_pca_base_priority_store	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x1a7575ab	sdhci_add_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0x39062042	enclosure_add_device	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0x9bf15c5e	drm_crtc_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xaf621340	cdrom_get_last_written	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xb7816191	phy_enable_interrupts	vmlinux	EXPORT_SYMBOL
+0x1551dc51	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x71fa908a	cache_flush	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x73488653	bc_svc_process	net/sunrpc/sunrpc	EXPORT_SYMBOL
+0x56b63670	lzo1x_1_compress	lib/lzo/lzo_compress	EXPORT_SYMBOL_GPL
+0xe7d7dbe0	journal_invalidatepage	fs/jbd/jbd	EXPORT_SYMBOL
+0xaaf924a7	ubi_leb_erase	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0xa1775517	dm_rh_get_region_key	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x3b71e4fc	isdnhdlc_decode	drivers/isdn/i4l/isdnhdlc	EXPORT_SYMBOL
+0xd76e57f3	mISDNipac_irq	drivers/isdn/hardware/mISDN/mISDNipac	EXPORT_SYMBOL
+0xd0bc06ce	capifs_new_ncci	drivers/isdn/capi/capifs	EXPORT_SYMBOL
+0xcd499a85	edac_pci_alloc_ctl_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xc1b9670d	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0xa1aabbbf	pcmcia_request_configuration	vmlinux	EXPORT_SYMBOL
+0xd1780ea6	regulator_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x8c06a108	xenbus_transaction_start	vmlinux	EXPORT_SYMBOL_GPL
+0x5538e57f	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0xb3819662	dib3000mc_pid_parse	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0xb60e5e5f	capi_cmsg_header	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x8d316093	drm_lock_take	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xcbc0a1ec	drm_gem_handle_create	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xbed085a1	pcmcia_request_window	vmlinux	EXPORT_SYMBOL
+0x27996e97	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x2e226918	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0xeb20de20	relay_switch_subbuf	vmlinux	EXPORT_SYMBOL_GPL
+0x962b999b	rpc_create	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xeb260e2a	register_ip_vs_app_inc	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xfd76c6cb	wusbhc_rh_status_data	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x0c1c883d	video_device_release	drivers/media/video/videodev	EXPORT_SYMBOL
+0x32d5e7fc	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x72a32c7c	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x5d2b0362	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x83ca5655	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
+0xb49e0992	fuse_conn_put	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x27d6824f	capi_ctr_resume_output	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x7b3f3285	drm_helper_mode_fill_fb_struct	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x6484d0ba	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0xcb813ad0	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x94f09e17	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x91b47374	regulator_bulk_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x7a848702	_read_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0xf5b4a948	crc_itu_t	lib/crc-itu-t	EXPORT_SYMBOL
+0x4eef6af7	em28xx_set_mode	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0xff54c7ac	drm_pci_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x85705e4c	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0xc4d300b5	ieee80211_get_hdrlen_from_skb	net/wireless/cfg80211	EXPORT_SYMBOL
+0x753e5bd1	rt2x00mac_bss_info_changed	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x758d5d2f	atmel_open	drivers/net/wireless/atmel	EXPORT_SYMBOL
+0x0b9b25e9	mii_ethtool_gset	drivers/net/mii	EXPORT_SYMBOL
+0x17501e29	mii_ethtool_sset	drivers/net/mii	EXPORT_SYMBOL
+0x5c02483f	videobuf_querybuf	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xd31f56d7	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x3d437f4b	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x958dc374	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0xaa84a8ae	acpi_processor_power_init_bm_check	vmlinux	EXPORT_SYMBOL
+0x4ce9b576	snd_hda_check_board_codec_sid_config	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xb602c57e	nf_ct_l3proto_module_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xbcf62f8c	wlp_dev_prim_OUI_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xf51743d8	ib_get_cached_lmc	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x05a4e36d	drm_i2c_encoder_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xaadea34f	release_sock	vmlinux	EXPORT_SYMBOL
+0x50e7193a	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
+0x59bbeb33	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x5264cc7d	agp_backend_acquire	vmlinux	EXPORT_SYMBOL
+0xed0a299f	textsearch_destroy	vmlinux	EXPORT_SYMBOL
+0x5e652b50	snd_pcm_hw_constraint_msbits	sound/core/snd-pcm	EXPORT_SYMBOL
+0xcbaf4931	get_cmd_string	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xac8d723f	iwl_bss_info_changed	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xec8b6c8c	cx8802_unregister_driver	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0x673eb25d	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x57f8ce6f	sync_inode	vmlinux	EXPORT_SYMBOL
+0xb859f38b	krealloc	vmlinux	EXPORT_SYMBOL
+0x8f6b7950	set_irq_data	vmlinux	EXPORT_SYMBOL
+0x3a3d5bc8	oxygen_read32	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xd0e8f8de	snd_card_create	sound/core/snd	EXPORT_SYMBOL
+0x35e33c1e	nfs4_acl_write_who	fs/nfsd/nfsd	EXPORT_SYMBOL
+0xec780257	input_register_device	vmlinux	EXPORT_SYMBOL
+0x14cfe183	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x8a348811	snd_midi_event_reset_encode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0x00deeb07	__fscache_write_page	fs/fscache/fscache	EXPORT_SYMBOL
+0xdb509451	gigaset_stop	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x2ba707a8	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0xfa6261e9	led_classdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x0e23cbea	ata_sff_qc_issue	vmlinux	EXPORT_SYMBOL_GPL
+0x1163f0a7	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0xa0216fd1	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x23ebbd94	simple_sync_file	vmlinux	EXPORT_SYMBOL
+0xb803d10e	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x6a27bfce	csum_partial_copy_generic	vmlinux	EXPORT_SYMBOL
+0xc6b1163f	mdio45_links_ok	drivers/net/mdio	EXPORT_SYMBOL
+0xcb7416b8	drm_idlelock_release	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x015651d6	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x064defd0	atm_dev_register	net/atm/atm	EXPORT_SYMBOL
+0x4b01887d	pp_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0xea370795	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x0e5b1797	ima_iint_find_insert_get	vmlinux	EXPORT_SYMBOL_GPL
+0x2e978a76	inotify_init_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x6fe3d8cf	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0xf9a482f9	msleep	vmlinux	EXPORT_SYMBOL
+0x56804df0	snd_opl4_read	sound/drivers/opl4/snd-opl4-lib	EXPORT_SYMBOL
+0xae63cfc8	dca3_get_tag	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0xcc19edb9	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x8f366f33	sata_async_notification	vmlinux	EXPORT_SYMBOL_GPL
+0x878ef0a1	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x82110046	__bforget	vmlinux	EXPORT_SYMBOL
+0xa979030d	__audit_inode_child	vmlinux	EXPORT_SYMBOL_GPL
+0x309ee040	xdr_reserve_space	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x8e55093f	set_h225_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xa4ec830c	inet6_add_protocol	net/ipv6/ipv6	EXPORT_SYMBOL
+0x76b79bf1	p9stat_read	net/9p/9pnet	EXPORT_SYMBOL
+0x93a67ec8	uwb_pal_unregister	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xe0ff7a18	unregister_pppox_proto	drivers/net/pppox	EXPORT_SYMBOL
+0x9834b755	ab3100_event_registers_startup_state_get	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0xfb2fb510	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x839f6559	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
+0xca72a5f7	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0xda27772f	md_unregister_thread	vmlinux	EXPORT_SYMBOL
+0x9984c858	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x52ad768b	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x79aa04a2	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0xab600421	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0xf0f1c21c	rpcauth_unregister	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x77e0f8fa	fc_eh_host_reset	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xd33d7b9c	ipmi_smi_add_proc_entry	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xb804be91	tcf_exts_destroy	vmlinux	EXPORT_SYMBOL
+0xdaf4dfb3	fb_mode_option	vmlinux	EXPORT_SYMBOL_GPL
+0xc39be05e	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x96fafe85	rds_stats_info_copy	net/rds/rds	EXPORT_SYMBOL_GPL
+0x01c7dda4	cnic_register_driver	drivers/net/cnic	EXPORT_SYMBOL
+0x66b3ad2a	sdio_unregister_driver	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xc5ae143e	dm_exception_store_type_unregister	drivers/md/dm-snapshot	EXPORT_SYMBOL
+0xd29316b6	input_free_polled_device	drivers/input/input-polldev	EXPORT_SYMBOL
+0x6cc02c84	drm_mode_connector_attach_encoder	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4b8d21ee	tcf_hash_lookup	vmlinux	EXPORT_SYMBOL
+0x3535e59d	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x512bbc2f	regulator_get	vmlinux	EXPORT_SYMBOL_GPL
+0xe154fdde	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x18df9c18	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x6fe22814	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x4d9b6d35	snd_pcm_format_size	sound/core/snd-pcm	EXPORT_SYMBOL
+0x0b9f91b8	unregister_ip_vs_scheduler	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x4bed44a9	cxgb3_unregister_client	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0x0153cccd	ib_alloc_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x6facdd31	drm_mode_detachmode_crtc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2939c955	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0xc11d8093	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x6a037cf1	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0xd5794c89	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x69fe03a1	register_quota_format	vmlinux	EXPORT_SYMBOL
+0x0d6f0247	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x99abdaf8	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x52760ca9	getnstimeofday	vmlinux	EXPORT_SYMBOL
+0xad87613e	snd_print_pcm_rates	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xb9f24b83	snd_opl4_create	sound/drivers/opl4/snd-opl4-lib	EXPORT_SYMBOL
+0x967511d8	snd_opl3_create	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0x1b734d89	dccp_v4_conn_request	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0xf8f6cd7f	dib8000_set_gpio	drivers/media/dvb/frontends/dib8000	EXPORT_SYMBOL
+0x804e8f81	write_dst	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x3dd0688a	flexcop_pid_feed_control	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xcb07caac	phy_register_fixup	vmlinux	EXPORT_SYMBOL
+0x454676fe	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x7da28f12	nvram_check_checksum	vmlinux	EXPORT_SYMBOL
+0x582f0e5e	pci_vpd_truncate	vmlinux	EXPORT_SYMBOL
+0xb32dbfa1	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x80d752db	file_update_time	vmlinux	EXPORT_SYMBOL
+0xc0925145	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0xee76ec7e	inet6_csk_search_req	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0xf49bc67a	atm_pcr_goal	net/atm/atm	EXPORT_SYMBOL
+0x390447f3	mb_cache_entry_alloc	fs/mbcache	EXPORT_SYMBOL
+0xf3d0d7b6	uwb_rc_cmd_async	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xd3beab99	nand_correct_data	drivers/mtd/nand/nand_ecc	EXPORT_SYMBOL
+0x571d878d	xc5000_attach	drivers/media/common/tuners/xc5000	EXPORT_SYMBOL
+0xe85abb16	sis_info133_for_sata	drivers/ata/pata_sis	EXPORT_SYMBOL_GPL
+0xf03888df	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0xff02ce89	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x4380f105	relay_file_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x6a9f26c9	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x393fe7f3	sound_class	sound/soundcore	EXPORT_SYMBOL
+0xb67be1f1	snd_emu10k1_voice_alloc	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0x3fb4d161	snd_seq_kernel_client_dispatch	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xb387b246	rpc_wake_up_status	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf39bf4d9	put_cmsg	vmlinux	EXPORT_SYMBOL
+0xf41363c7	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x99cda0b5	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL
+0x51e7707c	filp_close	vmlinux	EXPORT_SYMBOL
+0xa9fcf31d	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x6c428572	svcauth_gss_flavor	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x8d1a827e	svcauth_gss_register_pseudoflavor	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x67b27ec1	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x1d3b695f	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x0eccfc4c	snd_hda_mixer_bind_ctls_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xa49a0f70	wlp_neighborhood_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xfb641264	usbnet_nway_reset	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xbb985ebc	saa7134_ts_unregister	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x7e6f1307	capi20_get_manufacturer	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x1972fce1	ether_setup	vmlinux	EXPORT_SYMBOL
+0xda684663	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xf3c01334	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0xa7592c4e	__break_lease	vmlinux	EXPORT_SYMBOL
+0xeb504fb7	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x9f2d613e	param_set_bool	vmlinux	EXPORT_SYMBOL
+0xd344f2d5	async_tx_quiesce	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL
+0xbae34c27	scsi_nl_remove_transport	vmlinux	EXPORT_SYMBOL_GPL
+0xb5418861	atomic64_add	vmlinux	EXPORT_SYMBOL
+0x852b503f	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x30191a43	force_sig	vmlinux	EXPORT_SYMBOL
+0x16756dc0	snd_usbmidi_input_start	sound/usb/snd-usb-lib	EXPORT_SYMBOL
+0x210f3c39	parport_ieee1284_read_nibble	drivers/parport/parport	EXPORT_SYMBOL
+0xfc2c93e1	wm831x_auxadc_read_uv	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x495426ee	v4l2_ctrl_get_name	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x33176cb5	pci_set_dma_max_seg_size	vmlinux	EXPORT_SYMBOL
+0x05240ee7	percpu_counter_batch	vmlinux	EXPORT_SYMBOL
+0x7006c031	d_path	vmlinux	EXPORT_SYMBOL
+0x79a7e516	vring_del_virtqueue	drivers/virtio/virtio_ring	EXPORT_SYMBOL_GPL
+0x044b877a	scsi_is_fc_vport	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xe8f617eb	mISDN_unregister_clock	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x9d1422a3	b1dma_load_firmware	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x7d411c86	acpi_notifier_call_chain	vmlinux	EXPORT_SYMBOL
+0x1ff69dd8	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x6f6c0230	hci_free_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x8d9c2489	usbnet_resume	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xaee06d61	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x80127f5d	bio_integrity_tag_size	vmlinux	EXPORT_SYMBOL
+0x6b92c3b1	igrab	vmlinux	EXPORT_SYMBOL
+0x55dd9aaf	snd_pcm_open_substream	sound/core/snd-pcm	EXPORT_SYMBOL
+0x8a68b9ac	ssb_device_disable	drivers/ssb/ssb	EXPORT_SYMBOL
+0x01b34f51	libipw_txb_free	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x8a2db3b1	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0xb0247701	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0xf553db1b	per_cpu__softnet_data	vmlinux	EXPORT_SYMBOL
+0x1d002dce	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x9aa3745d	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL
+0x1866ba0f	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0xab95bd05	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0xd16712f3	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x16305289	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0xeb4f6d73	snd_ac97_update	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xf2f21693	snd_device_free	sound/core/snd	EXPORT_SYMBOL
+0xe4ed04ad	nf_ct_l3protos	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x797d7e96	nand_calculate_ecc	drivers/mtd/nand/nand_ecc	EXPORT_SYMBOL
+0x43300a29	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0xe3aceb6d	regulator_set_optimum_mode	vmlinux	EXPORT_SYMBOL_GPL
+0xca138214	xenbus_dev_error	vmlinux	EXPORT_SYMBOL_GPL
+0x5ac376a5	acpi_install_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x3da5eb6d	kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x02fa9d74	oxygen_pci_suspend	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xd58ec0cc	ndisc_build_skb	net/ipv6/ipv6	EXPORT_SYMBOL
+0x1598dc9d	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x34eeea7a	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x44a907dd	rpc_queue_upcall	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0eba74e0	sdhci_remove_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0xa03727a1	v4l2_i2c_subdev_init	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0x8d39666d	v4l2_i2c_subdev_addr	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0xa338381a	hiddev_hid_event	vmlinux	EXPORT_SYMBOL_GPL
+0x07dabf57	mddev_congested	vmlinux	EXPORT_SYMBOL
+0x9a73db6d	snd_pcm_period_elapsed	sound/core/snd-pcm	EXPORT_SYMBOL
+0xad1e038b	usbatm_usb_probe	drivers/usb/atm/usbatm	EXPORT_SYMBOL_GPL
+0x5ecf60af	fcoe_ctlr_link_up	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0x991fd047	i2400m_dev_bootstrap	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0xb6011c0c	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL
+0xd6a8b367	snd_hda_mixer_amp_volume_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x5ae76f73	auto_pin_cfg_labels	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x83e337fb	mlx4_qp_query	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x92e38b10	lgs8gl5_attach	drivers/media/dvb/frontends/lgs8gl5	EXPORT_SYMBOL
+0x8f699913	capilib_release	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x7a33596c	capi20_get_serial	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x981dc096	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x31ab833d	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL
+0x4063e440	snd_emu10k1_synth_copy_from_user	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0x75d40fe0	tifm_alloc_device	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x233ca0dc	b1dma_interrupt	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x412e794d	skb_append	vmlinux	EXPORT_SYMBOL
+0xee6d3c8c	pciserial_suspend_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x2dcb0123	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0xab56bc40	cfg80211_wireless_stats	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xea0e51bb	uwb_rc_mac_addr_get	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xb027c0ee	uwb_rc_dev_addr_get	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x016a8264	usb_stor_CB_reset	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x5ff22cf7	iscsi_tcp_segment_unmap	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xec6fd579	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0xaa403b61	audit_log_start	vmlinux	EXPORT_SYMBOL
+0xf0cc97ab	oxygen_write8_masked	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xb1910398	iwl_mac_remove_interface	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x14dfecc6	saa7134_boards	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x5ff42b08	acpi_video_get_capabilities	vmlinux	EXPORT_SYMBOL
+0x876dafc3	ec_write	vmlinux	EXPORT_SYMBOL
+0x2bc95bd4	memset	vmlinux	EXPORT_SYMBOL
+0xde37d03c	sget	vmlinux	EXPORT_SYMBOL
+0xd62e0e23	set_irq_chip	vmlinux	EXPORT_SYMBOL
+0xa8c468b5	ip6_dst_blackhole	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x5fdba6e7	tcp_vegas_pkts_acked	net/ipv4/tcp_vegas	EXPORT_SYMBOL_GPL
+0x24527d30	hci_send_sco	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xfead5635	uwb_rc_get_by_grandpa	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x2b1635d2	iscsi_tcp_dgst_header	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xcadc74dd	ttm_bo_unmap_virtual	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xa3240ec5	cdrom_media_changed	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xcb10ba71	blk_queue_max_hw_segments	vmlinux	EXPORT_SYMBOL
+0x02ee26c1	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0xe7a79fd1	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x0b0e2c73	snd_ak4114_build	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0xd9e7547b	mlx4_cq_modify	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xf0eff2dd	videobuf_dma_free	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0xa4ce64aa	cx88_set_control	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0x064db9a5	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x4550ba8a	register_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0x6d340f64	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x25d3e2a3	atomic64_dec_return	vmlinux	EXPORT_SYMBOL
+0x5a1b8f5f	per_cpu__cpu_sibling_map	vmlinux	EXPORT_SYMBOL
+0x1e72c603	spi_attach_transport	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0xefcb88d2	iwl_send_add_sta	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x23c2d883	ib_alloc_fast_reg_page_list	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x46b9d74b	unregister_cdrom	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0x2e47f677	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x2cb89191	unregister_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x8009cbd4	ps2_drain	vmlinux	EXPORT_SYMBOL
+0xf0af967a	tpm_show_temp_deactivated	vmlinux	EXPORT_SYMBOL_GPL
+0x028a205a	drm_agp_bind	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xc9ec8704	udp_table	vmlinux	EXPORT_SYMBOL
+0x31970273	agp3_generic_tlbflush	vmlinux	EXPORT_SYMBOL
+0xdcbae479	pnp_get_resource	vmlinux	EXPORT_SYMBOL
+0x645d3db6	acpi_bus_get_status	vmlinux	EXPORT_SYMBOL
+0xb30abf8d	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0xe48f3039	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x1b0d2065	ring_buffer_record_disable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x552789c0	snd_hda_is_supported_format	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x73aac73d	rds_message_populate_header	net/rds/rds	EXPORT_SYMBOL_GPL
+0x90a0a0ca	__lbtf_cmd	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0xa5228b24	v4l2_int_device_try_attach_all	drivers/media/video/v4l2-int-device	EXPORT_SYMBOL_GPL
+0x9afdfd48	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0xaf3dd7dc	scsi_logging_level	vmlinux	EXPORT_SYMBOL
+0x827ff72f	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x9d06688b	register_xenbus_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x518c7d36	nla_put	vmlinux	EXPORT_SYMBOL
+0x93800b61	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0xb98ef804	vm_stat	vmlinux	EXPORT_SYMBOL
+0xa329f07e	register_shrinker	vmlinux	EXPORT_SYMBOL
+0xeee22fb9	register_sound_dsp	sound/soundcore	EXPORT_SYMBOL
+0x285fec13	ipmi_register_smi	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xf6bcbd73	hwrng_register	vmlinux	EXPORT_SYMBOL_GPL
+0x0357ff4b	misc_register	vmlinux	EXPORT_SYMBOL
+0x8246fcdf	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x6cbdfc1d	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x636b12c8	nf_nat_need_gre	net/ipv4/netfilter/nf_nat_proto_gre	EXPORT_SYMBOL_GPL
+0x17ce645d	locks_end_grace	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x79271f0b	dvb_usb_device_init	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0x21b2fb0f	ib_init_ah_from_mcmember	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x5caf5ad7	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0xc460b8df	ata_sff_wait_ready	vmlinux	EXPORT_SYMBOL_GPL
+0x89c43fb7	dev_attr_unload_heads	vmlinux	EXPORT_SYMBOL_GPL
+0xe236b244	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x18494003	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x72bf2140	mtrr_add	vmlinux	EXPORT_SYMBOL
+0x1e8dc9da	dccp_sendmsg	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x59116015	i2400m_rx	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x1d818afb	i2400m_tx	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0xa5920763	wm8350_unmask_irq	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x7bee80f2	clip_tbl_hook	vmlinux	EXPORT_SYMBOL
+0xbfee3ad5	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL
+0x405466fe	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0xb07dfb3d	acpi_remove_gpe_handler	vmlinux	EXPORT_SYMBOL
+0x7a21541b	blk_integrity_unregister	vmlinux	EXPORT_SYMBOL
+0x83442de2	iget_failed	vmlinux	EXPORT_SYMBOL
+0xc3880471	xdr_decode_netobj	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x964a6bee	__fscache_acquire_cookie	fs/fscache/fscache	EXPORT_SYMBOL
+0x1a0def3b	input_register_polled_device	drivers/input/input-polldev	EXPORT_SYMBOL
+0xed2481b4	ethtool_op_set_tso	vmlinux	EXPORT_SYMBOL
+0xda08c0d7	pcibios_get_irq_routing_table	vmlinux	EXPORT_SYMBOL
+0xb3689929	sata_set_spd	vmlinux	EXPORT_SYMBOL_GPL
+0x24d8b179	pci_restore_state	vmlinux	EXPORT_SYMBOL
+0xe292cb33	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x20b3857d	register_atm_ioctl	net/atm/atm	EXPORT_SYMBOL
+0xa8d6daac	iTCO_vendor_pre_start	drivers/watchdog/iTCO_vendor_support	EXPORT_SYMBOL
+0xbeb8df49	ssb_pmu_set_ldo_paref	drivers/ssb/ssb	EXPORT_SYMBOL
+0x796a740e	flexcop_dma_config_timer	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x91093aa3	flexcop_device_initialize	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x17b48928	acpi_bus_trim	vmlinux	EXPORT_SYMBOL_GPL
+0x99aabfc7	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x7c8573af	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x34e0f0ed	svc_unreg_xprt_class	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xb1ce314b	usb_serial_generic_write	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xd34c7f95	scsi_tgt_it_nexus_destroy	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0x89ef19a9	pps_register_source	drivers/pps/pps_core	EXPORT_SYMBOL
+0x27dbe8c1	mlx4_buf_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x6179536a	ib_cm_notify	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xb4470d5c	arp_xmit	vmlinux	EXPORT_SYMBOL
+0xf86bd87e	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x3b245e5b	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0xcb5e2def	mdiobus_register	vmlinux	EXPORT_SYMBOL
+0xb8fa8873	agp_enable	vmlinux	EXPORT_SYMBOL
+0x6ade5801	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL
+0x2f2a8c76	__remove_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x1a75caa3	_read_lock	vmlinux	EXPORT_SYMBOL
+0xc1143fcd	snd_timer_interrupt	sound/core/snd-timer	EXPORT_SYMBOL
+0xedcf6be4	qword_add	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0a8c4f6c	fc_eh_device_reset	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xbe986978	ppp_register_net_channel	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xe3d53987	sdio_claim_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x525b2c45	capi_ctr_suspend_output	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xf09fa58f	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0xb73d8c1f	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x5f569535	bdi_init	vmlinux	EXPORT_SYMBOL
+0x851ec372	usbnet_probe	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x2e4a39f8	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x17df17bc	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0xce36ded6	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL
+0x6fe009ed	ethtool_op_set_tx_csum	vmlinux	EXPORT_SYMBOL
+0x6c831666	md_register_thread	vmlinux	EXPORT_SYMBOL
+0x4b224a48	snd_sbmixer_suspend	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0x0f21408e	ieee80211_stop_tx_ba_session	net/mac80211/mac80211	EXPORT_SYMBOL
+0x0b260441	generic_mii_ioctl	drivers/net/mii	EXPORT_SYMBOL
+0x0614dd5a	v4l2_video_std_frame_period	drivers/media/video/videodev	EXPORT_SYMBOL
+0x495804bd	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x8e30c0e4	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x0334da4e	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0xb58dcfa2	synchronize_sched_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x767ddb02	set_memory_wc	vmlinux	EXPORT_SYMBOL
+0x91607d95	set_memory_wb	vmlinux	EXPORT_SYMBOL
+0x247d3a62	xprt_wake_pending_tasks	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3c163808	bt_accept_dequeue	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x2d579390	p9_client_wstat	net/9p/9pnet	EXPORT_SYMBOL
+0x5d0fbe38	fc_rport_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x43780c6b	fc_lport_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x1ee49487	generic_rndis_bind	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0x0283ef95	tcf_unregister_action	vmlinux	EXPORT_SYMBOL
+0xe2330b96	bitmap_endwrite	vmlinux	EXPORT_SYMBOL
+0xb6101001	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x52026cdf	security_sb_parse_opts_str	vmlinux	EXPORT_SYMBOL
+0x15ef2dd9	kfifo_free	vmlinux	EXPORT_SYMBOL
+0x752ccc64	per_cpu__cpu_info	vmlinux	EXPORT_SYMBOL
+0xb9f5d752	videobuf_mmap_mapper	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x2c805e3d	zl10039_attach	drivers/media/dvb/frontends/zl10039	EXPORT_SYMBOL
+0x3389f926	cfag12864b_enable	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0xd3d7818d	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0xfedb8025	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0xab5d7dbb	acpiphp_register_attention	vmlinux	EXPORT_SYMBOL_GPL
+0x7521afb6	leave_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x095c4971	__ieee80211_get_radio_led_name	net/mac80211/mac80211	EXPORT_SYMBOL
+0xef345ef2	in6_dev_finish_destroy	net/ipv6/ipv6	EXPORT_SYMBOL
+0x22e2c782	jbd2_journal_init_dev	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x8cc36c4b	fscache_add_cache	fs/fscache/fscache	EXPORT_SYMBOL
+0xcf9f3328	dlm_release_lockspace	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0xbdea8446	sas_expander_alloc	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x9c24eef8	ib_umem_page_count	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x2072b73f	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0xcc119a2a	eth_header	vmlinux	EXPORT_SYMBOL
+0xacefec75	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x5bfc03c3	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xfd51b281	gnttab_end_foreign_access_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x8cf111fd	acpi_unlock_ac_dir	vmlinux	EXPORT_SYMBOL
+0x786f359c	unregister_framebuffer	vmlinux	EXPORT_SYMBOL
+0x201bc344	pci_sriov_migration	vmlinux	EXPORT_SYMBOL_GPL
+0x8f48679a	rb_prev	vmlinux	EXPORT_SYMBOL
+0xe3f66e73	user_match	vmlinux	EXPORT_SYMBOL_GPL
+0x70492bb2	request_key_async_with_auxdata	vmlinux	EXPORT_SYMBOL
+0xea065e01	task_handoff_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xef36a490	down_killable	vmlinux	EXPORT_SYMBOL
+0x5b3d1c1e	iwl_mac_hw_scan	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x8f91d6c8	capi20_register	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x59aab179	ib_umem_get	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x334a98e3	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x0eec0366	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x9b65f908	phonet_stream_ops	net/phonet/phonet	EXPORT_SYMBOL
+0x10129995	rt2x00mac_get_stats	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xb95eeb2b	i2400m_setup	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0xf0b259d2	wm8350_reg_write	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x06d728b1	tcp_parse_md5sig_option	vmlinux	EXPORT_SYMBOL
+0x22e2a86c	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL
+0x24eb7e32	leds_list	vmlinux	EXPORT_SYMBOL_GPL
+0x04c3f2c1	gnttab_empty_grant_references	vmlinux	EXPORT_SYMBOL_GPL
+0x35f0faa2	acpi_evaluate_object	vmlinux	EXPORT_SYMBOL
+0xeae3dfd6	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x7bef6bd6	snd_ac97_resume	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xb44b3da7	capi_ctr_handle_message	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xd037e910	ipmi_smi_msg_received	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x58743d0f	handle_sysrq	vmlinux	EXPORT_SYMBOL
+0x4f7bd9aa	pcie_port_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x1cc6719a	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0xf5c9012e	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0xb2935f53	ieee80211_queue_work	net/mac80211/mac80211	EXPORT_SYMBOL
+0x260ce19f	dccp_send_ack	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xb12c702a	scsi_tgt_queue_command	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0xdfd28376	b1_detect	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x27b35c51	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x72b9b4bd	tpm_show_active	vmlinux	EXPORT_SYMBOL_GPL
+0x3e2ae3a8	acpi_release_global_lock	vmlinux	EXPORT_SYMBOL
+0xaed25dda	p54_free_skb	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0x7858ab04	iwl_scan_cancel	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xd1ae6e7c	usbnet_tx_timeout	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x5b88faf6	cx2341x_ext_ctrls	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0xcf683cf2	saa7146_devices	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x26c515e8	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x6e07a54e	acpi_get_gpe_status	vmlinux	EXPORT_SYMBOL
+0xfb633a16	snd_pcm_hw_param_first	sound/core/snd-pcm	EXPORT_SYMBOL
+0x681f028e	uwb_rc_neh_error	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x23694c88	memstick_resume_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x454aa44f	gigaset_debuglevel	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xd4930023	add_mtd_partitions	vmlinux	EXPORT_SYMBOL
+0xa3994259	pci_select_bars	vmlinux	EXPORT_SYMBOL
+0xf184d189	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x6e1b196c	snd_hda_queue_unsol_event	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x9f725576	snd_pcm_new	sound/core/snd-pcm	EXPORT_SYMBOL
+0x4cbebacb	svc_create_pooled	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xed96e57e	ip6t_unregister_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL
+0x1774731c	sas_read_port_mode_page	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x18386239	sas_unregister_ha	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x8923996b	iwl_update_tkip_key	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xe63fa030	mlx4_register_interface	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x3f3b323a	isac_d_l2l1	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0x36950961	ib_find_gid	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x7303f851	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0xc7eaa8d3	__ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0xd625b332	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0xabce128f	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0xc26351f8	bind_evtchn_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x0a1e87f9	atomic64_add_negative	vmlinux	EXPORT_SYMBOL
+0xfd1d9b02	blk_rq_count_integrity_sg	vmlinux	EXPORT_SYMBOL
+0xcefe6717	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL
+0x58493baa	qtree_write_dquot	vmlinux	EXPORT_SYMBOL
+0x176716d3	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x93080ee2	journal_get_undo_access	fs/jbd/jbd	EXPORT_SYMBOL
+0x8546b18b	if_usb_prog_firmware	drivers/net/wireless/libertas_tf/libertas_tf_usb	EXPORT_SYMBOL_GPL
+0x9061d9fb	videobuf_dma_sync	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x920859b9	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x24c6dc04	acpi_lock_ac_dir	vmlinux	EXPORT_SYMBOL
+0xfec3c2f2	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x90ff6c9f	nf_ct_invert_tuplepr	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xa31b52e1	mlx4_free_hwq_res	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xfe3170c7	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x56310925	regulator_mode_to_status	vmlinux	EXPORT_SYMBOL_GPL
+0x1844189a	fb_set_suspend	vmlinux	EXPORT_SYMBOL
+0x99fa3f62	dput	vmlinux	EXPORT_SYMBOL
+0x95e40ffc	is_container_init	vmlinux	EXPORT_SYMBOL
+0x5bd26000	rpc_proc_unregister	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xdde6f44e	rpc_delay	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0d2a8ca0	rfkill_set_sw_state	net/rfkill/rfkill	EXPORT_SYMBOL
+0xa637b42b	fill_inquiry_response	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x5a67fb85	tcp_v4_remember_stamp	vmlinux	EXPORT_SYMBOL
+0x999be1da	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL
+0xc428068d	sata_deb_timing_long	vmlinux	EXPORT_SYMBOL_GPL
+0x04f26915	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x4bf8c268	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x0b14eef5	mISDNisar_irq	drivers/isdn/hardware/mISDN/mISDNisar	EXPORT_SYMBOL
+0x7754f3ef	mISDNisac_irq	drivers/isdn/hardware/mISDN/mISDNipac	EXPORT_SYMBOL
+0x68734aef	drm_vblank_pre_modeset	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9886c895	sk_free	vmlinux	EXPORT_SYMBOL
+0xfdc1a0a7	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x2a303d4d	check_signature	vmlinux	EXPORT_SYMBOL
+0x8c35d732	ieee80211_hdrlen	net/wireless/cfg80211	EXPORT_SYMBOL
+0xf98f057a	ieee80211_stop_queue	net/mac80211/mac80211	EXPORT_SYMBOL
+0xfb6c83c3	jbd2_journal_update_format	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xc16263b8	parport_set_timeout	drivers/parport/parport	EXPORT_SYMBOL
+0xf3251e7b	v4l2_norm_to_name	drivers/media/video/videodev	EXPORT_SYMBOL
+0xc6c0f127	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL
+0x5692df09	kobject_init	vmlinux	EXPORT_SYMBOL
+0xce4d1d56	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x6b9b88f3	sleep_on	vmlinux	EXPORT_SYMBOL
+0xa2ee8330	dccp_ioctl	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x954f17b3	parport_read	drivers/parport/parport	EXPORT_SYMBOL
+0xb1c091e5	mpt_suspend	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x9f64a95a	smscore_register_device	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x2377d74f	ata_link_online	vmlinux	EXPORT_SYMBOL_GPL
+0x9486ec90	key_type_user	vmlinux	EXPORT_SYMBOL_GPL
+0xadccda3d	simple_lookup	vmlinux	EXPORT_SYMBOL
+0xf6a7a427	p9_client_clunk	net/9p/9pnet	EXPORT_SYMBOL
+0x13132a4e	wlp_eda_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x5f5c959a	dm_io	drivers/md/dm-mod	EXPORT_SYMBOL
+0x694b1f06	ib_query_srq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xef4e831e	drm_idlelock_take	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xf78d04ab	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0xa8d7791e	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
+0x54a6d074	atomic64_dec	vmlinux	EXPORT_SYMBOL
+0x126f7a3d	bio_integrity_endio	vmlinux	EXPORT_SYMBOL
+0x184b82fb	mmc_vddrange_to_ocrmask	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xaff22e87	ir_codes_pixelview_new_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x87b614d8	ib_ud_header_pack	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xccc51f36	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0xc26e32b7	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x72a947c2	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x1af40e18	__copy_from_user_ll	vmlinux	EXPORT_SYMBOL
+0xf28bf68b	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x917a43e6	get_sb_ns	vmlinux	EXPORT_SYMBOL
+0xbe116723	do_posix_clock_nosettime	vmlinux	EXPORT_SYMBOL_GPL
+0x20e9d463	snd_opl3_timer_new	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0x1b96f127	ip_vs_conn_put	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x5432d87a	osd_WaitEventSet	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0x85b75821	iscsi_session_chkready	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xa69b37cd	sdio_f0_writeb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xdaf02533	dib7000p_attach	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x0ba3d611	dib7000m_attach	drivers/media/dvb/frontends/dib7000m	EXPORT_SYMBOL
+0xdfceb958	capi20_put_message	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x8e77781d	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x99047abf	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x2f221636	skb_push	vmlinux	EXPORT_SYMBOL
+0x3054411f	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x9eaa7941	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x08a0569f	alloc_file	vmlinux	EXPORT_SYMBOL
+0x07e54df1	free_task	vmlinux	EXPORT_SYMBOL
+0x9d7bfe13	tcp_vegas_get_info	net/ipv4/tcp_vegas	EXPORT_SYMBOL_GPL
+0xea964f50	rndis_status	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0x17f70959	i2c_del_adapter	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xb0d7f93b	drm_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x5838f6c9	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x7cc2bae6	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x40bb51d2	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0xa8ecbe6d	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x99c95fa5	unregister_sound_special	sound/soundcore	EXPORT_SYMBOL
+0x287d9aad	fat_dir_empty	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x356c926f	sas_end_device_alloc	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xa3cbf0be	mmc_release_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xb3a8e984	ata_port_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x94cdab82	__getblk	vmlinux	EXPORT_SYMBOL
+0x10c0ea88	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x2d055670	snd_hda_mixer_amp_tlv	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x142ac657	snd_hda_input_mux_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xebd53668	mlx4_qp_reserve_range	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x02a7ec58	dvb_dmx_swfilter_packets	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x0089232a	iw_cm_connect	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x019aded0	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL
+0xf502d273	acpi_get_current_resources	vmlinux	EXPORT_SYMBOL
+0xe78b218a	vfs_quota_sync	vmlinux	EXPORT_SYMBOL
+0xd0efe320	iTCO_vendor_pre_stop	drivers/watchdog/iTCO_vendor_support	EXPORT_SYMBOL
+0x178e0b3c	wlp_dev_model_name_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x6ac4f8e4	get_phy_device	vmlinux	EXPORT_SYMBOL
+0x077ca269	ata_cable_sata	vmlinux	EXPORT_SYMBOL_GPL
+0xf02f32a0	svc_exit_thread	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbdae1062	rds_message_unmapped	net/rds/rds	EXPORT_SYMBOL_GPL
+0x884ec103	dlm_posix_lock	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0xed65a683	ubi_leb_map	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x11906593	cx88_newstation	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x1f3abd65	ipmi_smi_watchdog_pretimeout	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x79d418e5	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x67053080	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x198bf42b	snd_wss_get_double	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xa84c4d35	snd_wss_put_double	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x37400bfb	print_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x7a18127e	gigaset_initcs	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x6d9ee9bb	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x5a744b86	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0xb8e88a4d	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x90117a85	ata_sas_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x84eac044	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0xb2425b4b	fc_lport_reset	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x6a527d26	em28xx_audio_analog_set	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x93a64734	FsmChangeState	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x0493404e	netpoll_poll	vmlinux	EXPORT_SYMBOL
+0x4b359cb7	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x9428f243	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x2da02af8	scsi_nl_add_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x3d227a7f	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL
+0x99b88ede	snd_vx_irq_handler	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xd7f4837e	inet6_del_protocol	net/ipv6/ipv6	EXPORT_SYMBOL
+0x04799f9b	orinoco_init	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x872358d8	drm_class_device_register	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL
+0xda0255fd	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x77aacfee	udplite_prot	vmlinux	EXPORT_SYMBOL
+0xf585c820	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0xc7a70e0f	pcmcia_eject_card	vmlinux	EXPORT_SYMBOL
+0x74189dc6	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0xf972e85e	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x4326f770	bio_integrity_enabled	vmlinux	EXPORT_SYMBOL
+0x162d6ad5	iwl_eeprom_init	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xe1d342ed	drm_gtf_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2a678a13	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0xf690ebf6	vga_tryget	vmlinux	EXPORT_SYMBOL
+0xdfc25575	regulator_count_voltages	vmlinux	EXPORT_SYMBOL_GPL
+0xa89acbb3	acpi_evaluate_reference	vmlinux	EXPORT_SYMBOL
+0x4b86a66c	snd_timer_open	sound/core/snd-timer	EXPORT_SYMBOL
+0x40075992	snd_rawmidi_transmit_empty	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0xf741c793	zlib_deflateEnd	lib/zlib_deflate/zlib_deflate	EXPORT_SYMBOL
+0x06cde219	stop_airo_card	drivers/net/wireless/airo	EXPORT_SYMBOL
+0xc5dff24c	fb_set_cmap	vmlinux	EXPORT_SYMBOL
+0x8c069ebc	pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0xb376d79d	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0xa878b7ba	unload_nls	vmlinux	EXPORT_SYMBOL
+0x128d1b5a	seq_open_private	vmlinux	EXPORT_SYMBOL
+0xb6bc49a9	__supported_pte_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x2212b098	oxygen_pci_remove	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xf85eef23	snd_jack_set_parent	sound/core/snd	EXPORT_SYMBOL
+0x67b2600a	sunrpc_cache_update	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x38905ef1	v9fs_get_trans_by_name	net/9p/9pnet	EXPORT_SYMBOL
+0x5768bd15	dvb_dmx_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x0d84b227	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x8dc5f47e	kernel_listen	vmlinux	EXPORT_SYMBOL
+0xa5f72c2e	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x719b182c	pnp_register_card_driver	vmlinux	EXPORT_SYMBOL
+0x76bf656d	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0xeca17c34	dquot_free_space	vmlinux	EXPORT_SYMBOL
+0x740bc630	gss_mech_get	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0xbc03d38b	nat_rtp_rtcp_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0x8d52ac07	ebt_unregister_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL
+0xd83ef901	fc_eh_abort	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x934c97c2	fc_set_rport_loss_tmo	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xf4e85c6a	wm8350_device_init	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x5254838e	ib_alloc_fast_reg_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x908bc88a	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0xb60ab30c	ata_bmdma_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x1958075c	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x2e60bace	memcpy	vmlinux	EXPORT_SYMBOL
+0xe23ae481	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x870404b8	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0xe6bb47af	rpc_run_task	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xea661fda	ip6t_do_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL
+0xd29b009f	crc_itu_t_table	lib/crc-itu-t	EXPORT_SYMBOL
+0x48e7b304	spi_release_transport	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0x6871bdfc	iwl_rx_pm_debug_statistics_notif	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x11dc4b6d	bttv_gpio_enable	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0x9c56fd34	ib_sa_unregister_client	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x916fc16a	ata_std_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x40c89d46	acpi_get_table_by_index	vmlinux	EXPORT_SYMBOL
+0x478d10b2	ht_destroy_irq	vmlinux	EXPORT_SYMBOL
+0xfbeb862e	bdevname	vmlinux	EXPORT_SYMBOL
+0x9b55d1e2	cdev_init	vmlinux	EXPORT_SYMBOL
+0x82450247	init_file	vmlinux	EXPORT_SYMBOL
+0x764bd77c	request_resource	vmlinux	EXPORT_SYMBOL
+0x3c8257ca	snd_hda_mixer_bind_ctls_get	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xfc76689e	snd_unregister_oss_device	sound/core/snd	EXPORT_SYMBOL
+0x8df7186e	nf_ct_expect_init	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xca519b27	fc_exch_alloc	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x100851d1	nand_scan_bbt	drivers/mtd/nand/nand	EXPORT_SYMBOL
+0x8fad9386	inet_getname	vmlinux	EXPORT_SYMBOL
+0x95bd6200	agp_generic_insert_memory	vmlinux	EXPORT_SYMBOL
+0x85e7deb2	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x98b0cd12	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0xbb44706d	soc_camera_xlate_by_fourcc	drivers/media/video/soc_camera	EXPORT_SYMBOL
+0x82d4f54c	dm_get_mapinfo	drivers/md/dm-mod	EXPORT_SYMBOL
+0x7ae3b09c	drm_mode_config_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2d307ba8	put_mtd_device	vmlinux	EXPORT_SYMBOL_GPL
+0x2fcd9e17	dpm_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x01d19038	acpi_enable_subsystem	vmlinux	EXPORT_SYMBOL
+0xbf9bcc8d	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0xcd03270c	xprt_register_transport	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xfc406bbb	ieee80211_start_tx_ba_cb	net/mac80211/mac80211	EXPORT_SYMBOL
+0xac5da11f	iwl_eeprom_query16	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2ce3f208	dibx000_get_i2c_adapter	drivers/media/dvb/frontends/dibx000_common	EXPORT_SYMBOL
+0xd7d811f1	i2c_smbus_process_call	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xcb7e8740	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x48ffb877	pci_disable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x90bf821e	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x0336ccc0	iput	vmlinux	EXPORT_SYMBOL
+0x8733e9a3	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0xdc980ff0	xprt_complete_rqst	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x073da09c	pn_sock_unhash	net/phonet/phonet	EXPORT_SYMBOL
+0x5a157ae4	nfs4_acl_get_whotype	fs/nfsd/nfsd	EXPORT_SYMBOL
+0xf91fef15	iscsi_alloc_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x77733bcd	cx88_shutdown	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x0c98b955	capi_ctr_down	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xefe21106	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0xe929fc29	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x03eccf67	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x03fd2571	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x0ebc9885	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0xda0a6b0e	acpi_map_lsapic	vmlinux	EXPORT_SYMBOL
+0x43e622a2	fuse_sync_release	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0xa52e308c	mt352_attach	drivers/media/dvb/frontends/mt352	EXPORT_SYMBOL
+0xdad5bee3	mt312_attach	drivers/media/dvb/frontends/mt312	EXPORT_SYMBOL
+0x7509830f	to_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x003ffabd	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x92d31cfb	fixed_phy_add	vmlinux	EXPORT_SYMBOL_GPL
+0x17fbbf6d	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL
+0xeea9dbaf	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x71a50dbc	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x0b4ac0a8	simple_set_mnt	vmlinux	EXPORT_SYMBOL
+0x1b9aca3f	jprobe_return	vmlinux	EXPORT_SYMBOL_GPL
+0x00a467af	rds_wq	net/rds/rds	EXPORT_SYMBOL_GPL
+0xee5e7a12	nf_conntrack_alter_reply	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x20c4df26	jbd2_journal_blocks_per_page	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x83eae5b7	wusbhc_chid_set	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xf0726fd1	if_usb_reset_device	drivers/net/wireless/libertas_tf/libertas_tf_usb	EXPORT_SYMBOL_GPL
+0x92a5a79c	sdhci_free_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0x6104d559	cx231xx_send_gpio_cmd	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x5e7fecd9	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x0c77a731	ata_sff_data_xfer_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x23d026b6	fb_firmware_edid	vmlinux	EXPORT_SYMBOL
+0x654c49e2	aer_irq	vmlinux	EXPORT_SYMBOL_GPL
+0xa847d95f	key_negate_and_link	vmlinux	EXPORT_SYMBOL
+0x936af453	snd_hda_codec_resume_cache	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x0a3445da	fscache_check_aux	fs/fscache/fscache	EXPORT_SYMBOL
+0x0864c4a4	dlm_new_lockspace	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0x6edb0b5f	ssb_bus_sdiobus_register	drivers/ssb/ssb	EXPORT_SYMBOL
+0x4cb4077f	iscsi_queuecommand	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x90d148eb	iw_cm_init_qp_attr	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x100c13c6	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0xaf8ec8e7	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0xd08197fa	acpi_load_tables	vmlinux	EXPORT_SYMBOL
+0x8a1203a9	kref_get	vmlinux	EXPORT_SYMBOL
+0xc33df894	cfg80211_unlink_bss	net/wireless/cfg80211	EXPORT_SYMBOL
+0x8de69060	iwlcore_eeprom_enhanced_txpower	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xccdafd1c	ttm_bo_init_mm	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x6edae968	ks0108_isinited	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0xcb83a698	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x33bfb958	__netdev_alloc_page	vmlinux	EXPORT_SYMBOL
+0x13dc31a7	inotify_inode_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0x3815901a	ring_buffer_resize	vmlinux	EXPORT_SYMBOL_GPL
+0x5741eab3	journal_errno	fs/jbd/jbd	EXPORT_SYMBOL
+0x0dd4a56c	usbnet_get_drvinfo	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xe8f449d5	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x7a205eaa	pci_disable_msi	vmlinux	EXPORT_SYMBOL
+0x761532ef	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x25a9db60	svc_wake_up	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5dbc0fec	xprt_write_space	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x7c2ea11c	ndisc_send_skb	net/ipv6/ipv6	EXPORT_SYMBOL
+0xee269067	journal_check_available_features	fs/jbd/jbd	EXPORT_SYMBOL
+0x9321df95	dlm_lock	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0x95aa5fa6	hostap_set_roaming	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x34d53c0b	videobuf_read_stream	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xbc6e76dc	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0xdba2a501	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x2d89342a	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0xda7ca6cb	fb_mode_is_equal	vmlinux	EXPORT_SYMBOL
+0x4b07e779	_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0xffc7c184	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x0a380b9f	cfg80211_wext_siwgenie	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x881298f2	nf_ct_get_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x8f060aae	xfrm6_tunnel_register	net/ipv6/tunnel6	EXPORT_SYMBOL
+0x5f4b3ebf	xfrm4_tunnel_register	net/ipv4/tunnel4	EXPORT_SYMBOL
+0x781400af	ssb_clockspeed	drivers/ssb/ssb	EXPORT_SYMBOL
+0x65515bcf	ib_init_ah_from_wc	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x32b76bef	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0xf78bdf7f	security_sb_set_mnt_opts	vmlinux	EXPORT_SYMBOL
+0x52d111ea	pm_qos_update_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x38cab31c	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x613ee35b	snd_pcm_lib_ioctl	sound/core/snd-pcm	EXPORT_SYMBOL
+0xf42029de	mISDN_unregister_device	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x5e55e318	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x1d21f60f	regulator_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x3d2124cc	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x3b3016d3	cpufreq_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0xe93e49c3	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x1c648524	single_release	vmlinux	EXPORT_SYMBOL
+0xb7b18281	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x90c09d49	jbd2_journal_restart	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xbcd8fa2a	jbd2_journal_destroy	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x99c7a8b8	jbd2_dev_to_name	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x50a5313f	mlx4_SYNC_TPT	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x18a4032e	v4l2_device_register	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0xa108eb4d	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x81c96bed	wm8350_isink_set_flash	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0x8019fc63	rt2x00queue_get_queue	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x69375d21	iwl_txq_ctx_stop	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xaccabc6a	in4_pton	vmlinux	EXPORT_SYMBOL
+0xe57878a1	in6_pton	vmlinux	EXPORT_SYMBOL
+0xf81eeb89	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x8a769352	cfb_copyarea	vmlinux	EXPORT_SYMBOL
+0xd0181f4f	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x2455c156	__clear_user	vmlinux	EXPORT_SYMBOL
+0x612329d6	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x886736fc	olpc_platform_info	vmlinux	EXPORT_SYMBOL_GPL
+0xcee29501	config_group_init	fs/configfs/configfs	EXPORT_SYMBOL
+0xd6f9bd8d	iwl_set_default_wep_key	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7e90a318	wm8350_free_irq	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x47b37f22	memstick_alloc_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x03b7b781	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x9512de45	ata_sff_softreset	vmlinux	EXPORT_SYMBOL_GPL
+0x1ecb9943	posix_acl_to_xattr	vmlinux	EXPORT_SYMBOL
+0xb18429eb	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0xf5c643e4	auth_unix_forget_old	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x8e1a34dc	dccp_invalid_packet	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0x96dbd36a	iwl_tx_skb	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x72eeac24	iwl_rx_csa	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x8155ecb9	tifm_map_sg	drivers/misc/tifm_core	EXPORT_SYMBOL
+0xb7be0bce	drm_mode_config_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xa0a4ac21	tcf_hash_insert	vmlinux	EXPORT_SYMBOL
+0x38563e3e	register_pernet_gen_device	vmlinux	EXPORT_SYMBOL_GPL
+0x4e457e0e	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x90a1004a	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0xb1233d19	bioset_integrity_create	vmlinux	EXPORT_SYMBOL
+0xce42d1f2	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x2e1a9782	snd_sbdsp_command	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0xccc291b3	ieee80211_channel_to_frequency	net/wireless/cfg80211	EXPORT_SYMBOL
+0xca05868a	mii_check_media	drivers/net/mii	EXPORT_SYMBOL
+0x4d1b908d	edac_mc_handle_fbd_ue	drivers/edac/edac_core	EXPORT_SYMBOL
+0x8387b400	edac_mc_handle_fbd_ce	drivers/edac/edac_core	EXPORT_SYMBOL
+0xb5ffc2c5	platform_device_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x114ede58	user_revoke	vmlinux	EXPORT_SYMBOL
+0x50df18b4	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x6beafdfa	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x6fff393f	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x0c2cdbf1	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x651a4139	test_taint	vmlinux	EXPORT_SYMBOL
+0x89195dc3	sonet_copy_stats	net/atm/atm	EXPORT_SYMBOL
+0x522ccdaa	bttv_sub_unregister	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0xc14ceda7	dvb_register_frontend	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xa69aa6ad	ir_codes_pv951_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x15fe0cd3	raid6_gfexp	drivers/md/raid6_pq	EXPORT_SYMBOL
+0x56928749	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL
+0x2c8f5989	acpi_remove_address_space_handler	vmlinux	EXPORT_SYMBOL
+0xa99d0dbf	pci_scan_bus_parented	vmlinux	EXPORT_SYMBOL
+0xf5a691cd	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0xc8039a73	ipcomp_init_state	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL
+0x27e12bda	can_rx_register	net/can/can	EXPORT_SYMBOL
+0xcb085591	ei_open	drivers/net/8390	EXPORT_SYMBOL
+0x2c418264	cfi_qry_mode_on	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL_GPL
+0xeea5e856	dib3000mc_attach	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0x8947782f	dib3000mb_attach	drivers/media/dvb/frontends/dib3000mb	EXPORT_SYMBOL
+0x24aac4d9	crypto_aes_expand_key	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0xe6387d87	xt_check_match	vmlinux	EXPORT_SYMBOL_GPL
+0x66ca86b6	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x7b56bd05	acpi_lid_notifier_register	vmlinux	EXPORT_SYMBOL
+0xc402cc99	register_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x67521902	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0xc4e3c3ce	generic_file_llseek_unlocked	vmlinux	EXPORT_SYMBOL
+0x4311c71f	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x1bedae23	mem_map	vmlinux	EXPORT_SYMBOL
+0xfedd35fc	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0xc66f2ab8	register_sound_midi	sound/soundcore	EXPORT_SYMBOL
+0x05d26363	svc_reg_xprt_class	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x78f9b710	nf_ct_l3proto_try_module_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x1e145952	pps_unregister_source	drivers/pps/pps_core	EXPORT_SYMBOL
+0x689bfee2	sdio_release_irq	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xad75d814	mmc_wait_for_cmd	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x48f18168	wm831x_reg_write	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x416983d9	netdev_fix_features	vmlinux	EXPORT_SYMBOL
+0x69a13201	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x269cafa5	inotify_find_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x4cc335be	rpc_mkpipe	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3f4f17c4	wlp_dev_serial_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x6c4b020f	mxl5005s_attach	drivers/media/common/tuners/mxl5005s	EXPORT_SYMBOL
+0x817813a8	drm_get_encoder_name	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x64d5bce6	cad_pid	vmlinux	EXPORT_SYMBOL
+0xe4f638ea	snd_trident_stop_voice	sound/pci/trident/snd-trident	EXPORT_SYMBOL
+0x94ba2546	get_sb_mtd	vmlinux	EXPORT_SYMBOL_GPL
+0x374366e4	ata_host_start	vmlinux	EXPORT_SYMBOL_GPL
+0x233618f3	agp_put_bridge	vmlinux	EXPORT_SYMBOL
+0x33daddd7	blk_rq_map_integrity_sg	vmlinux	EXPORT_SYMBOL
+0x1f8aa56e	snd_hda_get_connections	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x6974015a	snd_component_add	sound/core/snd	EXPORT_SYMBOL
+0x85478a0b	inet6_hash_frag	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0xf0b41ef3	atm_proc_root	net/atm/atm	EXPORT_SYMBOL
+0x5a7bfe41	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0xe5f8dd16	journal_update_format	fs/jbd/jbd	EXPORT_SYMBOL
+0x46b1f102	wm8350_dcdc_set_slot	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0x4e540680	hostap_set_encryption	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xc2821775	tuner_count	drivers/media/common/tuners/tuner-types	EXPORT_SYMBOL
+0x76a673d6	lis3lv02d_init_device	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0x152d4148	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x0531dcb8	ata_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0xba5d93b9	pm_runtime_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x448e89a0	call_usermodehelper_setcleanup	vmlinux	EXPORT_SYMBOL
+0xfb6af58d	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0xd1cd70ac	wimax_reset	net/wimax/wimax	EXPORT_SYMBOL
+0x81e4e1af	nf_nat_proto_unique_tuple	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0xf95b9afd	nf_nat_mangle_udp_packet	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0xe2304303	mac_map_monitor_sense	drivers/video/macmodes	EXPORT_SYMBOL
+0x06869e71	smscore_unregister_hotplug	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x42d8c22f	si21xx_attach	drivers/media/dvb/frontends/si21xx	EXPORT_SYMBOL
+0xb98308d8	mISDN_dsp_element_register	drivers/isdn/mISDN/mISDN_dsp	EXPORT_SYMBOL
+0x28d62c90	ip_dev_find	vmlinux	EXPORT_SYMBOL
+0xb51fbd64	edac_op_state	vmlinux	EXPORT_SYMBOL_GPL
+0x4a676048	ata_acpi_gtm_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0xa693dd85	ieee80211_restart_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0x809249bb	iscsi_tcp_recv_segment_is_hdr	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xecc8f788	iscsi_itt_to_ctask	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x22dd8931	hostap_80211_rx	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x7c576277	smsendian_handle_message_header	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x92339700	ib_rereg_phys_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x44c0c219	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x8c3ac7e2	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x37ad4176	__tracepoint_block_bio_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x5e368f46	path_lookup	vmlinux	EXPORT_SYMBOL
+0x7944e0fc	tracing_off	vmlinux	EXPORT_SYMBOL_GPL
+0x31e76b57	recalibrate_cpu_khz	vmlinux	EXPORT_SYMBOL
+0x1675606f	bad_dma_address	vmlinux	EXPORT_SYMBOL
+0xe20c9214	snd_iprintf	sound/core/snd	EXPORT_SYMBOL
+0x347dcf11	rpcauth_init_credcache	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x1cf11c07	iwl_tt_initialize	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2fba18c6	nxt6000_attach	drivers/media/dvb/frontends/nxt6000	EXPORT_SYMBOL
+0xeba7faeb	drm_agp_bind_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xeabe92ea	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x57fb5876	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x8c9e9029	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x96144dc8	qdisc_watchdog_schedule	vmlinux	EXPORT_SYMBOL
+0xb5888324	input_ff_create_memless	vmlinux	EXPORT_SYMBOL_GPL
+0x20eaa833	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x7470b859	xdr_shift_buf	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x17d421ca	tifm_queue_work	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x77db8252	rdma_disconnect	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0xd30ae7a4	ib_create_cq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x66e76b94	i2c_bit_add_numbered_bus	drivers/i2c/algos/i2c-algo-bit	EXPORT_SYMBOL
+0xfd89029f	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0xe9e70d13	pnp_request_card_device	vmlinux	EXPORT_SYMBOL
+0x4ef4cc62	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL
+0xa6f07a98	dentry_open	vmlinux	EXPORT_SYMBOL
+0xe138f9f3	srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x731dba7a	xen_domain_type	vmlinux	EXPORT_SYMBOL_GPL
+0xb5a6ebe2	wmi_remove_notify_handler	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0x280e5d26	iwl_tx_agg_stop	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5312ee96	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x40a27c37	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x52095e19	acpi_get_data	vmlinux	EXPORT_SYMBOL
+0x0e41c3c0	slow_work_unregister_user	vmlinux	EXPORT_SYMBOL
+0xa5808bbf	tasklet_init	vmlinux	EXPORT_SYMBOL
+0xdc140d5e	nf_nat_setup_info	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0x5531a161	jbd2_journal_get_undo_access	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x849fbded	ib_dealloc_fmr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x94d9df49	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL
+0xf553318d	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0xa07d90ce	ata_sff_hsm_move	vmlinux	EXPORT_SYMBOL_GPL
+0x32f2a13d	sata_link_debounce	vmlinux	EXPORT_SYMBOL_GPL
+0xc71a7e0b	stop_machine	vmlinux	EXPORT_SYMBOL_GPL
+0x53986488	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xfa3a680f	wimax_dev_add	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x10f8caac	wimax_msg	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x5411281f	saa7134_queryctrl	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL_GPL
+0xdee57228	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0xb47b6b63	fb_is_primary_device	vmlinux	EXPORT_SYMBOL
+0xc57d5a64	ata_do_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x43400dac	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0xe262fb16	rdma_set_ib_paths	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x1d1a9460	ttm_mem_global_init	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x75f3bcee	xt_unregister_matches	vmlinux	EXPORT_SYMBOL
+0x40af0dec	ata_xfer_mode2mask	vmlinux	EXPORT_SYMBOL_GPL
+0xde163435	security_inode_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0xfdfc0b3b	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0xa5922bb1	kfifo_init	vmlinux	EXPORT_SYMBOL
+0xa9fd7363	uwb_rc_ie_add	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xe35f5d38	osd_auto_detect_ver	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x3fd67a8f	mlx4_uar_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xd8a35343	qdisc_watchdog_cancel	vmlinux	EXPORT_SYMBOL
+0xd8cdc487	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0xadfd3056	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x60f11894	svc_authenticate	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe1a81c3a	icmpv6msg_statistics	net/ipv6/ipv6	EXPORT_SYMBOL
+0xcd42e346	iscsi_update_cmdsn	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x0756d766	iwl_tx_agg_start	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xd00fc8ab	cx88_vdev_init	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x4c1442c1	ir_codes_real_audio_220_32_keys_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xf5d15715	gigaset_shutdown	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xbb8fb807	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x5327b5d3	usb_hcd_pci_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x2d491610	driver_add_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x5c889008	tpm_bios_log_teardown	vmlinux	EXPORT_SYMBOL_GPL
+0xe15aeee2	downgrade_write	vmlinux	EXPORT_SYMBOL
+0xe456bd3a	complete	vmlinux	EXPORT_SYMBOL
+0x7a4c1438	pv_info	vmlinux	EXPORT_SYMBOL_GPL
+0x344e49a0	snd_hda_bus_new	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xb2646fcb	config_item_init_type_name	fs/configfs/configfs	EXPORT_SYMBOL
+0x7d5e2bfd	i1480_fw_upload	drivers/uwb/i1480/dfu/i1480-dfu-usb	EXPORT_SYMBOL_GPL
+0xf6410ee3	iscsi_block_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xc7c8bd4e	fc_fcp_destroy	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x22b6e16e	nsc_gpio_write	drivers/char/nsc_gpio	EXPORT_SYMBOL
+0x0dc00f43	ata_bmdma_start	vmlinux	EXPORT_SYMBOL_GPL
+0xa1354936	ata_port_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x0a539d55	rdev_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0xdb864d65	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x599824bb	snd_ac97_pcm_close	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xe3083298	snd_pcm_new_stream	sound/core/snd-pcm	EXPORT_SYMBOL
+0x559e9a2a	__ieee80211_get_tx_led_name	net/mac80211/mac80211	EXPORT_SYMBOL
+0x6db9ea06	sync_page_io	vmlinux	EXPORT_SYMBOL_GPL
+0xb3786465	sata_link_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x18bdcd12	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0xf69915cd	cdev_index	vmlinux	EXPORT_SYMBOL
+0x8a7d1c31	high_memory	vmlinux	EXPORT_SYMBOL
+0xdea4fb34	smp_call_function_many	vmlinux	EXPORT_SYMBOL
+0x920317d2	usb_serial_deregister	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x0c1ee07f	iscsi_itt_to_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x03165a85	v4l2_ctrl_get_menu	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x089aa902	mc44s803_attach	drivers/media/common/tuners/mc44s803	EXPORT_SYMBOL
+0xb4d19216	saa7146_pgtable_alloc	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x0dfa3f53	l1_event	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xe3fbe148	acpi_install_table_handler	vmlinux	EXPORT_SYMBOL
+0x481cb9ab	acpi_enter_sleep_state_prep	vmlinux	EXPORT_SYMBOL
+0x95352ea9	acpi_check_mem_region	vmlinux	EXPORT_SYMBOL
+0x07fc030b	simple_link	vmlinux	EXPORT_SYMBOL
+0x3133162a	journal_blocks_per_page	fs/jbd/jbd	EXPORT_SYMBOL
+0x23391e32	usb_serial_suspend	drivers/usb/serial/usbserial	EXPORT_SYMBOL
+0x2c2c8d05	iwl_is_ht40_tx_allowed	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x98b5be88	videobuf_queue_vmalloc_init	drivers/media/video/videobuf-vmalloc	EXPORT_SYMBOL_GPL
+0x231bf9f2	ib_create_fmr_pool	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x91e22b98	hidinput_find_field	vmlinux	EXPORT_SYMBOL_GPL
+0x7ae1ae8e	cpufreq_frequency_table_put_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x4abaefae	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0xb6c5a973	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x67d4ebe4	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0xaa34c1d0	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0xf8b30e93	mempool_create	vmlinux	EXPORT_SYMBOL
+0xcae61af3	p9_idpool_create	net/9p/9pnet	EXPORT_SYMBOL
+0xc474ca91	drm_cvt_mode	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x98a8c765	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x5c760099	mem_section	vmlinux	EXPORT_SYMBOL
+0xb05a3587	send_sig_info	vmlinux	EXPORT_SYMBOL
+0xedc03953	iounmap	vmlinux	EXPORT_SYMBOL
+0x7394a49a	xprt_release_xprt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xaf988a9c	mlx4_qp_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x6ed9a324	mptscsih_get_scsi_lookup	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x3770d158	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x691e08ab	unregister_netdevice	vmlinux	EXPORT_SYMBOL
+0x346bce29	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0xd338352e	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x674e6358	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0xd0ee38b8	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0xd79b5a02	allow_signal	vmlinux	EXPORT_SYMBOL
+0x8e310014	snd_timer_global_register	sound/core/snd-timer	EXPORT_SYMBOL
+0xa955e0bc	snd_rawmidi_info_select	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x0c7da019	sas_remove_host	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x1bccd925	fc_fabric_logoff	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xb5b83353	gspca_frame_add	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x88fac8f4	ata_host_register	vmlinux	EXPORT_SYMBOL_GPL
+0x9aa5c43b	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0xeba2d113	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x0c805f93	clflush_cache_range	vmlinux	EXPORT_SYMBOL_GPL
+0xaec21fea	snd_ac97_update_bits	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x98598719	nf_ct_delete_from_lists	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xb3670026	xfrm6_rcv	net/ipv6/ipv6	EXPORT_SYMBOL
+0xebe98312	ppp_output_wakeup	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xd66c0b8d	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x1a17a9e7	pci_enable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x4d208a46	snd_hda_add_vmaster	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x2941f890	xdr_buf_subsegment	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x7094f8ae	bt_err	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x518a52f4	fscache_init_cache	fs/fscache/fscache	EXPORT_SYMBOL
+0x88f94145	lbs_host_sleep_cfg	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0xde8b268a	flexcop_dma_free	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xf0c1b027	async_raid6_2data_recov	crypto/async_tx/async_raid6_recov	EXPORT_SYMBOL_GPL
+0xe996298c	bio_integrity_free	vmlinux	EXPORT_SYMBOL
+0xd17502b5	bio_integrity_prep	vmlinux	EXPORT_SYMBOL
+0x345f4426	bio_integrity_trim	vmlinux	EXPORT_SYMBOL
+0xd08c23cf	each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x90eb5e02	cfg80211_put_bss	net/wireless/cfg80211	EXPORT_SYMBOL
+0x85f0833b	libipw_is_valid_channel	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x74ee9098	sms_board_load_modules	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x89c8314f	drm_fb_helper_single_fb_probe	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x9fc20df8	btmrvl_check_evtpkt	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0x24a0de98	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x3bc76170	phy_connect	vmlinux	EXPORT_SYMBOL
+0x8c60b06d	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x9c2da3e0	__xenbus_register_frontend	vmlinux	EXPORT_SYMBOL_GPL
+0xc395ca39	rds_inc_init	net/rds/rds	EXPORT_SYMBOL_GPL
+0xb725d128	wusb_cluster_id_put	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x3b6f38d4	iscsi_unblock_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x1247a075	fcoe_ctlr_recv	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0x5ebefe4b	v4l_printk_ioctl	drivers/media/video/videodev	EXPORT_SYMBOL
+0xe3cd9b5c	saa7146_debug	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x1828341c	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x8a78989f	irq_from_evtchn	vmlinux	EXPORT_SYMBOL_GPL
+0x8c401bf5	kobject_get	vmlinux	EXPORT_SYMBOL
+0x1c7a7e95	kobject_put	vmlinux	EXPORT_SYMBOL
+0xf3ff4955	relay_open	vmlinux	EXPORT_SYMBOL_GPL
+0x4101bbde	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0xec794ba0	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x762cae46	cfi_read_pri	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL
+0x722c4f65	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0xfc39e32f	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0xf1deabf2	div64_u64	vmlinux	EXPORT_SYMBOL
+0xc12f7e0d	trace_profile_buf_nmi	vmlinux	EXPORT_SYMBOL_GPL
+0xa20ac9d4	relay_close	vmlinux	EXPORT_SYMBOL_GPL
+0x1396488b	fc_exch_mgr_free	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x4631a3bb	libipw_channel_to_freq	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x136c2709	detach_hdlc_protocol	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x02f847bc	ib_copy_path_rec_from_user	drivers/infiniband/core/ib_uverbs	EXPORT_SYMBOL
+0x363a5888	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x9fa274b4	dq_data_lock	vmlinux	EXPORT_SYMBOL
+0x185b04fa	d_validate	vmlinux	EXPORT_SYMBOL
+0x150853cf	down_trylock	vmlinux	EXPORT_SYMBOL
+0x7e07a861	snd_ak4114_check_rate_and_errors	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0x24334476	wimax_report_rfkill_sw	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x48d00e29	rt2x00usb_write_tx_data	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xb7b2c13a	ib_cm_listen	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xdca0e950	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x7b7f0607	fib_rules_cleanup_ops	vmlinux	EXPORT_SYMBOL_GPL
+0xc256e762	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x38203ca1	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x3266cbbe	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x2d03eaa2	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x3076615b	lbs_start_card	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0xde860abb	mlx4_fmr_enable	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x502108d0	mpt_fwfault_debug	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xeba56a0d	cx231xx_unregister_extension	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL
+0x2444887e	dibusb_dib3000mc_frontend_attach	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xb2db2592	dvb_ringbuffer_write	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x9944e2e5	ir_codes_hauppauge_new_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x6e3ff83a	edac_device_alloc_index	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xf4a8385f	iommu_domain_free	vmlinux	EXPORT_SYMBOL_GPL
+0xf99bb564	tpm_show_owned	vmlinux	EXPORT_SYMBOL_GPL
+0xadf6aa4d	tpm_pcr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x3f238101	dcookie_register	vmlinux	EXPORT_SYMBOL_GPL
+0xf6643b4b	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0xdb35ad3f	snd_hda_multi_out_analog_open	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x66139a2f	sas_port_add	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x4771977b	iscsi_tcp_recv_skb	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x14f2aa5a	capi20_get_version	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x5737f547	amd756_smbus	drivers/i2c/busses/i2c-amd756	EXPORT_SYMBOL
+0x866c6796	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x6a2ada68	xt_table_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x3bc2f935	tcf_exts_dump_stats	vmlinux	EXPORT_SYMBOL
+0x8e3530e2	ethtool_op_set_ufo	vmlinux	EXPORT_SYMBOL
+0x499d3f77	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x2e4c3e6b	pm_request_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x2a0a4724	bind_evtchn_to_irqhandler	vmlinux	EXPORT_SYMBOL_GPL
+0x0acb1a3c	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0xe90dcae0	__request_module	vmlinux	EXPORT_SYMBOL
+0x2095976a	nfs4_acl_new	fs/nfsd/nfsd	EXPORT_SYMBOL
+0x67750428	fc_exch_done	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xb710b449	iwl_is_monitor_mode	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x70fd5a74	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0xdaa4782d	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0xd7572e74	ata_sff_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0xb89af9bf	srandom32	vmlinux	EXPORT_SYMBOL
+0x23fd3028	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0xff708fd3	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x054e550b	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x79a4fab8	snd_pcm_sgbuf_ops_page	sound/core/snd-pcm	EXPORT_SYMBOL
+0xdb1b42d1	xfrm6_tunnel_spi_lookup	net/ipv6/xfrm6_tunnel	EXPORT_SYMBOL
+0x139c4708	cx231xx_dev_init	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0xfa74d3e5	iw_destroy_cm_id	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x6b7da06e	netpoll_cleanup	vmlinux	EXPORT_SYMBOL
+0xe1b43321	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x189a9a23	qtree_read_dquot	vmlinux	EXPORT_SYMBOL
+0x8882789f	set_binfmt	vmlinux	EXPORT_SYMBOL
+0xd4e5c3b3	mac_find_mode	drivers/video/macmodes	EXPORT_SYMBOL
+0x2f34d910	dm_io_client_destroy	drivers/md/dm-mod	EXPORT_SYMBOL
+0xb025997c	ttm_fbdev_mmap	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x865f4a0b	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0xfc69c2ec	hvc_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x271ce725	__first_cpu	vmlinux	EXPORT_SYMBOL
+0x2f8c1c11	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x359f906b	mptscsih_IssueTaskMgmt	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xcf2f31fd	snd_seq_kernel_client_write_poll	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x2d0f99e5	print_ssid	net/wireless/lib80211	EXPORT_SYMBOL
+0x8ee38862	isdnhdlc_rcv_init	drivers/isdn/i4l/isdnhdlc	EXPORT_SYMBOL
+0xa04a01bd	qdisc_class_hash_insert	vmlinux	EXPORT_SYMBOL
+0x11143895	skb_dma_unmap	vmlinux	EXPORT_SYMBOL
+0xe5867808	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x74ebaf85	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x11156a21	__rpc_wait_for_completion_task	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6b2c3494	phonet_header_ops	net/phonet/phonet	EXPORT_SYMBOL
+0x17d17235	rdma_init_qp_attr	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x422617fa	ib_redirect_mad_qp	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xe80ce219	sysctl_tcp_dma_copybreak	vmlinux	EXPORT_SYMBOL
+0x77be2113	ethtool_op_set_tx_ipv6_csum	vmlinux	EXPORT_SYMBOL
+0x75bf65c4	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x2c17d7f0	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0xbf8b39e9	isapnp_present	vmlinux	EXPORT_SYMBOL
+0x8ed11386	register_sound_mixer	sound/soundcore	EXPORT_SYMBOL
+0x44a7f7aa	ssb_bus_suspend	drivers/ssb/ssb	EXPORT_SYMBOL
+0xdb37490f	osduld_put_device	drivers/scsi/osd/osd	EXPORT_SYMBOL
+0x56df5a59	mmc_regulator_set_ocr	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x0ec92d47	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0xdd913df6	cfg80211_wext_siwretry	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x3cab68f6	cfg80211_wext_giwretry	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xb19982b2	wlp_dev_serial_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x8af4b602	mptscsih_bus_reset	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x6c2a547d	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x883a6db2	ata_link_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x4af846c5	bio_integrity_advance	vmlinux	EXPORT_SYMBOL
+0x122f709b	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0xd2ff8fd9	register_virtio_device	drivers/virtio/virtio	EXPORT_SYMBOL_GPL
+0x94961283	vunmap	vmlinux	EXPORT_SYMBOL
+0x4ec4b6d0	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x35c2ba9e	refrigerator	vmlinux	EXPORT_SYMBOL
+0x47b90fd8	snd_seq_device_new	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0x3d93e418	nf_conntrack_l4proto_tcp6	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xef7127b0	p9_idpool_put	net/9p/9pnet	EXPORT_SYMBOL
+0x31b89e50	unregister_virtio_device	drivers/virtio/virtio	EXPORT_SYMBOL_GPL
+0xf8d92fe5	iw_cm_disconnect	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x5dd914a6	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0xe5c78a99	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0xbb37bb52	snd_seq_create_kernel_client	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xc8b98501	__nf_ct_ext_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL
+0xddcb3958	hci_conn_change_link_key	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xdc583c08	dlm_unlock	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0x05952b25	dvb_dmx_swfilter	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x117093be	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL
+0x2efe5e09	atomic64_xchg	vmlinux	EXPORT_SYMBOL
+0x11f950ba	task_current_syscall	vmlinux	EXPORT_SYMBOL_GPL
+0xb5ba7680	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x23cb582f	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x9a316c92	rds_conn_create	net/rds/rds	EXPORT_SYMBOL_GPL
+0x077e3214	fcoe_ctlr_link_down	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0x239e881a	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0xcae4937b	cpufreq_frequency_table_cpuinfo	vmlinux	EXPORT_SYMBOL_GPL
+0xc9c47a4a	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x65bf40a8	get_mtd_device	vmlinux	EXPORT_SYMBOL_GPL
+0x92831a14	ata_sas_port_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x2a607e5c	ata_port_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x86c43ac7	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0xa412f23b	rds_conn_destroy	net/rds/rds	EXPORT_SYMBOL_GPL
+0xe906157f	wm831x_free_irq	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0xa0b1be57	cx88_ir_start	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x26e76fb8	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0xf4fb32e1	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x7d08d5e5	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x59b77ea8	agp_find_bridge	vmlinux	EXPORT_SYMBOL
+0x9ea0ad49	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x1c87b45d	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x2f9b37d4	lib80211_register_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL
+0xa7587646	crc7	lib/crc7	EXPORT_SYMBOL
+0xe3d0a2d2	scsi_tgt_alloc_queue	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0x4174b5db	mii_check_link	drivers/net/mii	EXPORT_SYMBOL
+0xe2a8d521	dm_io_client_create	drivers/md/dm-mod	EXPORT_SYMBOL
+0xd36b7093	gigaset_fill_inbuf	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xc998d641	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x7389c9a8	acpi_bus_get_power	vmlinux	EXPORT_SYMBOL
+0xcb733bf2	acpi_bus_set_power	vmlinux	EXPORT_SYMBOL
+0x96cbcf31	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x21470665	snd_i2c_readbytes	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0x9b24c4a1	nlmclnt_init	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0xc73e7254	mlx4_qp_release_range	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x0d78ebb7	tea5761_attach	drivers/media/common/tuners/tea5761	EXPORT_SYMBOL_GPL
+0x30fb985f	ib_alloc_mw	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x85cc0139	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0xbc360b88	hid_report_raw_event	vmlinux	EXPORT_SYMBOL_GPL
+0x0ff78713	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0xdeb22ad0	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL
+0x3abd8620	fd_install	vmlinux	EXPORT_SYMBOL
+0xd7a18997	snd_hda_mixer_amp_switch_info	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x376d41dc	nf_nat_used_tuple	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0x193990de	nf_nat_packet	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0x73cc06fb	parport_release	drivers/parport/parport	EXPORT_SYMBOL
+0x11503b02	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x530b0937	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x362d21a8	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x3ce4ca6f	disable_irq	vmlinux	EXPORT_SYMBOL
+0x87754115	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0xa70fabbe	release_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x17c15809	snd_midi_event_decode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0xbfe929f8	nf_expect_event_cb	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xbd37aa15	usb_ftdi_elan_edset_input	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x114b30d6	iscsi_tcp_hdr_recv_prep	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xad9c7285	mlx4_free_cmd_mailbox	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x2ab2a76c	cdrom_get_media_event	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xe9aac7d1	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x2db5d59a	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x680ae84b	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0xd6b0beb5	path_put	vmlinux	EXPORT_SYMBOL
+0x9562c244	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0xa0ceef51	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x4c177b64	tcp_vegas_state	net/ipv4/tcp_vegas	EXPORT_SYMBOL_GPL
+0xd2b82d7e	fc_remote_port_delete	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x8a489bcd	video_register_device	drivers/media/video/videodev	EXPORT_SYMBOL
+0xdd424b88	drm_irq_uninstall	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x822042d4	edac_mc_find	drivers/edac/edac_core	EXPORT_SYMBOL
+0xc17d83f3	dst_discard	vmlinux	EXPORT_SYMBOL
+0xaa2a72bf	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x87df8c9a	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x848d8433	vfs_get_dqblk	vmlinux	EXPORT_SYMBOL
+0xf201007e	vfs_set_dqblk	vmlinux	EXPORT_SYMBOL
+0x659774b9	blk_add_driver_data	vmlinux	EXPORT_SYMBOL_GPL
+0xdadf7ca4	kick_process	vmlinux	EXPORT_SYMBOL_GPL
+0xde0e185e	jbd2_journal_init_jbd_inode	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x3686ea09	spi_print_msg	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0xea0bf1e3	memstick_suspend_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xbde5030e	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x905e2b82	pciserial_remove_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x41adc4aa	pciserial_resume_ports	vmlinux	EXPORT_SYMBOL_GPL
+0xeb16915d	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x0da10ec3	security_sock_graft	vmlinux	EXPORT_SYMBOL
+0xe728e201	fscache_put_operation	fs/fscache/fscache	EXPORT_SYMBOL
+0x36b3602b	xt_proto_init	vmlinux	EXPORT_SYMBOL_GPL
+0x0b1beb31	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x9ece7c4e	ssb_bus_pcmciabus_register	drivers/ssb/ssb	EXPORT_SYMBOL
+0x3cf1f3f7	iwl_hw_nic_init	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3eba5761	smsclient_sendrequest	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x950921b7	ipmi_set_my_LUN	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x22639241	sata_pmp_qc_defer_cmd_switch	vmlinux	EXPORT_SYMBOL_GPL
+0xc673e23e	ata_scsi_change_queue_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x6f798b95	pci_get_subsys	vmlinux	EXPORT_SYMBOL
+0x9eecde16	do_brk	vmlinux	EXPORT_SYMBOL
+0x2bfc4d7f	tracepoint_get_iter_range	vmlinux	EXPORT_SYMBOL_GPL
+0xf4f7a4d6	ir_rc5_timer_end	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x878ab3ce	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x72d8d9d9	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0xdd41cc8e	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x22516766	phy_device_free	vmlinux	EXPORT_SYMBOL
+0x06c77b35	generic_permission	vmlinux	EXPORT_SYMBOL
+0x58d37280	hostap_set_hostapd	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xf3336440	usbnet_open	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xe563f3ba	cx8802_get_device	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0xcef2efd1	pci_test_config_bits	vmlinux	EXPORT_SYMBOL_GPL
+0xbf53bd77	call_usermodehelper_stdinpipe	vmlinux	EXPORT_SYMBOL
+0x2b663773	snd_hda_find_mixer_ctl	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x647101c9	snd_ctl_notify	sound/core/snd	EXPORT_SYMBOL
+0x6199e0f2	fc_get_host_stats	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x288d1750	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x9c93b924	pci_find_next_bus	vmlinux	EXPORT_SYMBOL
+0x9d3aa376	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x1acda5b2	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x8e0637ba	i8253_lock	vmlinux	EXPORT_SYMBOL
+0x926fe900	snd_pcm_hw_constraint_step	sound/core/snd-pcm	EXPORT_SYMBOL
+0x9174ef7f	hostap_init_proc	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x928a2547	usbnet_disconnect	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x13090f4c	tifm_alloc_adapter	drivers/misc/tifm_core	EXPORT_SYMBOL
+0xa87e47ba	drm_framebuffer_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9c75d35a	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x18d53420	kgdb_register_io_module	vmlinux	EXPORT_SYMBOL_GPL
+0xad0e66e5	set_user_nice	vmlinux	EXPORT_SYMBOL
+0xb12bd6d8	gss_pseudoflavor_to_service	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0xbb782b12	iwl_set_rxon_channel	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x24903798	ib_modify_port	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x77980e23	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0xf34806ec	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x55bc9922	nf_nat_pptp_hook_inbound	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL
+0xcecbb104	nf_conntrack_l3proto_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x7c0b99a5	nf_conntrack_l4proto_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x25fa2da6	qdisc_class_hash_grow	vmlinux	EXPORT_SYMBOL
+0xbc65541f	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0xf1852395	dma_find_channel	vmlinux	EXPORT_SYMBOL
+0xeaa739d4	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x51920976	fb_find_mode	vmlinux	EXPORT_SYMBOL
+0xe16bc675	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x4ba3b634	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x15568631	lookup_address	vmlinux	EXPORT_SYMBOL_GPL
+0xb7dde280	nfulnl_log_packet	net/netfilter/nfnetlink_log	EXPORT_SYMBOL_GPL
+0x5fb0a038	sas_queuecommand	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xcb3bcdcf	fc_get_host_port_type	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x06c35888	videobuf_sg_dma_unmap	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x3693500b	af9005_rc_keys	drivers/media/dvb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL
+0x4d8f4c15	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x9cb96e92	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL
+0x68857319	vga_put	vmlinux	EXPORT_SYMBOL
+0x3370da07	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x74bfc369	__tracepoint_kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x280f9f14	__per_cpu_offset	vmlinux	EXPORT_SYMBOL
+0x3ee9c27a	set_sig_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xfeb3a568	rt2x00pci_regbusy_read	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0xb2967548	iwl_rx_missed_beacon_notif	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x4c0a847b	drm_crtc_helper_set_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xdf724d5b	drm_exit	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xb3f8f294	proto_register	vmlinux	EXPORT_SYMBOL
+0x7b19ceeb	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x1cf99135	tpm_show_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0xf08b87ef	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x51d12d4e	acpi_pci_disabled	vmlinux	EXPORT_SYMBOL
+0x4003be0e	snd_sbmixer_read	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0xb4f3588a	__fc_frame_alloc	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xbe7e004b	smscore_start_device	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xc4f3d829	flexcop_wan_set_speed	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xd734c975	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0xafe01377	down_read	vmlinux	EXPORT_SYMBOL
+0xacfa16b2	sas_phy_reset	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x9682f32d	v4l_compat_translate_ioctl	drivers/media/video/v4l1-compat	EXPORT_SYMBOL
+0xdd88506c	km_report	vmlinux	EXPORT_SYMBOL
+0x2d554819	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x9bbc7d5a	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0xabd0c91c	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x66543b71	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0xe3a43572	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x5a2b1b67	gnttab_free_grant_reference	vmlinux	EXPORT_SYMBOL_GPL
+0x950ee7d1	fb_find_logo	vmlinux	EXPORT_SYMBOL_GPL
+0x742ac24b	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x91cbf37c	posix_acl_permission	vmlinux	EXPORT_SYMBOL
+0x18d01d71	d_lookup	vmlinux	EXPORT_SYMBOL
+0x3e362a31	virtio_check_driver_offered_feature	drivers/virtio/virtio	EXPORT_SYMBOL_GPL
+0x73d052a7	ubi_leb_change	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x9beafff3	b1dma_reset	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x2e64cba5	ib_reg_phys_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x31121fe1	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x48ea65fb	pcmcia_get_socket	vmlinux	EXPORT_SYMBOL
+0x0f402d9b	pcmcia_put_socket	vmlinux	EXPORT_SYMBOL
+0xf811e69d	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x279e1089	pci_iomap	vmlinux	EXPORT_SYMBOL
+0x534b8856	dm_underlying_device_busy	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x3c3c3af1	ttm_bo_global_init	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x6b05eff0	drm_mode_equal	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x609aff78	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x7c46233a	cpufreq_quick_get	vmlinux	EXPORT_SYMBOL
+0x7aa0a61d	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x0186d073	percpu_counter_set	vmlinux	EXPORT_SYMBOL
+0x42c8de35	ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x68a24153	snd_pcm_format_physical_width	sound/core/snd-pcm	EXPORT_SYMBOL
+0xf0db5048	video_output_register	drivers/video/output	EXPORT_SYMBOL
+0x7b1136a3	fc_exch_mgr_reset	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x21abee70	iwl_hwrate_to_tx_control	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3611bb61	t3_l2t_send_event	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0x6f9c72e3	dvb_ringbuffer_read	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x6eb787ee	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x4710d448	ethtool_op_set_flags	vmlinux	EXPORT_SYMBOL
+0x79295036	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x8ca56963	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0xea858cb5	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0xc6f0b194	iscsi_eh_target_reset	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x75ddeb1b	iwl_send_static_wepkey_cmd	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x386de63e	ei_start_xmit	drivers/net/8390	EXPORT_SYMBOL
+0x7478c372	dvb_pll_attach	drivers/media/dvb/frontends/dvb-pll	EXPORT_SYMBOL
+0x9edd3de6	dm_rh_recovery_start	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x3d0f1709	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x4d851952	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0xcd351414	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0xbf595d0c	ebt_register_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL
+0x160d8bfd	ib_fmr_pool_map_phys	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xf1421d13	drm_mode_sort	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe04223b7	edac_mc_add_mc	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xbd008b0a	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x2f215bf2	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x612f9f03	pci_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0xe075d6eb	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x56402c5b	filter_current_check_discard	vmlinux	EXPORT_SYMBOL_GPL
+0xc7b0663f	dma_supported	vmlinux	EXPORT_SYMBOL
+0x0b327e64	__snd_util_memblk_new	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0xd7589eab	nf_nat_seq_adjust_hook	net/ipv4/netfilter/nf_conntrack_ipv4	EXPORT_SYMBOL_GPL
+0xeea4146f	atm_init_aal5	net/atm/atm	EXPORT_SYMBOL
+0x950ab681	rdma_resolve_route	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x972401dc	drm_mm_search_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x17f341a0	i8042_lock_chip	vmlinux	EXPORT_SYMBOL
+0x31f97103	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x06c72111	inode_init_once	vmlinux	EXPORT_SYMBOL
+0xa0572380	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x9889a3f8	nf_ip6_checksum	net/ipv6/ipv6	EXPORT_SYMBOL
+0xf2f71561	hci_conn_put_device	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x4a48d81c	raid6_datap_recov	drivers/md/raid6_pq	EXPORT_SYMBOL_GPL
+0x5b3f4087	pcmcia_suspend_card	vmlinux	EXPORT_SYMBOL
+0x5d09a802	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x794639ff	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x89da5efb	usb_stor_clear_halt	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xbb657c9a	rt2x00usb_initialize	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xce1befdd	drm_core_ioremapfree	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x7be1051a	fw_core_handle_bus_reset	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xff810afa	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0xfaf58b3b	ata_sff_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x77fa5d1f	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0xe5166f5f	p9_tag_lookup	net/9p/9pnet	EXPORT_SYMBOL
+0x3eb63e1a	drm_framebuffer_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x80556e61	pnp_device_attach	vmlinux	EXPORT_SYMBOL
+0x62049256	acpi_disable	vmlinux	EXPORT_SYMBOL
+0xa91b5561	acpi_video_backlight_support	vmlinux	EXPORT_SYMBOL
+0xac0292be	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xb3faff86	lbs_add_card	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x8b5e4c4d	mmc_register_driver	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xe14cf7d0	cx88_core_irq	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x51ba1643	ir_codes_kworld_plus_tv_analog_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x355a3dd6	gigaset_add_event	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x601ab7b5	fifo_create_dflt	vmlinux	EXPORT_SYMBOL
+0xc6d9bb67	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0xaf85cfc0	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x38a9c2c7	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x8a14477d	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00ba16a2	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0xa176c9d4	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0xe27fd046	blk_insert_request	vmlinux	EXPORT_SYMBOL
+0x2d732104	blkcipher_walk_virt_block	vmlinux	EXPORT_SYMBOL_GPL
+0xa8b4961d	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x7a2dcbdb	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0xc1c03312	svc_set_client	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x94a08134	nf_nat_proto_nlattr_to_range	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0xc245c03b	fw_core_remove_card	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x674da121	ipmi_free_recv_msg	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x00491470	add_mtd_device	vmlinux	EXPORT_SYMBOL_GPL
+0xb34d4c2e	acpi_terminate	vmlinux	EXPORT_SYMBOL
+0x25308b07	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL
+0x6d294e43	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0xb60ab4f8	snd_pcm_lib_preallocate_pages_for_all	sound/core/snd-pcm	EXPORT_SYMBOL
+0xe97f4ce5	qword_get	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x105aee94	journal_revoke	fs/jbd/jbd	EXPORT_SYMBOL
+0xe1457735	drm_ht_remove_item	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x22aab09e	drm_vblank_get	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x30fbd7ff	ethtool_op_set_sg	vmlinux	EXPORT_SYMBOL
+0x6043092c	atomic64_dec_and_test	vmlinux	EXPORT_SYMBOL
+0x43c96c09	pcim_iomap_table	vmlinux	EXPORT_SYMBOL
+0x9e166680	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0xcf767fbe	seq_release	vmlinux	EXPORT_SYMBOL
+0x30700c35	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0xc24e85e9	ring_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0x3ab4cd93	ring_buffer_size	vmlinux	EXPORT_SYMBOL_GPL
+0x91d94495	module_layout	vmlinux	EXPORT_SYMBOL
+0x428c965d	nf_conntrack_event_cb	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xe690b8fd	__ipv6_isatap_ifid	net/ipv6/ipv6	EXPORT_SYMBOL
+0x3786eb5c	osd_req_list_dev_partitions	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xc9b083b6	parport_register_driver	drivers/parport/parport	EXPORT_SYMBOL
+0xce45a6f1	raid6_gfexi	drivers/md/raid6_pq	EXPORT_SYMBOL
+0xa7c4fd6c	capi_message2str	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x702aac43	xfrm_audit_state_notfound	vmlinux	EXPORT_SYMBOL_GPL
+0x412f41f7	hidinput_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x02f389cc	qtree_entry_unused	vmlinux	EXPORT_SYMBOL
+0xcc1fb551	baswap	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xdc23fec4	ir_codes_fusionhdtv_mce_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x73a48b4a	ata_sff_std_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x3d388324	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0xd6feefa5	agp_num_entries	vmlinux	EXPORT_SYMBOL_GPL
+0xf220b0bc	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0xafa17ef2	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x8e2430ea	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x66b2a859	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0xe4870354	_read_trylock	vmlinux	EXPORT_SYMBOL
+0x060d1064	set_memory_ro	vmlinux	EXPORT_SYMBOL_GPL
+0xf97666a0	set_memory_rw	vmlinux	EXPORT_SYMBOL_GPL
+0xd6b33026	cpu_khz	vmlinux	EXPORT_SYMBOL
+0xc652fd69	snd_hda_get_jack_connectivity	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xf1a88845	dccp_destroy_sock	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xe075ef55	uwb_rc_reset_all	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xf5e15e65	ir_codes_winfast_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x5e986adc	dm_noflush_suspending	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0xbb4a1408	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0xbb441d17	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x6544f639	acpi_get_physical_device	vmlinux	EXPORT_SYMBOL
+0x6cdc5c6b	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x7785628e	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x3f39b162	up_write	vmlinux	EXPORT_SYMBOL
+0xca3141e7	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x582373e4	snd_rawmidi_kernel_open	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x79cad415	auth_domain_put	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x57c8a8b2	p9_client_remove	net/9p/9pnet	EXPORT_SYMBOL
+0x8c10fc01	iwl_sta_rx_agg_stop	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa63d85ab	slhc_remember	drivers/net/slhc	EXPORT_SYMBOL
+0x14de3746	mpt_halt_firmware	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xe72e6436	drm_mm_put_block	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x21d50a51	tcf_hash_release	vmlinux	EXPORT_SYMBOL
+0x072e76f1	cpufreq_cpu_get	vmlinux	EXPORT_SYMBOL_GPL
+0xcbe3268b	cpufreq_cpu_put	vmlinux	EXPORT_SYMBOL_GPL
+0x53a5d176	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0xc4bcf664	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x63970138	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x3a4671ea	fget	vmlinux	EXPORT_SYMBOL
+0x9f508059	snd_ctl_boolean_mono_info	sound/core/snd	EXPORT_SYMBOL
+0x63e10bf8	can_send	net/can/can	EXPORT_SYMBOL
+0x7ead9272	iscsi_complete_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xb0a4efac	fc_queuecommand	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x65bc54ab	phy_sanitize_settings	vmlinux	EXPORT_SYMBOL
+0x54416539	lib80211_crypt_info_free	net/wireless/lib80211	EXPORT_SYMBOL
+0x70f3041a	jbd2_journal_abort	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x2aa29af1	b1_free_card	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x706b3a33	cpufreq_frequency_table_get_attr	vmlinux	EXPORT_SYMBOL_GPL
+0x44e9a829	match_token	vmlinux	EXPORT_SYMBOL
+0xed7c9b5d	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x1a323362	__ftrace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0xb13c4dba	down_write	vmlinux	EXPORT_SYMBOL
+0x09c64fbd	ieee80211_frequency_to_channel	net/wireless/cfg80211	EXPORT_SYMBOL
+0xb67f6760	dibusb_power_ctrl	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xd94696e8	FsmDelTimer	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0xa85db862	drm_get_dev	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x6923dca6	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x1b9e0ff1	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x8212721d	xenbus_dev_request_and_reply	vmlinux	EXPORT_SYMBOL
+0x88561351	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x04ebfd2f	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x4966180d	flush_signals	vmlinux	EXPORT_SYMBOL
+0x35e49d03	nf_ct_remove_expectations	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x39a58f27	mb_cache_entry_insert	fs/mbcache	EXPORT_SYMBOL
+0xb6a02b11	umc_device_unregister	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0xea5dc614	usb_stor_disconnect	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x31219afb	ath_is_world_regd	drivers/net/wireless/ath/ath	EXPORT_SYMBOL
+0x06a3ac04	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0xfcacf15a	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0xb49601fd	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x94e92aa0	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0xefc28e6c	pccard_register_pcmcia	vmlinux	EXPORT_SYMBOL
+0xafef8fa9	register_memory_notifier	vmlinux	EXPORT_SYMBOL
+0x8ffdb3b8	crc16	vmlinux	EXPORT_SYMBOL
+0x434f536c	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0xd2a8caf0	work_on_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xd9fbeb0e	snd_mixer_oss_ioctl_card	sound/core/oss/snd-mixer-oss	EXPORT_SYMBOL
+0xc06d8b77	cfg80211_wext_siwencodeext	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x83067009	nfnetlink_unicast	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x22cd2720	nf_tproxy_assign_sock	net/netfilter/nf_tproxy_core	EXPORT_SYMBOL_GPL
+0x5eda8079	libipw_rx_mgt	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xf1deeed0	mpt_raid_phys_disk_pg1	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x00a5cbe1	iommu_iova_to_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x3755c4a2	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x9f40a6d6	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x56a60dbf	iscsi_tcp_task_xmit	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x59305e9c	dibusb2_0_streaming_ctrl	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x6699ff3c	cdrom_mode_select	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0x1391a7fc	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0xb48e8622	snd_pcm_lib_preallocate_free_for_all	sound/core/snd-pcm	EXPORT_SYMBOL
+0x0031d52c	nf_conntrack_in	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x74899b9e	wlp_dev_prim_OUI_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xf7109c53	iscsi_tcp_conn_setup	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x6d24b399	memstick_set_rw_addr	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x049064e6	dm_kcopyd_client_create	drivers/md/dm-mod	EXPORT_SYMBOL
+0xb9f469e6	ib_sa_join_multicast	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x879d13bf	drm_mode_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2f3c0182	edac_pci_free_ctl_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xece18c13	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x9f0f7252	ata_port_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x7857cc0b	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0xa555953d	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x14ef4db8	rpc_setbufsize	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xce91012a	p54_rx	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0x000b406c	usbnet_purge_paused_rxq	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xbb30c3d0	cx88_risc_stopper	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x11d6970e	usbhid_set_leds	vmlinux	EXPORT_SYMBOL_GPL
+0x68672f80	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0xf6bb4729	color_table	vmlinux	EXPORT_SYMBOL
+0x0ca7b7a8	acpi_check_region	vmlinux	EXPORT_SYMBOL
+0xc80c9de1	put_disk	vmlinux	EXPORT_SYMBOL
+0x46085e4f	add_timer	vmlinux	EXPORT_SYMBOL
+0x7d4f2cfc	auth_unix_add_addr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x73390df1	can_proto_register	net/can/can	EXPORT_SYMBOL
+0xbd6cf178	fw_core_remove_address_handler	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x830cb003	hid_allocate_device	vmlinux	EXPORT_SYMBOL_GPL
+0xeb66a15e	dma_sync_wait	vmlinux	EXPORT_SYMBOL
+0x5ecc4993	md_set_array_sectors	vmlinux	EXPORT_SYMBOL
+0x9ba7089d	argv_split	vmlinux	EXPORT_SYMBOL
+0x101c923e	__tracepoint_power_start	vmlinux	EXPORT_SYMBOL_GPL
+0x6c8410d5	uwb_ack_policy_show	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x5cfa4639	flexcop_dump_reg	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x8363708b	drm_add_modes_noedid	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xb352177e	find_first_bit	vmlinux	EXPORT_SYMBOL
+0x2c03a0bb	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x31a89d59	rpc_debug	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3a9523b8	svc_xprt_enqueue	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x84f1abf3	rds_inc_put	net/rds/rds	EXPORT_SYMBOL_GPL
+0xb2a945e0	hostap_dump_rx_header	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xa12ad27f	hostap_dump_tx_header	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xacbdffe6	dst_pio_disable	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x00cde2c0	crypto_aes_set_key	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0x54e3d72d	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x5086ac3a	alg_test	vmlinux	EXPORT_SYMBOL_GPL
+0xbef43296	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x70c647b9	snd_unregister_device	sound/core/snd	EXPORT_SYMBOL
+0x22aaed28	svc_destroy	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x560324eb	__fscache_update_cookie	fs/fscache/fscache	EXPORT_SYMBOL
+0x445a3712	fat_detach	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x2567874f	wusbhc_b_create	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x4ca0a3c2	ei_poll	drivers/net/8390	EXPORT_SYMBOL
+0xace35cae	mISDN_FsmDelTimer	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xe2eddac5	pci_target_state	vmlinux	EXPORT_SYMBOL
+0x355c59b5	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x7a6b834d	crypto_unregister_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0xc1a40d2c	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL
+0xac86184c	ring_buffer_peek	vmlinux	EXPORT_SYMBOL_GPL
+0x70b1d967	dccp_orphan_count	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xe28104f1	wusbhc_b_destroy	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x8fd5a560	iscsi_put_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x1852fc0e	microtune_attach	drivers/media/common/tuners/mt20xx	EXPORT_SYMBOL_GPL
+0x2baa6586	capilib_new_ncci	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x18382f6a	ib_copy_path_rec_to_user	drivers/infiniband/core/ib_uverbs	EXPORT_SYMBOL
+0x067c9b15	ib_modify_ah	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x107704f4	drm_ioctl	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0d4b77b7	gen_pool_add	vmlinux	EXPORT_SYMBOL
+0xa945ea50	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0xd6a78d08	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x029444f0	native_read_tsc	vmlinux	EXPORT_SYMBOL
+0x9fd8ef36	snd_hda_ctl_add	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x23b75b0d	hci_register_proto	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xd903c5df	wlp_dev_model_nr_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xb9da8086	dibusb2_0_power_ctrl	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x0ddc8ff7	b1_reset_ctr	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x23622ed6	drm_mode_duplicate	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x50211ee3	tcp_free_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0xc0580937	rb_erase	vmlinux	EXPORT_SYMBOL
+0x97d6a2c9	can_proto_unregister	net/can/can	EXPORT_SYMBOL
+0x77f4844c	sas_find_local_phy	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x8e9b34fb	ata_sff_busy_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x2adec1e0	__nvram_check_checksum	vmlinux	EXPORT_SYMBOL
+0xaafdc258	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x17543bc6	save_mount_options	vmlinux	EXPORT_SYMBOL
+0xa601aab9	unregister_kretprobe	vmlinux	EXPORT_SYMBOL_GPL
+0xc3e49534	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0xabbe59c4	cache_check	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5882ba33	nf_conntrack_set_hashsize	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x1532960e	iscsi_destroy_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xce1b68e6	video_usercopy	drivers/media/video/videodev	EXPORT_SYMBOL
+0x52a58c24	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00c208a9	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0xd251d7b0	security_socket_getpeersec_dgram	vmlinux	EXPORT_SYMBOL
+0x25b81a32	set_blocksize	vmlinux	EXPORT_SYMBOL
+0xa69b6774	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x69d2575f	efi	vmlinux	EXPORT_SYMBOL
+0x2a6e4295	snd_sbmixer_resume	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0x38f8a4d0	wlp_dev_prim_OUI_sub_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x9643a884	saa7134_devlist_lock	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x495e4b0c	btcx_calc_skips	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0xcb2ac2ae	flexcop_i2c_request	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xae71d526	saa7146_pgtable_build_single	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x89fc6f28	recv_Dchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x0acf7679	dma_issue_pending_all	vmlinux	EXPORT_SYMBOL
+0xdbb7dcaf	md_done_sync	vmlinux	EXPORT_SYMBOL
+0x3b3d5743	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x8a0a230f	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0xf2a644fb	copy_from_user	vmlinux	EXPORT_SYMBOL
+0xf8dc1ab6	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x3d2c947a	security_inode_notifysecctx	vmlinux	EXPORT_SYMBOL
+0x5ae2c9f7	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x1e7c1532	lib80211_crypt_info_init	net/wireless/lib80211	EXPORT_SYMBOL
+0x29fe292e	nf_ct_nat_offset	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x3696b5c8	ipv6_chk_prefix	net/ipv6/ipv6	EXPORT_SYMBOL
+0x9832201f	usb_ftdi_elan_edset_output	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x2a5bf768	osd_execute_request	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x96fa0064	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x32ed1d7c	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x90a1601f	dmi_check_system	vmlinux	EXPORT_SYMBOL
+0xfad2b08e	mdio_bus_type	vmlinux	EXPORT_SYMBOL
+0xae7403ce	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x0a429b78	cfg80211_wext_siwtxpower	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x0b82eb3a	cfg80211_wext_giwtxpower	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xed9055fe	rpc_call_sync	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x4310ac04	ip6_xmit	net/ipv6/ipv6	EXPORT_SYMBOL
+0x2504ec82	jbd2_journal_unlock_updates	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x3880ed1f	tcf_exts_dump	vmlinux	EXPORT_SYMBOL
+0x0518f928	ata_sff_dev_select	vmlinux	EXPORT_SYMBOL_GPL
+0xa184e51d	ata_noop_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0xf57682c8	acpi_get_object_info	vmlinux	EXPORT_SYMBOL
+0xb5044271	vsscanf	vmlinux	EXPORT_SYMBOL
+0x6788248d	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x82d79b51	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x04486e88	rcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x0e52592a	panic	vmlinux	EXPORT_SYMBOL
+0x830e547b	ioremap_prot	vmlinux	EXPORT_SYMBOL
+0xd7dd777b	reserve_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0xcbf5c416	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x1beac9aa	pci_set_dma_seg_boundary	vmlinux	EXPORT_SYMBOL
+0xb6244511	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x12da5bb2	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x5705088a	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x04069b1d	set_irq_nested_thread	vmlinux	EXPORT_SYMBOL_GPL
+0xbd4ac87f	__fscache_relinquish_cookie	fs/fscache/fscache	EXPORT_SYMBOL
+0x415cdc36	dlm_posix_get	fs/dlm/dlm	EXPORT_SYMBOL_GPL
+0x7112a173	usbnet_get_ethernet_addr	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xcfcb5a9d	enclosure_register	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0xb01a1998	ir_codes_manli_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xe6a3d1dc	ata_sas_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0xf5945bac	gnttab_free_grant_references	vmlinux	EXPORT_SYMBOL_GPL
+0xaf4b1540	acpi_get_irq_routing_table	vmlinux	EXPORT_SYMBOL
+0x584f738e	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x80fa0694	xip_file_mmap	vmlinux	EXPORT_SYMBOL_GPL
+0xbb125d39	rpc_wake_up_next	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe47dcfd8	journal_load	fs/jbd/jbd	EXPORT_SYMBOL
+0x2f2889a0	gf128mul_init_64k_lle	crypto/gf128mul	EXPORT_SYMBOL
+0x3755f990	gf128mul_init_64k_bbe	crypto/gf128mul	EXPORT_SYMBOL
+0xe415b005	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x6ff94f40	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0xdf9dc3f6	ata_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x5211d98e	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x46ec6010	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0xbcfec4fd	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x2217ba5f	ieee802154_nl_assoc_indic	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x92daf095	dvb_usb_device_exit	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0x41e0a065	iw_handler_get_spy	vmlinux	EXPORT_SYMBOL
+0x6413029b	xt_find_match	vmlinux	EXPORT_SYMBOL
+0x94bbc509	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0xbb167766	fb_var_to_videomode	vmlinux	EXPORT_SYMBOL
+0x5152e605	memcmp	vmlinux	EXPORT_SYMBOL
+0x44f21bea	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x57a82653	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0xdbeec7a7	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x5927a6b1	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x4436f7ec	snd_vx_create	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xfd16c00e	snd_card_set_id	sound/core/snd	EXPORT_SYMBOL
+0xf9c1ebbb	fc_slave_alloc	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xb062c309	drm_fb_helper_fill_fix	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xf33431e5	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x3902f4ec	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0xcce27eb0	snd_hda_input_mux_info	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x8ecf4acc	bttv_write_gpio	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0x1af895df	drm_encoder_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0a345b41	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x7a5b32ef	dma_async_memcpy_buf_to_buf	vmlinux	EXPORT_SYMBOL
+0x8eea2ecf	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0xf1345c95	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x02a78a0d	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0xbdd295f0	trace_vprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x3771b461	crc_ccitt	lib/crc-ccitt	EXPORT_SYMBOL
+0xc48b7ccf	ata_mode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x881039d0	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x81799cee	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x839d725e	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x7d6e60e4	vfs_quota_on	vmlinux	EXPORT_SYMBOL
+0x6b01ceb0	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x3457cb68	param_set_long	vmlinux	EXPORT_SYMBOL
+0x5b14ec1a	rpc_put_mount	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x524c0fe0	xfrm6_tunnel_deregister	net/ipv6/tunnel6	EXPORT_SYMBOL
+0x1afcc077	xfrm4_tunnel_deregister	net/ipv4/tunnel4	EXPORT_SYMBOL
+0x818c7e4d	configfs_undepend_item	fs/configfs/configfs	EXPORT_SYMBOL
+0xece9604f	enclosure_unregister	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0xf9e7832f	mISDN_FsmNew	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xe4cfb9b2	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0xa2145213	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x3086471e	usb_string	vmlinux	EXPORT_SYMBOL_GPL
+0x8149ea54	ata_timing_find_mode	vmlinux	EXPORT_SYMBOL_GPL
+0xcae05a11	nf_ct_unexpect_related	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x6b58f4ce	p9_client_attach	net/9p/9pnet	EXPORT_SYMBOL
+0xb04b86bc	ib_alloc_pd	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x0cf16182	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0xe9c7ff9c	agp_generic_free_gatt_table	vmlinux	EXPORT_SYMBOL
+0xf441ac43	ioread8_rep	vmlinux	EXPORT_SYMBOL
+0xe0a12b1d	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x39fe0187	lease_modify	vmlinux	EXPORT_SYMBOL
+0xf378d64a	kmap_atomic_to_page	vmlinux	EXPORT_SYMBOL
+0x230f3ffb	lib80211_crypt_deinit_handler	net/wireless/lib80211	EXPORT_SYMBOL
+0x83911c38	osd_PageFree	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0x704dea4c	dibx000_init_i2c_master	drivers/media/dvb/frontends/dibx000_common	EXPORT_SYMBOL
+0x3092db2a	dibx000_exit_i2c_master	drivers/media/dvb/frontends/dibx000_common	EXPORT_SYMBOL
+0x1a9009d6	ir_codes_dm1105_nec_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x48728ca9	mISDN_freedchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x56eb51da	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x928dedd8	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x8dae3df4	cpu_sysdev_class	vmlinux	EXPORT_SYMBOL
+0x3f0546a8	ioread32_rep	vmlinux	EXPORT_SYMBOL
+0x7467386b	srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x2ae3deaa	release_and_free_resource	sound/core/snd	EXPORT_SYMBOL
+0xae43cbb0	snd_pcm_hw_constraint_ratdens	sound/core/snd-pcm	EXPORT_SYMBOL
+0x38251c0f	rpc_put_task	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x1f2bc46e	iscsi_tcp_conn_teardown	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x17d0fa4a	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0xcd3099d0	regulator_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x9e4b3747	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0xb6ed1e53	strncpy	vmlinux	EXPORT_SYMBOL
+0x73e20c1c	strlcpy	vmlinux	EXPORT_SYMBOL
+0x3be7af02	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x1a45cb6c	acpi_disabled	vmlinux	EXPORT_SYMBOL
+0x6f077fcf	ib_get_mad_data_offset	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x434313c3	tcf_em_tree_destroy	vmlinux	EXPORT_SYMBOL
+0xac973c63	fddi_type_trans	vmlinux	EXPORT_SYMBOL
+0xc61aff34	pcmcia_get_socket_by_nr	vmlinux	EXPORT_SYMBOL
+0xf2475e6e	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0xf195c682	fb_invert_cmaps	vmlinux	EXPORT_SYMBOL
+0x1976bc16	__tracepoint_kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x29bd4c46	__cap_init_eff_set	vmlinux	EXPORT_SYMBOL
+0xcb60451e	p9_client_cb	net/9p/9pnet	EXPORT_SYMBOL
+0xa877f2a5	uwb_est_find_size	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xdb3eba3b	ib_create_srq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x885142a6	nf_net_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0xf3e5e1bc	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x3038c5d3	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0xf3fb61e7	rfkill_unregister	net/rfkill/rfkill	EXPORT_SYMBOL
+0xfa48bbc9	cx88_ir_stop	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x098b71c6	fb_dealloc_cmap	vmlinux	EXPORT_SYMBOL
+0x5ec3e02f	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x38b40ab5	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x41482d8b	strndup_user	vmlinux	EXPORT_SYMBOL
+0xa4cb9738	ring_buffer_reset	vmlinux	EXPORT_SYMBOL_GPL
+0xff006818	set_pages_wb	vmlinux	EXPORT_SYMBOL
+0xe04bdfd4	snd_cs8427_iec958_pcm	sound/i2c/snd-cs8427	EXPORT_SYMBOL
+0xf96fc5f2	rds_conn_create_outgoing	net/rds/rds	EXPORT_SYMBOL_GPL
+0x5d7a35bf	wlp_setup	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xfdcbfbe2	pccard_nonstatic_ops	drivers/pcmcia/rsrc_nonstatic	EXPORT_SYMBOL
+0xb2659e3d	mptscsih_remove	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x19cd2826	ir_codes_behold_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xcd24360a	__xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x8664f62e	cpufreq_update_policy	vmlinux	EXPORT_SYMBOL
+0xfdce6be5	agp_bind_memory	vmlinux	EXPORT_SYMBOL
+0xb7b3f965	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0xb635066c	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x944832d6	ftrace_print_symbols_seq	vmlinux	EXPORT_SYMBOL
+0x951f183b	snd_hda_add_codec_preset	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x958e7476	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x01418a1f	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x3328d9f5	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x166aa634	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x7037d79d	k8_flush_garts	vmlinux	EXPORT_SYMBOL_GPL
+0xc41cd35b	snd_hda_mixer_bind_switch_get	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xf65278dd	snd_hda_mixer_bind_switch_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x60bb3e70	cfg80211_wext_siwfrag	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x5476263b	cfg80211_wext_giwfrag	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x0d86af7d	svc_xprt_received	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf90a3815	ib_destroy_cq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xd3028e75	drm_sman_set_manager	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xdac47406	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0xb98a0185	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x8ba82dbe	ata_slave_link_init	vmlinux	EXPORT_SYMBOL_GPL
+0xe1f8ce2e	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x4185cf4b	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0xaba9ff34	allocate_resource	vmlinux	EXPORT_SYMBOL
+0xfed88605	uio_event_notify	drivers/uio/uio	EXPORT_SYMBOL_GPL
+0x007b91f8	iwl_sta_rx_agg_start	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x89ae5c65	alloc_mdio_bitbang	drivers/net/phy/mdio-bitbang	EXPORT_SYMBOL
+0x59f09431	pm_schedule_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x1bae569e	block_prepare_write	vmlinux	EXPORT_SYMBOL
+0x02d81845	audit_log_task_context	vmlinux	EXPORT_SYMBOL
+0xdd56705e	dccp_init_sock	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x2e8471c3	lbtf_remove_card	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x0b3fb5ed	hostap_free_data	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x73e88283	ubi_get_volume_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x742f4caf	mt2060_attach	drivers/media/common/tuners/mt2060	EXPORT_SYMBOL
+0x229bd6b1	alloc_netdev_mq	vmlinux	EXPORT_SYMBOL
+0xb65091b3	selinux_secmark_refcount_dec	vmlinux	EXPORT_SYMBOL_GPL
+0x9f166fdf	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0xf9a054b5	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x62ad06d1	dvb_usb_get_hexline	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0x305dc3c6	cfag12864b_isenabled	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0x03c06156	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x1be72c86	security_sb_clone_mnt_opts	vmlinux	EXPORT_SYMBOL
+0xc0a562d7	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0xcf1fd448	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x37e74642	get_jiffies_64	vmlinux	EXPORT_SYMBOL
+0x109af9a2	sas_port_delete_phy	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x3b8c71ac	del_mtd_partitions	vmlinux	EXPORT_SYMBOL
+0xf2f6f0b7	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x1845e7c5	acpi_evaluate_integer	vmlinux	EXPORT_SYMBOL
+0x02a6ce5a	crc16_table	vmlinux	EXPORT_SYMBOL
+0x29cab765	init_buffer	vmlinux	EXPORT_SYMBOL
+0x7d2575c1	ubi_close_volume	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x12b30875	videobuf_read_one	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x703fc738	ir_codes_avertv_303_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xc9156900	scsi_nl_add_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xbf7fd2f5	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x571f9073	snd_pcm_lib_readv	sound/core/snd-pcm	EXPORT_SYMBOL
+0x5555d51e	rpcauth_create	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xa9b7afd8	wmi_set_block	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0xdb1ec6cb	iwl_rx_statistics	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa6cb7bb7	dev2t3cdev	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xfdfbad19	drm_sman_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3c9a1409	drm_ht_just_insert_please	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3dd511ab	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x2f075468	vfs_link	vmlinux	EXPORT_SYMBOL
+0x1906db90	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0xb867ae7e	snd_hda_bind_vol	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x3d1dd4d1	journal_flush	fs/jbd/jbd	EXPORT_SYMBOL
+0x94340030	radeonfb_resize	drivers/gpu/drm/radeon/radeon	EXPORT_SYMBOL
+0xe6ff7e0c	ll_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x48a70518	ks0108_writedata	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0x993b0e38	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x4a344fae	usb_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x69e39b99	phy_driver_unregister	vmlinux	EXPORT_SYMBOL
+0xf82abc1d	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL
+0x9ce5cacb	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x2447533c	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0xd7a6fafa	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0xc2f0f059	snd_hda_get_bool_hint	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x99eceb98	ath_regd_init	drivers/net/wireless/ath/ath	EXPORT_SYMBOL
+0x80c7b483	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x9ec70d42	unregister_mtd_chip_driver	vmlinux	EXPORT_SYMBOL
+0xd768e985	regulator_has_full_constraints	vmlinux	EXPORT_SYMBOL_GPL
+0x8aebc298	d_delete	vmlinux	EXPORT_SYMBOL
+0x154b8a6d	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x45450063	mod_timer	vmlinux	EXPORT_SYMBOL
+0x7a723040	fw_iso_context_stop	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x99052a84	acpi_os_write_port	vmlinux	EXPORT_SYMBOL
+0xb29bc8bd	idr_remove	vmlinux	EXPORT_SYMBOL
+0x2c9874fe	ida_remove	vmlinux	EXPORT_SYMBOL
+0xb42453d3	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0xcd1cb422	save_stack_trace_tsk	vmlinux	EXPORT_SYMBOL_GPL
+0x8d5178ee	snd_ac97_set_rate	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xbf9d1b96	nfsd_debug	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc21443e6	ct_sip_parse_numerical_param	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xaf62058a	cx88_core_put	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xd3383957	af9005_rc_keys_size	drivers/media/dvb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL
+0x21451ac4	drm_sman_owner_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4ca12ff3	drm_get_resource_start	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xc2e765d2	amd_unregister_ecc_decoder	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0xab28ab5d	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0xa41a6534	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x4f783f30	acpi_read	vmlinux	EXPORT_SYMBOL
+0xb0905a57	pci_disable_device	vmlinux	EXPORT_SYMBOL
+0x44282f81	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0xe58a3360	p9_error_init	net/9p/9pnet	EXPORT_SYMBOL
+0x94dd2560	fscache_obtained_object	fs/fscache/fscache	EXPORT_SYMBOL
+0x8d70ce1f	uwb_ack_policy_store	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x4b407e2f	rt2x00mac_add_interface	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x4ef97b84	dma_release_channel	vmlinux	EXPORT_SYMBOL_GPL
+0xae4dfd6b	mdiobus_read	vmlinux	EXPORT_SYMBOL
+0x30e74134	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x83904ad4	per_cpu__irq_regs	vmlinux	EXPORT_SYMBOL
+0x0f9fd9c0	rpc_ntop	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xccc2372e	rpc_pton	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x2d2b270a	alloc_hdlcdev	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0xc0e69f82	mpt_device_driver_deregister	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x759d84e2	b1dma_release_appl	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x0bcba5e7	ib_query_port	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xcfd9a2c0	des_ekey	crypto/des_generic	EXPORT_SYMBOL_GPL
+0x22bce513	mdio_mii_ioctl	drivers/net/mdio	EXPORT_SYMBOL
+0xa3ec7a7b	drm_irq_install	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xfee8ef7b	ks0108_address	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0xae7102e7	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x3208f7d8	key_link	vmlinux	EXPORT_SYMBOL
+0xd8daebc1	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x9629486a	per_cpu__cpu_number	vmlinux	EXPORT_SYMBOL
+0x43e4defc	mdio45_nway_restart	drivers/net/mdio	EXPORT_SYMBOL
+0xb663e226	eip_interrupt	drivers/net/8390p	EXPORT_SYMBOL
+0x1e45a8b8	videobuf_queue_to_vmalloc	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x7297f7fd	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x9a78a84c	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x23e96417	dquot_drop	vmlinux	EXPORT_SYMBOL
+0x4d213730	snd_hda_codec_amp_update	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x47ff920d	snd_opl3_new	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0xf7b55990	nand_scan	drivers/mtd/nand/nand	EXPORT_SYMBOL_GPL
+0xc3401729	mISDN_register_clock	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xa76fe9f4	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0xe13cd8a7	dmi_name_in_vendors	vmlinux	EXPORT_SYMBOL
+0x3398ae6a	phy_scan_fixups	vmlinux	EXPORT_SYMBOL
+0xa8d68abd	acpi_warning	vmlinux	EXPORT_SYMBOL
+0x885c5526	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0xf19294db	bt_sock_unregister	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x0d44ae09	wlp_eda_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x628853db	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0xc368f687	pcmcia_socket_list_rwsem	vmlinux	EXPORT_SYMBOL
+0xa0925f14	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x8b989cf9	acpi_bus_can_wakeup	vmlinux	EXPORT_SYMBOL
+0x647844de	keyring_clear	vmlinux	EXPORT_SYMBOL
+0xfebc9935	__kill_fasync	vmlinux	EXPORT_SYMBOL
+0x5186518f	profile_pc	vmlinux	EXPORT_SYMBOL
+0x83aa4177	snd_timer_resolution	sound/core/snd-timer	EXPORT_SYMBOL
+0x69c3f959	gss_service_to_auth_domain_name	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x894098da	jbd2_journal_wipe	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x3c2f13d0	iwl_set_decrypted_flag	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7e1183c9	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x1e0c2be4	ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x18b9c832	snd_hda_multi_out_analog_prepare	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xd331fc1d	p9pdu_dump	net/9p/9pnet	EXPORT_SYMBOL
+0xe5be5eae	wlp_uuid_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x08c6bd5b	mlx4_fmr_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xee93522c	hisax_register	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x883883f9	__ps2_command	vmlinux	EXPORT_SYMBOL
+0xb5770413	pcmcia_socket_dev_early_resume	vmlinux	EXPORT_SYMBOL
+0x0a0216bc	fb_set_var	vmlinux	EXPORT_SYMBOL
+0x6eeda40f	__nla_put	vmlinux	EXPORT_SYMBOL
+0x0ca5d7c4	generic_unplug_device	vmlinux	EXPORT_SYMBOL
+0x0237b57a	arch_unregister_cpu	vmlinux	EXPORT_SYMBOL
+0x1aeecf6b	svc_sock_names	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x17e08779	inet_diag_register	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL
+0x1753d85d	sas_port_mark_backlink	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x930784cf	fc_fcp_complete	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x7a2b8630	dm_rh_dirty_log	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xa9aec96b	pcmcia_adjust_io_region	vmlinux	EXPORT_SYMBOL
+0x85477b47	ata_pci_sff_prepare_host	vmlinux	EXPORT_SYMBOL_GPL
+0x1f8ec1b3	acpi_get_pci_rootbridge_handle	vmlinux	EXPORT_SYMBOL_GPL
+0xa145d824	blk_trace_startstop	vmlinux	EXPORT_SYMBOL_GPL
+0x72a02d3c	snd_pcm_hw_rule_add	sound/core/snd-pcm	EXPORT_SYMBOL
+0x570aaa2c	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x3d4d9657	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x07ff4aea	xenbus_scanf	vmlinux	EXPORT_SYMBOL_GPL
+0xda8af7ad	fb_find_nearest_mode	vmlinux	EXPORT_SYMBOL
+0xde417b81	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x31fd8ac8	snd_card_file_remove	sound/core/snd	EXPORT_SYMBOL
+0x3b91f3af	snd_free_pages	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0x3101936e	rds_message_add_extension	net/rds/rds	EXPORT_SYMBOL_GPL
+0x104cd198	rds_info_copy	net/rds/rds	EXPORT_SYMBOL_GPL
+0xb5f1e7a9	__iscsi_complete_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xf9765833	dmi_match	vmlinux	EXPORT_SYMBOL_GPL
+0x063d96b6	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
+0xc2ddad6a	get_phy_id	vmlinux	EXPORT_SYMBOL
+0x932fb349	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0xc4c21bf5	security_inode_getsecctx	vmlinux	EXPORT_SYMBOL
+0xefdd5a63	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x8f9c199c	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x5a4896a8	__put_user_2	vmlinux	EXPORT_SYMBOL
+0xcf6044c0	snd_ac97_read	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xf3797152	snd_interval_ratnum	sound/core/snd-pcm	EXPORT_SYMBOL
+0x966ed6b8	iwlcore_eeprom_release_semaphore	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xcccfb2fa	sata_deb_timing_hotplug	vmlinux	EXPORT_SYMBOL_GPL
+0x6576bca4	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x37b9d4c4	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x622bcbac	__pm_runtime_set_status	vmlinux	EXPORT_SYMBOL_GPL
+0x1f602f2f	tpm_bios_log_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x0daa8dc6	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x44161c19	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x78f3b8b1	wimax_msg_send	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0xae5500ec	ipv6_dev_get_saddr	net/ipv6/ipv6	EXPORT_SYMBOL
+0xaff5a1eb	iwl_uninit_drv	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa7888c0e	tea5761_autodetection	drivers/media/common/tuners/tea5761	EXPORT_SYMBOL_GPL
+0xc8af50c3	dm_register_path_selector	drivers/md/dm-multipath	EXPORT_SYMBOL_GPL
+0xb98537cb	rrrr_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0xe57cfd03	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x783ecbf1	tpm_show_pcrs	vmlinux	EXPORT_SYMBOL_GPL
+0xc60502be	call_usermodehelper_setkeys	vmlinux	EXPORT_SYMBOL
+0xa8a6f639	__check_region	vmlinux	EXPORT_SYMBOL
+0xc5a892b0	pn_sock_hash	net/phonet/phonet	EXPORT_SYMBOL
+0x899ad648	nf_nat_protocol_register	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0xda2af776	hci_conn_hold_device	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xfc16bc2a	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0xd62436ca	key_task_permission	vmlinux	EXPORT_SYMBOL
+0xdb0c5156	snd_i2c_bus_create	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0xade88e76	snd_malloc_pages	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0x39cd1f9b	ieee80211_rate_control_register	net/mac80211/mac80211	EXPORT_SYMBOL
+0xc8a520cd	nf_nat_protocol_unregister	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0xe07ced31	inet_diag_unregister	net/ipv4/inet_diag	EXPORT_SYMBOL_GPL
+0x455437d8	iscsi_offload_mesg	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x9f0dd6ac	sas_domain_attach_transport	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x552ead02	detach_capi_ctr	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x0fa08ca7	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x42595e58	vgacon_text_force	vmlinux	EXPORT_SYMBOL
+0x22e2e43e	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0xe5692487	snd_hwdep_new	sound/core/snd-hwdep	EXPORT_SYMBOL
+0xb2a8dfda	rt2x00usb_vendor_request_buff	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x7b7909d1	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x9daa2587	rtc_set_mmss	vmlinux	EXPORT_SYMBOL_GPL
+0xfc4f55f3	down_interruptible	vmlinux	EXPORT_SYMBOL
+0xf7e1e950	mmc_request_done	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x0611ed75	ipmi_set_gets_events	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xac7ddba9	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x35d8c94a	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x8a00ccaa	vfs_quota_off	vmlinux	EXPORT_SYMBOL
+0xa719b668	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0xa58ff7c7	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x2b9d6102	snd_ctl_boolean_stereo_info	sound/core/snd	EXPORT_SYMBOL
+0xa470d45a	ip6_sk_dst_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0xa5f5a4d9	parport_ieee1284_epp_read_addr	drivers/parport/parport	EXPORT_SYMBOL
+0xf166fde1	sdio_writew	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x3522ece7	edac_pci_add_device	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x3744cf36	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0xf0afa19d	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x20789fcc	__ieee80211_get_assoc_led_name	net/mac80211/mac80211	EXPORT_SYMBOL
+0xf181d11b	ieee80211_ctstoself_duration	net/mac80211/mac80211	EXPORT_SYMBOL
+0x4d5dc35f	fuse_request_send	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x6feb2039	acpi_write	vmlinux	EXPORT_SYMBOL
+0x870a57e4	nf_ct_expect_put	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x63ef13df	tda829x_attach	drivers/media/common/tuners/tda8290	EXPORT_SYMBOL_GPL
+0x6cc5a90b	register_tcf_proto_ops	vmlinux	EXPORT_SYMBOL
+0x318920b1	register_dock_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xe9f5a5ee	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x01c97cf0	lock_super	vmlinux	EXPORT_SYMBOL
+0xff480992	dump_fpu	vmlinux	EXPORT_SYMBOL
+0x0f1e7525	wimax_dev_init	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x7eee8ce3	fuse_conn_get	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x00f5d358	osd_req_flush_obsd	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x5364f77c	iscsi_suspend_tx	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x3896a53c	hdlc_start_xmit	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0xc7a95298	unregister_md_personality	vmlinux	EXPORT_SYMBOL
+0x55b294e8	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x33c95a2b	xenbus_unmap_ring_vfree	vmlinux	EXPORT_SYMBOL_GPL
+0x7712771a	unbind_from_irqhandler	vmlinux	EXPORT_SYMBOL_GPL
+0xc9ab2eef	acpi_os_wait_events_complete	vmlinux	EXPORT_SYMBOL
+0x952a3ce7	filp_open	vmlinux	EXPORT_SYMBOL
+0x8ab25418	get_empty_filp	vmlinux	EXPORT_SYMBOL
+0xa834d37b	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x72094fde	oxygen_reset_uart	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xd0b70ffc	snd_rawmidi_set_ops	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x88cc66cc	snd_pcm_link_rwlock	sound/core/snd-pcm	EXPORT_SYMBOL
+0x8dabbc55	ip_vs_tcp_conn_listen	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x69e9a1d4	xfrm6_prepare_output	net/ipv6/ipv6	EXPORT_SYMBOL
+0x1d99d49a	dccp_timestamp	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x32b9033b	ir_codes_apac_viewcomp_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x1cb148f5	ir_extract_bits	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x016b9869	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x34f7309d	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x6aef6cfb	agp_allocate_memory	vmlinux	EXPORT_SYMBOL
+0x3dd8c9cf	pci_read_vpd	vmlinux	EXPORT_SYMBOL
+0xc64b8442	copy_io_context	vmlinux	EXPORT_SYMBOL
+0x8fa74514	sysdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x87c1af12	get_disk	vmlinux	EXPORT_SYMBOL
+0x18081b50	__free_pages	vmlinux	EXPORT_SYMBOL
+0xab57e311	tracepoint_probe_register	vmlinux	EXPORT_SYMBOL_GPL
+0xf8802492	print_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0xa47e45d2	nf_nat_amanda_hook	net/netfilter/nf_conntrack_amanda	EXPORT_SYMBOL_GPL
+0x8b2bd518	parport_get_port	drivers/parport/parport	EXPORT_SYMBOL
+0x79d34a43	parport_put_port	drivers/parport/parport	EXPORT_SYMBOL
+0x98a4c3eb	inet_bind	vmlinux	EXPORT_SYMBOL
+0xeab314e6	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL
+0x5404f924	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL
+0x632951b1	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x0a1cc545	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x0cd6248c	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0xf3306d78	thaw_process	vmlinux	EXPORT_SYMBOL
+0xcf8d1cce	v9fs_register_trans	net/9p/9pnet	EXPORT_SYMBOL
+0xcd1edda6	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0xed187fdf	pci_assign_resource	vmlinux	EXPORT_SYMBOL
+0x2e11ce89	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x6902d93b	journal_try_to_free_buffers	fs/jbd/jbd	EXPORT_SYMBOL
+0xa4e1607f	dvb_generic_open	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x3c168290	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0xed41170e	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0xd8e336f5	skb_split	vmlinux	EXPORT_SYMBOL
+0x74075e55	input_grab_device	vmlinux	EXPORT_SYMBOL
+0xb4b422e6	default_mtd_writev	vmlinux	EXPORT_SYMBOL_GPL
+0xb0261384	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0xc6d00767	regulator_get_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x74b91444	regulator_get_init_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0xf10de535	ioread8	vmlinux	EXPORT_SYMBOL
+0x53978d13	iwl_clear_stations_table	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xae225455	eip_open	drivers/net/8390p	EXPORT_SYMBOL
+0x10ff55c7	ib_destroy_srq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x686c703f	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x2fa346a0	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x0343bdf1	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
+0x4fd033a0	pcmcia_error_func	vmlinux	EXPORT_SYMBOL
+0xb6230f1f	gnttab_grant_foreign_access	vmlinux	EXPORT_SYMBOL_GPL
+0x9401a07c	pci_get_hp_params	vmlinux	EXPORT_SYMBOL_GPL
+0x2632db4e	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x2103fa09	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0xc3cf1128	in_group_p	vmlinux	EXPORT_SYMBOL
+0xc7c89f9f	apic	vmlinux	EXPORT_SYMBOL_GPL
+0x8f127c06	osd_req_write	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xb0a8ef38	ir_codes_rc5_tv_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x99719ad5	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x05e6eaef	tcp_md5_hash_key	vmlinux	EXPORT_SYMBOL
+0x95034833	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0xf9249d19	snd_timer_stop	sound/core/snd-timer	EXPORT_SYMBOL
+0x13f4bac9	sdio_register_driver	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xf53d4c26	qdisc_class_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x09ddb585	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
+0xc6c565b1	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
+0xf70e7cc7	ata_sff_lost_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x36ac2037	tifm_add_adapter	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x47463001	dst_error_recovery	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x4744b665	drm_helper_encoder_in_use	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x593a36c2	scsi_dh_handler_exist	vmlinux	EXPORT_SYMBOL_GPL
+0x226e86a9	audit_log	vmlinux	EXPORT_SYMBOL
+0xfb3cfa0b	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0xe19aa117	snd_sbdsp_get_byte	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0xc7358e62	xdr_process_buf	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x81e7da1d	iwl_tt_enter_ct_kill	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xb9a95edd	dib8000_set_wbd_ref	drivers/media/dvb/frontends/dib8000	EXPORT_SYMBOL
+0x1e9dbbd7	tda18271_attach	drivers/media/common/tuners/tda18271	EXPORT_SYMBOL_GPL
+0x5cb895f3	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0xaca9db90	ata_sff_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x0f28cb91	nvram_read_byte	vmlinux	EXPORT_SYMBOL
+0xedbc6f67	gnttab_end_foreign_access	vmlinux	EXPORT_SYMBOL_GPL
+0x53e26839	pci_enable_wake	vmlinux	EXPORT_SYMBOL
+0x0662e2f0	ring_buffer_empty_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x65735444	snd_ac97_update_power	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x7e945021	snd_ak4114_reinit	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0xe86650e0	lib80211_unregister_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL
+0xbdab03a8	v4l2_int_device_register	drivers/media/video/v4l2-int-device	EXPORT_SYMBOL_GPL
+0x28d6e0ea	xt_replace_table	vmlinux	EXPORT_SYMBOL_GPL
+0x7ab3c122	edac_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0xbaf8ea27	acpi_lock_battery_dir	vmlinux	EXPORT_SYMBOL
+0x5a57d155	__percpu_counter_init	vmlinux	EXPORT_SYMBOL
+0x56398615	mark_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x15b0606e	e820_any_mapped	vmlinux	EXPORT_SYMBOL_GPL
+0x26a21c0c	snd_wss_get_single	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x9765a512	snd_wss_put_single	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xe6df29c7	snd_midi_event_encode_byte	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0x65467f3c	usb_stor_bulk_transfer_sg	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xd9822ca1	sas_task_abort	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x9e839b37	iscsi_host_set_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xc08b61f5	v4l2_int_device_unregister	drivers/media/video/v4l2-int-device	EXPORT_SYMBOL_GPL
+0x71c1f6f1	dm_dispatch_request	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0xd43a17c2	rdma_resolve_ip	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0xacc2e4f1	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x53bf08b1	tpm_remove_hardware	vmlinux	EXPORT_SYMBOL_GPL
+0x7e1db573	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL
+0xc4c55023	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0xf9899664	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x664e8550	set_cpus_allowed_ptr	vmlinux	EXPORT_SYMBOL_GPL
+0xab38f367	snd_vx_setup_firmware	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xbab5aee0	sas_register_ha	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xc67055ee	iwl_txq_check_empty	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xae84f1fe	tcf_em_tree_dump	vmlinux	EXPORT_SYMBOL
+0x39741b40	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x6971447a	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x7e64181d	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL
+0xf4e97fb4	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x4d0ee131	crypto_init_shash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0xac7bb0e1	crypto_init_ahash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x7285f84f	unregister_jprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x52ebb126	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x5af21e0b	snd_emu10k1_ptr_read	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0xe0af6d29	svc_sock_update_bufs	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xeae931e6	vcc_insert_socket	net/atm/atm	EXPORT_SYMBOL
+0x5943be6f	uwb_rsv_get_usable_mas	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x350fb00b	osd_req_remove_partition	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x90a1b72a	skb_pull	vmlinux	EXPORT_SYMBOL
+0x15a7d544	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x08ca8114	ata_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x09c8eb55	font_vga_8x16	vmlinux	EXPORT_SYMBOL
+0x96ed3393	pci_add_new_bus	vmlinux	EXPORT_SYMBOL
+0xa2827d76	snd_hda_get_jack_location	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x4f2bb3cf	uwb_rts_cts_store	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x6342cc6e	fw_iso_context_start	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x93d2422d	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x9080d640	phy_start_interrupts	vmlinux	EXPORT_SYMBOL
+0xdbb9d0f3	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0xf82e3d47	acpi_initialize_objects	vmlinux	EXPORT_SYMBOL
+0xfa1f4662	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x132c0ace	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x9765d9b2	snd_hda_codec_set_pincfg	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x8314d984	snd_hda_codec_get_pincfg	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x64b4e996	fc_fcp_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x7fd8efa5	parport_register_port	drivers/parport/parport	EXPORT_SYMBOL
+0xdd3a05e4	lbs_stop_card	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x7a0a47fe	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0xcccab8eb	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0xf5ccf15f	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0xe0c0d0bf	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x891c8a11	cpufreq_global_kobject	vmlinux	EXPORT_SYMBOL
+0x1c8a04b0	acpi_reset	vmlinux	EXPORT_SYMBOL
+0xa5c36cec	inotify_unmount_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0xa237bbd0	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0xf891105b	snd_emux_lock_voice	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0xd60a3e76	oxygen_read16	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x89bf8d9c	ieee80211_stop_tx_ba_cb	net/mac80211/mac80211	EXPORT_SYMBOL
+0xa89ea9cb	drm_mode_validate_clocks	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x1db66b3f	drm_rmmap_locked	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x957b53ce	edac_pci_handle_npe	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x93ba5cd5	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x98b1f054	register_gifconf	vmlinux	EXPORT_SYMBOL
+0xbf96736f	cpufreq_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x36759cc3	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x457594fa	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x6466a1e6	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x86f6b99d	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x12d75819	cfg80211_classify8021d	net/wireless/cfg80211	EXPORT_SYMBOL
+0x459bd478	inet_dccp_listen	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x7a3ca43e	ata_do_dev_read_id	vmlinux	EXPORT_SYMBOL_GPL
+0xd3951da4	acpi_resource_to_address64	vmlinux	EXPORT_SYMBOL
+0x3cddaf67	iscsi_conn_stop	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xd03c7700	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x3d7ea99a	gnttab_grant_foreign_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x8ae77528	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x965197dd	atm_charge	net/atm/atm	EXPORT_SYMBOL
+0x3d3827f7	i2c_bus_type	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0x63081a72	pccard_static_ops	vmlinux	EXPORT_SYMBOL
+0xdc43a9c8	daemonize	vmlinux	EXPORT_SYMBOL
+0xaaa76463	kmap	vmlinux	EXPORT_SYMBOL
+0x8c783bc0	rpc_malloc	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x1bf13b5e	icmpv6_send	net/ipv6/ipv6	EXPORT_SYMBOL
+0x3fc23318	fscache_wait_bit	fs/fscache/fscache	EXPORT_SYMBOL
+0x64ebe677	wmi_query_block	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0xb9eb3906	usbnet_pause_rx	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x114dd2e9	video_device_release_empty	drivers/media/video/videodev	EXPORT_SYMBOL
+0x4dfb0831	put_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xd1adea37	regulator_set_current_limit	vmlinux	EXPORT_SYMBOL_GPL
+0x86a51007	gnttab_end_foreign_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x198356fb	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x705761c6	put_page	vmlinux	EXPORT_SYMBOL
+0x6901119a	trace_nowake_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x3aa1dbcf	_spin_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x74954462	timecounter_read	vmlinux	EXPORT_SYMBOL
+0x6897d9a2	rpc_lookup_cred	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x041013fd	nf_conntrack_lock	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xca600855	bt878	drivers/media/dvb/bt8xx/bt878	EXPORT_SYMBOL
+0x046ece15	saa7146_vv_release	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0x6661e396	led_classdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x3360d001	rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x9fd06519	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x1090cec6	security_inode_setsecctx	vmlinux	EXPORT_SYMBOL
+0x8223976d	dquot_scan_active	vmlinux	EXPORT_SYMBOL
+0x8d27791f	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0xcebc5f88	p9_client_walk	net/9p/9pnet	EXPORT_SYMBOL
+0x7921f3d0	mpt_set_taskmgmt_in_progress_flag	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x6c794b85	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0xc181fa09	neigh_update	vmlinux	EXPORT_SYMBOL
+0x0201c6bf	phy_stop	vmlinux	EXPORT_SYMBOL
+0x89d9ea8d	ata_dummy_port_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00546468	put_io_context	vmlinux	EXPORT_SYMBOL
+0xeb88f029	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0xcb36ee33	bd_claim_by_disk	vmlinux	EXPORT_SYMBOL_GPL
+0xbb6ebc39	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0xb45b24f6	k8_nb_ids	vmlinux	EXPORT_SYMBOL
+0xfe727411	get_phys_to_machine	vmlinux	EXPORT_SYMBOL_GPL
+0x8c6199e3	snd_vx_check_reg_bit	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0x045072cd	nf_ct_port_nla_policy	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xc1f87b7d	ieee80211_generic_frame_duration	net/mac80211/mac80211	EXPORT_SYMBOL
+0xddbb36f3	iscsi_conn_start	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x8a89e397	em28xx_uninit_isoc	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x10dd3f6d	ethtool_op_set_tx_hw_csum	vmlinux	EXPORT_SYMBOL
+0x3f1899f1	up	vmlinux	EXPORT_SYMBOL
+0x2cf647c4	rpc_call_start	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xd5e27d72	rds_page_copy_user	net/rds/rds	EXPORT_SYMBOL_GPL
+0xf2c86d27	iscsi_lookup_endpoint	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xc9592536	ubi_leb_unmap	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x7c028d4d	nand_scan_tail	drivers/mtd/nand/nand	EXPORT_SYMBOL_GPL
+0x98a68ed1	icmp_send	vmlinux	EXPORT_SYMBOL
+0x947ab0ca	pci_hp_remove_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x9a7e5167	path_get	vmlinux	EXPORT_SYMBOL
+0xa625d6f4	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x531b604e	__virt_addr_valid	vmlinux	EXPORT_SYMBOL
+0x79a1dcc6	iwl_rx_replenish	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x0a22a91c	mlx4_uar_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xc95ad02d	mISDN_initdchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xa920e090	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x15ae2479	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
+0xbfe6adb2	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x23864ce7	cpuset_mem_spread_node	vmlinux	EXPORT_SYMBOL_GPL
+0xe466edff	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x867c684a	setup_APIC_eilvt_ibs	vmlinux	EXPORT_SYMBOL_GPL
+0x9ca0ee43	snd_cards	sound/core/snd	EXPORT_SYMBOL
+0x05ce6d23	sdhci_resume_host	drivers/mmc/host/sdhci	EXPORT_SYMBOL_GPL
+0x7a45377b	acpi_video_unregister	drivers/acpi/video	EXPORT_SYMBOL
+0x6c702af7	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x48b5d784	dev_open	vmlinux	EXPORT_SYMBOL
+0xcf7a962e	cn_add_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x8cc79cab	iowrite16_rep	vmlinux	EXPORT_SYMBOL
+0xbfc177bc	iowrite32_rep	vmlinux	EXPORT_SYMBOL
+0x89aafd60	ilookup	vmlinux	EXPORT_SYMBOL
+0x4302d0eb	free_pages	vmlinux	EXPORT_SYMBOL
+0x4bbb7f27	snd_mpu401_uart_interrupt_tx	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL
+0x451dc950	nat_q931_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xcda0ded2	btcx_screen_clips	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0x1c48dd31	gigaset_m10x_input	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x81e6b37f	dmi_get_system_info	vmlinux	EXPORT_SYMBOL
+0xf1932e29	mdiobus_free	vmlinux	EXPORT_SYMBOL
+0xa03523d5	security_unix_stream_connect	vmlinux	EXPORT_SYMBOL
+0x5f3a6edf	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0xd43c4f63	__f_setown	vmlinux	EXPORT_SYMBOL
+0xf1463412	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0xf0c0df3c	nf_nat_mangle_tcp_packet	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0x8307afef	lbs_send_tx_feedback	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x54efc750	video_register_device_no_warn	drivers/media/video/videodev	EXPORT_SYMBOL
+0x3730151d	tea5767_attach	drivers/media/common/tuners/tea5767	EXPORT_SYMBOL_GPL
+0xee9feae8	xt_find_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x62737e1d	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x2a0a2ec8	kset_register	vmlinux	EXPORT_SYMBOL
+0x928e3a8e	fput	vmlinux	EXPORT_SYMBOL
+0xacafa8e7	vector_used_by_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x253f3d14	vmbus_get_interface	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL
+0x3fd927fe	sas_phy_delete	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x1d77b399	iwl_bcast_addr	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xfa96afb9	pcmcia_get_window	vmlinux	EXPORT_SYMBOL
+0x4705ccdf	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x5108b3fc	acpi_os_map_memory	vmlinux	EXPORT_SYMBOL_GPL
+0xe4009bfd	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0xa3c73e83	wimax_msg_len	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0xef0c20ac	ip6_frag_init	net/ipv6/ipv6	EXPORT_SYMBOL
+0xf62a174a	journal_set_features	fs/jbd/jbd	EXPORT_SYMBOL
+0xeae74760	scsi_nl_send_transport_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x9174c443	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x26057882	sas_phy_free	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xdc4971e8	cx88_risc_databuffer	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x211713b5	smscore_unregister_device	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xd3ffab51	drm_ht_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xea70e72c	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL
+0x135a56e7	regulator_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x14f05243	add_disk	vmlinux	EXPORT_SYMBOL
+0x2eb9a0e8	_read_lock_irq	vmlinux	EXPORT_SYMBOL
+0xdb42d8a7	snd_wss_out	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xfc852663	xt_rateest_put	net/netfilter/xt_RATEEST	EXPORT_SYMBOL_GPL
+0x8ec83224	mptscsih_info	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x08a392e1	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x01fd453e	usbhid_lookup_quirk	vmlinux	EXPORT_SYMBOL_GPL
+0x85a1c562	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0xc824f767	snd_hda_override_amp_caps	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xe93468d6	video_output_unregister	drivers/video/output	EXPORT_SYMBOL
+0x0b8aad57	uwb_est_unregister	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x1cc0b3c0	iscsi_requeue_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x8c4d5a19	mlx4_qp_modify	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x72d4e8d4	drm_handle_vblank	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xcd94a3a4	inet_csk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0xd306af19	xt_unregister_table	vmlinux	EXPORT_SYMBOL_GPL
+0x4eb183dd	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x4e830a3e	strnicmp	vmlinux	EXPORT_SYMBOL
+0x951722c9	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x1d027e4b	snd_pcm_format_signed	sound/core/snd-pcm	EXPORT_SYMBOL
+0xe1d5a325	journal_start_commit	fs/jbd/jbd	EXPORT_SYMBOL
+0xe3f4dd99	hostap_80211_ops	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x86635e5b	hostap_info_init	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xe24a7b88	drm_ht_find_item	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x113bc3aa	qdisc_calculate_pkt_len	vmlinux	EXPORT_SYMBOL
+0xa9195f46	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0xb144d8e5	fbcon_set_bitops	vmlinux	EXPORT_SYMBOL
+0x3a5b8ac7	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x02649054	security_sock_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x11a18b14	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x655cb202	snd_sf_linear_to_log	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0xf36714a8	xdr_encode_array2	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x08ed0b62	mac_vmode_to_var	drivers/video/macmodes	EXPORT_SYMBOL
+0x0e394729	flexcop_sram_ctrl	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x0d50aef1	fw_iso_context_create	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x093c8b2e	sock_release	vmlinux	EXPORT_SYMBOL
+0xc3c442ed	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x679833f6	pci_find_device	vmlinux	EXPORT_SYMBOL
+0x8d17dd4e	user_instantiate	vmlinux	EXPORT_SYMBOL_GPL
+0x1b89419f	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x4e688a70	snd_emu10k1_synth_bzero	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0x9bbdc21b	ct_sip_get_sdp_header	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xf829cd56	nf_nat_icmp_reply_translation	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0x75811312	crc_ccitt_table	lib/crc-ccitt	EXPORT_SYMBOL
+0xa0b0bdd1	nlmclnt_proc	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x62727d56	iwl_calib_set	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x444d8587	mlx4_mtt_addr	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x240e5fd1	b1dmactl_read_proc	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0xb49c2612	drm_debugfs_create_files	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x34908c14	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x5262fac2	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x7b4b64bf	register_posix_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x08a3e5d1	net_ipv6_ctl_path	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x83581089	gf128mul_init_4k_lle	crypto/gf128mul	EXPORT_SYMBOL
+0x9b2560b9	gf128mul_init_4k_bbe	crypto/gf128mul	EXPORT_SYMBOL
+0xa0255440	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0xf9f123ec	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x1ae63dd1	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x55dabfb6	scsi_dh_attach	vmlinux	EXPORT_SYMBOL_GPL
+0xa80ce981	scsi_dh_detach	vmlinux	EXPORT_SYMBOL_GPL
+0xcfadd723	__percpu_counter_add	vmlinux	EXPORT_SYMBOL
+0x8dca832f	__percpu_counter_sum	vmlinux	EXPORT_SYMBOL
+0xf786ef5e	idr_init	vmlinux	EXPORT_SYMBOL
+0xbb89de17	ida_init	vmlinux	EXPORT_SYMBOL
+0xdbcdfda2	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x70bc17d7	inode_wait	vmlinux	EXPORT_SYMBOL
+0xd6ee688f	vmalloc	vmlinux	EXPORT_SYMBOL
+0xd6cb3359	fc_setup_rport	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xed47b224	hermes_struct_init	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x755e6b3c	ib_free_fast_reg_page_list	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x40809959	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x3ea0b48c	pci_request_region	vmlinux	EXPORT_SYMBOL
+0x7eb017d0	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x5f56db66	per_cpu__ftrace_event_seq	vmlinux	EXPORT_SYMBOL
+0x60f047af	snd_emu10k1_voice_free	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0xcd8fb50e	ct_sip_parse_request	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xa74e109a	wlp_uuid_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xb23f3eb0	wm831x_bulk_read	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x65b2df20	flexcop_sram_set_dest	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xdd3febe2	drm_gem_object_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2f149b4b	ata_sff_irq_on	vmlinux	EXPORT_SYMBOL_GPL
+0xf11543ff	find_first_zero_bit	vmlinux	EXPORT_SYMBOL
+0xec5ba3b8	mb_cache_entry_find_first	fs/mbcache	EXPORT_SYMBOL
+0x7de2b351	ib_attach_mcast	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xbd38a9be	ib_detach_mcast	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x72f08e65	drm_get_edid	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe454ea1b	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x303f804b	x86_dma_fallback_dev	vmlinux	EXPORT_SYMBOL
+0x6cd07288	gss_mech_get_by_name	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x6b754e6f	p9_parse_header	net/9p/9pnet	EXPORT_SYMBOL
+0x2ea2be72	__sas_task_abort	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xbee80b93	ppp_unregister_compressor	drivers/net/ppp_generic	EXPORT_SYMBOL
+0x99a55a0e	recv_Dchannel_skb	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x31c24aa4	capi20_isinstalled	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xdf66ca81	ucode_cpu_info	arch/x86/kernel/microcode	EXPORT_SYMBOL_GPL
+0x70760fcd	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0xbb96268a	agp_generic_alloc_page	vmlinux	EXPORT_SYMBOL
+0x8c6929da	acpi_bus_add	vmlinux	EXPORT_SYMBOL
+0xd32df3b0	bio_split	vmlinux	EXPORT_SYMBOL
+0x70360f0c	lock_rename	vmlinux	EXPORT_SYMBOL
+0x16f12fc2	snd_hda_codec_configure	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xf531b451	dccp_set_state	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x551b9d50	v4l2_chip_match_i2c_client	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0xc1a2e6dc	i2c_bit_add_bus	drivers/i2c/algos/i2c-algo-bit	EXPORT_SYMBOL
+0xf7fcaf85	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x2d399a80	pci_pme_active	vmlinux	EXPORT_SYMBOL
+0x0cd19d6d	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL
+0xdb82d28b	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x09a7021c	mutex_lock_killable	vmlinux	EXPORT_SYMBOL
+0x1e2653c7	xdr_inline_decode	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xec766bbd	__fscache_check_page_write	fs/fscache/fscache	EXPORT_SYMBOL
+0xde6eba24	usb_ftdi_elan_edset_single	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0xd12f281f	mlx4_register_vlan	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x737470e0	fw_iso_buffer_destroy	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xe409b491	crypto_aes_decrypt_x86	arch/x86/crypto/aes-i586	EXPORT_SYMBOL_GPL
+0x627e608e	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x2cc42e0a	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x46e9bf10	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x7158e706	ata_bmdma_status	vmlinux	EXPORT_SYMBOL_GPL
+0x15aa4c50	snd_timer_start	sound/core/snd-timer	EXPORT_SYMBOL
+0x81e6ec4d	usb_serial_generic_read_bulk_callback	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x26ed949e	iwl_tx_cmd_complete	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x17100ac3	iwl_eeprom_query_addr	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x28ea03b9	drm_mode_attachmode_crtc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x268cc6a2	sys_close	vmlinux	EXPORT_SYMBOL
+0x97b22d04	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0xa2bf037b	fat_build_inode	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x76c6fc06	mlx4_qp_remove	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x23f999e6	s5h1409_attach	drivers/media/dvb/frontends/s5h1409	EXPORT_SYMBOL
+0xc10fe128	cdebbuf_free	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xb04c9b3d	register_pernet_gen_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0xa4d4f0e6	global_cache_flush	vmlinux	EXPORT_SYMBOL
+0xd1472061	acpi_pci_register_driver	vmlinux	EXPORT_SYMBOL
+0xf315f9f1	seq_read	vmlinux	EXPORT_SYMBOL
+0xb8dfc4de	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x6980fe91	param_get_int	vmlinux	EXPORT_SYMBOL
+0xdf227c9c	snd_hda_codec_write	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x98ba3b81	tcf_hash_new_index	vmlinux	EXPORT_SYMBOL
+0x1150fc87	start_tty	vmlinux	EXPORT_SYMBOL
+0x3f84d4c9	gnttab_release_grant_reference	vmlinux	EXPORT_SYMBOL_GPL
+0x5600904f	fb_get_color_depth	vmlinux	EXPORT_SYMBOL
+0x590fbb0f	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0xbc931114	user_update	vmlinux	EXPORT_SYMBOL_GPL
+0xcd3cce46	snd_pcm_notify	sound/core/snd-pcm	EXPORT_SYMBOL
+0x09d9cd51	phonet_proto_register	net/phonet/phonet	EXPORT_SYMBOL
+0xfb75254a	nf_ct_get_tuplepr	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x2536bd0a	rt2x00mac_remove_interface	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xf5649781	dm_table_get_mode	drivers/md/dm-mod	EXPORT_SYMBOL
+0xcd986622	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0xd821f038	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0xfdc0c72a	regulator_set_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x0e3aa5b0	pnp_unregister_card_driver	vmlinux	EXPORT_SYMBOL
+0x7b245915	notify_change	vmlinux	EXPORT_SYMBOL
+0xc7c14bee	follow_up	vmlinux	EXPORT_SYMBOL
+0xb224fbe2	param_get_short	vmlinux	EXPORT_SYMBOL
+0xbae3b0db	ieee80211_start_tx_ba_cb_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL
+0xfca610dc	garp_request_join	net/802/garp	EXPORT_SYMBOL_GPL
+0xd982d9ca	sm501_set_clock	drivers/mfd/sm501	EXPORT_SYMBOL_GPL
+0x2916bf63	drm_sman_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2cdd853d	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
+0x96972b47	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0xd21708dc	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x519f7fb9	pm_runtime_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x91481982	__ratelimit	vmlinux	EXPORT_SYMBOL
+0x13b46f37	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0xca85d8cf	tracepoint_probe_update_all	vmlinux	EXPORT_SYMBOL_GPL
+0xbbb98859	edid_info	vmlinux	EXPORT_SYMBOL_GPL
+0xaf8df540	snd_rawmidi_transmit_ack	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x46606883	nf_conntrack_find_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x49ca5ac5	mpt_verify_adapter	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x1ac8112b	dib8000_i2c_enumeration	drivers/media/dvb/frontends/dib8000	EXPORT_SYMBOL
+0x3bf66f4e	md_write_start	vmlinux	EXPORT_SYMBOL
+0x8d55cf04	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x70518333	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0xc5666227	pci_hp_change_slot_info	vmlinux	EXPORT_SYMBOL_GPL
+0x510569f5	simple_empty	vmlinux	EXPORT_SYMBOL
+0x16c57b0c	unregister_jprobes	vmlinux	EXPORT_SYMBOL_GPL
+0xb4ecadae	nf_nat_sip_expect_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xc9924ad1	dccp_make_response	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xcbda6a12	journal_lock_updates	fs/jbd/jbd	EXPORT_SYMBOL
+0xb22beff6	fuse_file_poll	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x04e6918b	__lbs_cmd	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x7e10f6d9	ir_input_init	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x232229bf	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x5775b666	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x4dcc7852	hid_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x820eef8f	__hid_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xbeb61ba3	__pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x44314efb	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x5adc8042	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x387c3e01	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x7b55cdde	hci_register_cb	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x74e05890	umc_match_pci_id	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0x24d6b320	ip_ct_attach	vmlinux	EXPORT_SYMBOL
+0xea3d6763	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x820f81bd	__pm_runtime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x13672f1c	__pm_runtime_put	vmlinux	EXPORT_SYMBOL_GPL
+0xeff3df8e	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0xe7d2aca1	security_sk_classify_flow	vmlinux	EXPORT_SYMBOL
+0x9b8077ac	snd_hda_codec_setup_stream	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x1039c905	wimax_state_get	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x2919b156	xdr_decode_string_inplace	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x63f96884	fscache_cache_cleared_wq	fs/fscache/fscache	EXPORT_SYMBOL
+0xcbd6b4c8	query_amp_caps	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xf9f17392	svc_seq_show	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x199febf8	fc_vport_create	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xe1f66e74	rt2x00pci_suspend	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0xaec56223	ttpci_budget_init	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0xbf3028d7	tcp_md5_hash_header	vmlinux	EXPORT_SYMBOL
+0x5dec950c	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x9b12becd	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0xd0fef3b2	agp_free_key	vmlinux	EXPORT_SYMBOL
+0xa75c8b4b	pnp_device_detach	vmlinux	EXPORT_SYMBOL
+0x9d9f0d41	rwsem_down_write_failed	vmlinux	EXPORT_SYMBOL
+0x5de51cca	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0xc8bc13e2	snd_wss_timer	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x66017ec7	osd_req_decode_sense_full	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x182121f2	fc_lport_destroy	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x64b02fed	ir_codes_avermedia_dvbt_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x6057c6f3	capi_message2cmsg	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xdd431670	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00ebcb5d	ata_id_string	vmlinux	EXPORT_SYMBOL_GPL
+0xb4994f55	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0xc43cd3bc	acpi_unlock_battery_dir	vmlinux	EXPORT_SYMBOL
+0xb252d579	find_lock_page	vmlinux	EXPORT_SYMBOL
+0xcbd52698	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x9e5c2841	wiphy_register	net/wireless/cfg80211	EXPORT_SYMBOL
+0x680dc450	videobuf_to_vmalloc	drivers/media/video/videobuf-vmalloc	EXPORT_SYMBOL_GPL
+0xaa0b5115	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x9940bc15	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x28655e92	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x4c3e4e59	file_permission	vmlinux	EXPORT_SYMBOL
+0x71356fba	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x45947727	param_array_set	vmlinux	EXPORT_SYMBOL
+0x43ab66c3	param_array_get	vmlinux	EXPORT_SYMBOL
+0x81265f73	nf_nat_sdp_addr_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0x4488353e	iscsi_conn_queue_work	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x591253c0	ib_send_cm_sidr_req	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x2ede0527	ib_send_cm_sidr_rep	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xf63370f2	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x1f418230	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0xd73ef534	sysdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0xc692b4b8	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x2be7fb8e	disable_kprobe	vmlinux	EXPORT_SYMBOL_GPL
+0xc6294545	wimax_rfkill	net/wimax/wimax	EXPORT_SYMBOL
+0x5cb3c47d	ipv6_dup_options	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x9b561038	add_mtd_blktrans_dev	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL
+0xc3087995	videobuf_dvb_unregister_bus	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x39534d95	dvb_generic_ioctl	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x012b5ae8	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL
+0xf995ad7e	sys_copyarea	vmlinux	EXPORT_SYMBOL
+0x80de8e1c	drm_fasync	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x6c7af74f	usb_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0xb57d6ca9	pcmcia_resume_card	vmlinux	EXPORT_SYMBOL
+0x8e002cda	acpi_remove_gpe_block	vmlinux	EXPORT_SYMBOL
+0xaff7ed9e	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0xab65ed80	set_memory_uc	vmlinux	EXPORT_SYMBOL
+0xd5308b4c	iwl_power_initialize	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xc7191877	i2c_smbus_write_word_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x6d777605	fw_card_add	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x47ba9bb6	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0xf2f0426b	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x7e275ea8	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0xb86e086f	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x2398473d	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0xd361e0e5	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x3c660398	wpan_phy_free	net/ieee802154/wpan-class	EXPORT_SYMBOL
+0xf770a6b4	wusbd	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xdea7e409	mptscsih_is_phys_disk	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x62637a74	mptscsih_qcmd	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x56610289	dst_attach	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x8acae3dd	ir_codes_pinnacle_pctv_hd_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x5943a1c1	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x766cae4c	snd_util_mem_avail	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x3b30bc05	dccp_disconnect	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x68dad543	lcd_device_unregister	drivers/video/backlight/lcd	EXPORT_SYMBOL
+0x92e364d5	iwl_eeprom_get_mac	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x101f215f	ib_sa_get_mcmember_rec	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x34ea0c00	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0xb1938dce	release_cis_mem	vmlinux	EXPORT_SYMBOL
+0x4772766c	pcim_pin_device	vmlinux	EXPORT_SYMBOL
+0x63856fd6	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x29176a37	tcf_hash_check	vmlinux	EXPORT_SYMBOL
+0xa43b9539	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x96a36fa2	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x384c2790	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x08d66a3a	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0xb6e227aa	rtc_lock	vmlinux	EXPORT_SYMBOL
+0x5cc05cee	exportfs_encode_fh	fs/exportfs/exportfs	EXPORT_SYMBOL_GPL
+0xd4da7803	iwl_find_station	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x71fdc376	videobuf_read_start	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xdc9a3c43	smscore_register_hotplug	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x5e95da31	ir_codes_tt_1500_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x3741bff3	hid_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x92148d79	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL
+0xaa3497d4	ata_sff_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x1bce46a1	pcie_set_readrq	vmlinux	EXPORT_SYMBOL
+0x9558f20d	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x3c390cb3	securityfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x43e17ce8	ilookup5	vmlinux	EXPORT_SYMBOL
+0x41b4deb5	prepare_creds	vmlinux	EXPORT_SYMBOL
+0xa95e5bef	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0xcb301b6e	snd_hda_get_jack_type	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x2058edcb	snd_dma_reserve_buf	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0x4ea1dedd	journal_release_buffer	fs/jbd/jbd	EXPORT_SYMBOL
+0x2cd18d96	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0xb5d968cc	net_assign_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x382c1933	pci_block_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0x83a476ce	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0xb3994c7a	per_cpu__kstat	vmlinux	EXPORT_SYMBOL
+0x6299ea76	wiphy_rfkill_set_hw_state	net/wireless/cfg80211	EXPORT_SYMBOL
+0x2ecba488	sunrpc_cache_pipe_upcall	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbe8caee2	i2400m_set_init_config	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x902e20ef	mlx4_cq_resize	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xb077ef32	acpi_enter_sleep_state	vmlinux	EXPORT_SYMBOL
+0xd89da37f	movable_zone	vmlinux	EXPORT_SYMBOL
+0x7a56a2b6	ring_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x5aa6fa60	iwl_tx_queue_free	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3638517a	iwl_rx_queue_free	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5d0f6f57	kbd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x6793c91f	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x87f962f7	have_submounts	vmlinux	EXPORT_SYMBOL
+0x07cc4a5d	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0xd5d23d73	snd_add_device_sysfs_file	sound/core/snd	EXPORT_SYMBOL
+0x6c5304c5	rpcb_getport_sync	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xdea44926	iwl_set_mode	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xf5c90709	cx88_sram_channel_dump	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xd8f7dab5	dm_rh_update_states	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x613e5279	lro_vlan_hwaccel_receive_frags	vmlinux	EXPORT_SYMBOL
+0xe6ebc016	key_create_or_update	vmlinux	EXPORT_SYMBOL
+0x4273aa83	ring_buffer_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xf397b9aa	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x5efc8166	xprt_adjust_cwnd	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe93d0b47	saa7146_unregister_extension	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0xa20dbc48	ib_process_mad_wc	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xf4f14de6	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x5206ec7a	dev_load	vmlinux	EXPORT_SYMBOL
+0xac0ba8c1	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0xabd0b28e	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL
+0xbb355561	bio_add_page	vmlinux	EXPORT_SYMBOL
+0xe4968f5e	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x7e9ebb05	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x54703968	ipt_unregister_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL
+0xc2ce6edb	rt2x00mac_conf_tx	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x8670273d	iwl_hwrate_to_plcp_idx	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdbac3340	iwl_send_statistics_request	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xcca32b55	mptscsih_slave_destroy	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x40f2b10c	ipmi_alloc_smi_msg	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xafc7c996	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x30226ddf	agp_device_command	vmlinux	EXPORT_SYMBOL
+0xaffe7da7	fb_bl_default_curve	vmlinux	EXPORT_SYMBOL_GPL
+0x77ecac9f	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x4358ac76	open_by_devnum	vmlinux	EXPORT_SYMBOL
+0xd40c82ef	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x6ea09972	snd_midi_channel_alloc_set	sound/core/seq/snd-seq-midi-emul	EXPORT_SYMBOL
+0x27662db8	hostap_add_interface	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xd75f1d45	cxgb3_register_client	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0x8c25ae75	flexcop_device_kfree	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x4b2d4a18	drm_helper_initial_config	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xa07c4cba	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0xa1b3dc30	xt_unregister_target	vmlinux	EXPORT_SYMBOL
+0x21664a67	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
+0xb423dba1	console_blanked	vmlinux	EXPORT_SYMBOL
+0x2203f781	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0xe1b80e44	oxygen_write_i2c	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x92f9f944	ieee80211_start_tx_ba_session	net/mac80211/mac80211	EXPORT_SYMBOL
+0x74fe168b	config_group_init_type_name	fs/configfs/configfs	EXPORT_SYMBOL
+0x59e3238b	gigaset_freedriver	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x12314c15	nforce2_smbus	drivers/i2c/busses/i2c-nforce2	EXPORT_SYMBOL_GPL
+0x23679939	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x1b498b76	xdr_enter_page	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xd0d5636c	ct_sip_parse_address_param	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xe44d80cd	nf_conntrack_unregister_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xdf41c483	ssb_pcicore_dev_irqvecs_enable	drivers/ssb/ssb	EXPORT_SYMBOL
+0xe02801aa	iscsi_create_conn	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xf762962f	rndis_rx_fixup	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0x96a5d03a	cx231xx_capture_start	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x01f61115	ttm_bo_mem_space	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x992ace53	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL
+0x612390ad	netpoll_set_trap	vmlinux	EXPORT_SYMBOL
+0x884150f9	ata_do_eh	vmlinux	EXPORT_SYMBOL_GPL
+0xfaf98462	bitrev32	vmlinux	EXPORT_SYMBOL
+0x78087953	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x8a99a016	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0xf6b639cf	mlx4_write_mtt	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x37d91069	smsendian_handle_tx_message	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x45284ae9	smsendian_handle_rx_message	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x115eedf6	register_isdn	drivers/isdn/i4l/isdn	EXPORT_SYMBOL
+0x07d52613	gigaset_skb_sent	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xb5d52c27	ec_transaction	vmlinux	EXPORT_SYMBOL
+0x8280f21f	pci_scan_slot	vmlinux	EXPORT_SYMBOL
+0x8f80d3fb	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0xca1630f7	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x4ccef0e8	cfg80211_connect_result	net/wireless/cfg80211	EXPORT_SYMBOL
+0xc6f6f938	gss_mech_register	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0xe4e1cad0	jbd2_journal_set_features	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x41d251d8	usbnet_start_xmit	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xc79be149	ab3100_event_register	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x161b1d34	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0xa5994572	filter_match_preds	vmlinux	EXPORT_SYMBOL_GPL
+0xb3e80e4c	iscsi_conn_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x9458c58c	iwl_configure_filter	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xda5e742a	saa7146_pgtable_free	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x32288722	ipmi_set_maintenance_mode	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x86623fd7	notify_remote_via_irq	vmlinux	EXPORT_SYMBOL_GPL
+0xb758b225	acpi_disable_event	vmlinux	EXPORT_SYMBOL
+0x6c9b4ea9	pci_request_regions	vmlinux	EXPORT_SYMBOL
+0x4df119fa	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0xef9febd0	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x381c4bb1	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x65b934ff	usb_serial_handle_sysrq_char	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x841a7b1f	rt2x00pci_remove	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0x6e39d670	rt2x00pci_resume	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0x23dae7e3	dm_table_event	drivers/md/dm-mod	EXPORT_SYMBOL
+0x5075723c	sock_create	vmlinux	EXPORT_SYMBOL
+0x743a165e	ata_pack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0xfaf0e64a	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x6226e37a	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL
+0x66ef50a2	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x7ac2f329	snd_seq_expand_var_event	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x95085a61	ip_vs_conn_new	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x6ffcd772	__fscache_read_or_alloc_page	fs/fscache/fscache	EXPORT_SYMBOL
+0x247975ff	dm_region_hash_create	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x41c75332	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0xce72111f	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x5088eae5	agp_generic_enable	vmlinux	EXPORT_SYMBOL
+0xb707efdf	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x8c13bf12	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x33fb415a	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0xd0b08261	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x5bb1e117	sony_pic_camera_command	drivers/platform/x86/sony-laptop	EXPORT_SYMBOL
+0x6ab8ef9d	cdrom_number_of_slots	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xa7038951	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x295012d9	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0xe0617f64	agp_generic_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x29b6ede3	pcim_iomap	vmlinux	EXPORT_SYMBOL
+0x81531eee	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x5d6b7ad8	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x9eb37367	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x7dafe504	snd_akm4xxx_build_controls	sound/i2c/other/snd-ak4xxx-adda	EXPORT_SYMBOL
+0x4d57ae3c	uwb_rsv_type_str	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xc410b5ec	mii_check_gmii_support	drivers/net/mii	EXPORT_SYMBOL
+0x5638ac4c	mptscsih_taskmgmt_response_code	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x25bd6158	ib_free_send_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xf7f0fd5c	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x44ea8ba6	dma_async_device_register	vmlinux	EXPORT_SYMBOL
+0xb7dec617	ata_ehi_clear_desc	vmlinux	EXPORT_SYMBOL_GPL
+0xe81851a8	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0xe0259c5e	find_get_page	vmlinux	EXPORT_SYMBOL
+0x8fcb3078	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x0256389f	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x280acd4b	snd_sbmixer_write	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0x27abf33b	sl811h_driver	drivers/usb/host/sl811-hcd	EXPORT_SYMBOL
+0x409bb260	p54_parse_eeprom	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0xa73c1f34	sms_board_setup	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x955c1f76	amd_decode_nb_mce	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0xfd9d0c0a	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0xe49ff3b0	ata_wait_register	vmlinux	EXPORT_SYMBOL_GPL
+0x9ca09e19	invalidate_inodes	vmlinux	EXPORT_SYMBOL
+0x7bc52df6	drop_file_write_access	vmlinux	EXPORT_SYMBOL_GPL
+0x393f86a8	nf_tproxy_get_sock_v4	net/netfilter/nf_tproxy_core	EXPORT_SYMBOL_GPL
+0x0f2f7518	wa_urb_enqueue	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0x0dae96fd	wa_urb_dequeue	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0xf4bd7456	rt2x00usb_clear_entry	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x6c9d63da	iwl_get_free_ucode_key_index	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x8c19d428	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x98f0612d	dev_mc_delete	vmlinux	EXPORT_SYMBOL
+0xeda0d76e	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0xf1ae824d	get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x8251bcc3	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x7054a3e4	request_dma	vmlinux	EXPORT_SYMBOL
+0xe6ea6deb	snd_mpu401_uart_new	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL
+0x9c2b68fc	cfg80211_roamed	net/wireless/cfg80211	EXPORT_SYMBOL
+0x9e26164c	fat_attach	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x545367d9	ssb_bus_may_powerdown	drivers/ssb/ssb	EXPORT_SYMBOL
+0x41ba1d14	iscsi_pool_free	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x19f1f81c	eip_close	drivers/net/8390p	EXPORT_SYMBOL
+0x429eafc2	cx231xx_register_extension	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL
+0xa8204f50	dm_rh_recovery_prepare	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xe6af28c8	lis3lv02d_joystick_enable	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0x8c68b0f7	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0xca01f51c	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x678e7705	ata_sff_data_xfer	vmlinux	EXPORT_SYMBOL_GPL
+0x958c42c7	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL
+0x7e7cfa58	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0xaf8e1aa2	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x6635634a	xip_file_write	vmlinux	EXPORT_SYMBOL_GPL
+0x9ad52bcb	iwl_check_rxon_cmd	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x6cc5d3c2	tcf_exts_validate	vmlinux	EXPORT_SYMBOL
+0xefa70426	hid_dump_device	vmlinux	EXPORT_SYMBOL_GPL
+0x70de6793	md_new_event	vmlinux	EXPORT_SYMBOL_GPL
+0x701d0ebd	snprintf	vmlinux	EXPORT_SYMBOL
+0xd7d67687	get_io_context	vmlinux	EXPORT_SYMBOL
+0x0cb88680	__tracepoint_block_rq_remap	vmlinux	EXPORT_SYMBOL_GPL
+0x18e1683f	snd_dma_program	sound/core/snd	EXPORT_SYMBOL
+0x1f569a90	rpcauth_destroy_credcache	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x16e19270	scsi_tgt_tsk_mgmt_request	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0x150f0746	cx231xx_init_vbi_isoc	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0xba5df831	ata_scsi_simulate	vmlinux	EXPORT_SYMBOL_GPL
+0x6b3e1df8	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x2296c00d	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0xa42d6587	__bread	vmlinux	EXPORT_SYMBOL
+0xf3ba721c	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x4fb12128	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x7e032a12	ieee80211_beacon_get	net/mac80211/mac80211	EXPORT_SYMBOL
+0x58867192	wlp_dev_prim_subcat_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x1e790820	iscsi_session_teardown	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xdfdbb0cd	iwl_sensitivity_calibration	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xc15404d4	free_sja1000dev	drivers/net/can/sja1000/sja1000	EXPORT_SYMBOL_GPL
+0x32487391	em28xx_init_isoc	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x954488a4	syncookie_secret	vmlinux	EXPORT_SYMBOL
+0x9ceb163c	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x4a7af41b	agp_alloc_page_array	vmlinux	EXPORT_SYMBOL
+0x4b085dbf	agp3_generic_configure	vmlinux	EXPORT_SYMBOL
+0x176eb6b9	snd_card_register	sound/core/snd	EXPORT_SYMBOL
+0xe2283b4d	rds_rdma_send_complete	net/rds/rds	EXPORT_SYMBOL_GPL
+0x68df212c	journal_init_dev	fs/jbd/jbd	EXPORT_SYMBOL
+0x3dc26521	b1pciv4_detect	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x1b6314fd	in_aton	vmlinux	EXPORT_SYMBOL
+0x82fed7e8	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0xba2d8594	ec_read	vmlinux	EXPORT_SYMBOL
+0xb7eb82ee	cfb_imageblit	vmlinux	EXPORT_SYMBOL
+0x7b52a859	wrmsr_safe_on_cpu	vmlinux	EXPORT_SYMBOL
+0xb20c9618	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0xc6bbcc56	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x80c3942e	oxygen_write_spi	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xe7cbd38c	nf_nat_sip_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xadbefc1a	nf_nat_irc_hook	net/netfilter/nf_conntrack_irc	EXPORT_SYMBOL_GPL
+0x9e51b9ba	nf_nat_ftp_hook	net/netfilter/nf_conntrack_ftp	EXPORT_SYMBOL_GPL
+0x38669208	rt2x00usb_probe	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xc1027b1a	p54_register_common	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0x32b5ab3f	tcp_close	vmlinux	EXPORT_SYMBOL
+0x938558db	__scm_send	vmlinux	EXPORT_SYMBOL
+0xd4f36df1	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x6cf0dbba	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0xbc16519b	pnp_register_driver	vmlinux	EXPORT_SYMBOL
+0x3dd4d3a7	bprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x4f1335bf	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0xdbe52d78	blk_trace_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x50915dbc	__put_cred	vmlinux	EXPORT_SYMBOL
+0x968185e9	nand_default_bbt	drivers/mtd/nand/nand	EXPORT_SYMBOL
+0x4b49de71	dm_path_uevent	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0xafc1c793	fw_csr_iterator_next	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x347ff964	xfrm_migrate	vmlinux	EXPORT_SYMBOL
+0x627d9324	del_mtd_device	vmlinux	EXPORT_SYMBOL_GPL
+0xabd62ba3	register_framebuffer	vmlinux	EXPORT_SYMBOL
+0x4ec8d891	dquot_free_inode	vmlinux	EXPORT_SYMBOL
+0x4327c892	snd_hda_resume	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x8fa27336	rt2x00queue_map_txskb	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xa19400ea	mfd_remove_devices	drivers/mfd/mfd-core	EXPORT_SYMBOL
+0x0836695c	drm_sman_takedown	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x7b1d544d	edac_handler_set	vmlinux	EXPORT_SYMBOL_GPL
+0x3cd06035	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x5d87c067	register_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x9ed685ee	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0xc2539263	register_cdrom	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0x0ced678d	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x45d27ffa	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x934e7275	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0xec1b043e	regulator_suspend_prepare	vmlinux	EXPORT_SYMBOL_GPL
+0x43385ad9	acpi_pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x3a2b38ea	bd_claim	vmlinux	EXPORT_SYMBOL
+0xf51ae235	touch_nmi_watchdog	vmlinux	EXPORT_SYMBOL
+0x577ad406	oxygen_pci_probe	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xaf5bf6ef	nfs_debug	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x22d967e1	nf_ct_deliver_cached_events	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x30124474	hidraw_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0xb3284531	acpi_dbg_layer	vmlinux	EXPORT_SYMBOL
+0x1251d30f	call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x861c3d3f	mlx4_mtt_init	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x6f7f7d73	dvb_ringbuffer_empty	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x4e867c22	saa7146_vfree_destroy_pgtable	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x86b1667d	hwrng_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xe26f820f	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x018167a9	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x465eaa86	snd_pcm_release_substream	sound/core/snd-pcm	EXPORT_SYMBOL
+0x571ff00e	xfrm6_rcv_spi	net/ipv6/ipv6	EXPORT_SYMBOL
+0xe4d11d2c	dccp_reqsk_init	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xfcfda1b7	parport_remove_port	drivers/parport/parport	EXPORT_SYMBOL
+0x82c1c855	iwl_set_rxon_chain	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x513266bd	tcf_exts_change	vmlinux	EXPORT_SYMBOL
+0xa3a1d161	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
+0x97de0ddd	acpi_install_gpe_block	vmlinux	EXPORT_SYMBOL
+0xda26faef	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x75e8f3c3	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x629a7f6e	do_posix_clock_nonanosleep	vmlinux	EXPORT_SYMBOL_GPL
+0x57b57ebe	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x3b20f21b	snd_trident_alloc_voice	sound/pci/trident/snd-trident	EXPORT_SYMBOL
+0x05060a19	snd_opl3_regmap	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0x22fc5d01	scsi_tgt_free_queue	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0xd16100ad	dm_dirty_log_destroy	drivers/md/dm-log	EXPORT_SYMBOL
+0x4eb178a4	i2c_master_send	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xce0f65c5	fw_iso_context_queue	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xdbf098e7	pskb_put	vmlinux	EXPORT_SYMBOL_GPL
+0xae1ce836	ata_sas_slave_configure	vmlinux	EXPORT_SYMBOL_GPL
+0xbd6c3ddf	ata_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x31a7fec2	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x479c3c86	find_next_zero_bit	vmlinux	EXPORT_SYMBOL
+0x8ee69235	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0xaac1dae9	snd_ctl_new1	sound/core/snd	EXPORT_SYMBOL
+0xaef83135	wiphy_free	net/wireless/cfg80211	EXPORT_SYMBOL
+0xadbe736b	journal_abort	fs/jbd/jbd	EXPORT_SYMBOL
+0x28e02b6b	dvb_ca_en50221_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x8d42eba2	dm_rh_stop_recovery	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x1e491a04	ib_unmap_fmr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x0c154973	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0xc988656a	security_task_getsecid	vmlinux	EXPORT_SYMBOL
+0x9aca161d	seq_open	vmlinux	EXPORT_SYMBOL
+0x0a3aba55	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x86ed282a	rpc_uaddr2sockaddr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xfa8656c8	iscsi_eh_device_reset	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x5dabde11	iwl_hw_detect	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x92c559f6	pci_bus_type	vmlinux	EXPORT_SYMBOL
+0x03182f49	pci_enable_bridges	vmlinux	EXPORT_SYMBOL
+0xf41dad07	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x0e821e78	__lock_page	vmlinux	EXPORT_SYMBOL
+0x2634eecf	ring_buffer_read	vmlinux	EXPORT_SYMBOL_GPL
+0xf499fdb2	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x608956db	ib_sa_cancel_query	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x76b32412	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0xcabe04de	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0xb4a466b2	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL
+0xec52d0a9	pcmcia_access_configuration_register	vmlinux	EXPORT_SYMBOL
+0xe4ff9cce	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL
+0xefdd70ce	security_secid_to_secctx	vmlinux	EXPORT_SYMBOL
+0xdecf669b	follow_down	vmlinux	EXPORT_SYMBOL
+0xc9fb1c2a	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0xe783dd08	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x9e82ed7a	snd_sbmixer_add_ctl	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0x23b8fd19	rds_info_register_func	net/rds/rds	EXPORT_SYMBOL_GPL
+0xef70be5b	tifm_unregister_driver	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x360b1afe	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x8b7d8caf	dccp_statistics	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xe36bb585	ubi_leb_read	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x3086be2a	dib3000mc_pid_control	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0x35293dd5	drm_mode_create_dithering_property	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0b3efc8f	btmrvl_add_card	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0xd0d5bf66	genphy_read_status	vmlinux	EXPORT_SYMBOL
+0x707ff1bb	ata_xfer_mask2mode	vmlinux	EXPORT_SYMBOL_GPL
+0xb58a3e52	redraw_screen	vmlinux	EXPORT_SYMBOL
+0xe0fb6357	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0xc517c0f2	pci_reenable_device	vmlinux	EXPORT_SYMBOL
+0x1a91df7d	get_write_access	vmlinux	EXPORT_SYMBOL
+0xc9705471	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x9c7de443	v4l2_prio_change	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0xd98ccba4	drm_poll	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2fc5012a	isapnp_protocol	vmlinux	EXPORT_SYMBOL
+0x11d54485	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0xf3bf0bce	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0xe2e8065e	memdup_user	vmlinux	EXPORT_SYMBOL
+0xe63c10f5	bttv_get_pcidev	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0xd9e240f3	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL
+0x9d787e3b	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x6307fc98	del_timer	vmlinux	EXPORT_SYMBOL
+0xed0071b5	ivtv_init_on_first_open	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0xba5323dc	ipmi_set_my_address	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x4dc45be9	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL
+0x54377c44	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL
+0x6df230c7	map_destroy	vmlinux	EXPORT_SYMBOL
+0x149db923	selinux_string_to_sid	vmlinux	EXPORT_SYMBOL_GPL
+0x9e711ad2	pm_qos_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x4e941d1e	snd_pcm_lib_free_pages	sound/core/snd-pcm	EXPORT_SYMBOL
+0xdaf7ce1a	rds_recv_incoming	net/rds/rds	EXPORT_SYMBOL_GPL
+0x571a67f0	nf_ct_expect_find_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xa8f30b16	hci_suspend_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x173dd9a5	vcc_release_async	net/atm/atm	EXPORT_SYMBOL
+0x7d1b8494	smscore_set_board_id	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x927bf8c1	smscore_get_board_id	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xa4758981	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x15b2f451	dev_close	vmlinux	EXPORT_SYMBOL
+0x8d9e8ccc	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0xea688053	snd_card_disconnect	sound/core/snd	EXPORT_SYMBOL
+0x3adbd595	v4l2_field_names	drivers/media/video/videodev	EXPORT_SYMBOL
+0x335778af	zl10353_attach	drivers/media/dvb/frontends/zl10353	EXPORT_SYMBOL
+0xeff223c8	tda9887_attach	drivers/media/common/tuners/tda9887	EXPORT_SYMBOL_GPL
+0x8a01e02c	dm_put	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x2b00e464	fw_send_response	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xfdc59e53	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0xe2306a01	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x2fd4b292	acpi_bus_get_device	vmlinux	EXPORT_SYMBOL
+0x738803e6	strnlen	vmlinux	EXPORT_SYMBOL
+0x426c21ab	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x9ebd4c04	adjust_resource	vmlinux	EXPORT_SYMBOL
+0xd0e43207	usb_nop_xceiv_register	drivers/usb/otg/nop-usb-xceiv	EXPORT_SYMBOL
+0xd54e219d	hermes_docmd_wait	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x1fde8126	dm_dirty_log_create	drivers/md/dm-log	EXPORT_SYMBOL
+0x36761f58	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0xc54c12cf	xprt_setup_backchannel	net/sunrpc/sunrpc	EXPORT_SYMBOL
+0xcfe97f49	rpc_peeraddr2str	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x7e5009c5	wlp_dev_name_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x40728a63	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
+0xd95f03e0	isa_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x3a2204c6	security_netlink_recv	vmlinux	EXPORT_SYMBOL
+0x1187d3ac	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0xf0a1fdb3	snd_midi_process_event	sound/core/seq/snd-seq-midi-emul	EXPORT_SYMBOL
+0xab5b975e	nf_conntrack_l3proto_generic	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xb3013935	libipw_wx_get_encodeext	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x87427ac3	mlx4_srq_arm	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x21316231	mpt_event_register	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x48abc08a	rdma_join_multicast	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x4c86830a	iw_cm_listen	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x450e3be9	lis3lv02d_poweron	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0x43287880	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x20eb63f7	usb_mon_register	vmlinux	EXPORT_SYMBOL_GPL
+0x59759a77	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL
+0x77752617	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x7f402ef6	blk_plug_device	vmlinux	EXPORT_SYMBOL
+0xe85c1523	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x712aa29b	_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0xf573e673	snd_wss_pcm	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x911ab738	snd_rawmidi_drop_output	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0xa3e61115	fc_remove_host	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xb5e943d6	v4l2_device_unregister_subdev	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0x4335f2da	ata_sas_port_init	vmlinux	EXPORT_SYMBOL_GPL
+0xf174ed48	acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0xb47f6cda	cx88_print_irqbits	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xd544e902	pgprot_writecombine	vmlinux	EXPORT_SYMBOL_GPL
+0xf9922d0b	xdr_encode_pages	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe909e5b1	xdr_read_pages	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6fbb3bd9	init_rs_non_canonical	lib/reed_solomon/reed_solomon	EXPORT_SYMBOL_GPL
+0xcbd2c134	iwlcore_free_geos	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x124cb753	ir_codes_encore_enltv_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x153c0f31	drm_free_agp	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xcc1f1c3d	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x0110b3d1	register_hotplug_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0x64526a93	atomic64_sub_return	vmlinux	EXPORT_SYMBOL
+0xea8bdd56	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x4c3140c8	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0xb2682405	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x32f17454	ring_buffer_event_data	vmlinux	EXPORT_SYMBOL_GPL
+0x96f9d138	snd_hda_ch_mode_info	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc52901f7	iscsi_create_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xabad069f	lbs_cmd_802_11_rate_adapt_rateset	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x27a9df48	dm_dirty_log_type_unregister	drivers/md/dm-log	EXPORT_SYMBOL
+0x4f506333	ks0108_startline	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0x80d95aa1	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x24c2ec34	__pm_runtime_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x6e1d156e	vfs_quota_on_path	vmlinux	EXPORT_SYMBOL
+0x8bd313b8	__tracepoint_kfree	vmlinux	EXPORT_SYMBOL
+0x41551f69	override_creds	vmlinux	EXPORT_SYMBOL
+0xb1500888	journal_get_create_access	fs/jbd/jbd	EXPORT_SYMBOL
+0x4303a4e2	iwl_rx_reply_rx_phy	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa215f1b2	dsp_audio_s16_to_law	drivers/isdn/mISDN/mISDN_dsp	EXPORT_SYMBOL
+0xe30d4016	ib_flush_fmr_pool	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x55d9f6d5	dca_remove_requester	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0x44cc0b74	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x90035333	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0xd3a0ff1a	acpi_device_hid	vmlinux	EXPORT_SYMBOL
+0xa4ef5621	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x07e7ac5a	ieee80211_radiotap_iterator_init	net/wireless/cfg80211	EXPORT_SYMBOL
+0x1fed0540	rfkill_resume_polling	net/rfkill/rfkill	EXPORT_SYMBOL
+0xf30fda27	lzo1x_decompress_safe	lib/lzo/lzo_decompress	EXPORT_SYMBOL_GPL
+0xca5278da	__fscache_register_netfs	fs/fscache/fscache	EXPORT_SYMBOL
+0xe94ed568	iscsi_eh_abort	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xd70a9854	sdio_writesb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x424acc6d	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x0278fddb	request_key	vmlinux	EXPORT_SYMBOL
+0xb813ce5a	timecompare_transform	vmlinux	EXPORT_SYMBOL
+0x38a83122	jbd2_journal_lock_updates	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xd17bced6	__fscache_read_or_alloc_pages	fs/fscache/fscache	EXPORT_SYMBOL
+0x1e326b97	v4l2_ctrl_query_fill	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x1e9603ce	drm_i_have_hw_lock	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x11541190	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x05101071	mtd_table_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x4fe2ab34	nla_append	vmlinux	EXPORT_SYMBOL
+0x831df37d	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL
+0xb86e4ab9	random32	vmlinux	EXPORT_SYMBOL
+0xd15cb847	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0xc51ce88d	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0xe94ba885	snd_dma_free_pages	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0xf2e4c0e1	ieee80211_find_sta	net/mac80211/mac80211	EXPORT_SYMBOL
+0x154d2b6a	ieee80211_tx_status_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL
+0xb5adb754	ir_codes_cinergy_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x183fdfdd	ir_codes_gotview7135_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xfd7d001b	ttm_bo_wait	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x00461141	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x5a42a035	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x8df56538	pci_do_scan_bus	vmlinux	EXPORT_SYMBOL
+0xfc976517	bt_sock_unlink	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x539574ca	iscsi_add_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xaad0846e	iwl_bg_scan_completed	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x4709b63b	can_free_echo_skb	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x7e7bdf44	ves1x93_attach	drivers/media/dvb/frontends/ves1x93	EXPORT_SYMBOL
+0x8ff8dbcd	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x1dcaa0c8	v4l2_prio_max	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x9d251144	drm_fb_helper_panic	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xfe5052ac	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x56fe62e2	tcp_v4_md5_hash_skb	vmlinux	EXPORT_SYMBOL
+0xdb1efe12	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0x615a09cf	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x36d0e6d3	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x101318dc	__copy_from_user_ll_nocache	vmlinux	EXPORT_SYMBOL
+0x60c3aeec	complete_request_key	vmlinux	EXPORT_SYMBOL
+0x272d394e	mtrr_del	vmlinux	EXPORT_SYMBOL
+0x8bad4a6a	rds_inc_addref	net/rds/rds	EXPORT_SYMBOL_GPL
+0x6f4212c6	rt2x00usb_uninitialize	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xd83dc5b3	iwl_sta_tx_modify_enable_tid	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa20ce1b8	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x181b8909	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0xc0c66e2f	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL
+0x0ad2461b	pci_configure_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x34e46b5d	securityfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x62c40daa	pv_cpu_ops	vmlinux	EXPORT_SYMBOL
+0x6d644b43	pv_mmu_ops	vmlinux	EXPORT_SYMBOL
+0x3a066cf9	cfg80211_ibss_joined	net/wireless/cfg80211	EXPORT_SYMBOL
+0x0b3c8707	osd_req_write_kern	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x643e803d	lbs_remove_card	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x4f8643b8	hostap_set_string	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x712d58ed	videobuf_mmap_setup	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x01c31b46	tea5767_autodetection	drivers/media/common/tuners/tea5767	EXPORT_SYMBOL_GPL
+0x7ebb1314	xfrm_migrate_state_find	vmlinux	EXPORT_SYMBOL
+0x29a87652	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0xb5b10083	tpm_calc_ordinal_duration	vmlinux	EXPORT_SYMBOL_GPL
+0xee52d9e3	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
+0x118f01ea	putname	vmlinux	EXPORT_SYMBOL
+0xac01b8c9	snd_ctl_remove_id	sound/core/snd	EXPORT_SYMBOL
+0x4b576aca	bt878_stop	drivers/media/dvb/bt8xx/bt878	EXPORT_SYMBOL
+0x82c2640b	i2c_add_adapter	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xa602665a	drm_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x1812e493	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0xea10655a	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0xf313da4e	sha_transform	vmlinux	EXPORT_SYMBOL
+0x9b6eb137	ksize	vmlinux	EXPORT_SYMBOL
+0x42a6ceaf	hci_conn_security	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xc2fea7a6	dm_send_uevents	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0xd6ed4c3f	rtnl_kill_links	vmlinux	EXPORT_SYMBOL_GPL
+0xcdd52fa1	pci_stop_bus_device	vmlinux	EXPORT_SYMBOL_GPL
+0x9c04a037	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x8bda7430	ring_buffer_iter_peek	vmlinux	EXPORT_SYMBOL_GPL
+0xa5efbf4c	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x3d46186b	mptscsih_bios_param	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xf33c155d	ir_codes_msi_tvanywhere_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x98d25201	unregister_dca_provider	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0x44e8d440	ipmi_smi_watcher_register	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x2bb55d6e	acpi_remove_notify_handler	vmlinux	EXPORT_SYMBOL
+0x6f556bdb	acpi_get_gpe_device	vmlinux	EXPORT_SYMBOL
+0xf310e3d0	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x62d991d0	libipw_wx_set_encodeext	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xa20707b8	pcibios_set_irq_routing	vmlinux	EXPORT_SYMBOL
+0x1adf1842	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0xcf97f3bd	dead_socket	vmlinux	EXPORT_SYMBOL
+0x395a6d47	pci_clear_mwi	vmlinux	EXPORT_SYMBOL
+0x3eb1ac94	shash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x99ea12ce	panic_blink	vmlinux	EXPORT_SYMBOL
+0x7e99ec6e	rds_info_deregister_func	net/rds/rds	EXPORT_SYMBOL_GPL
+0x3f8d4b91	uwb_rsv_establish	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x29a8366b	ppp_register_channel	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xc72f8bc4	ata_sas_port_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x24c7698a	xenbus_write	vmlinux	EXPORT_SYMBOL_GPL
+0xc459798e	kmap_high	vmlinux	EXPORT_SYMBOL
+0x3e7b71c9	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x12e09214	__ring_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x79ad224b	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x62d26e1b	fc_get_host_speed	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x90230e44	dvb_unregister_frontend	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x7a70218d	i2c_use_client	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xe9f1f88e	drm_agp_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3e605511	async_syndrome_val	crypto/async_tx/async_pq	EXPORT_SYMBOL_GPL
+0xc13a5631	ata_sff_dumb_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x1bb49a41	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0xf18805fe	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL
+0x8660ca71	bio_endio	vmlinux	EXPORT_SYMBOL
+0x70c6031a	ring_buffer_normalize_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0x37d62701	nf_ct_expect_unregister_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x1960d395	ieee80211_stop_queues	net/mac80211/mac80211	EXPORT_SYMBOL
+0xd4aaf703	wa_create	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0x7b30db08	sas_rphy_remove	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x92aacc16	wm8350_ldo_set_slot	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0x2ec16bc9	libipw_set_geo	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xc69b30b3	libipw_get_geo	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xebd4f42c	btcx_riscmem_alloc	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0x02ff9464	cfag12864b_isinited	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0xd60736ec	gf128mul_free_64k	crypto/gf128mul	EXPORT_SYMBOL
+0x67f54aac	cryptd_ablkcipher_child	crypto/cryptd	EXPORT_SYMBOL_GPL
+0xa0fee358	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x7ed3f021	pcmcia_register_driver	vmlinux	EXPORT_SYMBOL
+0x470dc314	xenbus_frontend_closed	vmlinux	EXPORT_SYMBOL_GPL
+0xb1645a2e	sg_free_table	vmlinux	EXPORT_SYMBOL
+0xe8f893a6	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x82c65f8b	ring_buffer_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00cd74c1	wlp_dev_model_nr_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x1cad5752	i1480_rceb_check	drivers/uwb/i1480/dfu/i1480-dfu-usb	EXPORT_SYMBOL_GPL
+0xc4334729	iscsi_unregister_transport	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x358ec423	pcie_port_service_unregister	vmlinux	EXPORT_SYMBOL
+0x4a971ec7	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x1efe283f	__cap_full_set	vmlinux	EXPORT_SYMBOL
+0x6f2338bb	simple_tuner_attach	drivers/media/common/tuners/tuner-simple	EXPORT_SYMBOL_GPL
+0xd5fdb8d6	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0xa46c1fb8	tcp4_gro_receive	vmlinux	EXPORT_SYMBOL
+0xb40bf657	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
+0xc45ce074	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x52d1bfbf	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x59f55be0	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0xba1cd7b7	__add_pages	vmlinux	EXPORT_SYMBOL_GPL
+0xc33f6f4c	on_each_cpu	vmlinux	EXPORT_SYMBOL
+0x8699abfe	dma_set_mask	vmlinux	EXPORT_SYMBOL
+0x19d2b73e	snd_pcm_set_sync	sound/core/snd-pcm	EXPORT_SYMBOL
+0x8efd144c	parport_find_number	drivers/parport/parport	EXPORT_SYMBOL
+0x58fbea8f	iwl_rx_queue_restock	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa859840f	mISDN_freebchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xeb919efd	drm_gem_object_lookup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xc65abeb7	agp3_generic_sizes	vmlinux	EXPORT_SYMBOL
+0xc9fa8992	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x969be41f	inotify_remove_watch_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x8e222cbb	bioset_create	vmlinux	EXPORT_SYMBOL
+0x67848c95	dib0070_attach	drivers/media/dvb/frontends/dib0070	EXPORT_SYMBOL
+0x35f9730f	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0xfc1e1dfa	__cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0xea124bd1	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x2e92a61a	names_cachep	vmlinux	EXPORT_SYMBOL
+0xd5bba222	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0xa138a07a	snd_info_create_card_entry	sound/core/snd	EXPORT_SYMBOL
+0xc8e96dea	qword_addhex	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x15f073d1	ivtv_reset_ir_gpio	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0xb0d904b7	raid6_empty_zero_page	drivers/md/raid6_pq	EXPORT_SYMBOL
+0x99c549ed	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x24461369	xrlim_allow	vmlinux	EXPORT_SYMBOL
+0xb4897083	ata_qc_complete_multiple	vmlinux	EXPORT_SYMBOL_GPL
+0xcd499827	pci_unmap_rom	vmlinux	EXPORT_SYMBOL
+0x4d2e3391	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL
+0x016e79e0	wimax_msg_alloc	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0xb57e374f	svc_sock_create	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3b729db2	mlx4_mr_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x2b5a7794	mpt_get_msg_frame	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xb649041d	ttm_bo_unref	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x22b6533b	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x7c87f1b7	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x8014b6af	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x4484a5a4	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0xa1b759ce	fb_add_videomode	vmlinux	EXPORT_SYMBOL
+0xcb5af483	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0xd2a76735	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x94f36c40	single_open	vmlinux	EXPORT_SYMBOL
+0xf2bef659	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0xa3d7cee6	snd_ac97_suspend	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x198788b4	snd_lookup_oss_minor_data	sound/core/snd	EXPORT_SYMBOL
+0x4a3ea5c0	snd_request_card	sound/core/snd	EXPORT_SYMBOL
+0x0a725901	cfg80211_send_disassoc	net/wireless/cfg80211	EXPORT_SYMBOL
+0x9453b0f1	svc_sock_destroy	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xab14e193	xfrm6_tunnel_free_spi	net/ipv6/xfrm6_tunnel	EXPORT_SYMBOL
+0xefcadee5	xfrm6_find_1stfragopt	net/ipv6/ipv6	EXPORT_SYMBOL
+0x062f1bee	drm_helper_disable_unused_functions	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xf906b020	genphy_config_advert	vmlinux	EXPORT_SYMBOL
+0xfef96e23	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x2ad770b8	register_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0xa6dd95b2	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x58fef6f8	ist_info	vmlinux	EXPORT_SYMBOL
+0x1a724fcc	snd_seq_kernel_client_ctl	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xa7b91a7b	lockd_down	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x145e8726	wlp_wss_activate_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x8767045b	mlx4_pd_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x76396cc8	dm_register_target	drivers/md/dm-mod	EXPORT_SYMBOL
+0x0f0ba55e	ii_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0xf96ae1c2	security_inode_create	vmlinux	EXPORT_SYMBOL_GPL
+0xfea0d043	xprt_reserve_xprt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x95284709	v4l2_prio_close	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0xec62bb9d	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0xc74bd5df	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x7c6799d7	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x9f9c4856	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x4080d6ae	__snd_util_mem_free	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x0bb6bf5e	wusb_cluster_id_get	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x1f5f8255	ezusb_writememory	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xf520d09e	ib_sa_register_client	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x610a5b44	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0xfcc2a43c	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x4c4deacc	blk_trace_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x5857e434	groups_free	vmlinux	EXPORT_SYMBOL
+0x3980aac1	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x9e059d9e	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x2def7f76	rtc_cmos_write	vmlinux	EXPORT_SYMBOL
+0x1bedf504	mptscsih_taskmgmt_complete	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xaa165d27	capilib_release_appl	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xc0890413	gf128mul_64k_lle	crypto/gf128mul	EXPORT_SYMBOL
+0x384ef9ce	gf128mul_64k_bbe	crypto/gf128mul	EXPORT_SYMBOL
+0xd554194e	tcf_destroy_chain	vmlinux	EXPORT_SYMBOL
+0x981236c9	sk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x74b5b2df	ata_sff_port_start32	vmlinux	EXPORT_SYMBOL_GPL
+0x0f97fe90	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0xf0696401	acpi_pci_detect_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0x3d542f4c	pci_request_region_exclusive	vmlinux	EXPORT_SYMBOL
+0xe997667b	wrmsr_on_cpu	vmlinux	EXPORT_SYMBOL
+0x58da1299	fw_core_handle_request	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xa1687de0	ipmi_unregister_smi	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x5118c382	secure_dccp_sequence_number	vmlinux	EXPORT_SYMBOL
+0xee7eb9e1	pnp_platform_devices	vmlinux	EXPORT_SYMBOL
+0x2f42e7a1	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
+0x73e8f6db	cfg80211_send_deauth	net/wireless/cfg80211	EXPORT_SYMBOL
+0xe1b7b349	rfkill_register	net/rfkill/rfkill	EXPORT_SYMBOL
+0xaab8671a	p9_idpool_get	net/9p/9pnet	EXPORT_SYMBOL
+0x52af25a5	km_migrate	vmlinux	EXPORT_SYMBOL
+0x71a3a963	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0xce88bae6	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x19a304ba	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x86f87a2d	tpm_dev_release	vmlinux	EXPORT_SYMBOL_GPL
+0xd8a65c38	atomic64_sub	vmlinux	EXPORT_SYMBOL
+0xc87e487a	sched_clock_idle_sleep_event	vmlinux	EXPORT_SYMBOL_GPL
+0xeb1fabf6	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x022506f5	snd_i2c_device_create	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0x5e7f4920	snd_pcm_format_set_silence	sound/core/snd-pcm	EXPORT_SYMBOL
+0x94a79a88	libipw_wx_get_encode	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x79c3f4c9	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0xe6488b47	cpufreq_notify_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x14fb5e2e	usb_buffer_map_sg	vmlinux	EXPORT_SYMBOL_GPL
+0xaeb20109	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x898a729f	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x93a6e0b2	io_schedule	vmlinux	EXPORT_SYMBOL
+0x60c3d91a	arch_acpi_processor_cleanup_pdc	vmlinux	EXPORT_SYMBOL
+0xfcdc4203	ib_create_send_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x60d2f0ec	ata_pci_bmdma_init	vmlinux	EXPORT_SYMBOL_GPL
+0x545f89d7	cfb_fillrect	vmlinux	EXPORT_SYMBOL
+0xe6590648	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0xd3244823	ima_counts_get	vmlinux	EXPORT_SYMBOL_GPL
+0x7b7fab62	block_write_end	vmlinux	EXPORT_SYMBOL
+0x1a4c3ebe	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0xfb2a3293	math_state_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x0464d420	ab3100_set_register_interruptible	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x84acf42d	ab3100_get_register_interruptible	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x7bc0c61b	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x2b9f8e23	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0xbfdd02e8	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0xda8fd495	isapnp_write_byte	vmlinux	EXPORT_SYMBOL
+0x215db6e9	tracepoint_probe_register_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x758664b6	wiphy_rfkill_stop_polling	net/wireless/cfg80211	EXPORT_SYMBOL
+0x87bd2342	fc_attach_transport	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x6d3a4f3d	mlx4_fmr_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xb1a318e0	cb710_sg_dwiter_write_next_block	drivers/misc/cb710/cb710	EXPORT_SYMBOL_GPL
+0xd2970374	lnbh24_attach	drivers/media/dvb/frontends/lnbp21	EXPORT_SYMBOL
+0xfc27303b	HiSax_closecard	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x34704ea7	ttm_global_item_unref	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xc469c244	drm_fb_helper_restore	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x80c63161	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0xac87ac3d	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xf838064c	agp_bridge	vmlinux	EXPORT_SYMBOL
+0x52021d39	gpiochip_add	vmlinux	EXPORT_SYMBOL_GPL
+0xdc714560	register_kprobe	vmlinux	EXPORT_SYMBOL_GPL
+0xb5d8913d	register_jprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x80e732f1	register_snap_client	net/802/psnap	EXPORT_SYMBOL
+0xb184aeef	mlx4_srq_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x90faff9e	lis3lv02d_poweroff	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0x595266c3	wireless_spy_update	vmlinux	EXPORT_SYMBOL
+0xc111b888	inet_listen	vmlinux	EXPORT_SYMBOL
+0x69577709	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0xc399468f	scsi_nl_remove_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xcfcc83ad	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xb0e70343	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x4ba71596	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0xe705c2c2	snd_hda_codec_read	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x9a8e1877	snd_array_free	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc4b9f28a	jbd2_journal_clear_features	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x0c26569c	drm_fb_helper_check_var	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x07b52e38	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x5fe98126	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x518f529d	agp_generic_destroy_pages	vmlinux	EXPORT_SYMBOL
+0xf7016530	xenbus_gather	vmlinux	EXPORT_SYMBOL_GPL
+0xcdfeb2e7	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x507de8c6	add_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x19fd187b	nf_ct_gre_keymap_add	net/netfilter/nf_conntrack_proto_gre	EXPORT_SYMBOL_GPL
+0xf36093a5	bt_accept_unlink	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x19f0e900	iwl_debug_level	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdbeedace	enclosure_remove_device	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0xbee44115	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x760a0f4f	yield	vmlinux	EXPORT_SYMBOL
+0xd0f26040	sdio_claim_irq	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x77348bb2	rdma_listen	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x8d7f5e9a	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
+0x1db21d74	__tracepoint_kfree_skb	vmlinux	EXPORT_SYMBOL_GPL
+0xaa5310f9	__tracepoint_napi_poll	vmlinux	EXPORT_SYMBOL_GPL
+0x1dc36131	fb_destroy_modedb	vmlinux	EXPORT_SYMBOL
+0x2c5cd852	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x91dacaa2	acpi_processor_ffh_cstate_probe	vmlinux	EXPORT_SYMBOL_GPL
+0xe885b27f	snd_jack_report	sound/core/snd	EXPORT_SYMBOL
+0xed936b29	__nf_ct_try_assign_helper	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x4cc1b61c	osd_WaitEventCreate	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0xbe25b39d	ath_regd_get_band_ctl	drivers/net/wireless/ath/ath	EXPORT_SYMBOL
+0x13874171	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0xb0bc7cfc	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x9e2000a7	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0xbee40246	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x0ba29b61	xenbus_dev_fatal	vmlinux	EXPORT_SYMBOL_GPL
+0x9fe13403	inode_init_always	vmlinux	EXPORT_SYMBOL
+0xedc5a0ba	d_invalidate	vmlinux	EXPORT_SYMBOL
+0xa0b04675	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0xcff72ab6	pid_task	vmlinux	EXPORT_SYMBOL
+0xa4c3bb33	set_h245_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xc6613c3a	seq_print_acct	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x8df17b83	stp_proto_register	net/802/stp	EXPORT_SYMBOL_GPL
+0x017ea7c7	cx231xx_tuner_callback	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x2eb2f903	drm_sman_free_key	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x68b4f8ee	drm_class_device_unregister	drivers/gpu/drm/drm	EXPORT_SYMBOL_GPL
+0x65c69f20	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x51e45f1c	tpm_register_hardware	vmlinux	EXPORT_SYMBOL_GPL
+0x95076ce6	textsearch_unregister	vmlinux	EXPORT_SYMBOL
+0x409d4cbb	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x988ed85d	set_memory_x	vmlinux	EXPORT_SYMBOL
+0x14f39c51	inet6_csk_bind_conflict	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x310bbe40	garp_register_application	net/802/garp	EXPORT_SYMBOL_GPL
+0xd60d08e4	iwl_set_rxon_ht	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa35de80f	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x676fc613	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0xe9a2f090	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x9382382c	pcmcia_loop_config	vmlinux	EXPORT_SYMBOL
+0xa27c0890	scsi_unregister_device_handler	vmlinux	EXPORT_SYMBOL_GPL
+0xb0b847ac	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x4059792f	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0xa4cb4462	ieee80211_rts_duration	net/mac80211/mac80211	EXPORT_SYMBOL
+0x4ea90536	ip6_route_output	net/ipv6/ipv6	EXPORT_SYMBOL
+0x9615bb8e	s5h1420_get_tuner_i2c_adapter	drivers/media/dvb/frontends/s5h1420	EXPORT_SYMBOL
+0x923aa88e	dvb_ringbuffer_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x3f8d5173	drm_crtc_helper_set_config	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xb846ffe7	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x3bc946bf	__dst_free	vmlinux	EXPORT_SYMBOL
+0x110638d4	tty_find_polling_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x78aace90	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x973873ab	_spin_lock	vmlinux	EXPORT_SYMBOL
+0x9cce5192	pn_sock_get_port	net/phonet/phonet	EXPORT_SYMBOL
+0xb050f329	init_rs	lib/reed_solomon/reed_solomon	EXPORT_SYMBOL_GPL
+0x50720c86	fcoe_ctlr_els_send	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0x6ff72975	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x78df6bd7	no_pci_devices	vmlinux	EXPORT_SYMBOL
+0x6c2e3320	strncmp	vmlinux	EXPORT_SYMBOL
+0x42494cea	ring_buffer_event_length	vmlinux	EXPORT_SYMBOL_GPL
+0x3796bdcc	snd_pcm_format_little_endian	sound/core/snd-pcm	EXPORT_SYMBOL
+0x280ae679	dccp_reqsk_send_ack	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xbbd1a344	usb_stor_access_xfer_buf	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x2c5c33f6	iwl_send_cmd_pdu_async	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xc9363193	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0xa34f1ef5	crc32_le	vmlinux	EXPORT_SYMBOL
+0xb903674c	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0xf349c602	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x155fba99	sas_port_free	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x9c8ac5d8	iscsi_tcp_task_init	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x2fbd9c75	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0xa40a8590	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x264c0d74	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x0dd39da3	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x35d58830	ring_buffer_alloc_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x460f31aa	rodata_test_data	vmlinux	EXPORT_SYMBOL_GPL
+0xef9aedfc	boot_option_idle_override	vmlinux	EXPORT_SYMBOL
+0x63343b1d	snd_usbmidi_input_stop	sound/usb/snd-usb-lib	EXPORT_SYMBOL
+0x53445f68	nlm_debug	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x257bd19d	stp_proto_unregister	net/802/stp	EXPORT_SYMBOL_GPL
+0xd5963710	fat_add_entries	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x80721096	umc_controller_reset	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0xce5a08a8	sas_port_alloc_num	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xc50cfd00	mii_nway_restart	drivers/net/mii	EXPORT_SYMBOL
+0xfd8489bd	dvb_net_release	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xc923e2da	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0xedf06e14	bitmap_end_sync	vmlinux	EXPORT_SYMBOL
+0x43f23d2a	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x70be3621	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0xf8365b46	bio_integrity_alloc	vmlinux	EXPORT_SYMBOL
+0xb8dc0469	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0xaf02343a	set_pages_array_uc	vmlinux	EXPORT_SYMBOL
+0xe0fa01fb	libipw_wx_set_encode	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xd41dbb24	videobuf_poll_stream	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xd5de2d14	drm_sg_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2c6cec27	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x21ad8512	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0xa89540d9	ata_sff_data_xfer32	vmlinux	EXPORT_SYMBOL_GPL
+0xd15deffa	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0xe56a9336	snd_pcm_format_width	sound/core/snd-pcm	EXPORT_SYMBOL
+0xf29e9eb0	xdr_decode_array2	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x074c8a8c	ipv6_push_nfrag_opts	net/ipv6/ipv6	EXPORT_SYMBOL
+0x86541c17	ipt_register_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL
+0xe42528bc	tda10023_attach	drivers/media/dvb/frontends/tda10023	EXPORT_SYMBOL
+0x8da5f4b1	tda10021_attach	drivers/media/dvb/frontends/tda10021	EXPORT_SYMBOL
+0xa2fb4945	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x6cba0cca	ata_pio_need_iordy	vmlinux	EXPORT_SYMBOL_GPL
+0x81472677	acpi_get_table	vmlinux	EXPORT_SYMBOL
+0xc9561772	fb_destroy_modelist	vmlinux	EXPORT_SYMBOL_GPL
+0xf41b4b84	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x98678db9	snd_mixer_oss_notify_callback	sound/core/snd	EXPORT_SYMBOL
+0x69b0089b	ieee802154_nl_disassoc_confirm	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x01805ed5	drm_crtc_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x97b9148b	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0xca81ea9a	xenbus_transaction_end	vmlinux	EXPORT_SYMBOL_GPL
+0x3a48abbf	d_move	vmlinux	EXPORT_SYMBOL
+0xf3115759	ring_buffer_read_start	vmlinux	EXPORT_SYMBOL_GPL
+0xd69574f5	snd_hda_codec_amp_stereo	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x49e16f88	ipcomp_destroy	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL
+0x2b4fb7d1	b1_loaded	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x9bf90b99	rdma_reject	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x230e12fb	ipmi_get_version	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x2a90ad51	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x217de9e0	request_key_async	vmlinux	EXPORT_SYMBOL
+0x1c763b87	touch_atime	vmlinux	EXPORT_SYMBOL
+0x53614269	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL
+0xad1a4073	ieee80211_unregister_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0xbd17a0df	gf128mul_4k_lle	crypto/gf128mul	EXPORT_SYMBOL
+0x0c2f123f	gf128mul_4k_bbe	crypto/gf128mul	EXPORT_SYMBOL
+0xfcc4d4e4	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0xe3cc3a39	phonet_proto_unregister	net/phonet/phonet	EXPORT_SYMBOL
+0x7e782891	iwl_send_calib_results	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x6a2c753d	wm8350_gpio_config	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xbef80ff5	dibusb_read_eeprom_byte	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x089f2485	ib_unregister_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x59450035	ib_modify_cq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xff7c139c	cryptd_free_ablkcipher	crypto/cryptd	EXPORT_SYMBOL_GPL
+0xdecb104b	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0xac59270d	acpi_processor_notify_smm	vmlinux	EXPORT_SYMBOL
+0x349cba85	strchr	vmlinux	EXPORT_SYMBOL
+0xf890fe7f	pm_idle	vmlinux	EXPORT_SYMBOL
+0x794487ee	disable_hlt	vmlinux	EXPORT_SYMBOL
+0x1e6d26a8	strstr	vmlinux	EXPORT_SYMBOL
+0xd292bac2	xenbus_bind_evtchn	vmlinux	EXPORT_SYMBOL_GPL
+0xf75f01a2	k8_northbridges	vmlinux	EXPORT_SYMBOL
+0x2dd16564	arch_register_cpu	vmlinux	EXPORT_SYMBOL
+0xfdc782cc	ieee80211_get_buffered_bc	net/mac80211/mac80211	EXPORT_SYMBOL
+0xd8c953c9	usb_serial_generic_resume	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xa53687a2	ppp_channel_index	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xaaacf01b	cfi_qry_mode_off	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL_GPL
+0x07956739	recv_Echannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xeb86c131	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0xb0eedea9	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0xf2fca922	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x9fb6ae5a	pnp_release_card_device	vmlinux	EXPORT_SYMBOL
+0xedbf277c	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x2789d811	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x8f8572dc	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0xe96df0e9	md_check_recovery	vmlinux	EXPORT_SYMBOL
+0xa22d6783	ata_bus_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x89e45edc	fuse_do_ioctl	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x95a2529e	spi_display_xfer_agreement	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0x7d1a1bf6	__iscsi_get_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xe3a3e6f8	i2c_release_client	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x523fc98e	take_over_console	vmlinux	EXPORT_SYMBOL
+0xfce31666	slow_work_cancel	vmlinux	EXPORT_SYMBOL
+0xac4ca1b0	intlog2	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x10a584c2	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x122e7b05	napi_reuse_skb	vmlinux	EXPORT_SYMBOL
+0xaabc400f	dma_mark_declared_memory_occupied	vmlinux	EXPORT_SYMBOL
+0xec538ff8	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x747b054d	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0xda928914	nmi_watchdog	vmlinux	EXPORT_SYMBOL
+0x2e51ad80	xdr_buf_read_netobj	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xd0f094a0	ext_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x22827678	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x5e10f7eb	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x1430e6e0	unregister_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x2f857551	machine_check_poll	vmlinux	EXPORT_SYMBOL_GPL
+0xb0f60189	nf_nat_pptp_hook_exp_gre	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL
+0x183a3999	nf_conntrack_hash_insert	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x66e158a2	rt2x00mac_config	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x9a60af0b	iwl_bg_scan_check	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x0f566d33	cx8802_cancel_buffers	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0xcc9ccaff	dibusb_rc_keys	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x6065e810	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x506746b6	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x8d16025a	fat_free_clusters	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x82cd19f3	register_xenstore_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x06383715	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0xf3f2121b	bt_sock_poll	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xed8610e2	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0xa8e2243b	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x374ed073	scnprintf	vmlinux	EXPORT_SYMBOL
+0x56bcd4fd	aead_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x9c71e738	per_cpu__vm_event_states	vmlinux	EXPORT_SYMBOL
+0x77c212f0	mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x0339d46a	libipw_xmit	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x1823885a	amd_register_ecc_decoder	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x86093562	tcf_register_action	vmlinux	EXPORT_SYMBOL
+0x5d465c6e	blk_queue_ordered	vmlinux	EXPORT_SYMBOL
+0x5097ee7b	snd_seq_kernel_client_enqueue_blocking	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xbfe366cf	fc_fcp_ddp_setup	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xc676918f	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x2d3124e4	sata_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x447bf880	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x8a3eabf0	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0xd63e248e	iscsi_recv_pdu	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xd972fb6a	iwl_mac_config	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x110b053a	ir_codes_pixelview_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x04403fcf	unregister_capi_driver	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x20645642	drm_debug	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x606b2919	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x370f567f	rdev_get_id	vmlinux	EXPORT_SYMBOL_GPL
+0x2c5749e6	acpi_clear_gpe	vmlinux	EXPORT_SYMBOL
+0x48807571	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0xbe091a0e	sas_ioctl	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x547a4903	i2400m_dev_reset_handle	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x35e89ae6	ib_get_cached_gid	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x7e4a63f3	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x472674e3	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0xe9587909	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x5dea5303	acpi_root_dir	vmlinux	EXPORT_SYMBOL
+0xa4f11c31	wrmsr_on_cpus	vmlinux	EXPORT_SYMBOL
+0x3f01570a	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x6e782c23	iomap_create_wc	vmlinux	EXPORT_SYMBOL_GPL
+0x1e422a69	jbd2_journal_get_create_access	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x1b4fcd0c	spi_schedule_dv_device	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0xb7a6fc9c	arp_create	vmlinux	EXPORT_SYMBOL
+0x25389411	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0xea90bdd3	acpi_attach_data	vmlinux	EXPORT_SYMBOL
+0x284c0be0	no_llseek	vmlinux	EXPORT_SYMBOL
+0xdd955cdb	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x513c2b33	cxgb3_free_stid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xd48dbb4f	flexcop_eeprom_check_mac_addr	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x7dc49c41	rtc_irq_set_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x86c72b16	dma_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0xfcfa03ff	fb_videomode_to_modelist	vmlinux	EXPORT_SYMBOL
+0xbf13b163	rwsem_down_read_failed	vmlinux	EXPORT_SYMBOL
+0xa350a8f8	set_memory_array_uc	vmlinux	EXPORT_SYMBOL
+0x64eae7ad	set_memory_array_wb	vmlinux	EXPORT_SYMBOL
+0x52c9d89c	snd_hda_build_controls	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x55898976	wlp_dev_prim_subcat_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x03c67b60	fc_lport_config	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x18d72311	lro_receive_frags	vmlinux	EXPORT_SYMBOL
+0xc2c86e7e	ata_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x59355a90	acpi_pci_check_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0xdd3eb72a	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x8ad02167	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x5b1e4981	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0xa841a3d7	snd_util_memhdr_new	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x1a241d70	iscsi_segment_init_linear	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xe1101f4d	ir_codes_avermedia_m135a_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x78cd3e82	fw_card_initialize	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xeb05a697	ata_sff_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x7dceceac	capable	vmlinux	EXPORT_SYMBOL
+0x61486e99	v9fs_unregister_trans	net/9p/9pnet	EXPORT_SYMBOL
+0xc1e00d52	lbtf_bcn_sent	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x03bf0099	iwl_verify_ucode	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xebb257b5	drm_mode_create_tv_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x819d22aa	nf_afinfo	vmlinux	EXPORT_SYMBOL
+0x60339f93	hid_debug_event	vmlinux	EXPORT_SYMBOL_GPL
+0xb4280f00	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x8a8211d3	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0xe651f76e	selinux_is_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0xc8b57c27	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x8eb58c6e	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x3f6bd206	nf_ct_port_tuple_to_nlattr	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xa12ec709	iwl_get_passive_dwell_time	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x8cc2c120	give_up_console	vmlinux	EXPORT_SYMBOL
+0x7c60d66e	getname	vmlinux	EXPORT_SYMBOL
+0xe7ffe877	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x964ac0a7	snd_seq_root	sound/core/snd	EXPORT_SYMBOL
+0xf3957736	nf_conntrack_helper_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x476ac697	mpt_reset_register	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xeb78a5fa	ivtv_vapi_result	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x37a1b336	rdma_resolve_addr	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0xcea15648	pcmcia_find_io_region	vmlinux	EXPORT_SYMBOL
+0x9a11a0fc	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x520de0b8	snd_hda_mixer_bind_ctls_info	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x14fe0e98	snd_akm4xxx_reset	sound/i2c/other/snd-ak4xxx-adda	EXPORT_SYMBOL
+0x63229ed8	snd_pcm_sgbuf_get_chunk_size	sound/core/snd-pcm	EXPORT_SYMBOL
+0x0ff2b602	slhc_compress	drivers/net/slhc	EXPORT_SYMBOL
+0xd5d615d5	cb710_sg_dwiter_read_next_block	drivers/misc/cb710/cb710	EXPORT_SYMBOL_GPL
+0x6629fa64	gspca_get_i_frame	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x1c852e7c	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x7b17803a	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x76ed6c38	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
+0xf20dabd8	free_irq	vmlinux	EXPORT_SYMBOL
+0x37ac8d05	ieee80211_get_response_rate	net/wireless/cfg80211	EXPORT_SYMBOL
+0xc2066af0	batostr	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x7b18f072	jbd2_journal_init_inode	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x6629f300	uwb_pal_register	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xe2380981	usb_serial_probe	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x3206bf64	ssb_bus_unregister	drivers/ssb/ssb	EXPORT_SYMBOL
+0xcbc1a8ee	osd_req_format	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x9387acc6	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x23d65676	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0xb9fd2205	add_efi_memmap	vmlinux	EXPORT_SYMBOL
+0xb92e3ee5	snd_hda_mixer_amp_switch_get	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x4f816e9b	snd_pcm_format_big_endian	sound/core/snd-pcm	EXPORT_SYMBOL
+0x3b38b88d	rpcauth_register	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf366812f	iwl_get_ra_sta_id	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x6fa7214f	mt2131_attach	drivers/media/common/tuners/mt2131	EXPORT_SYMBOL
+0x84734511	xfrm_audit_policy_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x5866dd19	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x09d44df9	in_lock_functions	vmlinux	EXPORT_SYMBOL
+0xedd1ba52	rpc_wake_up	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbd6c80ac	sas_port_add_phy	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x109cd692	cxgb3_insert_tid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xbc0d91e1	timeval_usec_diff	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x5191cc4f	netpoll_parse_options	vmlinux	EXPORT_SYMBOL
+0x3708b277	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0xfe26bfc8	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x2eb2bc7c	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0xcc6ab305	is_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0xe84d8708	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0xd80328bb	__kmalloc_track_caller	vmlinux	EXPORT_SYMBOL
+0xa1248d77	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0xc36d22b7	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0xe0c77bb5	mce_notify_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x5760b2dd	__wusb_dev_get_by_usb_dev	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xa4d39f11	dib7000p_i2c_enumeration	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x86341e0f	ib_sa_service_rec_query	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x285a1220	alloc_fcdev	vmlinux	EXPORT_SYMBOL
+0x37e18d61	input_event	vmlinux	EXPORT_SYMBOL
+0x66f96dd4	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x5635a60a	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x73b77dab	slow_work_enqueue	vmlinux	EXPORT_SYMBOL
+0x91009452	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x74cc1cbe	unregister_cpu_notifier	vmlinux	EXPORT_SYMBOL
+0xb9e451f9	iwl_rate_get_lowest_plcp	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdc053205	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x55ae9ceb	tc_classify	vmlinux	EXPORT_SYMBOL
+0x8ba510b1	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0xc9425420	wusbhc_mmcie_rm	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x5b1cd5f5	ab3100_event_unregister	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x51124c29	ivtv_udma_prepare	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x60721da7	dsp_audio_law_to_s32	drivers/isdn/mISDN/mISDN_dsp	EXPORT_SYMBOL
+0xaeaedceb	fw_fill_response	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x9c02a737	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x4c1182cb	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x68e26234	proc_create_data	vmlinux	EXPORT_SYMBOL
+0xd494ee54	speedstep_get_freqs	vmlinux	EXPORT_SYMBOL_GPL
+0xf0a610c6	snd_hda_build_pcms	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xf56bf14e	snd_ac97_write_cache	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x3971b4df	snd_ecards_limit	sound/core/snd	EXPORT_SYMBOL
+0xd9072e1a	snd_midi_event_no_status	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0xcec27be1	sunrpc_cache_register_pipefs	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc826558a	nand_wait_ready	drivers/mtd/nand/nand	EXPORT_SYMBOL_GPL
+0x0bd662f6	raid6_gfmul	drivers/md/raid6_pq	EXPORT_SYMBOL
+0x8e6a14b8	edac_device_alloc_ctl_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xa203a404	btmrvl_send_module_cfg_cmd	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0x371b80e7	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0xbbdda61d	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x84812605	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0xd77a5aa5	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x85f09690	b1_irq_table	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x3e34e777	ib_destroy_fmr_pool	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x39415b86	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x2791208d	phy_disable_interrupts	vmlinux	EXPORT_SYMBOL
+0xdf68d339	pci_enable_sriov	vmlinux	EXPORT_SYMBOL_GPL
+0xe078f7e6	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0xd8022a66	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x9c0d3c24	crypto_givcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x5aee024b	snd_hda_codec_resume_amp	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc5e3dddf	wmi_get_event_data	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0xa23bc730	dib0070_ctrl_agc_filter	drivers/media/dvb/frontends/dib0070	EXPORT_SYMBOL
+0x23a62ae7	ib_query_gid	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xddeddcfb	nf_log_packet	vmlinux	EXPORT_SYMBOL
+0x2767f11e	qdisc_tree_decrease_qlen	vmlinux	EXPORT_SYMBOL
+0x6ba1660e	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x5bee9f7b	usb_autopm_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x54fc0d93	ata_eh_freeze_port	vmlinux	EXPORT_SYMBOL_GPL
+0x3771195d	blkcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x340d4016	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0xe5fe5e4e	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0xe73d6882	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x675524ec	rpc_sockaddr2uaddr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x9f455e35	video_device_alloc	drivers/media/video/videodev	EXPORT_SYMBOL
+0xc8945130	drm_fb_helper_init_crtc_count	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xde9360ba	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x8fa4d774	nf_conntrack_l4proto_udp4	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x9c964743	p9stat_free	net/9p/9pnet	EXPORT_SYMBOL
+0x0e195c1c	nfs4_acl_nfsv4_to_posix	fs/nfsd/nfsd	EXPORT_SYMBOL
+0x8e12f46d	wusbhc_mmcie_set	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xac1cc88c	mlx4_INIT_PORT	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x1fc195a5	ubi_do_get_device_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x689819e2	sm501_modify_reg	drivers/mfd/sm501	EXPORT_SYMBOL_GPL
+0x2cdea06d	cx18_reset_ir_gpio	drivers/media/video/cx18/cx18	EXPORT_SYMBOL
+0x08935706	dm_rh_inc_pending	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x97506238	mISDN_initbchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xa504d76f	async_gen_syndrome	crypto/async_tx/async_pq	EXPORT_SYMBOL_GPL
+0xa17099ba	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0xdd3c27a7	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x596bcad7	pcmcia_socket_dev_suspend	vmlinux	EXPORT_SYMBOL
+0x834bf8d3	ata_sff_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x0ca3b8dd	journal_get_write_access	fs/jbd/jbd	EXPORT_SYMBOL
+0x4ed5e0d7	v4l2_chip_match_host	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0xc8891c0a	drm_ati_pcigart_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9601c2c5	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0xfb0443fb	acpi_get_parent	vmlinux	EXPORT_SYMBOL
+0xfe3b83c4	fb_show_logo	vmlinux	EXPORT_SYMBOL
+0x6fa7225e	fb_pan_display	vmlinux	EXPORT_SYMBOL
+0xf66f7be4	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0xe5919cb1	xdr_encode_opaque	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xb2e912f8	wlp_remove	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x7b59e251	iscsi_session_recovery_timedout	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x576fdbac	ib_sa_free_multicast	drivers/infiniband/core/ib_sa	EXPORT_SYMBOL
+0x7b5d4b7a	ib_is_mad_class_rmpp	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xd48e1075	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL
+0xa501e5f4	snd_rawmidi_new	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x35f5e2b9	svc_max_payload	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x682da57c	cx88_set_stereo	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x36e18301	dm_rh_region_context	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xfd5ab976	b1_parse_version	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0xa6600bce	ib_dereg_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x2c45a757	parse_mtd_partitions	vmlinux	EXPORT_SYMBOL_GPL
+0xb22f570b	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0xac5c74d9	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xdc14eda7	pci_pci_problems	vmlinux	EXPORT_SYMBOL
+0x956a91ba	gpio_get_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0xd5d8b615	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x7d0d1617	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x85ee68d1	nf_conntrack_free	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x1a24e5e2	sonet_subtract_stats	net/atm/atm	EXPORT_SYMBOL
+0x6e413959	uwb_rsv_modify	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x3819ae11	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x84dbcc62	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x96898769	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x91cfb904	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x9db84557	ata_eh_thaw_port	vmlinux	EXPORT_SYMBOL_GPL
+0x596f03be	pnp_is_active	vmlinux	EXPORT_SYMBOL
+0xcf8af983	trace_profile_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x6ee806ee	snd_vx_dsp_load	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0x7296ac9d	drop_super	vmlinux	EXPORT_SYMBOL
+0xb72397d5	printk	vmlinux	EXPORT_SYMBOL
+0xc54eb6b9	cfg80211_get_bss	net/wireless/cfg80211	EXPORT_SYMBOL
+0xf1a01957	drm_helper_resume_force_mode	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x1f072c59	drm_property_add_enum	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xb971744b	sk_alloc	vmlinux	EXPORT_SYMBOL
+0xf2d22abf	sata_std_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0xb6490ab8	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x1b84c662	regulator_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x47f93bb7	remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x2a603925	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0xfbb63891	tracepoint_iter_start	vmlinux	EXPORT_SYMBOL_GPL
+0xbfb084df	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0xc3135a39	rpcauth_lookup_credcache	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x2ee752f2	hci_conn_switch_role	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x1d24a539	spi_dv_device	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL
+0x7bcd2ded	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x683b76a5	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x4b654ea8	pci_disable_msix	vmlinux	EXPORT_SYMBOL
+0x927b2282	kobject_add	vmlinux	EXPORT_SYMBOL
+0x10138352	tracing_on	vmlinux	EXPORT_SYMBOL_GPL
+0x7bb1b46e	snd_hda_create_spdif_out_ctls	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x566d30dd	parport_register_device	drivers/parport/parport	EXPORT_SYMBOL
+0xed9e1a34	bnx2_cnic_probe	drivers/net/bnx2	EXPORT_SYMBOL
+0x521b8bc7	wm8350_device_exit	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xd94a23f9	vp3054_i2c_remove	drivers/media/video/cx88/cx88-vp3054-i2c	EXPORT_SYMBOL
+0xd524d98a	drm_fb_helper_setcolreg	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x90385429	xfrm_audit_policy_add	vmlinux	EXPORT_SYMBOL_GPL
+0x20985710	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x0ba5da8d	agp_generic_alloc_user	vmlinux	EXPORT_SYMBOL
+0x9009602a	acpi_bus_get_ejd	vmlinux	EXPORT_SYMBOL_GPL
+0x735a0bd5	native_io_delay	vmlinux	EXPORT_SYMBOL
+0x9ebff902	start_thread	vmlinux	EXPORT_SYMBOL_GPL
+0xcd31f558	rfkill_get_led_trigger_name	net/rfkill/rfkill	EXPORT_SYMBOL
+0xd68abf23	rfkill_set_led_trigger_name	net/rfkill/rfkill	EXPORT_SYMBOL
+0x529d6317	br_should_route_hook	net/bridge/bridge	EXPORT_SYMBOL
+0x74a5a698	dvb_filter_pes2ts_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x8824f4ab	isdn_ppp_register_compressor	drivers/isdn/i4l/isdn	EXPORT_SYMBOL
+0x05f82b29	iw_handler_get_thrspy	vmlinux	EXPORT_SYMBOL
+0x4385be3b	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0xb33dfc72	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL
+0xe67f5bc6	agp_flush_chipset	vmlinux	EXPORT_SYMBOL
+0xbf74df8e	pci_scan_single_device	vmlinux	EXPORT_SYMBOL
+0x92305ef0	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x5cbfad63	p54_read_eeprom	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0x6403e338	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0xcd1ca2cb	iommu_domain_has_cap	vmlinux	EXPORT_SYMBOL_GPL
+0xb2a40568	agp_generic_remove_memory	vmlinux	EXPORT_SYMBOL
+0x4bfee15a	atomic64_set	vmlinux	EXPORT_SYMBOL
+0x2d7bb435	dqput	vmlinux	EXPORT_SYMBOL
+0x74828aca	dqget	vmlinux	EXPORT_SYMBOL
+0xb4ea7cf7	kgdb_connected	vmlinux	EXPORT_SYMBOL_GPL
+0xc81d67a6	snd_register_oss_device	sound/core/snd	EXPORT_SYMBOL
+0x191e88cf	snd_dma_pointer	sound/core/snd	EXPORT_SYMBOL
+0x24a94b26	snd_info_get_line	sound/core/snd	EXPORT_SYMBOL
+0xdd0e9ca7	rt2x00pci_rxdone	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0x2c7a0e72	iwl_set_rxon_hwcrypto	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x821e08e8	nand_release	drivers/mtd/nand/nand	EXPORT_SYMBOL_GPL
+0x1feb6553	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0xadaa2657	cpufreq_register_notifier	vmlinux	EXPORT_SYMBOL
+0xf93b7142	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x68e419ce	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0xffd61a8c	elv_add_request	vmlinux	EXPORT_SYMBOL
+0xa332cdd1	security_tun_dev_attach	vmlinux	EXPORT_SYMBOL
+0xf346231f	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0xe340b801	unregister_hdlc_device	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x899ab888	dm_table_unplug_all	drivers/md/dm-mod	EXPORT_SYMBOL
+0xd53c5e11	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x99a7f136	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x0e45519d	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x0340d0e1	acpi_pci_osc_control_set	vmlinux	EXPORT_SYMBOL
+0x874fefd5	fbcon_rotate_ud	vmlinux	EXPORT_SYMBOL
+0x9a842362	fbcon_rotate_cw	vmlinux	EXPORT_SYMBOL
+0xdb73c37b	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0xcf6cf154	relay_flush	vmlinux	EXPORT_SYMBOL_GPL
+0xbf2603ad	snd_sb16dsp_pcm	sound/isa/sb/snd-sb16-dsp	EXPORT_SYMBOL
+0xc12435e3	rpc_calc_rto	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x56183917	fc_destroy_rport	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xc419cd42	rt2x00mac_get_tx_stats	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xb8db5c43	ei_set_multicast_list	drivers/net/8390	EXPORT_SYMBOL
+0x52a631e3	saa7134_dmasound_init	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x3413b46b	saa7134_dmasound_exit	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x310a5d58	saa7146_vv_init	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0xdd30a7ef	drm_mode_width	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x1fe27115	kernel_bind	vmlinux	EXPORT_SYMBOL
+0xcc248d26	serial8250_suspend_port	vmlinux	EXPORT_SYMBOL
+0x4e6e8ea7	fg_console	vmlinux	EXPORT_SYMBOL
+0x444779c4	nla_find	vmlinux	EXPORT_SYMBOL
+0xb0c0b3cd	kernel_read	vmlinux	EXPORT_SYMBOL
+0xf05b0cdb	vfs_read	vmlinux	EXPORT_SYMBOL
+0x079d1581	ring_buffer_record_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x9237c9c4	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0xd8bffe34	snd_opl4_read_memory	sound/drivers/opl4/snd-opl4-lib	EXPORT_SYMBOL
+0x07153081	parport_write	drivers/parport/parport	EXPORT_SYMBOL
+0xeb9bb08f	ir_codes_npgtech_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x2d8e866b	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x9fb3dd30	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0xa8813189	__nvram_write_byte	vmlinux	EXPORT_SYMBOL
+0x9df39643	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL
+0x7976360c	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x4b0388d4	oxygen_write8	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x2777a875	journal_unlock_updates	fs/jbd/jbd	EXPORT_SYMBOL
+0xe196105f	i2400m_tx_msg_get	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x23a68c0e	videobuf_dma_map	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x7153a9ca	vlan_dev_vlan_id	vmlinux	EXPORT_SYMBOL
+0xdfa0e6ac	pcmcia_socket_dev_resume	vmlinux	EXPORT_SYMBOL
+0x59faf869	ata_base_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x6444fe87	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0xf4294e61	security_skb_classify_flow	vmlinux	EXPORT_SYMBOL
+0x0a88ec2a	sunrpc_cache_unregister_pipefs	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0177cae8	usbnet_resume_rx	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x9b2d7fac	videobuf_streamon	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x7228494f	drm_ati_pcigart_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xd99e1b6d	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0xdd2a6af9	agp_collect_device_status	vmlinux	EXPORT_SYMBOL
+0x8d6f81b4	__div64_32	vmlinux	EXPORT_SYMBOL
+0xe0a501e3	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x85bb2324	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x2cf59aec	mntput_no_expire	vmlinux	EXPORT_SYMBOL
+0x93fca811	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0xbb189cad	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x198d3dfc	rawv6_mh_filter_register	net/ipv6/ipv6	EXPORT_SYMBOL
+0x0233f349	iscsi_pool_init	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x78bae2d3	iwl_mac_conf_tx	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdbcd416e	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0xd050a974	__tcp_get_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x4b7d4f2f	pciserial_init_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x4575315d	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x77a3d130	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x2b4ea28b	rawv6_mh_filter_unregister	net/ipv6/ipv6	EXPORT_SYMBOL
+0x7e4b1ac8	iwl_rx_reply_error	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5fe7472a	stv0297_attach	drivers/media/dvb/frontends/stv0297	EXPORT_SYMBOL
+0xd59a5beb	mISDN_clear_bchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x0783cbef	fb_deferred_io_init	vmlinux	EXPORT_SYMBOL_GPL
+0x328b196e	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x70866803	dquot_reserve_space	vmlinux	EXPORT_SYMBOL
+0xdb8c3a21	nf_ct_l3proto_find_get	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x12493428	fuse_conn_kill	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0xd4c0b7a6	parport_ieee1284_write_compat	drivers/parport/parport	EXPORT_SYMBOL
+0x3d5cc24f	i2c_new_dummy	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0x3cc34221	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0xfff24940	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x899bd5bf	register_mtd_chip_driver	vmlinux	EXPORT_SYMBOL
+0xe36ad1a3	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x0f1c6fdf	jbd2_journal_release_buffer	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x3909f7b7	dib3000mc_i2c_enumeration	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0xbc546be6	dm_rh_mark_nosync	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xb19fda8d	capi_cmd2str	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xdbcc3754	drm_helper_hotplug_stage_two	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x9e740730	deregister_mtd_parser	vmlinux	EXPORT_SYMBOL_GPL
+0xbda02b12	pci_disable_sriov	vmlinux	EXPORT_SYMBOL_GPL
+0x970ce139	__any_online_cpu	vmlinux	EXPORT_SYMBOL
+0x9ac77f1a	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x5815f9ed	register_ip_vs_app	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xca61ddcc	vmbus_child_driver_unregister	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL
+0xf2a353ac	v4l2_i2c_tuner_addrs	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0xcaccb72a	dm_table_put	drivers/md/dm-mod	EXPORT_SYMBOL
+0x563397e2	fb_sys_write	vmlinux	EXPORT_SYMBOL_GPL
+0xb08f76ad	gen_pool_free	vmlinux	EXPORT_SYMBOL
+0xbf83c890	kunmap_high	vmlinux	EXPORT_SYMBOL
+0x059b53f2	snd_util_memhdr_free	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x438ea4e8	ib_send_cm_apr	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x90863005	fw_high_memory_region	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x9b86981c	sata_scr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x07608604	acpi_get_vendor_resource	vmlinux	EXPORT_SYMBOL
+0xacf4d843	match_strdup	vmlinux	EXPORT_SYMBOL
+0x472d2a9a	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x4672e88b	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x80d04401	ring_buffer_free_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x88b50c20	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0xb5b95805	dvb_ringbuffer_read_user	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xc499bef4	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x0739506f	bsg_register_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x633a93f0	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x7b35e366	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0xc57525e0	nf_nat_get_offset	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0x39a393e1	wpan_phy_alloc	net/ieee802154/wpan-class	EXPORT_SYMBOL
+0x6a32a580	iscsi_free_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x78c53d4a	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x833a3e07	snd_midi_channel_set_clear	sound/core/seq/snd-seq-midi-emul	EXPORT_SYMBOL
+0x7acaa90f	xprt_disconnect_done	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3f039717	ipv6_setsockopt	net/ipv6/ipv6	EXPORT_SYMBOL
+0x66d507e2	usb_serial_port_softint	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xf10dbbac	del_mtd_blktrans_dev	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL
+0x0cd77521	videobuf_alloc	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x44649f6c	drm_property_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xaad809c0	cache_register	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3dbdf519	dccp_getsockopt	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x8d2e3f96	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x645ce501	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0xa28d8527	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x9e01f6d4	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x1b4e9ea7	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x6d1371f9	bt_sock_wait_state	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xfa8bda42	ei_tx_timeout	drivers/net/8390	EXPORT_SYMBOL
+0xb731fcd2	fifo_set_limit	vmlinux	EXPORT_SYMBOL
+0x67580531	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x3cfedb3f	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x3a549fcc	rt2x00mac_set_key	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x2bac0f0e	mptscsih_event_process	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x1b5af179	memstick_detect_change	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x6c223830	cx22700_attach	drivers/media/dvb/frontends/cx22700	EXPORT_SYMBOL
+0x512283cd	drm_i2c_encoder_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xfdbd55a1	ipmi_request_settime	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xd1f91bcd	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0xd25d4f74	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x5bb4ecf0	mptscsih_resume	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xa44ca915	cx88_core_get	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xa58f19e2	dm_kill_unmapped_request	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0xfa567e48	xt_request_find_target	vmlinux	EXPORT_SYMBOL_GPL
+0xb1a40676	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x394ac64b	file_fsync	vmlinux	EXPORT_SYMBOL
+0xfe451b74	get_sb_bdev	vmlinux	EXPORT_SYMBOL
+0xc22a3091	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0xbaef2826	wlp_dev_prim_OUI_sub_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xace8e498	tifm_free_adapter	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x148023e3	memstick_new_req	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xeb26862f	dib3000mc_get_tuner_i2c_master	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0xb7fff8c5	dm_rh_delay	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xdc50cfee	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x6add5c9a	dmi_find_device	vmlinux	EXPORT_SYMBOL
+0x0196a3b7	register_md_personality	vmlinux	EXPORT_SYMBOL
+0x158ebbcc	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x35b6db06	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x03918fcd	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x4b34fbf5	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x39d01a1f	sdio_writeb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x43c89ef4	ir_decode_biphase	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xeb44f555	ib_destroy_ah	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xcb20ba1b	ib_destroy_qp	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x7c3194c1	usb_hcd_pci_probe	vmlinux	EXPORT_SYMBOL_GPL
+0xc6c41ce4	tty_name	vmlinux	EXPORT_SYMBOL
+0x7379acb6	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x8e963896	libipw_change_mtu	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xf494f618	mmc_regulator_get_ocrmask	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x0c521bc2	wm831x_request_irq	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0xb60897e1	bchannel_senddata	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x4658cd40	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL
+0x4615d757	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x105e2727	__tracepoint_kmalloc	vmlinux	EXPORT_SYMBOL
+0x8b16c4e6	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x6d0d8b8f	call_usermodehelper_pipe	vmlinux	EXPORT_SYMBOL
+0xe7685321	inet6_csk_reqsk_queue_hash_add	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x2b418289	fat_get_dotdot_entry	fs/fat/fat	EXPORT_SYMBOL_GPL
+0xb05a2aa5	wm8350_reg_lock	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xa99c40bf	mptscsih_host_reset	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x8b273cef	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x7a5c4b11	fib_default_rule_add	vmlinux	EXPORT_SYMBOL
+0xe1c71e60	ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x91e74408	do_SAK	vmlinux	EXPORT_SYMBOL
+0x086353b5	pci_save_state	vmlinux	EXPORT_SYMBOL
+0x79934989	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x1c534db0	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x855491a8	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0xdf622b84	tracepoint_iter_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x108e8985	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x0003bdc3	wimax_msg_data	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x5ac998de	sas_rphy_add	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xecd23512	cx88_free_buffer	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xfbc6306f	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0xc599a772	security_xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x93a29864	page_put_link	vmlinux	EXPORT_SYMBOL
+0x7444267e	rpc_sleep_on	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe84cc34d	ssb_dma_free_consistent	drivers/ssb/ssb	EXPORT_SYMBOL
+0xcf43c0c0	sp8870_attach	drivers/media/dvb/frontends/sp8870	EXPORT_SYMBOL
+0x828b3ce5	ir_codes_encore_enltv_fm53_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xb6aeb661	ata_id_c_string	vmlinux	EXPORT_SYMBOL_GPL
+0x238b0cc9	security_xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x0ac0ab25	vring_interrupt	drivers/virtio/virtio_ring	EXPORT_SYMBOL_GPL
+0x6f09ba8a	ubi_register_volume_notifier	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x1caa49bb	drm_property_create	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xf553cdc6	km_state_expired	vmlinux	EXPORT_SYMBOL
+0xafd96c8e	qdisc_list_del	vmlinux	EXPORT_SYMBOL
+0xb0e10781	get_option	vmlinux	EXPORT_SYMBOL
+0x487d86a4	nf_ct_gre_keymap_destroy	net/netfilter/nf_conntrack_proto_gre	EXPORT_SYMBOL_GPL
+0xce19bac5	register_inet6addr_notifier	net/ipv6/ipv6	EXPORT_SYMBOL
+0xe5c6b15c	flexcop_dma_xfer_control	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x27f15d0d	mt2266_attach	drivers/media/common/tuners/mt2266	EXPORT_SYMBOL
+0xa539b397	cryptd_alloc_ablkcipher	crypto/cryptd	EXPORT_SYMBOL_GPL
+0x9ba8d2d4	inet_accept	vmlinux	EXPORT_SYMBOL
+0x5ea520c5	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0xec37882b	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x5016c1c0	hidraw_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x9f2a2bd8	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x9af8e8a3	unbind_con_driver	vmlinux	EXPORT_SYMBOL
+0x2dedc4c2	acpi_format_exception	vmlinux	EXPORT_SYMBOL
+0x6de72bdc	pci_set_consistent_dma_mask	vmlinux	EXPORT_SYMBOL
+0xe697d108	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x14f332ea	up_read	vmlinux	EXPORT_SYMBOL
+0xa1c76e0a	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x815f2897	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0xa29f0d0a	nfnetlink_subsys_register	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x48e4e30f	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x40aa7a5c	cpufreq_frequency_table_verify	vmlinux	EXPORT_SYMBOL_GPL
+0x63073d82	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0xfffb14e0	bioset_free	vmlinux	EXPORT_SYMBOL
+0x7362dd1e	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x3daa69da	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0xcc51ee50	dma_spin_lock	vmlinux	EXPORT_SYMBOL
+0x20bc3470	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x0be13004	usb_storage_usb_ids	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x01c85ecc	gspca_dev_probe	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x800d356e	dib8000_get_i2c_master	drivers/media/dvb/frontends/dib8000	EXPORT_SYMBOL
+0x4312cb70	pcmcia_unregister_driver	vmlinux	EXPORT_SYMBOL
+0xa598e29c	vesa_modes	vmlinux	EXPORT_SYMBOL
+0xe4ddb52e	pn_skb_send	net/phonet/phonet	EXPORT_SYMBOL
+0xae3280bc	dccp_shutdown	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x43f2d87e	p9_client_destroy	net/9p/9pnet	EXPORT_SYMBOL
+0xb1152edd	iscsi_target_alloc	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x70718f53	attach_hdlc_protocol	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x29596da3	ttpci_budget_irq10_handler	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0xb8c07fe6	rdma_accept	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x4834cb8d	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0xc5d9c46c	agp_try_unsupported_boot	vmlinux	EXPORT_SYMBOL
+0xc5534d64	ioread16	vmlinux	EXPORT_SYMBOL
+0xba539c4f	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0xca1909c8	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x183fa88b	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0xef6ed1ba	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x57f98286	ieee802154_nl_beacon_indic	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x22da5f3d	lbs_resume	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x60af11eb	saa7146_setgpio	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0xfe029614	rdma_bind_addr	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x35b1b258	i2c_register_driver	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x837cb7cb	ttm_buffer_object_validate	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x1ddd4143	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xeeedaceb	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL
+0xec55fc64	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x859c6dc7	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x838c852b	svc_drop	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x466da8b0	jbd2_journal_forget	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xa76c2a59	isl6421_attach	drivers/media/dvb/frontends/isl6421	EXPORT_SYMBOL
+0x6489650a	ib_free_recv_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x56af0dbd	gf128mul_x_ble	crypto/gf128mul	EXPORT_SYMBOL
+0x398c1a2e	ata_bmdma32_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0xfe46493f	sata_scr_valid	vmlinux	EXPORT_SYMBOL_GPL
+0xc0d6b953	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
+0x69927dff	try_acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0xa8d891e7	cfg80211_get_mesh	net/wireless/cfg80211	EXPORT_SYMBOL
+0x7ada25fe	cx88_enum_input	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0x61aaa049	edac_mc_alloc	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x272e4543	skb_clone	vmlinux	EXPORT_SYMBOL
+0xacc19485	ibft_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x44a65d5c	lock_policy_rwsem_read	vmlinux	EXPORT_SYMBOL_GPL
+0xfd57756f	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x0487f831	fb_find_best_display	vmlinux	EXPORT_SYMBOL
+0x6b997b15	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x6f99d8e6	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x944d9845	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0xf822683f	rt2x00mac_rfkill_poll	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x6b28395b	sysctl_jiffies	vmlinux	EXPORT_SYMBOL
+0x7b8699eb	snd_seq_event_port_detach	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xd5ba1bff	jbd2_journal_start	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xb38b099e	uwb_rc_neh_grok	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x2b01c27e	ssb_device_enable	drivers/ssb/ssb	EXPORT_SYMBOL
+0xc8286558	iscsi_session_event	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xd88e6595	iwl_send_lq_cmd	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x1d15cf21	ib_query_ah	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x9acdf4a6	drm_encoder_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xc34efe27	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x381ade8b	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x1fed31e4	phy_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x2cafc9c0	phy_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0xc06f04db	pci_disable_link_state	vmlinux	EXPORT_SYMBOL
+0x1c7b6c2a	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0xdf968fcb	snd_hda_multi_out_dig_cleanup	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x74222210	garp_unregister_application	net/802/garp	EXPORT_SYMBOL_GPL
+0xb827b35e	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL
+0x323adf2c	ata_host_alloc_pinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x37f5bd1b	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x08e62194	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x60cab104	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0xbab63f32	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x278b9770	gss_mech_unregister	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x1ed081b9	jbd2_journal_force_commit_nested	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x4196c38b	hermes_write_ltv	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0xea87f131	videobuf_dma_init_kernel	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0xee1f5c56	mxl5007t_attach	drivers/media/common/tuners/mxl5007t	EXPORT_SYMBOL_GPL
+0x36b188d8	b1_interrupt	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x49041516	btmrvl_interrupt	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0xa29b1708	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0xf9167602	hid_check_keys_pressed	vmlinux	EXPORT_SYMBOL_GPL
+0xda26bb6d	ata_sff_qc_fill_rtf	vmlinux	EXPORT_SYMBOL_GPL
+0x379ffe48	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0xa90ad4e6	seq_release_private	vmlinux	EXPORT_SYMBOL
+0xf7026243	snd_ctl_remove	sound/core/snd	EXPORT_SYMBOL
+0x672c9d44	iTCO_vendor_pre_keepalive	drivers/watchdog/iTCO_vendor_support	EXPORT_SYMBOL
+0xee60ab92	ata_pci_remove_one	vmlinux	EXPORT_SYMBOL_GPL
+0x62b2af79	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0xcf1d28ab	acpi_error	vmlinux	EXPORT_SYMBOL
+0x6e0ab27c	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x510c60a5	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0xb6b61540	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x66881ef7	jbd2_journal_check_used_features	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xb9d2d482	sdio_readsb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xfef0217a	mmc_host_enable	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xa454990c	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
+0x2c3d53b0	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL
+0xe98ccd11	__set_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x89a2fa4e	auth_domain_lookup	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0b0d888b	icmpv6_err_convert	net/ipv6/ipv6	EXPORT_SYMBOL
+0xa2dbe675	rt2x00usb_kick_tx_queue	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xf09394df	rt2x00usb_kill_tx_queue	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x1a487a61	iwl_chain_noise_calibration	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2f25eee2	cx2341x_update	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0xaa4bd8d0	xfrm_audit_state_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x51b7c1a4	scsi_register_device_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x290ff3a8	serial8250_register_port	vmlinux	EXPORT_SYMBOL
+0x20e4efc0	fb_get_mode	vmlinux	EXPORT_SYMBOL
+0x3c1ab9bc	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x29335b9f	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x092c7d91	snd_emu10k1_synth_alloc	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0x6bf111f7	wlp_dev_prim_category_show	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x5ee4ef5a	ssb_bus_pcibus_register	drivers/ssb/ssb	EXPORT_SYMBOL
+0xeb289131	srp_transfer_data	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0x947124a5	mmc_detect_change	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xb41582e3	get_next_dframe	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x78a60d39	get_next_bframe	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x0e21ea57	drm_debugfs_remove_files	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xfda5675b	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x48eff34a	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0xacff07bf	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0xe34e6f9d	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x3dde0e07	amd_get_nb_id	vmlinux	EXPORT_SYMBOL_GPL
+0x34b8d1b8	oxygen_write16	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xff7fa791	oxygen_write32	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x30c9b624	snd_opl4_write	sound/drivers/opl4/snd-opl4-lib	EXPORT_SYMBOL
+0xa2e61bb6	sdio_readb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x59d83fe0	sdio_readw	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x1aeee6c7	sdio_readl	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xa8955e71	cpufreq_freq_attr_scaling_available_freqs	vmlinux	EXPORT_SYMBOL_GPL
+0x9929526e	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x4fdc98b6	ahash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x3f5ac57f	dquot_claim_space	vmlinux	EXPORT_SYMBOL
+0x2d9f2ce3	sched_clock_idle_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x44aaf30f	tsc_khz	vmlinux	EXPORT_SYMBOL
+0xb8e7ce2c	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x51b22743	uwb_rc_init	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x038adf0a	hostap_init_data	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x1276eff1	mlx4_CLOSE_PORT	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xce9c4c86	videobuf_streamoff	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xcf76ce95	cx2341x_fill_defaults	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0x6754d9fa	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0xa2e195a5	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x0f62d7c9	mark_info_dirty	vmlinux	EXPORT_SYMBOL
+0x923a4254	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x6fcb87a1	touch_softlockup_watchdog	vmlinux	EXPORT_SYMBOL
+0xc3301f02	rcu_expedited_torture_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x17f477f8	journal_start	fs/jbd/jbd	EXPORT_SYMBOL
+0x9a69b1d9	ppp_input	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xe44bbf87	register_filesystem	vmlinux	EXPORT_SYMBOL
+0xba497f13	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x6aaaee7e	rds_for_each_conn_info	net/rds/rds	EXPORT_SYMBOL_GPL
+0xcf8d791e	sas_remove_children	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xa35fcb10	eip_get_stats	drivers/net/8390p	EXPORT_SYMBOL
+0x2b3dfa9f	drm_getsarea	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xa4e1864b	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x2c208607	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x673f815e	agp_bridges	vmlinux	EXPORT_SYMBOL
+0x7b134ddf	acpi_get_name	vmlinux	EXPORT_SYMBOL
+0xd82613c0	atomic64_sub_and_test	vmlinux	EXPORT_SYMBOL
+0x3cb3931b	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x9f100139	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x2df115d4	eeprom_93cx6_multiread	drivers/misc/eeprom/eeprom_93cx6	EXPORT_SYMBOL_GPL
+0xf1043053	drm_mode_crtc_set_gamma_size	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x567eae61	drm_addbufs_agp	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x768cfd19	drm_addbufs_pci	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0fdf9ce2	hidraw_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x9e42fb69	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL
+0x4f5add5b	regulator_get_exclusive	vmlinux	EXPORT_SYMBOL_GPL
+0x358903de	generic_make_request	vmlinux	EXPORT_SYMBOL
+0xe007eada	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x1c87a811	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0xbf60c24f	garp_uninit_applicant	net/802/garp	EXPORT_SYMBOL_GPL
+0xcce79852	mii_phy_probe	drivers/net/sungem_phy	EXPORT_SYMBOL
+0x6d95361d	cx231xx_uninit_isoc	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x76d71b8e	ir_codes_dntv_live_dvb_t_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x02124474	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x13b3ac06	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x3e993321	pcmcia_insert_card	vmlinux	EXPORT_SYMBOL
+0x1cc37e09	dev_attr_sw_activity	vmlinux	EXPORT_SYMBOL_GPL
+0x57db7242	mangle_path	vmlinux	EXPORT_SYMBOL
+0x49a2e44e	snd_wss_create	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x7be09ec2	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x2c153337	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x520e9e53	oxygen_write_ac97	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x6f049ff4	fuse_conn_init	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0xe8794ce1	slhc_toss	drivers/net/slhc	EXPORT_SYMBOL
+0xabe3f159	mpt_alloc_fw_memory	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xd63d6819	drm_core_get_map_ofs	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x77387829	drm_gem_vm_close	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x7b0c84c4	acpi_remove_table_handler	vmlinux	EXPORT_SYMBOL
+0x40d37d54	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x9a6a83f9	cmos_lock	vmlinux	EXPORT_SYMBOL
+0xf8dabfce	unix_domain_find	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xad4bdd1f	ieee80211_scan_completed	net/mac80211/mac80211	EXPORT_SYMBOL
+0xa6b47b21	tda829x_probe	drivers/media/common/tuners/tda8290	EXPORT_SYMBOL_GPL
+0x40b7c4a9	i2c_smbus_read_i2c_block_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x9e7e628f	fw_bus_type	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x8958ad35	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x3720c11f	unregister_pernet_gen_device	vmlinux	EXPORT_SYMBOL_GPL
+0x3d83fe9f	tty_mutex	vmlinux	EXPORT_SYMBOL
+0xbcc308bb	strnlen_user	vmlinux	EXPORT_SYMBOL
+0x8289bfd9	kunmap	vmlinux	EXPORT_SYMBOL
+0xde2a6625	snd_hda_suspend	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xa57193c4	prism2_update_comms_qual	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x3bc32dfc	mlx4_db_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x2b503935	mpt_print_ioc_summary	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x4d369320	async_raid6_datap_recov	crypto/async_tx/async_raid6_recov	EXPORT_SYMBOL_GPL
+0x16a5e826	xt_free_table_info	vmlinux	EXPORT_SYMBOL
+0x61c65ddf	ata_bmdma_setup	vmlinux	EXPORT_SYMBOL_GPL
+0xb10d55bc	cn_netlink_send	vmlinux	EXPORT_SYMBOL_GPL
+0x31b306b7	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x874d639f	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0xaf334bbf	snd_dma_alloc_pages_fallback	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0x65ec98d3	dccp_poll	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x8ee6dbee	p54_unregister_common	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0x3ed2dad9	libipw_channel_to_index	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x804f922a	ipmi_addr_length	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xa46851f8	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x8155b252	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL
+0x584738f9	rdmsr_safe_on_cpu	vmlinux	EXPORT_SYMBOL
+0x9ac8c74c	__page_symlink	vmlinux	EXPORT_SYMBOL
+0xf9833936	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x57496431	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0xfdab6de3	unregister_sound_midi	sound/soundcore	EXPORT_SYMBOL
+0x9c1b7310	iscsi_segment_seek_sg	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x388c14fd	ivtv_set_irq_mask	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0xc2cf03cd	ib_unregister_event_handler	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xdd49095c	drm_ht_insert_item	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x7a2a837d	strict_strtol	vmlinux	EXPORT_SYMBOL
+0x74ad9c2d	unregister_kretprobes	vmlinux	EXPORT_SYMBOL_GPL
+0x863ab054	snd_ctl_register_ioctl	sound/core/snd	EXPORT_SYMBOL
+0xa5051071	ipcomp_input	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL
+0x22991f57	xdr_skb_read_bits	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x99d73ffa	nat_h245_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0x38079cb4	mmc_card_sleep	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x4540c4c2	ip_mc_rejoin_group	vmlinux	EXPORT_SYMBOL
+0x950b89e6	udp_prot	vmlinux	EXPORT_SYMBOL
+0x20c60ce3	br_fdb_test_addr_hook	vmlinux	EXPORT_SYMBOL_GPL
+0xb085ef18	snd_opl3_load_patch	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0xc9a24b39	inet6_sk_rebuild_header	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0xbd23545c	mb_cache_shrink	fs/mbcache	EXPORT_SYMBOL
+0xfb774cf8	register_hdlc_protocol	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0xee346a34	dib3000mc_set_config	drivers/media/dvb/frontends/dib3000mc	EXPORT_SYMBOL
+0x4c6c860f	unregister_quota_format	vmlinux	EXPORT_SYMBOL
+0xf1e98c74	avenrun	vmlinux	EXPORT_SYMBOL
+0xd0f19d6e	nf_ct_extend_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xe9e93c3b	free_mdio_bitbang	drivers/net/phy/mdio-bitbang	EXPORT_SYMBOL
+0x123959a1	v4l2_type_names	drivers/media/video/videodev	EXPORT_SYMBOL
+0x157628a2	ir_input_nokey	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xb4d297fd	register_mtd_parser	vmlinux	EXPORT_SYMBOL_GPL
+0x409d9e0a	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x7f65b1d3	dm_rh_recovery_in_flight	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x45d85020	ipmi_poll_interface	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x9cb8037b	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0xd83791bc	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL
+0xcb7bc1b2	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0xb44ad147	__ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x906356eb	snd_dma_get_reserved_buf	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0xd0a65eae	osd_req_list_collection_objects	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x28439439	saa7146_i2c_adapter_prepare	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x38c7a6f6	hid_output_report	vmlinux	EXPORT_SYMBOL_GPL
+0x907cdd76	vfs_dq_drop	vmlinux	EXPORT_SYMBOL
+0x96feae2e	block_sync_page	vmlinux	EXPORT_SYMBOL
+0xd228f305	cdev_add	vmlinux	EXPORT_SYMBOL
+0x85b39328	ring_buffer_write	vmlinux	EXPORT_SYMBOL_GPL
+0xa1463342	ring_buffer_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x82939ebd	rcu_batches_completed_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x584fd26a	snd_timer_new	sound/core/snd-timer	EXPORT_SYMBOL
+0xeeacab69	rpc_update_rtt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x25584749	mptscsih_change_queue_depth	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x9739a502	ib_modify_srq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x946224e3	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x085227e6	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0xb3740a00	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x06a96d89	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x6dd8bd28	dev_attr_em_message_type	vmlinux	EXPORT_SYMBOL_GPL
+0x79068fda	acpi_install_method	vmlinux	EXPORT_SYMBOL
+0x04d59bc9	fb_blank	vmlinux	EXPORT_SYMBOL
+0xad7ba473	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x30d5b9e6	open_exec	vmlinux	EXPORT_SYMBOL
+0x45d14bdf	hypercall_page	vmlinux	EXPORT_SYMBOL_GPL
+0xd49559d4	mb_cache_entry_find_next	fs/mbcache	EXPORT_SYMBOL
+0x62a96e26	iscsi_remove_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x30caf225	iwl_rx_queue_space	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xbb03150f	ip_vs_skb_replace	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x73611ab4	journal_forget	fs/jbd/jbd	EXPORT_SYMBOL
+0x12318559	NS8390p_init	drivers/net/8390p	EXPORT_SYMBOL
+0x05513b71	raid6_call	drivers/md/raid6_pq	EXPORT_SYMBOL_GPL
+0x2beb6400	dev_unicast_delete	vmlinux	EXPORT_SYMBOL
+0x43f56e82	ata_xfer_mode2shift	vmlinux	EXPORT_SYMBOL_GPL
+0x644f3d30	pnp_activate_dev	vmlinux	EXPORT_SYMBOL
+0x9424b8a3	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL
+0xb1f975aa	unlock_kernel	vmlinux	EXPORT_SYMBOL
+0x1ffc8464	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x7a89fbb4	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0xeac32db8	iscsi_destroy_endpoint	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x17ff32ec	ib_unregister_client	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x0c32ff8a	edac_pci_alloc_index	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x1fd7a543	bitmap_startwrite	vmlinux	EXPORT_SYMBOL
+0xe657c679	pm_runtime_idle	vmlinux	EXPORT_SYMBOL_GPL
+0xd1a7ce1c	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x37245b03	pci_enable_msix	vmlinux	EXPORT_SYMBOL
+0x9cb480f4	dynamic_debug_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x5b19634d	div_s64_rem	vmlinux	EXPORT_SYMBOL
+0xa81fb3d2	vfs_dq_quota_on_remount	vmlinux	EXPORT_SYMBOL
+0x4de6252e	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0xd7d79132	put_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x9bc95323	svc_xprt_copy_addrs	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf44711af	__nf_ct_kill_acct	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x40b53009	usbnet_unlink_rx_urbs	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xdfc5169b	slhc_init	drivers/net/slhc	EXPORT_SYMBOL
+0x334e56e8	saa7146_register_extension	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0xc02ef2c8	pcmcia_parse_tuple	vmlinux	EXPORT_SYMBOL
+0x2aeb2800	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0xb88bd64f	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x6cada202	ieee802154_nl_disassoc_indic	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x4997ea4e	usb_stor_transparent_scsi_command	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x7f0d1969	iscsi_verify_itt	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xa5637eb2	dm_get_rq_mapinfo	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x3074f033	drm_order	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x5e81e4fa	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0xd167af8c	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x09107155	pci_write_vpd	vmlinux	EXPORT_SYMBOL
+0xc43a3940	snd_mpu401_uart_interrupt	sound/drivers/mpu401/snd-mpu401-uart	EXPORT_SYMBOL
+0xf0caf44b	zlib_deflate_workspacesize	lib/zlib_deflate/zlib_deflate	EXPORT_SYMBOL
+0x9421a6a6	tosh_smm	drivers/char/toshiba	EXPORT_SYMBOL
+0x0d0770c3	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0xe0bc24a1	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x607b34f1	edd	vmlinux	EXPORT_SYMBOL
+0x4fac3208	snd_timer_notify	sound/core/snd-timer	EXPORT_SYMBOL
+0x09c80acf	svc_recv	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc3e5750f	bt_sock_recvmsg	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x24e9a363	l64781_attach	drivers/media/dvb/frontends/l64781	EXPORT_SYMBOL
+0xc847eebf	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0xc8995cd1	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0xd38e6637	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x8f59a835	bitmap_unplug	vmlinux	EXPORT_SYMBOL
+0x86fb9b05	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x4292364c	schedule	vmlinux	EXPORT_SYMBOL
+0x342f60fe	apm_info	vmlinux	EXPORT_SYMBOL
+0x7ec99bbe	snd_emux_free	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0xe4f1e5a3	iwl_rx_pm_sleep_notif	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x69d3bc9c	i2400m_netdev_setup	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x9bf84f95	dvb_usb_nec_rc_key_to_event	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0x6d6511e7	ir_dump_samples	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xf36498b9	ib_ud_header_unpack	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xc21f0b4e	drm_get_connector_name	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xbff7da01	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x5b1e0342	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x02d0e1d3	init_task	vmlinux	EXPORT_SYMBOL
+0xf2ddf275	oxygen_write_ac97_masked	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xcb8d5e0e	snd_emu10k1_memblk_map	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0xfd57f013	snd_rawmidi_transmit_peek	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x616d6d25	__fscache_wait_on_page_write	fs/fscache/fscache	EXPORT_SYMBOL
+0x74de659c	video_devdata	drivers/media/video/videodev	EXPORT_SYMBOL
+0x2036ba99	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x131e5f0a	usbatm_usb_disconnect	drivers/usb/atm/usbatm	EXPORT_SYMBOL_GPL
+0x3f152296	unregister_sja1000dev	drivers/net/can/sja1000/sja1000	EXPORT_SYMBOL_GPL
+0xc8a671b0	enclosure_component_register	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0xf52ca720	videobuf_queue_core_init	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x36a98a6c	i2c_verify_client	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x89d66811	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0xd991a455	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x48544fa2	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x36e2fd84	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x92719b0d	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x1da28aa8	pm_runtime_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0xe49a0619	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL
+0x1b015d25	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x8f80bf65	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x53fa33f4	revert_creds	vmlinux	EXPORT_SYMBOL
+0xdf929370	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x4ad3f518	snd_midi_event_reset_decode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0x4348f8ec	fb_ddc_read	drivers/video/fb_ddc	EXPORT_SYMBOL_GPL
+0x3290e959	iwl_fill_probe_req	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xb753b3a6	edac_mc_del_mc	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xa5a24ac2	md_do_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x28a33167	scsi_dh_set_params	vmlinux	EXPORT_SYMBOL_GPL
+0x4f2b339b	agp_generic_type_to_mask_type	vmlinux	EXPORT_SYMBOL
+0x8fcbc0c6	bio_clone	vmlinux	EXPORT_SYMBOL
+0xf0fdf6cb	__stack_chk_fail	vmlinux	EXPORT_SYMBOL
+0x3da171f9	pci_mem_start	vmlinux	EXPORT_SYMBOL
+0xcd2fd09d	snd_card_proc_new	sound/core/snd	EXPORT_SYMBOL
+0x644be003	hdlc_close	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0xd5aa3aa8	wm831x_reg_lock	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x2cc459b5	ir_codes_flydvb_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x1df1ff83	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x7d75328c	fbcon_set_rotate	vmlinux	EXPORT_SYMBOL
+0xe0406b5a	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x594bf15b	ioport_map	vmlinux	EXPORT_SYMBOL
+0x6a9ff81f	lbtf_cmd_response_rx	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x171c4c87	free_ieee80211	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xc0fbd4f3	ppp_unregister_channel	drivers/net/ppp_generic	EXPORT_SYMBOL
+0xb90ad84a	mptscsih_shutdown	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x68e56d01	saa7134_ts_register	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x19cb88bc	sp887x_attach	drivers/media/dvb/frontends/sp887x	EXPORT_SYMBOL
+0xe7949e59	dvb_ringbuffer_flush_spinlock_wakeup	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x696304da	xfrm_audit_state_add	vmlinux	EXPORT_SYMBOL_GPL
+0xf18202f7	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x5b83a85e	ata_pci_device_do_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x3c6c75b0	regulator_register	vmlinux	EXPORT_SYMBOL_GPL
+0xb5a459dc	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x25397340	key_alloc	vmlinux	EXPORT_SYMBOL
+0x21c75502	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x4bbc3e5f	pm_flags	vmlinux	EXPORT_SYMBOL
+0xd0b3e243	fat_search_long	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x09f3c921	wa_urb_enqueue_run	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0x10957388	osd_req_flush_collection	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x40849bb2	reset_airo_card	drivers/net/wireless/airo	EXPORT_SYMBOL
+0xb317686b	destroy_cis_cache	vmlinux	EXPORT_SYMBOL
+0x761188fd	dpm_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x62ddcc1c	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0xf2997713	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0xcdd18528	seq_path	vmlinux	EXPORT_SYMBOL
+0xcc5005fe	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0xd1f6c5f3	smp_num_siblings	vmlinux	EXPORT_SYMBOL
+0xf8b2ff6e	g_verify_token_header	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x68a0b514	iscsi_session_setup	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xd1893245	cx231xx_uninit_vbi_isoc	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x65414e67	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x9ca9fe3f	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x3be89d3c	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x0b3e9036	agp_create_memory	vmlinux	EXPORT_SYMBOL
+0xa68124fa	hweight8	vmlinux	EXPORT_SYMBOL
+0xc897c382	sg_init_table	vmlinux	EXPORT_SYMBOL
+0xf7623914	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x9beb42ec	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
+0x9e04b087	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x8ba4000d	default_unplug_io_fn	vmlinux	EXPORT_SYMBOL
+0xc87c1f84	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x37cb1b62	genphy_update_link	vmlinux	EXPORT_SYMBOL
+0xda38766f	ata_sff_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x818aba84	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x2408217b	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x46134f5c	register_sound_special_device	sound/soundcore	EXPORT_SYMBOL
+0x8b609563	snd_hda_mixer_amp_switch_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xd4087dcd	ath_rxbuf_alloc	drivers/net/wireless/ath/ath	EXPORT_SYMBOL
+0xde05025b	agp_generic_create_gatt_table	vmlinux	EXPORT_SYMBOL
+0x01bc94e2	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0xd61730c2	__fscache_unregister_netfs	fs/fscache/fscache	EXPORT_SYMBOL
+0x607dcb6e	uwb_rsv_accept	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xad410812	lbtf_rx	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x3423aab4	s5h1420_attach	drivers/media/dvb/frontends/s5h1420	EXPORT_SYMBOL
+0xc3ff5dff	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
+0x2eed2630	iommu_domain_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x40a8850c	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0xad096363	xenbus_printf	vmlinux	EXPORT_SYMBOL_GPL
+0xb7b61546	crc32_be	vmlinux	EXPORT_SYMBOL
+0x636a5691	acpi_register_ioapic	vmlinux	EXPORT_SYMBOL
+0x3dbcb222	rpc_restart_call	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x1c057c31	ieee80211_register_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0x4f3a820f	wlp_receive_frame	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x911912cf	wm8400_register_regulator	drivers/regulator/wm8400-regulator	EXPORT_SYMBOL_GPL
+0x6573d0d7	wm8350_register_regulator	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0x811a74e6	i2c_unregister_device	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0x22cd0d6c	drm_helper_crtc_in_use	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xd63d4f4b	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x16885eed	skb_find_text	vmlinux	EXPORT_SYMBOL
+0xaf3f6fe0	ata_sff_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0xc37226a5	tpm_pcr_extend	vmlinux	EXPORT_SYMBOL_GPL
+0x46834388	regulator_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x9a4ac47a	pci_clear_master	vmlinux	EXPORT_SYMBOL
+0x6ea06d44	bio_integrity_add_page	vmlinux	EXPORT_SYMBOL
+0x7ee91c1d	_spin_trylock	vmlinux	EXPORT_SYMBOL
+0xf375ba4c	current_fs_time	vmlinux	EXPORT_SYMBOL
+0xed3adf08	iwl_send_cmd_pdu	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2facc551	dvb_ca_en50221_frda_irq	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xd6430d26	tcf_hash_create	vmlinux	EXPORT_SYMBOL
+0x1c379418	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x873889fb	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x07147e39	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x952664c5	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0xe89f55d3	mmc_host_lazy_disable	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x07f4f2ce	hisax_unregister	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x3ec1d14e	tcf_hash_destroy	vmlinux	EXPORT_SYMBOL
+0x8214d465	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0xaa8c4696	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0xf4ce93ae	snd_cs8427_iec958_active	sound/i2c/snd-cs8427	EXPORT_SYMBOL
+0x7d37caad	tda10086_attach	drivers/media/dvb/frontends/tda10086	EXPORT_SYMBOL
+0x78fe258f	dvb_usb_generic_write	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0xebaf48e0	usbhid_submit_report	vmlinux	EXPORT_SYMBOL_GPL
+0xe6d804b2	dma_wait_for_async_tx	vmlinux	EXPORT_SYMBOL_GPL
+0xcfe8ceac	ata_sff_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x6075ed71	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x758c8a41	backlight_device_register	vmlinux	EXPORT_SYMBOL
+0x7f2fa165	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0xb1c3a01a	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x434fa55c	release_console_sem	vmlinux	EXPORT_SYMBOL
+0x49fe31fc	snd_emux_unlock_voice	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0x9788f4ab	skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0xfceffa0b	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0xe5baefcb	tty_throttle	vmlinux	EXPORT_SYMBOL
+0xa9e62cdb	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x22dec7f3	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x479e8813	elevator_init	vmlinux	EXPORT_SYMBOL
+0x2c827467	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x744c0c68	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x8ff4079b	pv_irq_ops	vmlinux	EXPORT_SYMBOL
+0xabda1e2e	decode_rs16	lib/reed_solomon/reed_solomon	EXPORT_SYMBOL_GPL
+0xdf6e4f08	wusb_dev_destroy	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x0b8ef590	raid6_2data_recov	drivers/md/raid6_pq	EXPORT_SYMBOL_GPL
+0x05e092e5	b1_send_message	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x4e792275	gigaset_dbg_buffer	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xe3b17cc0	drm_fb_helper_setcmap	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x0519accd	drm_put_dev	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xdc9a3dc1	drm_gem_vm_open	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x8864992e	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0xa0da1793	pcmcia_validate_mem	vmlinux	EXPORT_SYMBOL
+0xbfe8c6ca	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0xbc1f5ed2	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
+0xe31ea0df	i1480_cmd	drivers/uwb/i1480/dfu/i1480-dfu-usb	EXPORT_SYMBOL_GPL
+0x92307025	iwlcore_eeprom_query_addr	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x52134e3a	mlx4_map_phys_fmr	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x993208bc	ib_unregister_mad_agent	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xade8294e	drm_core_ioremap	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x38ee2cb0	regulator_list_voltage	vmlinux	EXPORT_SYMBOL_GPL
+0xd34f0c62	gen_pool_create	vmlinux	EXPORT_SYMBOL
+0xa5603420	scsi_is_fc_rport	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xc9d4d6d1	wmi_has_guid	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0x61684cdf	ttpci_budget_debiread	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0x6c8d5ae8	__gpio_get_value	vmlinux	EXPORT_SYMBOL_GPL
+0x432fd7f6	__gpio_set_value	vmlinux	EXPORT_SYMBOL_GPL
+0x14af0cf7	gen_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x3a5cd3ea	close_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0xc4776204	vma_kernel_pagesize	vmlinux	EXPORT_SYMBOL_GPL
+0x77cfcfde	__tracepoint_kmalloc_node	vmlinux	EXPORT_SYMBOL
+0xd62c833f	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x41ef1203	tifm_eject	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x0ddaacce	cx88_set_freq	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0x717c936d	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x65ccb6f0	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x181f8e8d	scsi_add_host	vmlinux	EXPORT_SYMBOL
+0x6547a582	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0xc9f3ce00	aio_put_req	vmlinux	EXPORT_SYMBOL
+0xb8bddf33	ip6t_ext_hdr	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL
+0xe8842591	mmc_wait_for_app_cmd	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xf0203067	rdma_notify	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x8e0b7743	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0xae13a604	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0xcb390d51	ata_pci_device_do_resume	vmlinux	EXPORT_SYMBOL_GPL
+0xcefcd99a	serial8250_unregister_port	vmlinux	EXPORT_SYMBOL
+0x0d2f209b	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x8029fd37	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0xc57f5b54	snd_sb16dsp_interrupt	sound/isa/sb/snd-sb16-dsp	EXPORT_SYMBOL
+0xf2e2d102	snd_ctl_rename_id	sound/core/snd	EXPORT_SYMBOL
+0x884fb93a	rt2x00lib_txdone	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x5a45366d	usbnet_get_link	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x99b789d0	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x8c8a4bab	ata_pci_sff_init_host	vmlinux	EXPORT_SYMBOL_GPL
+0x93c651be	acpi_info	vmlinux	EXPORT_SYMBOL
+0xd7d2e83e	acpi_evaluate_object_typed	vmlinux	EXPORT_SYMBOL
+0x70488c5e	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0xbb185e33	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0xcdfccc51	snd_hda_parse_pin_def_config	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xbff48e83	fat_alloc_new_dir	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x5085b944	cx88_get_control	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0x6606596a	ir_rc5_timer_keyup	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x7b05c696	b1ctl_read_proc	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x66666d70	ttm_global_item_ref	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x08e354fc	pskb_copy	vmlinux	EXPORT_SYMBOL
+0x215ce851	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0xce0e3259	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x23269a13	strict_strtoul	vmlinux	EXPORT_SYMBOL
+0x285ac517	strict_strtoll	vmlinux	EXPORT_SYMBOL
+0xf455fc35	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x74deb10c	used_vectors	vmlinux	EXPORT_SYMBOL_GPL
+0x36decee2	snd_sbmixer_new	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0x4726fa0e	wusbhc_rh_control	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x7668d5b9	ata_sff_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x2a42d848	sys_imageblit	vmlinux	EXPORT_SYMBOL
+0x56f494e0	smp_call_function	vmlinux	EXPORT_SYMBOL
+0xef6c3f70	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0xe2c2b5eb	cx2341x_ctrl_query	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0x48bd7c86	dibusb_dib3000mc_tuner_attach	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xe94b8c9c	dst_check_sum	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0xca7d4a2f	i2c_smbus_read_byte_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x93464a30	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x8e32d4c0	ps2_command	vmlinux	EXPORT_SYMBOL
+0x633ed0c0	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0xca5dbc50	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x471e4894	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x6c0fa5ff	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x100c48a2	unregister_dock_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x51cae183	pci_find_capability	vmlinux	EXPORT_SYMBOL
+0xc19c8163	atomic64_cmpxchg	vmlinux	EXPORT_SYMBOL
+0xb678366f	int_sqrt	vmlinux	EXPORT_SYMBOL
+0xe39b6c7f	dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x0799aca4	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x7b36d490	snd_pcm_suspend	sound/core/snd-pcm	EXPORT_SYMBOL
+0xf38bcdf3	nf_conntrack_max	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x391b8954	llc_mac_hdr_init	net/llc/llc	EXPORT_SYMBOL
+0x549cbf72	journal_dirty_metadata	fs/jbd/jbd	EXPORT_SYMBOL
+0x4f2462e0	config_item_get	fs/configfs/configfs	EXPORT_SYMBOL
+0x5b0b94b6	config_item_put	fs/configfs/configfs	EXPORT_SYMBOL
+0x4e5bac04	srp_rport_del	drivers/scsi/scsi_transport_srp	EXPORT_SYMBOL_GPL
+0x9e86e8e0	iwl_bg_abort_scan	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3062c2cf	iwl_setup_rxon_timing	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xacdeb154	__tracepoint_module_get	vmlinux	EXPORT_SYMBOL
+0x1eb9516e	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0xaf2b5464	fc_linkup	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xe4350361	rt2x00queue_get_entry	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x59409768	video_unregister_device	drivers/media/video/videodev	EXPORT_SYMBOL
+0x9eb43ee2	v4l2_ctrl_check	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x6c06e1c2	dib7000p_get_i2c_master	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x3625bf5a	dib7000m_get_i2c_master	drivers/media/dvb/frontends/dib7000m	EXPORT_SYMBOL
+0x86a48801	rdc_reset_state	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x66524fad	ttm_bo_device_release	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xd5b84b7f	drm_helper_probe_connector_modes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x29501527	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0xd461d847	xenbus_watch_path	vmlinux	EXPORT_SYMBOL_GPL
+0x85d732fb	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0xbbc21578	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x91c4cef4	simple_fsync	vmlinux	EXPORT_SYMBOL
+0xf5799f7a	stop_machine_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x494a2648	use_module	vmlinux	EXPORT_SYMBOL_GPL
+0x26157069	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x40759dcf	rds_connect_complete	net/rds/rds	EXPORT_SYMBOL_GPL
+0x69772293	uwb_phy_rate_show	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x33488340	saa7134_pgtable_alloc	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x94651dab	ir_codes_ati_tv_wonder_hd_600_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xe7c35aa6	drm_mm_pre_get	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9652a91e	nf_register_hook	vmlinux	EXPORT_SYMBOL
+0x5612d577	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x3b7c52c2	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x5ad1b278	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x9b4de8eb	idr_replace	vmlinux	EXPORT_SYMBOL
+0x82acfb70	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x530b1e98	pm_suspend	vmlinux	EXPORT_SYMBOL
+0xd9d2bb03	snd_usbmidi_disconnect	sound/usb/snd-usb-lib	EXPORT_SYMBOL
+0xe386af0b	snd_timer_continue	sound/core/snd-timer	EXPORT_SYMBOL
+0x4daa5e34	ib_resize_cq	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x71746222	register_netdev	vmlinux	EXPORT_SYMBOL
+0xa351d87f	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x94393b38	snd_sb16dsp_configure	sound/isa/sb/snd-sb16-dsp	EXPORT_SYMBOL
+0x72d09c69	iscsi_create_endpoint	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x02670b00	t3_l2t_get	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xffae58da	dvb_dmx_swfilter_204	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xfce17b22	b1dma_send_message	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x9b947eda	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x37db8f19	dmi_get_date	vmlinux	EXPORT_SYMBOL
+0x9e9f1714	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x35da2e61	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x85ac7f10	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL
+0x9603ed12	config_item_init	fs/configfs/configfs	EXPORT_SYMBOL
+0xb008d517	mlx4_srq_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xae8e926a	mISDNipac_init	drivers/isdn/hardware/mISDN/mISDNipac	EXPORT_SYMBOL
+0xf21ee780	i2c_transfer	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xd05c1d77	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0xad56b229	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0xff964b25	param_set_int	vmlinux	EXPORT_SYMBOL
+0x21db9a6f	snd_card_file_add	sound/core/snd	EXPORT_SYMBOL
+0xd29cf74c	xdr_inline_pages	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x155650f3	cx2341x_ctrl_get_menu	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0x0be05737	ttpci_eeprom_parse_mac	drivers/media/dvb/ttpci/ttpci-eeprom	EXPORT_SYMBOL
+0x9ce3f83f	nvram_write_byte	vmlinux	EXPORT_SYMBOL
+0x2bd43d13	dynamic_debug_enabled2	vmlinux	EXPORT_SYMBOL_GPL
+0xab32304e	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x7370a15a	snd_hda_get_hint	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xdfaef21c	snd_pcm_lib_mmap_iomem	sound/core/snd-pcm	EXPORT_SYMBOL
+0xc482499d	snd_midi_event_new	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0xfc22de74	mptbase_sas_persist_operation	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xf38f933b	ata_cable_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x4333eadb	param_set_short	vmlinux	EXPORT_SYMBOL
+0x29c02ae4	snd_hda_multi_out_analog_cleanup	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x681c6458	snd_wss_info_single	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x7971033c	nf_nat_tftp_hook	net/netfilter/nf_conntrack_tftp	EXPORT_SYMBOL_GPL
+0x038b1c29	get_h225_addr	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xe919dd5c	drm_sman_owner_clean	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xb4fb2b75	skb_pad	vmlinux	EXPORT_SYMBOL
+0xe23bd6a7	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0xe69ff06c	seq_write	vmlinux	EXPORT_SYMBOL
+0xceea8851	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x8863747c	snd_info_create_module_entry	sound/core/snd	EXPORT_SYMBOL
+0x36e5fbaf	fc_cpu_mask	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xdd365790	ei_interrupt	drivers/net/8390	EXPORT_SYMBOL
+0x94b589a2	mpt_config	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x543db4ff	ir_codes_avermedia_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xfdc77d6d	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x2dd30814	pcmcia_disable_device	vmlinux	EXPORT_SYMBOL
+0x999e8297	vfree	vmlinux	EXPORT_SYMBOL
+0x5d8a22d8	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0xfd3fcd0f	mutex_lock	vmlinux	EXPORT_SYMBOL
+0x6ef787ed	ib_response_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xf2ad9809	dma_async_memcpy_pg_to_pg	vmlinux	EXPORT_SYMBOL
+0xccab486f	ata_acpi_cbl_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x52aa0e21	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x2545c170	unregister_xenbus_watch	vmlinux	EXPORT_SYMBOL_GPL
+0xb1cfad22	rdmsr_on_cpu	vmlinux	EXPORT_SYMBOL
+0x7f4c5059	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x3aba4b0b	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0xb782a7d7	exportfs_decode_fh	fs/exportfs/exportfs	EXPORT_SYMBOL_GPL
+0xa95ee425	alloc_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x4f810863	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x72b591ee	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x953d6511	hvc_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0xf065f629	ioread16be	vmlinux	EXPORT_SYMBOL
+0xf5f19034	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x40d9623b	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x573a0c16	xprt_release_rqst_cong	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x00c52ef5	g_make_token_header	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x863273e3	smscore_unregister_client	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x5070f2e9	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x01dd4b9e	consume_skb	vmlinux	EXPORT_SYMBOL
+0x52ba1746	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x956078c0	pci_match_id	vmlinux	EXPORT_SYMBOL
+0x72e03bae	stop_machine_create	vmlinux	EXPORT_SYMBOL_GPL
+0x01a1fa16	snd_hda_mixer_bind_tlv	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x0a17158a	snd_opl3_hwdep_new	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0x145e7205	rpc_alloc_iostats	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x46328a4b	rt2x00lib_suspend	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x6a848442	input_allocate_polled_device	drivers/input/input-polldev	EXPORT_SYMBOL
+0x8fdd8de9	i2c_add_numbered_adapter	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0x3c18e601	tcf_action_dump_1	vmlinux	EXPORT_SYMBOL
+0xec6c19c9	ethtool_op_get_tso	vmlinux	EXPORT_SYMBOL
+0xc68b2769	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x8b1a7a66	pcie_aspm_enabled	vmlinux	EXPORT_SYMBOL
+0x5a010e51	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x0419aa47	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0xfc822e6e	kmem_cache_alloc_notrace	vmlinux	EXPORT_SYMBOL
+0xbab7e5ed	p9_client_open	net/9p/9pnet	EXPORT_SYMBOL
+0x2444d838	fuse_direct_io	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0xa0bbbdee	vring_transport_features	drivers/virtio/virtio_ring	EXPORT_SYMBOL_GPL
+0x0c4d4a14	dvb_frontend_sleep_until	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xb1a312e1	ib_unpack	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xe5f45fd6	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x44b1bccf	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xbff64c33	textsearch_prepare	vmlinux	EXPORT_SYMBOL
+0xd2a68761	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x74c5da68	sas_port_alloc	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xf3a79359	or51211_attach	drivers/media/dvb/frontends/or51211	EXPORT_SYMBOL
+0x47727675	async_memcpy	crypto/async_tx/async_memcpy	EXPORT_SYMBOL_GPL
+0xda3863ca	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x8c16bbd3	pci_iounmap	vmlinux	EXPORT_SYMBOL
+0x2ae0b32e	blk_queue_max_phys_segments	vmlinux	EXPORT_SYMBOL
+0x313e62c4	simple_getattr	vmlinux	EXPORT_SYMBOL
+0xa56f1315	mempool_free	vmlinux	EXPORT_SYMBOL
+0x9ccdb6d4	llc_sap_open	net/llc/llc	EXPORT_SYMBOL
+0x6a23717f	journal_init_inode	fs/jbd/jbd	EXPORT_SYMBOL
+0x3ce05f30	configfs_register_subsystem	fs/configfs/configfs	EXPORT_SYMBOL
+0xeef5d93e	usb_stor_Bulk_reset	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x847a0553	rt2x00lib_beacondone	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x8ddefaae	cx88_sram_channel_setup	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x7707a963	drm_vblank_put	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xfc9b1b54	tcf_em_tree_validate	vmlinux	EXPORT_SYMBOL
+0x156b7a8a	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x52dbf790	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xd2348369	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0xb382636d	bdget_disk	vmlinux	EXPORT_SYMBOL
+0xe79377c5	nlmsvc_unlock_all_by_sb	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x1a618932	nlmsvc_unlock_all_by_ip	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0xf79e0a70	sas_phy_enable	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x1bfeefde	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x14a5d2c5	ethtool_op_get_tx_csum	vmlinux	EXPORT_SYMBOL
+0x1aca8e9d	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x972b3567	agp_alloc_bridge	vmlinux	EXPORT_SYMBOL
+0x42224298	sscanf	vmlinux	EXPORT_SYMBOL
+0x3a02a214	__breadahead	vmlinux	EXPORT_SYMBOL
+0xc23ba1d7	snd_cs4236_ext_in	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x1f647904	snd_pcm_hw_constraint_integer	sound/core/snd-pcm	EXPORT_SYMBOL
+0xa39fdf79	rpc_bind_new_program	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x30123eb5	icmpv6_statistics	net/ipv6/ipv6	EXPORT_SYMBOL
+0xc77bc801	journal_stop	fs/jbd/jbd	EXPORT_SYMBOL
+0x41b16c3c	iwl_alloc_isr_ict	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x563f3080	led_classdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x48193639	acpi_lid_open	vmlinux	EXPORT_SYMBOL
+0xfe64ce00	inotify_add_watch	vmlinux	EXPORT_SYMBOL_GPL
+0xd0af441e	trace_define_common_fields	vmlinux	EXPORT_SYMBOL_GPL
+0x1cefe352	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0xeaa84857	csum_partial_copy_to_xdr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xb941a067	wlp_wss_activate_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x11b1ff9b	i2c_smbus_write_byte_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x0fabaccf	tcp_v4_md5_do_del	vmlinux	EXPORT_SYMBOL
+0x2c20c037	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x03ea1c94	agp_add_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0xcb6beb40	hweight32	vmlinux	EXPORT_SYMBOL
+0xe8cd902e	hweight16	vmlinux	EXPORT_SYMBOL
+0x486b6407	hweight64	vmlinux	EXPORT_SYMBOL
+0x30a4f4ca	bstr_printf	vmlinux	EXPORT_SYMBOL_GPL
+0x404c76c7	__create_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x08c02e67	snd_dma_alloc_pages	sound/core/snd-page-alloc	EXPORT_SYMBOL
+0xf9e11262	hostap_remove_proc	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xdc9bd500	sja1000_interrupt	drivers/net/can/sja1000/sja1000	EXPORT_SYMBOL_GPL
+0x07bed052	otg_get_transceiver	vmlinux	EXPORT_SYMBOL
+0x5acf7369	otg_set_transceiver	vmlinux	EXPORT_SYMBOL
+0x6565d33f	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x194e4688	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0xefef0909	register_kprobes	vmlinux	EXPORT_SYMBOL_GPL
+0x49db8db4	register_jprobes	vmlinux	EXPORT_SYMBOL_GPL
+0x2431a142	rpcauth_init_cred	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5e972192	put_rpccred	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe0160e54	edac_mc_handle_ce_no_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x26618ad4	xfrm_audit_state_replay_overflow	vmlinux	EXPORT_SYMBOL_GPL
+0x1fcece42	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x05034aa5	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0xe0e17b50	ata_std_qc_defer	vmlinux	EXPORT_SYMBOL_GPL
+0xb3c42c94	per_cpu__x86_bios_cpu_apicid	vmlinux	EXPORT_SYMBOL
+0xd5ac6527	snd_seq_event_port_attach	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xf5d4e6c7	rt2x00usb_vendor_req_buff_lock	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x328ce31c	mlx4_register_mac	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xdc4396ae	tifm_free_device	drivers/misc/tifm_core	EXPORT_SYMBOL
+0xa2bd0f83	cdrom_release	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xd6aa638f	cpufreq_unregister_governor	vmlinux	EXPORT_SYMBOL_GPL
+0x32fa6576	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x172e72d4	vdso_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0xc1a881a0	ieee802154_nl_assoc_confirm	net/ieee802154/nl802154	EXPORT_SYMBOL
+0x72c87670	uwb_rc_alloc	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x0255b299	fw_core_handle_response	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x2382989a	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x49ffb19c	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0xc2abbb8d	ata_pci_sff_init_one	vmlinux	EXPORT_SYMBOL_GPL
+0x2abb10ce	pnp_start_dev	vmlinux	EXPORT_SYMBOL
+0x7169fb64	security_inode_init_security	vmlinux	EXPORT_SYMBOL
+0xd705b4c7	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0xa615fbc6	oxygen_pci_resume	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xc79a8ac6	parport_wait_event	drivers/parport/parport	EXPORT_SYMBOL
+0x91ac1af2	iwl_power_update_mode	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x252082bc	drm_unbind_agp	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x18af7a50	drm_get_resource_len	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xc62771af	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x292093f4	native_rdmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0xfd6f4850	native_wrmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0xde6a006f	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x1d23fc21	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x3b07a97e	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0xcfb9006e	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0xd12ac59b	olpc_ec_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x04157461	arch_acpi_processor_init_pdc	vmlinux	EXPORT_SYMBOL
+0xd18b6eb2	acpi_unmap_lsapic	vmlinux	EXPORT_SYMBOL
+0x39e10bd8	snd_rawmidi_kernel_write	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x42cb66af	wimax_dev_rm	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x96877ac4	locks_start_grace	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0x320a4b9b	ftdi_elan_gone_away	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0xb7744421	gspca_disconnect	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x18b5804d	fw_core_initiate_bus_reset	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x3bf38dd2	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x68735aa5	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x58d5c14c	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x2c839c41	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0xc4b33aa6	tracepoint_probe_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xfb0cf2e9	touch_all_softlockup_watchdogs	vmlinux	EXPORT_SYMBOL
+0x9cf83b89	snd_ac97_pcm_double_rate_rules	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xd87c1541	svc_create_xprt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0cb4b189	tuners	drivers/media/common/tuners/tuner-types	EXPORT_SYMBOL
+0x86003a4e	intelfb_probe	drivers/gpu/drm/i915/i915	EXPORT_SYMBOL
+0x212db8d2	pcmcia_socket_list	vmlinux	EXPORT_SYMBOL
+0xfee8fd6b	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x6dcadb28	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0xbefb7980	tty_devnum	vmlinux	EXPORT_SYMBOL
+0xa92b8f0a	inotify_rm_wd	vmlinux	EXPORT_SYMBOL_GPL
+0x65e79714	uwb_rc_ie_rm	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xc1b14790	ib_post_send_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xfeac1d1b	pcmcia_read_cis_mem	vmlinux	EXPORT_SYMBOL
+0x35b0de8c	tpm_release	vmlinux	EXPORT_SYMBOL_GPL
+0xa58b6804	nla_parse	vmlinux	EXPORT_SYMBOL
+0xb6730393	ring_buffer_entries_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xb6bffb99	kstat_irqs_cpu	vmlinux	EXPORT_SYMBOL
+0x30f49f2e	llc_sap_find	net/llc/llc	EXPORT_SYMBOL
+0xc62654c5	umc_device_create	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0xf3d619ec	ir_codes_iodata_bctv7e_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xff271a29	input_free_device	vmlinux	EXPORT_SYMBOL
+0xf85f55b6	ata_bmdma_mode_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x06410dda	ata_host_init	vmlinux	EXPORT_SYMBOL_GPL
+0xec266b06	regulator_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x113a7f68	xprt_set_retrans_timeout_rtt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xdd20b1e7	pppox_unbind_sock	drivers/net/pppox	EXPORT_SYMBOL
+0x6aa30df3	tifm_unmap_sg	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x67630bf8	async_trigger_callback	crypto/async_tx/async_tx	EXPORT_SYMBOL_GPL
+0x7d11c268	jiffies	vmlinux	EXPORT_SYMBOL
+0xd559778f	osd_req_remove_object	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xdd4c0a07	ir_codes_evga_indtube_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x8e73a993	avmcard_dma_alloc	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x7ea9f05f	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0xbdfbb715	do_map_probe	vmlinux	EXPORT_SYMBOL
+0xf34895c6	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x2bb6fde2	__kfifo_put	vmlinux	EXPORT_SYMBOL
+0xb4ca9447	__kfifo_get	vmlinux	EXPORT_SYMBOL
+0x3efb35c9	get_online_cpus	vmlinux	EXPORT_SYMBOL_GPL
+0x4f5438c1	idle_halt	vmlinux	EXPORT_SYMBOL
+0x374c1e1c	fcoe_wwn_from_mac	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL_GPL
+0x0ad7083b	parport_find_base	drivers/parport/parport	EXPORT_SYMBOL
+0x025d1e3b	ivtv_api	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x22dadbbe	gigaset_if_receive	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x7a932a6e	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x39734458	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0xb272fd2a	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x07d9b576	fscache_wait_bit_interruptible	fs/fscache/fscache	EXPORT_SYMBOL
+0x0cdabbb4	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x62264222	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x33fde5f1	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x9f2bdaac	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x69c8c1d5	security_req_classify_flow	vmlinux	EXPORT_SYMBOL
+0x7465ea81	get_dcookie	vmlinux	EXPORT_SYMBOL_GPL
+0xe824f247	snd_ak4114_reg_write	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0x8411708d	__fscache_alloc_page	fs/fscache/fscache	EXPORT_SYMBOL
+0x8851ebba	osd_req_flush_object	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x3c107198	drm_agp_chipset_flush	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x14878009	amd_report_gart_errors	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x5dd67618	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x0727c4f3	iowrite8	vmlinux	EXPORT_SYMBOL
+0xd0d8621b	strlen	vmlinux	EXPORT_SYMBOL
+0xc7ec6c27	strspn	vmlinux	EXPORT_SYMBOL
+0x41a9c68d	_spin_trylock_bh	vmlinux	EXPORT_SYMBOL
+0x39954391	snd_hda_ch_mode_put	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x89ef5b22	rfkill_destroy	net/rfkill/rfkill	EXPORT_SYMBOL
+0xf5994609	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0xedbaee5e	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0xebd273a6	strict_strtoull	vmlinux	EXPORT_SYMBOL
+0x7b4e7334	crypto_ahash_type	vmlinux	EXPORT_SYMBOL_GPL
+0xd7ce0aaf	snd_ac97_mixer	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x078f6d5a	dccp_hashinfo	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xe7ee77d6	parport_announce_port	drivers/parport/parport	EXPORT_SYMBOL
+0xed279626	dibusb_streaming_ctrl	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0x92d23142	skb_trim	vmlinux	EXPORT_SYMBOL
+0x4097fa45	acpi_read_bit_register	vmlinux	EXPORT_SYMBOL
+0x19b70ac1	perf_tp_event	vmlinux	EXPORT_SYMBOL_GPL
+0x9fb8e3de	boot_cpu_data	vmlinux	EXPORT_SYMBOL
+0x6bb71038	snd_seq_delete_kernel_client	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x6bb71dc3	svc_proc_register	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x0652b6ab	rt2x00lib_resume	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x90adc43c	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x1b18dac9	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x4f432b51	per_cpu__xt_info_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x4d4959f8	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL
+0xc207a6ab	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
+0x4e3567f7	match_int	vmlinux	EXPORT_SYMBOL
+0xdd6bfccd	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0xd268c18f	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0xf7796bde	shash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x09144253	sysctl_string	vmlinux	EXPORT_SYMBOL
+0x395f5eca	snd_pcm_kernel_ioctl	sound/core/snd-pcm	EXPORT_SYMBOL
+0xbffd6921	rpcauth_generic_bind_cred	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5481c56b	iwl_rx_queue_update_write_ptr	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x4534d014	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x04d8c750	release_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0xe08cb051	snd_card_free_when_closed	sound/core/snd	EXPORT_SYMBOL
+0x1879fcbd	bridge_tunnel_header	net/wireless/cfg80211	EXPORT_SYMBOL
+0x052b7b4c	p9_client_auth	net/9p/9pnet	EXPORT_SYMBOL
+0x61d039d7	ir_codes_behold_columbus_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xeb82a41a	rdma_connect	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x2df8f555	i2c_get_adapter	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x253c30e2	ata_sff_host_intr	vmlinux	EXPORT_SYMBOL_GPL
+0x868acba5	get_options	vmlinux	EXPORT_SYMBOL
+0xb3b482ef	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0xfb6e3c2a	xdr_partial_copy_from_skb	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xdee68c53	hci_connect	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xf2182c03	iwl_send_cmd	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xa9b3a82a	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0xd31f9d5b	agp_generic_alloc_by_type	vmlinux	EXPORT_SYMBOL
+0x30706dd2	xenbus_map_ring	vmlinux	EXPORT_SYMBOL_GPL
+0x97a2ef45	acpi_get_pci_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x39ce9332	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x3f516716	fat_fill_super	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x90dd71a4	rt2x00usb_disconnect	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x9056cbdd	usbnet_get_settings	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x1df66c25	usbnet_set_settings	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x51dce73b	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0xe04ea188	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x714a3741	pci_remove_behind_bridge	vmlinux	EXPORT_SYMBOL
+0x3c9d1211	string_get_size	vmlinux	EXPORT_SYMBOL
+0x9343787e	dquot_initialize	vmlinux	EXPORT_SYMBOL
+0xfc41a360	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0xfed5fa8a	snd_pt2258_build_controls	sound/i2c/other/snd-pt2258	EXPORT_SYMBOL
+0xfb09982a	snd_pci_quirk_lookup	sound/core/snd	EXPORT_SYMBOL
+0x81df94d4	fl6_sock_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x977d5442	fddi_change_mtu	vmlinux	EXPORT_SYMBOL
+0x42225bdd	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL
+0x9c491f60	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0xda1be8e1	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x5e9ef7e0	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x4c172b36	snd_ak4114_create	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0x704858d8	snd_info_free_entry	sound/core/snd	EXPORT_SYMBOL
+0x0ed4a575	uwb_dev_try_get	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x05319ea4	fc_set_mfs	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x6a6acbc6	fc_disc_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x8ed1beaa	tifm_register_driver	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x9a188595	cb710_pci_update_config_reg	drivers/misc/cb710/cb710	EXPORT_SYMBOL_GPL
+0xfda878c5	sms_get_board	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x3e383385	nf_hooks	vmlinux	EXPORT_SYMBOL
+0x386cf2fb	pcmcia_dev_present	vmlinux	EXPORT_SYMBOL
+0xce1ac9f0	pci_release_region	vmlinux	EXPORT_SYMBOL
+0xd7474566	__copy_to_user_ll	vmlinux	EXPORT_SYMBOL
+0xae0c87ee	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x20a66ab0	snd_hda_codec_write_cache	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x496932b9	fscache_op_debug_id	fs/fscache/fscache	EXPORT_SYMBOL
+0x87d47ba3	fc_elsct_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x8ecfc5f7	drm_release	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe4f4665b	ipmi_validate_addr	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x54e84fb8	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xff1e9dd8	seq_list_start	vmlinux	EXPORT_SYMBOL
+0xa2a1e5c9	_write_lock_bh	vmlinux	EXPORT_SYMBOL
+0x4f96f230	snd_pcm_set_ops	sound/core/snd-pcm	EXPORT_SYMBOL
+0x3f5b1415	nf_ct_port_nlattr_to_tuple	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x26d86779	register_ip_vs_scheduler	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xcc8f2b27	cx8802_get_driver	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0xa1eabd87	drm_mode_list_concat	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x6f546720	drm_mm_get_block_generic	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe0cca33e	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x7460c126	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x416a5765	dma_run_dependencies	vmlinux	EXPORT_SYMBOL_GPL
+0x38bdc6fc	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x8317e20a	completion_done	vmlinux	EXPORT_SYMBOL
+0x88abec1d	osd_req_decode_get_attr_list	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x93d1e541	mlx4_alloc_cmd_mailbox	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x5a66a81d	mptscsih_dev_reset	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xd80474bb	mpt_detach	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x98627c6b	drm_connector_cleanup	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x27c61ece	qdisc_put_stab	vmlinux	EXPORT_SYMBOL
+0x258355b4	fb_find_best_mode	vmlinux	EXPORT_SYMBOL
+0x85d3e500	inotify_init	vmlinux	EXPORT_SYMBOL_GPL
+0x3292cc34	seq_printf	vmlinux	EXPORT_SYMBOL
+0x899069c3	mmc_free_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xc04cbf2d	wm8350_register_irq	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x059658d9	mptscsih_raid_id_to_num	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xb5276ec5	ivtv_clear_irq_mask	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x7936a6ef	drm_mode_validate_size	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x51b83cd3	pci_dev_driver	vmlinux	EXPORT_SYMBOL
+0x0b742fd7	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x2e97859f	rwsem_downgrade_wake	vmlinux	EXPORT_SYMBOL
+0x25174321	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x01848a8e	local_apic_timer_c2_ok	vmlinux	EXPORT_SYMBOL_GPL
+0x74506e60	fuse_dev_operations	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x6c54ce38	unregister_hdlc_protocol	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x4bd3a4f0	isac_irq	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0x2fdbf694	ib_send_cm_lap	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xe206b96e	drm_mm_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xac6855b0	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x02aff2f4	acpi_install_gpe_handler	vmlinux	EXPORT_SYMBOL
+0xdef5bf5c	fbcon_set_tileops	vmlinux	EXPORT_SYMBOL
+0xa6511bc8	pci_set_power_state	vmlinux	EXPORT_SYMBOL
+0x7231d740	rdmsr_on_cpus	vmlinux	EXPORT_SYMBOL
+0x4a93eb51	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x7dcc454e	dquot_alloc	vmlinux	EXPORT_SYMBOL
+0x9fe3b1fa	unlock_super	vmlinux	EXPORT_SYMBOL
+0xde70ab64	snd_i2c_sendbytes	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0x2b4f8746	iwl_add_station	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xf57fc01c	dibusb_pid_filter_ctrl	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xba65607f	attach_capi_ctr	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xb047a2c6	fw_csr_iterator_init	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x796fc5ce	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0xb3e0590d	acpi_set_current_resources	vmlinux	EXPORT_SYMBOL
+0xcd155cd9	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL
+0xc9beb3a1	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x326df9e1	vfs_stat	vmlinux	EXPORT_SYMBOL
+0xa0fbac79	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x5203a25e	snd_pcm_lib_malloc_pages	sound/core/snd-pcm	EXPORT_SYMBOL
+0x10a0d26e	nf_conntrack_flush_report	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x48034724	zlib_deflateReset	lib/zlib_deflate/zlib_deflate	EXPORT_SYMBOL
+0x460bd571	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0xd41e1464	__hvc_resize	vmlinux	EXPORT_SYMBOL_GPL
+0xbc8c14ee	cap_netlink_recv	vmlinux	EXPORT_SYMBOL
+0xcdca3691	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x896bb40d	jbd2_journal_set_triggers	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xa78bd894	iTCO_vendor_pre_set_heartbeat	drivers/watchdog/iTCO_vendor_support	EXPORT_SYMBOL
+0x7b0f879b	ib_cancel_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xa75079d6	dcdbas_smi_request	drivers/firmware/dcdbas	EXPORT_SYMBOL
+0x56c8799d	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x3ac01ac1	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0xde9b17ed	agp3_generic_fetch_size	vmlinux	EXPORT_SYMBOL
+0x59a9e7a7	wait_for_key_construction	vmlinux	EXPORT_SYMBOL
+0x3b4e659a	open_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0x958a8270	f_setown	vmlinux	EXPORT_SYMBOL
+0x05e807a9	xdr_encode_string	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x93b1b392	fc_linkdown	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xaa52157a	eip_start_xmit	drivers/net/8390p	EXPORT_SYMBOL
+0x42801d20	ubi_sync	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x3deb1673	dvb_generic_release	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xe55c31c6	edac_device_free_ctl_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xe37132fd	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0xce4904a4	acpi_leave_sleep_state	vmlinux	EXPORT_SYMBOL
+0x6d27ef64	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x1420a9dc	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x1d8f8059	__tracepoint_power_end	vmlinux	EXPORT_SYMBOL_GPL
+0x8103ea0b	submit_bh	vmlinux	EXPORT_SYMBOL
+0xf421f4ca	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0xb97a770f	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x405c1144	get_seconds	vmlinux	EXPORT_SYMBOL
+0xd18a8662	unregister_8022_client	net/802/p8022	EXPORT_SYMBOL
+0x491365ed	lbtf_cmd_copyback	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0x6b570953	hostap_set_word	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x91482eef	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x27bcb7fb	sys_fillrect	vmlinux	EXPORT_SYMBOL
+0xf0f1246c	kvasprintf	vmlinux	EXPORT_SYMBOL
+0xa6dcc773	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x2296d39a	svcauth_unix_set_client	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6c27feaf	drm_helper_probe_single_connector_modes	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x683cbb71	hid_dump_field	vmlinux	EXPORT_SYMBOL_GPL
+0x55aa8b34	ata_sff_dma_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x8b752ac1	ata_tf_to_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x66d87d38	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
+0xae07a307	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0xf04ea915	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x657349c3	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x13088a9f	llc_set_station_handler	net/llc/llc	EXPORT_SYMBOL
+0x72acd7d2	ib_create_qp	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x3ed96214	i2c_smbus_read_word_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xddfbbf29	tcf_hash_search	vmlinux	EXPORT_SYMBOL
+0x6ba47f93	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0xe6a7d924	xenbus_switch_state	vmlinux	EXPORT_SYMBOL_GPL
+0x6de28cba	d_alloc	vmlinux	EXPORT_SYMBOL
+0x042a3954	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x939c3b53	journal_extend	fs/jbd/jbd	EXPORT_SYMBOL
+0x96c0c18f	fc_host_post_event	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0x8649c1a2	iwl_leds_register	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5757bad6	b1_load_t4file	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0xb1918fb2	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x07f95cc4	ring_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0x0fa9d325	wiphy_unregister	net/wireless/cfg80211	EXPORT_SYMBOL
+0x915022de	fscache_object_lookup_negative	fs/fscache/fscache	EXPORT_SYMBOL
+0xed879e34	dvb_ca_en50221_camchange_irq	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xfa06820f	isdn_register_divert	drivers/isdn/i4l/isdn	EXPORT_SYMBOL
+0x7becf9f2	drm_gem_object_handle_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0ce5d506	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x9525bcf7	security_inode_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0xa95157c5	ir_codes_cinergy_1400_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x665cdea5	edac_pci_release_generic_ctl	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xd4d06f13	ipmi_destroy_user	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x83a6f4db	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x3679aa00	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x5ef5a7e2	pci_choose_state	vmlinux	EXPORT_SYMBOL
+0xb3205415	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0xa51cdfe8	__FIXADDR_TOP	vmlinux	EXPORT_SYMBOL
+0x696a2021	cfg80211_send_assoc_timeout	net/wireless/cfg80211	EXPORT_SYMBOL
+0xe7a2620e	save_vga	drivers/video/vgastate	EXPORT_SYMBOL
+0x8224ece8	__wa_destroy	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0x726bb9a2	iscsi_complete_scsi_task	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xf7365d60	fc_seq_exch_abort	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xcf8b77a4	cx2341x_mpeg_ctrls	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0x6138e837	ttpci_budget_init_hooks	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0x7da99cdd	clear_user	vmlinux	EXPORT_SYMBOL
+0x50c89f23	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x3f4a1ef9	memstick_next_req	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xa8f27711	dm_device_name	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x429129f2	mISDN_FsmRestartTimer	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x9f823278	register_capi_driver	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x7248d1f9	rdma_leave_multicast	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0xd4b881e3	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xa3887f16	ata_eh_qc_retry	vmlinux	EXPORT_SYMBOL_GPL
+0x4b4506dd	tpm_get_timeouts	vmlinux	EXPORT_SYMBOL_GPL
+0x6b487486	clear_inode	vmlinux	EXPORT_SYMBOL
+0xa018ae58	cfg80211_wext_siwessid	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x4122fb58	cfg80211_wext_giwessid	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x2411dfb5	svc_close_xprt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6465af21	__mlx4_cmd	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x9d9fb6d0	mmc_card_awake	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x17545b16	smscore_onresponse	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x046e30d8	ir_input_keydown	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x76a879e8	free_dca_provider	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0xe681b664	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0xb5ededad	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL
+0xdc342372	dmam_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0xbb648772	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x572e85d4	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x0a26b5d7	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x77a108df	_write_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x4c6ae4af	snd_trident_start_voice	sound/pci/trident/snd-trident	EXPORT_SYMBOL
+0x32a714cc	snd_sbdsp_reset	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0xce3ca308	copy_from_user_toio	sound/core/snd	EXPORT_SYMBOL
+0xe969d01e	usb_stor_bulk_srb	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x3429ea62	iscsi_suspend_queue	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xfb2d206c	dm_kcopyd_copy	drivers/md/dm-mod	EXPORT_SYMBOL
+0x864c65a1	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0xafe845e8	iommu_attach_device	vmlinux	EXPORT_SYMBOL_GPL
+0xbae9dbfd	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x9722fb71	oxygen_read_ac97	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xe6a16116	pps_event	drivers/pps/pps_core	EXPORT_SYMBOL
+0x9bd08718	mlx4_fmr_unmap	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xf3eb8b8c	i2c_smbus_read_block_data	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x690077b5	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
+0xd26f24dd	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x3bb78130	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x3e1f073d	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x8aa0e4d9	snd_hda_check_board_config	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x0c3a7756	snd_cs8427_iec958_build	sound/i2c/snd-cs8427	EXPORT_SYMBOL
+0x8623aea8	__nf_conntrack_helper_find_byname	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xe371cfb1	xfrm6_input_addr	net/ipv6/ipv6	EXPORT_SYMBOL
+0x8aa294cb	usb_stor_probe1	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x1b297e8e	usb_stor_probe2	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x7575598b	mlx4_cq_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x43e43105	tda8083_attach	drivers/media/dvb/frontends/tda8083	EXPORT_SYMBOL
+0xe47d2deb	update_region	vmlinux	EXPORT_SYMBOL
+0x0ebb1127	acpi_processor_unregister_performance	vmlinux	EXPORT_SYMBOL
+0x661601de	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0xd5f8822e	hci_get_route	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x8ff69c9b	mmc_card_can_sleep	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x8883b6b0	tifm_remove_adapter	drivers/misc/tifm_core	EXPORT_SYMBOL
+0x9b6cb936	cx88_set_tvaudio	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xfd48bade	capi20_release	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x4ccb87ed	tcf_em_unregister	vmlinux	EXPORT_SYMBOL
+0xf3702ef1	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x208d7a49	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0xcdaac192	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x82692209	kref_set	vmlinux	EXPORT_SYMBOL
+0x2ce98559	kcrypto_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x3e95df88	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x07ce7344	trace_seq_vprintf	vmlinux	EXPORT_SYMBOL_GPL
+0x53524196	ac97_bus_type	sound/ac97_bus	EXPORT_SYMBOL
+0xa32d00a9	rt2x00usb_regbusy_read	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xbecd2858	v4l2_prio_init	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x59ca3224	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x609f1c7e	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x5c4bfa13	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x0c3e5f80	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x287091d1	vfs_quota_enable	vmlinux	EXPORT_SYMBOL
+0xe523ad75	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0xa64a4cea	usb_nop_xceiv_unregister	drivers/usb/otg/nop-usb-xceiv	EXPORT_SYMBOL
+0x2ac3d309	parport_negotiate	drivers/parport/parport	EXPORT_SYMBOL
+0xe186afef	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x9e7d6bd0	__udelay	vmlinux	EXPORT_SYMBOL
+0xdf8c695a	__ndelay	vmlinux	EXPORT_SYMBOL
+0x2ba05e78	snd_timer_close	sound/core/snd-timer	EXPORT_SYMBOL
+0x1211df5d	saa7134_devlist	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x303f4b62	drm_mode_create_scaling_mode_property	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x25e1f1b7	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x2dd8444c	trace_seq_printf	vmlinux	EXPORT_SYMBOL_GPL
+0xd8a2ab95	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x5114ef02	v4l2_i2c_new_subdev_cfg	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0x7ec0b981	mISDNisar_init	drivers/isdn/hardware/mISDN/mISDNisar	EXPORT_SYMBOL
+0xcfa75d55	mISDNisac_init	drivers/isdn/hardware/mISDN/mISDNipac	EXPORT_SYMBOL
+0xf0910869	edac_mc_handle_ue_no_info	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x409873e3	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x07a890c8	fb_alloc_cmap	vmlinux	EXPORT_SYMBOL
+0xea2d33a2	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x825551bd	lib80211_crypt_quiescing	net/wireless/lib80211	EXPORT_SYMBOL
+0x5500d667	dccp_check_req	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x85d11b56	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0xb703911e	release_firmware	vmlinux	EXPORT_SYMBOL
+0x8c183cbe	iowrite16	vmlinux	EXPORT_SYMBOL
+0x436c2179	iowrite32	vmlinux	EXPORT_SYMBOL
+0xb0aa812e	fips_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x37befc70	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x7f24de73	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0xb6896671	crc_t10dif	lib/crc-t10dif	EXPORT_SYMBOL
+0x7b691474	iwl_reset_run_time_calib	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5df1c853	drm_detect_hdmi_monitor	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x76a05c7d	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0xeccc1dc4	pcmcia_socket_class	vmlinux	EXPORT_SYMBOL
+0x41344088	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x90690228	uwb_rc_get_by_dev	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x24c2669c	cxgb3_ofld_send	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xc4878d48	mdiobus_write	vmlinux	EXPORT_SYMBOL
+0x64005581	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL
+0xe303daaa	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x39fdb20f	iomap_atomic_prot_pfn	vmlinux	EXPORT_SYMBOL_GPL
+0x6e1bce14	atm_dev_deregister	net/atm/atm	EXPORT_SYMBOL
+0x1fc83e80	ab3100_get_chip_type	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x4ccfd5f9	soc_camera_host_register	drivers/media/video/soc_camera	EXPORT_SYMBOL
+0x0ecb2e5d	cfag12864b_disable	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0x22095aed	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x6d6cbadc	rb_last	vmlinux	EXPORT_SYMBOL
+0x8d703a15	inotify_rm_watch	vmlinux	EXPORT_SYMBOL_GPL
+0xe6fbe430	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x60a13e90	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0xdf60cc27	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x0ce81735	snd_hda_attach_beep_device	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x568b3cc2	snd_hda_detach_beep_device	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x41207c89	ndisc_mc_map	net/ipv6/ipv6	EXPORT_SYMBOL
+0xe30e11f4	wm8350_mask_irq	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xd9ee1e3f	v4l2_ctrl_query_menu	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x5a11a2d6	soc_camera_host_unregister	drivers/media/video/soc_camera	EXPORT_SYMBOL
+0xa58a4fe4	b1_load_firmware	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x72577047	acpi_smbus_read	drivers/acpi/sbshc	EXPORT_SYMBOL_GPL
+0xf2f329db	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x19d5d20a	acpi_walk_namespace	vmlinux	EXPORT_SYMBOL
+0x27728071	pci_enable_msi_block	vmlinux	EXPORT_SYMBOL
+0x3c2c5af5	sprintf	vmlinux	EXPORT_SYMBOL
+0xe9a6be71	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x9cb9f0ba	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x09c2aad2	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0xfa87d505	wimax_state_change	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0xdf05f8d4	uwb_rc_pre_reset	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x0b31388f	sas_eh_bus_reset_handler	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x3c9aa0e5	mmc_host_disable	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x43aac27c	mptscsih_io_done	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xc91bb9d3	rdma_addr_register_client	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0xf6ebc03b	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x1ebf6c2a	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL
+0x379d65f5	gen_pool_alloc	vmlinux	EXPORT_SYMBOL
+0xe227ad7f	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL
+0xaed013b9	posix_acl_valid	vmlinux	EXPORT_SYMBOL
+0xaf12413c	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x4b2b0266	journal_dirty_data	fs/jbd/jbd	EXPORT_SYMBOL
+0xd93c0f40	raid_class_release	drivers/scsi/raid_class	EXPORT_SYMBOL
+0xc5dc66af	iwl_setup_mac	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x225d2876	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0xfd05fddf	scsi_register	vmlinux	EXPORT_SYMBOL
+0x9aafc4f9	regulator_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xaa366828	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x4200839d	find_vma	vmlinux	EXPORT_SYMBOL
+0x5a58643a	svc_print_addr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3a462d81	nf_ct_extend_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xcccbddc4	sas_request_addr	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xa02a927a	can_get_echo_skb	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x5ba93f9d	raid6_gfinv	drivers/md/raid6_pq	EXPORT_SYMBOL
+0xad67228e	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x8c38074a	unregister_xenstore_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x5779d445	xenbus_exists	vmlinux	EXPORT_SYMBOL_GPL
+0xfd7d7713	acpi_exception	vmlinux	EXPORT_SYMBOL
+0x901d6b8f	dquot_destroy	vmlinux	EXPORT_SYMBOL
+0xcf97e1f4	inotify_dentry_parent_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0xd34fe6bb	dma_ops	vmlinux	EXPORT_SYMBOL
+0x5676be3e	fcoe_ctlr_recv_flogi	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0xc302235a	nxt200x_attach	drivers/media/dvb/frontends/nxt200x	EXPORT_SYMBOL
+0x317fa9f3	fw_run_transaction	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x71658821	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x1378e714	acpi_video_display_switch_support	vmlinux	EXPORT_SYMBOL
+0xa05c03df	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0xdc873a70	screen_info	vmlinux	EXPORT_SYMBOL
+0xc458e40f	gigaset_initdriver	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x43d5335e	qdisc_warn_nonwc	vmlinux	EXPORT_SYMBOL
+0x9c15507c	ata_eh_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0xa3d58cb6	pci_release_regions	vmlinux	EXPORT_SYMBOL
+0xbe531272	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0xfc6256b9	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x52eedbaa	snd_util_mem_free	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x4ea10c15	nlmclnt_done	fs/lockd/lockd	EXPORT_SYMBOL_GPL
+0xf4e7277b	mpt_device_driver_register	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xb5b3e710	videobuf_reqbufs	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xb77a61d4	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x41f49183	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x925c5e96	relay_subbufs_consumed	vmlinux	EXPORT_SYMBOL_GPL
+0x0d26a76d	_write_lock_irq	vmlinux	EXPORT_SYMBOL
+0xc0bf6ead	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL
+0x3aed8319	ieee80211_wake_queue	net/mac80211/mac80211	EXPORT_SYMBOL
+0x58487bc7	journal_ack_err	fs/jbd/jbd	EXPORT_SYMBOL
+0x0bda63ae	fc_seq_els_rsp_send	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x148f0c99	FsmFree	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0xc5c45494	ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x7cb1ae69	cpu_down	vmlinux	EXPORT_SYMBOL
+0x29be531f	snd_hda_create_spdif_share_sw	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x81fbbd75	inet6_csk_addr2sockaddr	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x4dab9335	libipw_wx_get_scan	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xcf4588e3	gspca_suspend	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x1878f62b	edac_err_assert	vmlinux	EXPORT_SYMBOL_GPL
+0x17f37bf1	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x317e93af	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0xe4c1df3e	_read_lock_bh	vmlinux	EXPORT_SYMBOL
+0x601b9eb9	iwl_tx_ant_restriction	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2a367efe	iwl_eeprom_check_version	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xd330627a	register_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x1b3f4dc0	drm_connector_property_set_value	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x534504a6	drm_connector_property_get_value	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xb0223109	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x415316d1	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x0fd95c71	xt_unregister_targets	vmlinux	EXPORT_SYMBOL
+0xaf9e8be3	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0xbfd94bb0	bind_virq_to_irqhandler	vmlinux	EXPORT_SYMBOL_GPL
+0x8e90499c	acpi_ec_remove_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x20000329	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x06483c29	uwb_rsv_terminate	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x9c045021	mraid_mm_register_adp	drivers/scsi/megaraid/megaraid_mm	EXPORT_SYMBOL
+0x61e10250	tda826x_attach	drivers/media/dvb/frontends/tda826x	EXPORT_SYMBOL
+0x618f7b03	ib_send_cm_dreq	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x36f6ab80	ib_send_cm_drep	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x4fcdc1f4	drm_addmap	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x1c2027ef	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0xc6164b3a	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x0b7c0785	get_sb_pseudo	vmlinux	EXPORT_SYMBOL
+0x4eaf2a5b	dump_trace	vmlinux	EXPORT_SYMBOL
+0x96719c0a	ssb_dma_set_mask	drivers/ssb/ssb	EXPORT_SYMBOL
+0xfa8c79c7	osd_dev_fini	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x30b55c38	parport_ieee1284_ecp_write_data	drivers/parport/parport	EXPORT_SYMBOL
+0xeb0b0aac	parport_ieee1284_epp_write_data	drivers/parport/parport	EXPORT_SYMBOL
+0xa12ae87b	videobuf_qbuf	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x2099679d	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xc66e33c8	dbgp_reset_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x4d4e542c	usb_hcd_pci_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x2ff85b31	blk_integrity_compare	vmlinux	EXPORT_SYMBOL
+0xefc2eedf	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x9c170d1e	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0xd985dc99	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0xfcec0987	enable_irq	vmlinux	EXPORT_SYMBOL
+0x1e7bbcb3	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x9c7077bd	enable_hlt	vmlinux	EXPORT_SYMBOL
+0xbb8ee629	iscsi_set_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x00092f0b	bt878_device_control	drivers/media/dvb/bt8xx/bt878	EXPORT_SYMBOL
+0x0ecbac44	b1_getrevision	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x91a4645a	ib_modify_mad	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x48ec2cc6	ib_query_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x909bcd50	pcmcia_register_socket	vmlinux	EXPORT_SYMBOL
+0x1ba36808	agp_unbind_memory	vmlinux	EXPORT_SYMBOL
+0x4edb808d	snd_vx_free_firmware	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0x2cd4b98e	__ieee80211_get_rx_led_name	net/mac80211/mac80211	EXPORT_SYMBOL
+0x2fb69b94	wlp_prepare_tx_frame	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x9cd0c6b9	raid_class_attach	drivers/scsi/raid_class	EXPORT_SYMBOL
+0xec642dcb	fc_rport_terminate_io	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xd304ee34	orinoco_up	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x4950b563	drm_mode_create	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x09d8caf7	fw_core_add_address_handler	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x46b5a483	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0xc3fa6a59	memchr	vmlinux	EXPORT_SYMBOL
+0xecde1418	_spin_lock_irq	vmlinux	EXPORT_SYMBOL
+0xc18ac88d	nf_ct_expect_hsize	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xdcf769e7	inet6_release	net/ipv6/ipv6	EXPORT_SYMBOL
+0x84bb9905	drm_mode_destroy	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xf092048f	fw_iso_context_destroy	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x6d2a20fb	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x352b7c66	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x31446401	ring_buffer_record_enable_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xedf3f1f1	do_machine_check	vmlinux	EXPORT_SYMBOL_GPL
+0x315c65fd	zlib_deflateInit2	lib/zlib_deflate/zlib_deflate	EXPORT_SYMBOL
+0x7cf39fe3	iwl_remove_dynamic_key	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xc013cdcc	iwl_init_channel_map	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x9a0058ba	dib7000pc_detection	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x8a4b6e4e	b1dma_register_appl	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x006d08fb	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x602ed00d	acpi_current_gpe_count	vmlinux	EXPORT_SYMBOL
+0x450b247a	submit_bio	vmlinux	EXPORT_SYMBOL
+0x13f8c41f	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0xfbf9be5d	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x549525ef	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0xcfc68341	synchronize_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x832456ce	mmc_remove_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x9a4f3575	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0xcec36555	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x873a1909	ata_sff_post_internal_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x93459875	ata_host_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x9be9f1ef	uwb_dev_for_each	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x0c17edb1	osd_sec_init_nosec_doall_caps	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x9a9e8ed4	mpt_HardResetHandler	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x974d22ae	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x639a749e	cache_purge	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x8a721ed9	rdma_addr_unregister_client	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0xe740a4dc	simple_map_init	vmlinux	EXPORT_SYMBOL
+0x222e7ce2	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0xca159458	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0xcedab7be	inode_setattr	vmlinux	EXPORT_SYMBOL
+0xf5357727	xdr_write_pages	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x210d3c35	usbnet_get_endpoints	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xc0c558f9	FsmRestartTimer	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x9b0df133	tcp4_gro_complete	vmlinux	EXPORT_SYMBOL
+0x10f2619e	ip_route_input	vmlinux	EXPORT_SYMBOL
+0xcebbbfb6	iscsi_conn_teardown	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x0b86a311	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x4b9065a9	nf_ct_alloc_hashtable	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xb25a5e02	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x192cac0d	tcp_md5_hash_skb_data	vmlinux	EXPORT_SYMBOL
+0x18f83fab	gnttab_grant_foreign_access_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x24eb0476	aio_complete	vmlinux	EXPORT_SYMBOL
+0x91766c09	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x851831ab	kill_pid	vmlinux	EXPORT_SYMBOL
+0x4722c30e	rt6_lookup	net/ipv6/ipv6	EXPORT_SYMBOL
+0xb5ca1c46	slhc_free	drivers/net/slhc	EXPORT_SYMBOL
+0x268f3d80	memstick_add_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x1fe757c8	saa7134_g_ctrl_internal	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL_GPL
+0xbc63a556	saa7134_s_ctrl_internal	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL_GPL
+0xabf55587	drm_gem_mmap	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x41166725	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x64999478	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x87f438a2	sysctl_intvec	vmlinux	EXPORT_SYMBOL
+0x3a85478e	dccp_v4_connect	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0xbc8631c9	hci_recv_fragment	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xdc7ec919	config_item_set_name	fs/configfs/configfs	EXPORT_SYMBOL
+0x30ac7c58	i2c_del_driver	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xf9f7414e	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0xd3318a24	blk_remove_plug	vmlinux	EXPORT_SYMBOL
+0xf5d57a6e	dquot_release	vmlinux	EXPORT_SYMBOL
+0xdabbf5c5	ring_buffer_read_page	vmlinux	EXPORT_SYMBOL_GPL
+0x880b189a	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0xe8abe42d	ieee80211_beacon_loss	net/mac80211/mac80211	EXPORT_SYMBOL
+0xde47c522	sas_slave_configure	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x555b3dcc	__dma_request_channel	vmlinux	EXPORT_SYMBOL_GPL
+0x057ce975	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0xaf9c4d76	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0xaaad0072	osd_req_list_partition_objects	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x66b13324	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x13605a38	snd_rawmidi_kernel_release	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x27384cef	sas_change_queue_type	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x9d804fa1	mult_to_ib_rate	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x940e4c80	i2c_clients_command	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xee8b7655	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0xa4a16f5b	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0xb7ace677	slow_work_register_user	vmlinux	EXPORT_SYMBOL
+0x3841ab01	unregister_kprobe	vmlinux	EXPORT_SYMBOL_GPL
+0xe658e9bd	hostap_init_ap_proc	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x97ecca51	mptscsih_ioc_reset	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x644cb7c2	videobuf_dma_init	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0xd5145151	mISDN_FsmEvent	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xe19a11ac	capi20_get_profile	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x9f85ed90	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x015af204	ethtool_op_get_ufo	vmlinux	EXPORT_SYMBOL
+0x20a7a828	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x0920df59	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
+0xfa0564fc	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0xb3253ed9	hpet_rtc_timer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x17d0219e	svc_auth_register	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x1d05d60d	wusbhc_rh_suspend	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x6ed0b7e4	qt1010_attach	drivers/media/common/tuners/qt1010	EXPORT_SYMBOL
+0x520b2638	ib_pack	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x3d68bd4b	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0xf1d64416	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x12a01ff9	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0xab2df85a	agp_backend_release	vmlinux	EXPORT_SYMBOL
+0xf9e4f13d	pci_set_master	vmlinux	EXPORT_SYMBOL
+0xc886e006	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x42bf95c8	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0xf1aaa835	snd_hda_multi_out_dig_prepare	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xe6dd54ad	wlp_dev_name_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x09604047	alloc_orinocodev	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0xb126d6c9	mmc_set_data_timeout	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0xf5ef842e	v4l_bound_align_image	drivers/media/video/v4l2-common	EXPORT_SYMBOL_GPL
+0xa4336cb0	flexcop_pass_dmx_data	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xcc30001d	iw_cm_accept	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x5bcc4272	intelfb_remove	drivers/gpu/drm/i915/i915	EXPORT_SYMBOL
+0x8610af2d	hid_connect	vmlinux	EXPORT_SYMBOL_GPL
+0xbe9c54fd	dma_async_device_unregister	vmlinux	EXPORT_SYMBOL
+0x1f1d6200	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
+0x61929ea0	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x55a3598f	vc_cons	vmlinux	EXPORT_SYMBOL
+0x70ad3fc6	remove_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x13320d73	drm_add_edid_modes	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9a033581	ata_common_sdev_attrs	vmlinux	EXPORT_SYMBOL_GPL
+0x325e677c	gnttab_grant_foreign_transfer_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x70d1f8f3	strncat	vmlinux	EXPORT_SYMBOL
+0xdd0a2ba2	strlcat	vmlinux	EXPORT_SYMBOL
+0x97bc05e0	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0xd32e52c7	posix_acl_chmod_masq	vmlinux	EXPORT_SYMBOL
+0xd2965f6f	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0xffb83c50	snd_ac97_bus	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xef9b4bbd	nfnetlink_set_err	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x338eb142	wm831x_auxadc_read	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x95d73af2	ata_pci_device_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x416af40e	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x59f94c23	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0xac3e18f6	bt_sock_register	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xb89b0631	fat_scan	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x1aa67657	wusbhc_create	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xa34341e3	usb_serial_handle_break	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x57cbf908	iwl_isr_ict	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x859dfb88	mpt_raid_phys_disk_get_num_paths	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x22a73912	__tcp_put_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0xe6d32191	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x17ff2c1d	__nvram_read_byte	vmlinux	EXPORT_SYMBOL
+0x0811ba27	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0xdc4845d1	snd_hda_multi_out_dig_close	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xc116c868	snd_pcm_hw_constraint_minmax	sound/core/snd-pcm	EXPORT_SYMBOL
+0x8006c614	dca_unregister_notify	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0xe0e8158f	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x69d38ed9	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x4077910d	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x9df7af8b	snd_midi_event_free	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0xa42ff5b7	jbd2_journal_check_available_features	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x7f5457c6	usb_stor_Bulk_transport	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xb00b793c	i2400m_bm_cmd_prepare	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x275f2e53	drm_gem_object_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4774b86b	__tcf_em_tree_match	vmlinux	EXPORT_SYMBOL
+0x0fe2d570	xenbus_directory	vmlinux	EXPORT_SYMBOL_GPL
+0x4c44d843	pci_get_bus_and_slot	vmlinux	EXPORT_SYMBOL
+0x067d8d35	security_release_secctx	vmlinux	EXPORT_SYMBOL
+0x43d6e4db	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0xaab06af8	_write_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00c4dc87	timecounter_init	vmlinux	EXPORT_SYMBOL
+0xa13a69ec	snd_hda_codec_amp_read	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xbca02b65	llc_sap_close	net/llc/llc	EXPORT_SYMBOL
+0x8a2dbae4	garp_request_leave	net/802/garp	EXPORT_SYMBOL_GPL
+0x5fc48609	osduld_unregister_test	drivers/scsi/osd/osd	EXPORT_SYMBOL
+0xa825c75b	videobuf_sg_alloc	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x31b29ea5	flexcop_dma_control_timer_irq	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0xa3d5e3f7	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x8d852afc	mdiobus_unregister	vmlinux	EXPORT_SYMBOL
+0xa031d8e4	hermes_doicmd_wait	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x3d911a0f	mii_link_ok	drivers/net/mii	EXPORT_SYMBOL
+0xb4b70383	soc_camera_format_by_fourcc	drivers/media/video/soc_camera	EXPORT_SYMBOL
+0x55f060ee	drm_sman_set_range	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x520c50b6	phy_detach	vmlinux	EXPORT_SYMBOL
+0x6e58ddf0	gnttab_end_foreign_transfer_ref	vmlinux	EXPORT_SYMBOL_GPL
+0xabb6071e	cfg80211_inform_bss_frame	net/wireless/cfg80211	EXPORT_SYMBOL
+0xfb47f6ad	wimax_msg_data_len	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0xbd92b5f6	nf_conntrack_l4proto_udp6	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xadb2beac	fscache_fsdef_index	fs/fscache/fscache	EXPORT_SYMBOL
+0x21e36bf2	smscore_registry_getmode	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x1ac08f9c	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x31f4dd2c	stop_tty	vmlinux	EXPORT_SYMBOL
+0xe211e11f	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x59d2ca48	lookup_create	vmlinux	EXPORT_SYMBOL_GPL
+0xb4ee6314	get_sb_nodev	vmlinux	EXPORT_SYMBOL
+0xe60fe32f	kthread_create	vmlinux	EXPORT_SYMBOL
+0xf4f29efe	snd_wss_info_double	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xd161a401	wl1251_alloc_hw	drivers/net/wireless/wl12xx/wl1251	EXPORT_SYMBOL_GPL
+0xd49902fc	rt2x00mac_tx	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x2b20a20e	sdio_writel	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xc5397da6	xenbus_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0xce0f85fa	xenbus_watch_pathfmt	vmlinux	EXPORT_SYMBOL_GPL
+0x0d3dda14	acpi_get_type	vmlinux	EXPORT_SYMBOL
+0xd5645e78	jbd2_journal_stop	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xd4a03414	sdio_memcpy_toio	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x778edd87	wm8350_block_write	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xc8e4329e	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0xa0b8502f	__trace_note_message	vmlinux	EXPORT_SYMBOL_GPL
+0xc594e5c5	iounmap_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x6132130b	snd_pcm_hw_constraint_ratnums	sound/core/snd-pcm	EXPORT_SYMBOL
+0x88088907	hci_unregister_proto	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xf16f0134	cfi_fixup	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL
+0xed061606	capi20_manufacturer	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xb2dc4ba7	ipmi_get_my_LUN	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xbfdb1358	twofish_setkey	crypto/twofish_common	EXPORT_SYMBOL_GPL
+0xd50ff3fc	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x6c1ce5ce	strcspn	vmlinux	EXPORT_SYMBOL
+0xf93b7614	lib80211_crypt_deinit_entries	net/wireless/lib80211	EXPORT_SYMBOL
+0xc7dac464	jbd2_journal_extend	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xa031cb7b	iwl_mac_get_tx_stats	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x51e9d881	md_allow_write	vmlinux	EXPORT_SYMBOL_GPL
+0xcbfe42ce	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x5a8e49fd	ata_cable_ignore	vmlinux	EXPORT_SYMBOL_GPL
+0x13954f9c	pci_scan_bridge	vmlinux	EXPORT_SYMBOL
+0xce84a4ad	bio_integrity_clone	vmlinux	EXPORT_SYMBOL
+0x981d5842	do_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x08e5c845	nf_conntrack_l3proto_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x8a223f1b	nf_conntrack_l4proto_register	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x5f3ccc4d	usb_serial_resume	drivers/usb/serial/usbserial	EXPORT_SYMBOL
+0x01ff797c	cx88_set_tvnorm	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x0ddee60b	hid_parse_report	vmlinux	EXPORT_SYMBOL_GPL
+0x81740a45	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x8556702a	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0xaec655c7	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x29b62c99	nf_nat_sdp_media_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0xc24bc805	ieee80211_rx	net/mac80211/mac80211	EXPORT_SYMBOL
+0x3e702642	ieee80211_rx_irqsafe	net/mac80211/mac80211	EXPORT_SYMBOL
+0x6d2e5837	drm_ut_debug_printk	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xf255438d	drm_get_drawable_info	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x7ffaa02e	drm_rmmap	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe1090898	nsc_gpio_read	drivers/char/nsc_gpio	EXPORT_SYMBOL
+0x1fc150cb	ata_timing_compute	vmlinux	EXPORT_SYMBOL_GPL
+0xe49b67a9	register_sound_special	sound/soundcore	EXPORT_SYMBOL
+0x3b24c5b3	svc_find_xprt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6cd7880e	svc_process	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x01d9ca8c	rpc_force_rebind	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x957d26c3	gss_svc_to_pseudoflavor	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x2ec5c52f	dccp_rcv_established	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x1ba3eaa9	parport_unregister_device	drivers/parport/parport	EXPORT_SYMBOL
+0xed3a0bf8	iwlcore_init_geos	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x29da08b3	init_atmel_card	drivers/net/wireless/atmel	EXPORT_SYMBOL
+0x2a0e5733	usbnet_skb_return	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x927fefbc	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x29537c9e	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0xc9e262be	inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0xa01334dd	rpc_killall_tasks	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x89849298	nf_ct_iterate_cleanup	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xbc76c60e	lbs_suspend	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0xbe82fa07	deregister_mtd_blktrans	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL
+0xe228058a	mpt_clear_taskmgmt_in_progress_flag	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x74bbe84a	arp_find	vmlinux	EXPORT_SYMBOL
+0xb2718571	dev_getbyhwaddr	vmlinux	EXPORT_SYMBOL
+0x8fb5b997	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x5be51f21	tpm_show_caps	vmlinux	EXPORT_SYMBOL_GPL
+0xbabc6acf	pci_pme_capable	vmlinux	EXPORT_SYMBOL
+0xbdf5c25c	rb_next	vmlinux	EXPORT_SYMBOL
+0x25672241	inode_permission	vmlinux	EXPORT_SYMBOL
+0xc064fe58	buffer_migrate_page	vmlinux	EXPORT_SYMBOL
+0x9ccb2622	finish_wait	vmlinux	EXPORT_SYMBOL
+0x2c0c3474	svc_xprt_init	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x52d7b2fd	llc_sap_list	net/llc/llc	EXPORT_SYMBOL
+0x32dedb35	iwl_mac_add_interface	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x50d3a5a3	dvb_unregister_adapter	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x03b60a5e	saa7146_set_hps_source_and_sync	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0x78e4a4ee	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x4bbe9f28	alloc_etherdev_mq	vmlinux	EXPORT_SYMBOL
+0xdf786a1f	phy_start_aneg	vmlinux	EXPORT_SYMBOL
+0x58bdf443	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x4cbbd171	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x61b7b126	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x528c709d	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x6d5e5a4e	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL
+0x6b6c3d10	nf_defrag_ipv4_enable	net/ipv4/netfilter/nf_defrag_ipv4	EXPORT_SYMBOL_GPL
+0x7d0d1f6b	uwb_rts_cts_show	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x349ea5ad	osd_dev_init	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x9614471d	pccard_validate_cis	vmlinux	EXPORT_SYMBOL
+0x0677c7be	hypervisor_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x3147857d	default_red	vmlinux	EXPORT_SYMBOL
+0xa681fe88	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0xff9ca065	fb_edid_to_monspecs	vmlinux	EXPORT_SYMBOL
+0x9af3f6c1	nf_ct_free_hashtable	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x6ece6c94	t3_l2t_send_slow	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xfcf47849	mmc_power_save_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x4dad5c57	cx88_setup_xc3028	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL_GPL
+0xfb36f1ae	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x59bc9609	acpi_write_bit_register	vmlinux	EXPORT_SYMBOL
+0xae0d5b7b	fb_deferred_io_cleanup	vmlinux	EXPORT_SYMBOL_GPL
+0x55285fd9	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x13e35430	t3_l2e_free	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xd34b881b	or51132_attach	drivers/media/dvb/frontends/or51132	EXPORT_SYMBOL
+0x29415d29	saa7146_devices_lock	drivers/media/common/saa7146	EXPORT_SYMBOL_GPL
+0x56f4bf87	ieee80211_iterate_active_interfaces_atomic	net/mac80211/mac80211	EXPORT_SYMBOL_GPL
+0x4ab1d992	cfi_cmdset_0020	drivers/mtd/chips/cfi_cmdset_0020	EXPORT_SYMBOL_GPL
+0x2c5dca98	cfi_cmdset_0002	drivers/mtd/chips/cfi_cmdset_0002	EXPORT_SYMBOL_GPL
+0xfc72cfca	cfi_cmdset_0001	drivers/mtd/chips/cfi_cmdset_0001	EXPORT_SYMBOL_GPL
+0xd5683469	cfi_cmdset_0003	drivers/mtd/chips/cfi_cmdset_0001	EXPORT_SYMBOL_GPL
+0xaa02dc9f	cfi_cmdset_0200	drivers/mtd/chips/cfi_cmdset_0001	EXPORT_SYMBOL_GPL
+0x5134c7be	i2c_new_probed_device	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0x2b7127a7	drm_agp_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x2994293e	async_xor_val	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL
+0xd30f59cb	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x80f2c867	br_handle_frame_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x74b09985	__pci_complete_power_transition	vmlinux	EXPORT_SYMBOL_GPL
+0xf3064768	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x41ed4921	wusbhc_rh_resume	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x0b7d6fec	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0xea10212a	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x2e395a28	may_umount	vmlinux	EXPORT_SYMBOL
+0x7ae3c64f	iscsi_tcp_r2tpool_alloc	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x7c6f3b7b	ib_query_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x84086193	md_integrity_add_rdev	vmlinux	EXPORT_SYMBOL
+0x4fc56cce	iommu_detach_device	vmlinux	EXPORT_SYMBOL_GPL
+0xb2680eac	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL
+0x382bdb58	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x12021d49	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x38fc318a	per_cpu__injectm	vmlinux	EXPORT_SYMBOL_GPL
+0x75271716	save_processor_state	vmlinux	EXPORT_SYMBOL
+0x79c4ef3b	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0xca0fe1ff	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x1d1d41c0	ct_sip_get_header	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0x5a4dedc0	jbd2_journal_ack_err	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x9dac7af4	sas_port_delete	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x0ddb2e5c	i2400m_queue_work	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x2039d922	dvb_net_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x11b59b37	edac_pci_del_device	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x8be79085	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x6eac1ad1	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x1f92eba7	regulator_bulk_disable	vmlinux	EXPORT_SYMBOL_GPL
+0xd0c05159	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x3ff62317	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x62af40fd	snd_rawmidi_input_params	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x3d73a797	p9_errstr2errno	net/9p/9pnet	EXPORT_SYMBOL
+0x200e40c4	iwl_rx_reply_compressed_ba	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x9767efdc	cxgb3_remove_tid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xf2eb52f3	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x0c222ae4	md_error	vmlinux	EXPORT_SYMBOL
+0xf546e025	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x6036bc87	framebuffer_alloc	vmlinux	EXPORT_SYMBOL
+0x3b5c7058	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x697d979a	cfg80211_wext_siwencode	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x699cadcf	cfg80211_wext_giwencode	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x29a75128	rds_trans_register	net/rds/rds	EXPORT_SYMBOL_GPL
+0x86be7924	dccp_packet_name	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x1063aeb4	dm_region_hash_destroy	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xad80dcfe	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0xcc1f616a	cpufreq_driver_target	vmlinux	EXPORT_SYMBOL_GPL
+0x576effec	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL
+0x6fc54f06	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0xc7c2b60f	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x9a418b18	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0xd4c1dda0	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x076a0909	fc_seq_start_next	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x7119ff19	mlx4_mr_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x17f884ff	dm_rh_get_state	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x7060bf0a	crypto_aes_encrypt_x86	arch/x86/crypto/aes-i586	EXPORT_SYMBOL_GPL
+0x475100c2	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x2f65df70	strstrip	vmlinux	EXPORT_SYMBOL
+0xcae32dcf	seq_escape	vmlinux	EXPORT_SYMBOL
+0x1e946fea	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x9eaee215	snd_i2c_probeaddr	sound/i2c/snd-i2c	EXPORT_SYMBOL
+0x0c494a2c	usb_stor_resume	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x5374bf47	open_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x6539e237	ubi_open_volume	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x5a0a7bc9	gigaset_blockdriver	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0xb744fa43	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0xa38d6bb9	dev_get_by_flags	vmlinux	EXPORT_SYMBOL
+0xeac50dd2	d_alloc_root	vmlinux	EXPORT_SYMBOL
+0x3c92ef33	page_address	vmlinux	EXPORT_SYMBOL
+0x8a69af93	snd_hda_mixer_amp_volume_info	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x75b580e7	osd_req_create_partition	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xf1cf8b05	fc_exch_mgr_add	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x379e8203	fc_exch_mgr_del	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xffe148a5	iwl_cmd_queue_free	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xbc937c86	iwl_rx_replenish_now	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdd88acca	iwl_full_rxon_required	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3a7155bf	ath_reg_notifier_apply	drivers/net/wireless/ath/ath	EXPORT_SYMBOL
+0xd69ff8cd	mlx4_pd_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x005ec3eb	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x8cadf9f0	skb_over_panic	vmlinux	EXPORT_SYMBOL
+0x93df3f12	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x5c1f07e4	ata_sas_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x8d03c4c5	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x6892088c	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x26b09a0e	mb_cache_entry_free	fs/mbcache	EXPORT_SYMBOL
+0x1b5f2a69	iscsi_scan_finished	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xffba372f	ab3100_mask_and_set_register_interruptible	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x0a6f2481	dibx000_reset_i2c_master	drivers/media/dvb/frontends/dibx000_common	EXPORT_SYMBOL
+0xc5af5a9a	i2c_smbus_read_byte	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x81a3ee9a	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0xe295c0ff	is_hpet_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x6ec6349f	snd_sbdsp_create	sound/isa/sb/snd-sb-common	EXPORT_SYMBOL
+0xc5e9ab1b	svc_xprt_put	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x859dd4b4	ei_close	drivers/net/8390	EXPORT_SYMBOL
+0x5eae399b	ethtool_op_get_flags	vmlinux	EXPORT_SYMBOL
+0x48f18dd2	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x823eb105	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x8e320015	snd_hda_create_spdif_in_ctls	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x3b35851a	__ieee80211_get_channel	net/wireless/cfg80211	EXPORT_SYMBOL
+0x48545bd4	rds_trans_unregister	net/rds/rds	EXPORT_SYMBOL_GPL
+0xa40fa60a	dccp_v4_send_check	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0xa91d1795	hci_conn_check_link_mode	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xa172de88	usb_stor_post_reset	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x57e83067	cxgb3_free_atid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0x7d2e9a1c	sdio_set_block_size	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x0606b978	confirm_Bsend	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xb771412b	rdma_create_id	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x9b94bee2	rdma_create_qp	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x9924c496	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x932d53d3	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL
+0xeaea59b1	pci_hp_create_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x9159b9d6	profile_event_register	vmlinux	EXPORT_SYMBOL_GPL
+0x3636b6e5	snd_hda_query_pin_caps	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x86f8894f	fscache_object_states	fs/fscache/fscache	EXPORT_SYMBOL
+0xd22801b3	lbs_notify_command_response	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x8827b7d5	ppp_unit_number	drivers/net/ppp_generic	EXPORT_SYMBOL
+0x5855f972	ppp_input_error	drivers/net/ppp_generic	EXPORT_SYMBOL
+0x6809de82	ir_codes_pctv_sedna_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xd1f36bc6	tpm_continue_selftest	vmlinux	EXPORT_SYMBOL_GPL
+0x5460c8d8	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x171b577b	unregister_kprobes	vmlinux	EXPORT_SYMBOL_GPL
+0x2187c2a1	usb_serial_generic_open	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0x5cc866fc	fc_exch_init	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xe100cf9b	v4l2_device_disconnect	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0x80e3832d	dvb_filter_get_ac3info	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x1740c666	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x9f7e0629	ps2_init	vmlinux	EXPORT_SYMBOL
+0xdf8ae826	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x11f447ce	__gpio_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x847a8410	elv_queue_empty	vmlinux	EXPORT_SYMBOL
+0x0cf07b99	user_describe	vmlinux	EXPORT_SYMBOL_GPL
+0x57154969	blkdev_get	vmlinux	EXPORT_SYMBOL
+0xa5e038be	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x785b0423	unregister_ftrace_event	vmlinux	EXPORT_SYMBOL_GPL
+0xe189e22e	ebt_do_table	net/bridge/netfilter/ebtables	EXPORT_SYMBOL
+0x6d8490d4	hci_unregister_cb	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xa038fdbc	fscache_enqueue_operation	fs/fscache/fscache	EXPORT_SYMBOL
+0x9e93eaff	cx24110_attach	drivers/media/dvb/frontends/cx24110	EXPORT_SYMBOL
+0xf6de7d9c	md_wait_for_blocked_rdev	vmlinux	EXPORT_SYMBOL
+0xfc4a6106	kill_pid_info_as_uid	vmlinux	EXPORT_SYMBOL_GPL
+0xc9723585	snd_virmidi_new	sound/core/seq/snd-seq-virmidi	EXPORT_SYMBOL
+0x09e8f03d	jbd2_journal_begin_ordered_truncate	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xcab24a46	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x1fca10a8	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x8d46090e	ata_sff_tf_load	vmlinux	EXPORT_SYMBOL_GPL
+0x8226642f	__gpio_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0xc170dde3	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0xe24d3a97	jiffies_64	vmlinux	EXPORT_SYMBOL
+0xeda3a721	snd_print_pcm_bits	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x880c74f3	svc_create	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbc532bcf	rpc_lookup_machine_cred	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6d8313e6	vmbus_child_driver_register	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL
+0xaa0691bf	iscsi_tcp_segment_done	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x64b4e68d	iwl_pci_resume	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x0278776f	mptscsih_abort	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x5d5fa3dd	dst_ca_attach	drivers/media/dvb/bt8xx/dst_ca	EXPORT_SYMBOL
+0x8a194db7	umc_device_register	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0x592b577c	sas_slave_alloc	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xb09e4e7b	videobuf_dma_init_user	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0xfafe5c3e	videobuf_queue_is_busy	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x5eb2bb5c	saa7146_register_device	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0x25a141fd	vlan_gro_receive	vmlinux	EXPORT_SYMBOL
+0x2bab97d6	xfrm_state_migrate	vmlinux	EXPORT_SYMBOL
+0xecefde28	pci_cleanup_aer_uncorrect_error_status	vmlinux	EXPORT_SYMBOL_GPL
+0x6def2db2	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x63efc536	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x196d652c	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x146872ea	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x22a618fb	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0xaea05ade	abort_creds	vmlinux	EXPORT_SYMBOL
+0x9d3767a5	ieee80211_alloc_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0x38b92846	llc_remove_pack	net/llc/llc	EXPORT_SYMBOL
+0x143d3bed	parport_pc_probe_port	drivers/parport/parport_pc	EXPORT_SYMBOL
+0x7dab26b6	wm831x_isinkv_values	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x647e2acc	mptscsih_slave_configure	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0x7dcfe779	dchannel_senddata	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x16633a7d	drm_mode_create_dvi_i_properties	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xf42a2b26	drm_ht_create	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x0599d661	lro_vlan_hwaccel_receive_skb	vmlinux	EXPORT_SYMBOL
+0x8440d45b	tcp_alloc_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x4188d439	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x2083560c	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x6f34c6a2	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x8dc6e564	restore_processor_state	vmlinux	EXPORT_SYMBOL
+0x65d6d0f0	gpio_direction_input	vmlinux	EXPORT_SYMBOL_GPL
+0x87aaddf8	wrmsr_safe_regs_on_cpu	vmlinux	EXPORT_SYMBOL
+0x65408378	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0xd7d36d1a	idr_find	vmlinux	EXPORT_SYMBOL
+0x26ced87c	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x291e3a22	cfg80211_disconnected	net/wireless/cfg80211	EXPORT_SYMBOL
+0x1799321f	cfg80211_send_rx_auth	net/wireless/cfg80211	EXPORT_SYMBOL
+0xd5948006	dccp_insert_option_timestamp	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x4ba50812	mlx4_multicast_attach	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xa6476034	dvb_register_adapter	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xc70adf09	ib_get_rmpp_segment	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0x1f6cd46e	ethtool_op_get_sg	vmlinux	EXPORT_SYMBOL
+0x934f66de	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x1975d205	tpm_read	vmlinux	EXPORT_SYMBOL_GPL
+0xe43617f7	acpi_gbl_FADT	vmlinux	EXPORT_SYMBOL
+0xd46f7f14	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x27bbf221	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x568c95a4	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0xe0e3347d	dccp_create_openreq_child	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x33db8ad4	mlx4_srq_query	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xe66f7ea0	register_dca_provider	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0xf7584a9c	find_font	vmlinux	EXPORT_SYMBOL
+0xb9eb3aa9	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0xab5b05d8	dccp_child_process	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x3c1443ec	p9_client_read	net/9p/9pnet	EXPORT_SYMBOL
+0xb6e7fb29	ivtv_vapi	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x5021c00c	ipmi_smi_watcher_unregister	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xf51e1e76	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0xd5eb1396	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0xda1ce447	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x892b26a0	set_memory_nx	vmlinux	EXPORT_SYMBOL
+0x2be3eb13	smp_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x62813e5c	nf_ct_port_nlattr_tuple_size	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xb09269d1	p9_client_write	net/9p/9pnet	EXPORT_SYMBOL
+0xd6a26035	mpt_register	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xbba05a58	drm_mode_probed_add	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9bb86853	phy_start	vmlinux	EXPORT_SYMBOL
+0x7a5265d9	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x0e2cde27	proc_dostring	vmlinux	EXPORT_SYMBOL
+0xb54533f7	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0xc34a54c6	snd_hda_calc_stream_format	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xe233e375	ib_query_pkey	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xf6ca0d78	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL
+0xfb9919a6	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x6bb049fd	journal_force_commit_nested	fs/jbd/jbd	EXPORT_SYMBOL
+0x84a7ae9e	usb_stor_control_msg	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xf08cdf42	orinoco_down	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0xb4b77c8b	hostap_80211_get_hdrlen	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x68e7a192	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x4a28b355	skb_insert	vmlinux	EXPORT_SYMBOL
+0x770a0036	isapnp_cfg_begin	vmlinux	EXPORT_SYMBOL
+0x5372dede	unregister_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xd42fbeea	uio_unregister_device	drivers/uio/uio	EXPORT_SYMBOL_GPL
+0x7c6914a2	iwl_alloc_all	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xba781ce4	hostap_set_auth_algs	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x904b8696	cx88_audio_thread	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x12f10736	udplite_table	vmlinux	EXPORT_SYMBOL
+0x58081c57	tc_classify_compat	vmlinux	EXPORT_SYMBOL
+0x7172dd2f	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0xe1046043	jbd2_journal_file_inode	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x39230e2d	log_wait_commit	fs/jbd/jbd	EXPORT_SYMBOL
+0x322940a4	dm_table_get_size	drivers/md/dm-mod	EXPORT_SYMBOL
+0x205dcd7a	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0xac297a61	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0xd2a75ee0	dmi_first_match	vmlinux	EXPORT_SYMBOL
+0x22c869fe	kill_mtd_super	vmlinux	EXPORT_SYMBOL_GPL
+0x600683d3	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x6b9178b3	xenbus_strstate	vmlinux	EXPORT_SYMBOL_GPL
+0xa5dfac14	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x6e9dd606	__symbol_put	vmlinux	EXPORT_SYMBOL
+0x8254fb75	snd_ac97_get_short_name	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0x9a1734ce	ssb_dma_translation	drivers/ssb/ssb	EXPORT_SYMBOL
+0x09654809	lbs_cmd_copyback	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0xdbdcd2f2	cx231xx_init_isoc	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x8ed95029	netpoll_send_udp	vmlinux	EXPORT_SYMBOL
+0x3af190f3	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL
+0xa5da0abd	acpi_enter_sleep_state_s4bios	vmlinux	EXPORT_SYMBOL
+0xb62179b5	pci_claim_resource	vmlinux	EXPORT_SYMBOL
+0x9b388444	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0xfa06c7d2	snd_pcm_lib_read	sound/core/snd-pcm	EXPORT_SYMBOL
+0x85c76ca0	lbs_host_to_card_done	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x07bae4e0	mpt_raid_phys_disk_pg0	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x13ffd687	input_close_device	vmlinux	EXPORT_SYMBOL
+0xbf523eb8	key_validate	vmlinux	EXPORT_SYMBOL
+0x650f8603	snd_pcm_format_silence_64	sound/core/snd-pcm	EXPORT_SYMBOL
+0x94758a26	tcp_vegas_init	net/ipv4/tcp_vegas	EXPORT_SYMBOL_GPL
+0x5920ca27	uwb_pca_base_priority_show	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0x9e7141ab	v4l2_device_unregister	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0x50b33ca4	capi_cmsg2message	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x621fa73f	drm_mode_connector_update_edid_property	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x021aaf09	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0xdc6a2f07	phy_connect_direct	vmlinux	EXPORT_SYMBOL
+0x6b00784a	ata_std_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x0b577bd5	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x8d57be40	__copy_from_user_ll_nocache_nozero	vmlinux	EXPORT_SYMBOL
+0x5f65cab1	blk_unplug	vmlinux	EXPORT_SYMBOL
+0x1985ed3c	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x8d98ccb1	bt_sock_ioctl	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xe1716f06	uwb_est_register	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x047f76dd	ubi_open_volume_nm	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0xfd6f0ef9	ubi_unregister_volume_notifier	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0x42fa6cb4	b1_release_appl	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0xa3d2e951	ttm_bo_mmap	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x2a31d9be	ttm_bo_kmap	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x8d4299cf	drm_mode_height	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4d5d4eca	fw_core_remove_descriptor	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x1595ecac	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x80494ace	tcf_action_exec	vmlinux	EXPORT_SYMBOL
+0x88f69e52	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0xa2aee561	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
+0xb3ee9454	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x3f854114	ipv6_opt_accepted	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0xff376a70	arpt_register_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL
+0x98cca479	ssb_bus_powerup	drivers/ssb/ssb	EXPORT_SYMBOL
+0x3cc0a3bb	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x7f8140b6	bd_release_from_disk	vmlinux	EXPORT_SYMBOL_GPL
+0xfb33d42a	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x626d0f85	ring_buffer_overruns	vmlinux	EXPORT_SYMBOL_GPL
+0xe5e7befb	kmap_atomic_pfn	vmlinux	EXPORT_SYMBOL_GPL
+0x39bf9301	_snd_pcm_hw_param_setempty	sound/core/snd-pcm	EXPORT_SYMBOL
+0xcee467f3	xprt_load_transport	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc7d0f15c	atm_alloc_charge	net/atm/atm	EXPORT_SYMBOL
+0x78976e61	iwl_isr_legacy	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xafda1004	cx88_reset	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0x0cde4acc	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0xea7967b5	inode_add_to_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x0bc649dc	snd_vx_dsp_boot	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0x885b03db	rds_cong_map_updated	net/rds/rds	EXPORT_SYMBOL_GPL
+0x64e9ec08	jbd2_journal_errno	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x44630c37	parport_ieee1284_ecp_read_data	drivers/parport/parport	EXPORT_SYMBOL
+0x14d4ab6e	parport_ieee1284_epp_read_data	drivers/parport/parport	EXPORT_SYMBOL
+0x7521f53e	ivtv_udma_setup	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x2b8eab1f	capilib_free_ncci	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x6d3a51c5	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0xa0f98771	ahash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x42896d60	dquot_transfer	vmlinux	EXPORT_SYMBOL
+0xfa446d80	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0xc2429b63	xt_rateest_lookup	net/netfilter/xt_RATEEST	EXPORT_SYMBOL_GPL
+0xcf7b5409	drm_agp_release	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3414954a	drm_clflush_pages	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xbc7feeb0	md_wakeup_thread	vmlinux	EXPORT_SYMBOL
+0xb18486d6	ata_std_bios_param	vmlinux	EXPORT_SYMBOL_GPL
+0xbd506a46	unregister_hotplug_dock_device	vmlinux	EXPORT_SYMBOL_GPL
+0xd4323f0b	xip_truncate_page	vmlinux	EXPORT_SYMBOL_GPL
+0x98a207f1	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x8b9d3ba7	tracepoint_iter_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x8a918a76	rpc_clone_client	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf3a4c7e3	rndis_tx_fixup	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0x7577f992	mdio_set_flag	drivers/net/mdio	EXPORT_SYMBOL
+0x03224c93	sdio_f0_readb	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xdb8b721a	xfrm_audit_state_icvfail	vmlinux	EXPORT_SYMBOL_GPL
+0x722e5614	hid_resolv_usage	vmlinux	EXPORT_SYMBOL_GPL
+0xc42f2f94	xenbus_read_driver_state	vmlinux	EXPORT_SYMBOL_GPL
+0xcc36f32e	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0xfde0b92c	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x12d1fedd	__nf_ct_l4proto_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xb34d29a5	ip_vs_conn_out_get	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0x6d1ced27	vcc_sklist_lock	net/atm/atm	EXPORT_SYMBOL
+0x9edca65e	fscache_object_slow_work_ops	fs/fscache/fscache	EXPORT_SYMBOL
+0x55318a49	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x46a8c1fc	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x16f76869	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0xd32f005f	kmap_atomic_prot	vmlinux	EXPORT_SYMBOL
+0xdaeabe2e	rpipe_ep_disable	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0x1e7a7f80	dvb_ca_en50221_camready_irq	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xb8b6715e	capi20_set_callback	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xd14df331	drm_mode_prune_invalid	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xcb4abd00	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0xc5a6bb3b	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x307f7776	timecompare_offset	vmlinux	EXPORT_SYMBOL
+0x6dc0c24b	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0xb218d8c3	snd_hda_add_new_ctls	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xd485b058	rt2x00pci_write_tx_data	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0xffaab667	iwl_get_active_dwell_time	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5726a177	mlx4_buf_write_mtt	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xdb17b27a	em28xx_unregister_extension	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL
+0xbe6d685b	xc2028_attach	drivers/media/common/tuners/tuner-xc2028	EXPORT_SYMBOL
+0xb34d4dbd	capi_ctr_ready	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x8a7ed1d0	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x28d0e769	scsi_nl_sock	vmlinux	EXPORT_SYMBOL_GPL
+0xff6878cf	fb_default_cmap	vmlinux	EXPORT_SYMBOL
+0x4042b18f	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x06d3adad	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x553f9dd3	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x2782ed42	wpan_phy_register	net/ieee802154/wpan-class	EXPORT_SYMBOL
+0xe1e6ab9e	rt2x00lib_rxdone	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xe7ce5d70	iwl_rates	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2ae98127	vp3054_i2c_probe	drivers/media/video/cx88/cx88-vp3054-i2c	EXPORT_SYMBOL
+0x4e3c748c	cpufreq_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x9833bc0c	hvc_kick	vmlinux	EXPORT_SYMBOL_GPL
+0x28fb929b	nfs4_acl_posix_to_nfsv4	fs/nfsd/nfsd	EXPORT_SYMBOL
+0xb6eac203	uwb_radio_stop	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x2c54c957	capifs_free_ncci	drivers/isdn/capi/capifs	EXPORT_SYMBOL
+0x13b25571	ib_register_client	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x02fcc8ad	i2c_smbus_xfer	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0xa88d4763	nf_setsockopt	vmlinux	EXPORT_SYMBOL
+0x5a97e29e	nf_getsockopt	vmlinux	EXPORT_SYMBOL
+0x579e0bf5	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x59a0cc8d	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x8a3ea981	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0xfb576e61	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x4454892c	alloc_disk	vmlinux	EXPORT_SYMBOL
+0xc4f19703	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x2a16388f	dquot_commit_info	vmlinux	EXPORT_SYMBOL
+0x269694cf	seq_putc	vmlinux	EXPORT_SYMBOL
+0x6c7d0f24	seq_puts	vmlinux	EXPORT_SYMBOL
+0xe530071c	pm_qos_remove_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0xa452c297	hpet_mask_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0x96439213	snd_pcm_hw_param_last	sound/core/snd-pcm	EXPORT_SYMBOL
+0xb90668b2	snd_seq_autoload_lock	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0x58c61abc	ata_dev_disable	vmlinux	EXPORT_SYMBOL_GPL
+0xa257d3c6	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0xc72e421c	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x38b663b6	do_add_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x86cc3b57	d_genocide	vmlinux	EXPORT_SYMBOL
+0x27adf232	tracing_generic_entry_update	vmlinux	EXPORT_SYMBOL_GPL
+0x5edd5e40	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0xcffa2aff	spi_populate_width_msg	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL_GPL
+0x06e003f7	iwl_rx_queue_alloc	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xb091e67d	i2400m_cmd_enter_powersave	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0xec458621	tcp_vegas_cwnd_event	net/ipv4/tcp_vegas	EXPORT_SYMBOL_GPL
+0x56947347	dmi_walk	vmlinux	EXPORT_SYMBOL_GPL
+0xf9533ae6	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x1c4ba163	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0xfb6b129e	d_rehash	vmlinux	EXPORT_SYMBOL
+0xc8dbcf6d	wusbhc_reset_all	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x114d8d00	__mmc_claim_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x1f5ae2a1	isacsx_setup	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0xef975ccb	b1_alloc_card	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0xa93dc6c6	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x2b47c2f3	pci_get_class	vmlinux	EXPORT_SYMBOL
+0x6b1b67d3	__bdevname	vmlinux	EXPORT_SYMBOL
+0x62e34dcf	vfs_write	vmlinux	EXPORT_SYMBOL
+0x04aa36bd	set_pages_nx	vmlinux	EXPORT_SYMBOL
+0x2592aa9f	snd_pcm_hw_refine	sound/core/snd-pcm	EXPORT_SYMBOL
+0x512c956d	mraid_mm_unregister_adp	drivers/scsi/megaraid/megaraid_mm	EXPORT_SYMBOL
+0x8a6bc6a0	dm_set_device_limits	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x38fbf3cc	netif_rx	vmlinux	EXPORT_SYMBOL
+0xdd6ca2d9	unregister_ip_vs_app	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xf410d653	rt2x00lib_probe_dev	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x14f67530	ivtv_debug	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x0df887a0	iw_handler_set_spy	vmlinux	EXPORT_SYMBOL
+0x07bb5979	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x76bb1c89	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x72ea7b2d	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x5efb04c6	can_bus_off	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x1eadb125	ib_dealloc_mw	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x20a3ab19	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x2a8eb271	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0xa68a0237	xdr_init_encode	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xcc4db302	cryptd_ahash_child	crypto/cryptd	EXPORT_SYMBOL_GPL
+0x25dd70c3	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x3be293d0	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x9ea966a1	pcmcia_request_io	vmlinux	EXPORT_SYMBOL
+0x80e5c088	ata_sff_check_status	vmlinux	EXPORT_SYMBOL_GPL
+0x160ea4c8	sfi_disabled	vmlinux	EXPORT_SYMBOL
+0xbdf8e109	set_groups	vmlinux	EXPORT_SYMBOL
+0xd39343bb	mmc_unregister_driver	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x11ddec9a	dvb_dmxdev_release	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xc126e890	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0xf0d34d83	tcf_generic_walker	vmlinux	EXPORT_SYMBOL
+0x66dcaf65	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x27149d41	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x0c2162e5	snd_ac97_write	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xeb4c2e1f	osd_req_get_attributes	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x35437f91	osd_req_set_attributes	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x16572f99	iwl_tt_handler	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x0fd00a68	acpi_clear_event	vmlinux	EXPORT_SYMBOL
+0xfd1c115b	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x60cd73ed	pv_apic_ops	vmlinux	EXPORT_SYMBOL_GPL
+0xba509ff7	ab3100_get_register_page_interruptible	drivers/mfd/ab3100-core	EXPORT_SYMBOL
+0x02178f6a	saa7134_set_dmabits	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x6df8d0b6	tua6100_attach	drivers/media/dvb/frontends/tua6100	EXPORT_SYMBOL
+0x66cbad4b	mtd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x52ea8f9a	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x7538b132	agp_off	vmlinux	EXPORT_SYMBOL
+0xc59051eb	cfg80211_scan_done	net/wireless/cfg80211	EXPORT_SYMBOL
+0xb06d4bf1	inet6_csk_xmit	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x0358278e	iwl_free_channel_map	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x204474bd	dm_unregister_path_selector	drivers/md/dm-multipath	EXPORT_SYMBOL_GPL
+0xc6e46fea	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x9df69a1f	ata_eh_analyze_ncq_error	vmlinux	EXPORT_SYMBOL_GPL
+0xe95ff06f	registered_fb	vmlinux	EXPORT_SYMBOL
+0xcc2f7820	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x0440865c	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0xd273b1b1	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x0adec58b	bt_class	net/bluetooth/bluetooth	EXPORT_SYMBOL_GPL
+0xa0c71dac	spi_populate_sync_msg	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL_GPL
+0x5fbe6515	ir_codes_pinnacle_color_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xccaf73ab	ttm_tt_set_placement_caching	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x9f9a00fd	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x8b618d08	overflowuid	vmlinux	EXPORT_SYMBOL
+0x7171121c	overflowgid	vmlinux	EXPORT_SYMBOL
+0x0fb0f045	fc_change_queue_depth	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xdba5349c	mlx4_unregister_vlan	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x7c8b0010	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x6df0b261	dma_async_tx_descriptor_init	vmlinux	EXPORT_SYMBOL
+0xca52a803	tpm_show_caps_1_2	vmlinux	EXPORT_SYMBOL_GPL
+0x53dd9fb7	pci_enable_device	vmlinux	EXPORT_SYMBOL
+0xb5c5a4fc	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x26446cc8	xprt_release_xprt_cong	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x68dde1c0	mISDN_register_device	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xd25141d1	wireless_send_event	vmlinux	EXPORT_SYMBOL
+0x67885985	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x3ef78d80	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x41e3137a	rpc_wake_up_queued_task	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x6e993ef2	unregister_snap_client	net/802/psnap	EXPORT_SYMBOL
+0x03fea02c	ttm_bo_move_accel_cleanup	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x6e29b980	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0xf40826f7	phy_driver_register	vmlinux	EXPORT_SYMBOL
+0xa31149b9	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x872a4b2d	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL
+0x5ea4014e	relay_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x9b4b30a9	snd_akm4xxx_write	sound/i2c/other/snd-ak4xxx-adda	EXPORT_SYMBOL
+0x7d079c18	nf_conntrack_register_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x699b30e5	fscache_withdraw_cache	fs/fscache/fscache	EXPORT_SYMBOL
+0xbaa68e05	wlp_reset_all	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x4560476c	iwl_rf_kill_ct_config	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xac669060	dst_wait_dst_ready	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x3aaa3c7f	dm_exception_store_type_register	drivers/md/dm-snapshot	EXPORT_SYMBOL
+0xbf4774db	ks0108_writecontrol	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0x5cdaa8da	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x4f05d1de	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0xe2921a36	phy_print_status	vmlinux	EXPORT_SYMBOL
+0x6dab231f	pci_remove_bus	vmlinux	EXPORT_SYMBOL
+0x812235f3	dquot_mark_dquot_dirty	vmlinux	EXPORT_SYMBOL
+0x8e763ae1	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x6e954a64	snd_ice1712_akm4xxx_build_controls	sound/pci/ice1712/snd-ice17xx-ak4xxx	EXPORT_SYMBOL
+0x43c66370	mpt_attach	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xe05ea9ae	itd1000_attach	drivers/media/dvb/frontends/itd1000	EXPORT_SYMBOL
+0x70d8ab82	acpi_acquire_global_lock	vmlinux	EXPORT_SYMBOL
+0x5a28f969	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00566d8f	inotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x76f3f8a5	num_k8_northbridges	vmlinux	EXPORT_SYMBOL
+0x6e224a7a	need_conntrack	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x0da9ac7a	flexcop_device_kmalloc	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x4a358252	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x1c1af916	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0xc625b2b6	mb_cache_entry_get	fs/mbcache	EXPORT_SYMBOL
+0x0434b2cb	ei_get_stats	drivers/net/8390	EXPORT_SYMBOL
+0xb4bc27a7	saa7134_set_gpio	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0xf826deb0	dvb_filter_pes2ts	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x18723d8f	ttm_tt_bind	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x12d02aa6	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x56edceeb	cpufreq_debug_printk	vmlinux	EXPORT_SYMBOL
+0x6bef888d	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL
+0xdd9259c0	bioset_integrity_free	vmlinux	EXPORT_SYMBOL
+0xf29c090f	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0xb28bf39d	send_sig	vmlinux	EXPORT_SYMBOL
+0x602c96f0	copy_to_user_fromio	sound/core/snd	EXPORT_SYMBOL
+0xfb51cdeb	usb_stor_set_xfer_buf	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xd54196b4	libipw_get_channel	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x851dd89a	usbnet_change_mtu	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0x5e38fc6d	wm8400_reg_read	drivers/mfd/wm8400-core	EXPORT_SYMBOL_GPL
+0xa90b1140	wm8400_set_bits	drivers/mfd/wm8400-core	EXPORT_SYMBOL_GPL
+0xfcd93949	wm8350_set_bits	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x67962dae	wm8350_reg_read	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x0366dcdf	ir_codes_videomate_s350_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x8b91cdc8	drm_vblank_count	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x35b0e73c	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0xaa897c64	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0xaaf45875	acpi_lid_notifier_unregister	vmlinux	EXPORT_SYMBOL
+0x7d5365d7	tracepoint_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x78cb2783	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x3285cc48	param_set_uint	vmlinux	EXPORT_SYMBOL
+0xd82c728e	rpc_init_wait_queue	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc6c4fdb0	usb_stor_ctrl_transfer	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x99410fa2	enclosure_for_each_device	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0x986b14b6	cdrom_open	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0x0584fbc6	tcp_v4_md5_do_add	vmlinux	EXPORT_SYMBOL
+0x199ed0cd	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x9d3850e1	gnttab_alloc_grant_references	vmlinux	EXPORT_SYMBOL_GPL
+0x3f462c61	osd_req_list_partition_collections	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x54f67c35	mpt_put_msg_frame	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x69e9a2cb	ata_scsi_slave_config	vmlinux	EXPORT_SYMBOL_GPL
+0x59ad36ea	ata_pci_device_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x4afe9a77	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x068c7263	ioremap_cache	vmlinux	EXPORT_SYMBOL
+0x65c9d976	iscsi_conn_error_event	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x2c5516f0	drm_pci_alloc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x6a823da8	cryptd_alloc_ahash	crypto/cryptd	EXPORT_SYMBOL_GPL
+0xeccdcbd0	ata_port_pbar_desc	vmlinux	EXPORT_SYMBOL_GPL
+0xdb4c88b4	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x8fad54a3	p9_client_stat	net/9p/9pnet	EXPORT_SYMBOL
+0x0230e109	alloc_ieee80211	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0x2a86d297	ib_create_cm_id	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xf338d4c3	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0xe0f7388a	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x748caf40	down	vmlinux	EXPORT_SYMBOL
+0x30059d69	iscsi_change_queue_depth	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xb8886d5c	drm_sysfs_connector_add	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xbafe79aa	ipmi_create_user	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x8eac0a69	blk_end_request	vmlinux	EXPORT_SYMBOL
+0xb427aafb	ubi_leb_write	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0xa436f079	mtd_concat_create	drivers/mtd/mtdconcat	EXPORT_SYMBOL
+0x8b13f1f7	videobuf_dvb_find_frontend	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x01087af0	mISDN_dsp_element_unregister	drivers/isdn/mISDN/mISDN_dsp	EXPORT_SYMBOL
+0x50de71c2	dev_unicast_unsync	vmlinux	EXPORT_SYMBOL
+0x87b9e44e	skb_put	vmlinux	EXPORT_SYMBOL
+0x326fd6cd	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x3895cd7a	nfnl_unlock	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x07ae60b6	nf_nat_proto_in_range	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0x3e326da7	configfs_depend_item	fs/configfs/configfs	EXPORT_SYMBOL
+0xd4ebc829	usb_ftdi_elan_read_pcimem	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x00e718b6	sas_domain_release_transport	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x62e32d43	capilib_data_b3_conf	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x1cccf652	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x650fb346	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0xb218b614	au8522_attach	drivers/media/dvb/frontends/au8522	EXPORT_SYMBOL
+0xcfdc2ba4	ttm_bo_move_memcpy	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xd1ccb568	drm_helper_connector_dpms	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x0af4f361	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0xe8984bd9	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0xae98c731	tpm_open	vmlinux	EXPORT_SYMBOL_GPL
+0x9f984513	strrchr	vmlinux	EXPORT_SYMBOL
+0x0a3131f6	strnchr	vmlinux	EXPORT_SYMBOL
+0x92fb217b	dcookie_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x1b47bdae	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x6339b6d0	snd_seq_device_load_drivers	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0x3b02e980	journal_clear_err	fs/jbd/jbd	EXPORT_SYMBOL
+0xccb6b38b	__fscache_uncache_page	fs/fscache/fscache	EXPORT_SYMBOL
+0x12f6e2e7	saa7134_s_std_internal	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL_GPL
+0x829ef9ce	isacsx_irq	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0xa1f9d097	edac_pci_handle_pe	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x57a6504e	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x44b911c3	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x6ff607b6	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x668402aa	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0xffadf004	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x23869dc7	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0xa37fc144	snd_pcm_hw_constraint_pow2	sound/core/snd-pcm	EXPORT_SYMBOL
+0x3849c4e8	nf_ct_gre_keymap_flush	net/netfilter/nf_conntrack_proto_gre	EXPORT_SYMBOL
+0x1de3e997	ssb_set_devtypedata	drivers/ssb/ssb	EXPORT_SYMBOL
+0x3136d8ff	ir_codes_dntv_live_dvbt_pro_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x99cdc86b	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0xfeb80087	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x8b42a1d6	alloc_pci_dev	vmlinux	EXPORT_SYMBOL
+0x9754ec10	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x480d41fc	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x0c4576cd	vfs_quota_on_mount	vmlinux	EXPORT_SYMBOL
+0x9d5eff70	parport_irq_handler	drivers/parport/parport	EXPORT_SYMBOL
+0xd973f48a	lbtf_add_card	drivers/net/wireless/libertas_tf/libertas_tf	EXPORT_SYMBOL_GPL
+0xf925fc7d	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
+0xc529fd46	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0xf52c377b	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0xa9d35c78	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x4d7275dc	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x9d2b6a58	hpet_register_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x2d6baa7d	snd_sb16dsp_get_pcm_ops	sound/isa/sb/snd-sb16-dsp	EXPORT_SYMBOL
+0x565a8a2e	__videobuf_mmap_setup	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xef29c40d	ir_codes_adstech_dvb_t_pci_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x1b08cef1	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x6fa96f6f	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x69e27c7a	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0xb45578b8	memscan	vmlinux	EXPORT_SYMBOL
+0xbe0e5cd2	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x9948d7fd	get_super	vmlinux	EXPORT_SYMBOL
+0x00801678	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x8668d134	rpipe_destroy	drivers/usb/wusbcore/wusb-wa	EXPORT_SYMBOL_GPL
+0xaa990d87	srp_attach_transport	drivers/scsi/scsi_transport_srp	EXPORT_SYMBOL_GPL
+0x3dd638cd	iwl_setup_rx_scan_handlers	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x74c336a7	ib_create_ah_from_wc	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x7e09d347	xfrm_state_sort	vmlinux	EXPORT_SYMBOL
+0xa7e33a56	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x254e061e	block_write_begin	vmlinux	EXPORT_SYMBOL
+0xba521813	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0xb7d7c12e	hpet_set_alarm_time	vmlinux	EXPORT_SYMBOL_GPL
+0xc29df8bc	sas_rphy_free	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xd73108c7	fc_release_transport	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xa5987a36	memstick_init_req	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xb57445f7	ir_codes_eztv_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x2dba1cfb	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0xbe1887e4	ata_unpack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x43420673	fb_deferred_io_fsync	vmlinux	EXPORT_SYMBOL_GPL
+0xe1761617	security_inet_conn_request	vmlinux	EXPORT_SYMBOL
+0x1268f357	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0xf826f727	wlp_dev_manufacturer_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0xd50fef48	acpi_detach_data	vmlinux	EXPORT_SYMBOL
+0x124f2056	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0xe716baed	acpi_unregister_ioapic	vmlinux	EXPORT_SYMBOL
+0x12e280e3	svc_proc_unregister	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x8d33a718	nfnetlink_send	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x9c97fbc1	uwb_radio_start	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x06fcd2c8	ib_umem_release	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xf8fcf3fc	ib_fmr_pool_unmap	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x26c90ea4	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x77212188	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x96505773	pci_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x3ae831b6	kref_init	vmlinux	EXPORT_SYMBOL
+0x99f37fb6	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL
+0xe1c31d44	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x3cfdfae5	trace_current_buffer_discard_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x50fad434	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x56ea266a	dccp_state_name	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xa2d63922	mlx4_mtt_cleanup	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x2c2bd600	cx24113_attach	drivers/media/dvb/frontends/cx24113	EXPORT_SYMBOL
+0xbee9c1e8	dm_rh_flush	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x1ba98fc4	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0xe395dcf4	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x8c54f7ea	serio_open	vmlinux	EXPORT_SYMBOL
+0x61a49168	pccard_get_tuple_data	vmlinux	EXPORT_SYMBOL
+0x22372645	agp_generic_free_by_type	vmlinux	EXPORT_SYMBOL
+0x22b325d5	kd_mksound	vmlinux	EXPORT_SYMBOL
+0xe4c331b6	acpi_os_unmap_memory	vmlinux	EXPORT_SYMBOL_GPL
+0xf5c05914	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x35a51429	audit_log_format	vmlinux	EXPORT_SYMBOL
+0x0732089b	snd_usb_create_midi_interface	sound/usb/snd-usb-lib	EXPORT_SYMBOL
+0xb95bf757	rt2x00pci_initialize	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0x6d2fc5a6	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0xbc1783be	sock_register	vmlinux	EXPORT_SYMBOL
+0x7f3e34f2	serio_close	vmlinux	EXPORT_SYMBOL
+0xcb362a1c	ata_link_next	vmlinux	EXPORT_SYMBOL_GPL
+0x9a323295	loop_register_transfer	vmlinux	EXPORT_SYMBOL
+0x6b3e0b5d	pci_find_bus	vmlinux	EXPORT_SYMBOL
+0xe7d32407	nmi_active	vmlinux	EXPORT_SYMBOL
+0xf4a5c213	avail_to_resrv_perfctr_nmi_bit	vmlinux	EXPORT_SYMBOL
+0x217b33d6	__snd_util_mem_alloc	sound/synth/snd-util-mem	EXPORT_SYMBOL
+0x1f58e71b	nfnl_lock	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0x1f2892c5	inet6_register_protosw	net/ipv6/ipv6	EXPORT_SYMBOL
+0x018edf04	rt2x00usb_suspend	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0x719ab913	hdlc_open	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x38e67a8b	register_mtd_blktrans	drivers/mtd/mtd_blkdevs	EXPORT_SYMBOL_GPL
+0x38a32b8a	saa7134_pgtable_free	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x92b5fc74	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL
+0xb4709322	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x90e2fcbf	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x62384d3a	snd_midi_event_encode	sound/core/seq/snd-seq-midi-event	EXPORT_SYMBOL
+0x69b18f43	rfc1042_header	net/wireless/cfg80211	EXPORT_SYMBOL
+0xe2426710	wmi_evaluate_method	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0x7b257c6c	iwl_disable_ict	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x33eb4f06	ib_get_dma_mr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x751ee5c3	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
+0x81314560	skb_under_panic	vmlinux	EXPORT_SYMBOL
+0x458f3465	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x70625f75	iscsi_tcp_conn_get_stats	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0xff767059	videobuf_next_field	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x33f833ff	af9005_rc_decode	drivers/media/dvb/dvb-usb/dvb-usb-af9005-remote	EXPORT_SYMBOL
+0x0b291f37	ring_buffer_consume	vmlinux	EXPORT_SYMBOL_GPL
+0x14778cad	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x879fbf5b	nf_nat_proto_put	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0xd105dcdf	scsi_host_put_command	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0x5636e2c4	hostap_set_hostapd_sta	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xa2a5fd77	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x9e45ec91	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0xb04ea8f0	agp_rebind_memory	vmlinux	EXPORT_SYMBOL
+0xe89272a5	rpc_print_iostats	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x34a69183	atm_dev_lookup	net/atm/atm	EXPORT_SYMBOL
+0x26c7889c	p9_client_fcreate	net/9p/9pnet	EXPORT_SYMBOL
+0x74f22f46	srp_target_alloc	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0x312d36b8	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x05495392	hid_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x605f4585	acpi_bus_register_driver	vmlinux	EXPORT_SYMBOL
+0x34729698	cpumask_next_and	vmlinux	EXPORT_SYMBOL
+0xbc572c5b	set_ras_addr_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0x52f4f713	v4l2_chip_ident_i2c_client	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x3134f8d2	drm_open	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xdf803bf9	nf_hook_slow	vmlinux	EXPORT_SYMBOL
+0xce5ac24f	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x28b3a7b4	snd_wss_mce_up	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x6c8f14d5	snd_pcm_limit_hw_rates	sound/core/snd-pcm	EXPORT_SYMBOL
+0x69424e05	wimax_report_rfkill_hw	net/wimax/wimax	EXPORT_SYMBOL_GPL
+0x9c9f24ea	usb_cypress_load_firmware	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0xa68d4a51	dm_dirty_log_type_register	drivers/md/dm-log	EXPORT_SYMBOL
+0x2e471f01	dca_register_notify	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0x6e571a55	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0xace5c0fc	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
+0x9f988164	vga_client_register	vmlinux	EXPORT_SYMBOL
+0x0f7b290c	bio_integrity_split	vmlinux	EXPORT_SYMBOL
+0xfbac2eef	v9fs_get_default_trans	net/9p/9pnet	EXPORT_SYMBOL
+0x2f3ba80b	fcoe_ctlr_init	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL
+0xeb7daf80	dvb_ringbuffer_avail	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x843a4935	xfrm_audit_state_notfound_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x2986f925	ata_pci_sff_activate_host	vmlinux	EXPORT_SYMBOL_GPL
+0x954301aa	ata_scsi_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x03e3686c	ata_timing_cycle2mode	vmlinux	EXPORT_SYMBOL_GPL
+0xa5bbb17e	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0xaaf544c4	console_start	vmlinux	EXPORT_SYMBOL
+0x8f4598f4	parport_unregister_driver	drivers/parport/parport	EXPORT_SYMBOL
+0xaac794cb	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x86cdfb6e	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0xa58eed48	xt_register_match	vmlinux	EXPORT_SYMBOL
+0x78995d81	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0xcf53f173	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x3277deab	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x238bb63f	register_kretprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x78e0d996	snd_emu10k1_synth_free	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0xfc1082e5	iscsi_host_alloc	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xfa20c849	libipw_networks_age	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xb9cbc8dd	__alloc_eip_netdev	drivers/net/8390p	EXPORT_SYMBOL
+0x74cc0a4a	genphy_suspend	vmlinux	EXPORT_SYMBOL
+0x9a9d2d95	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x78ca5984	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x3f4547a7	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0xd2555f19	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x57adf756	per_cpu__this_cpu_off	vmlinux	EXPORT_SYMBOL
+0x4a48f920	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0xfbe27a1c	rb_first	vmlinux	EXPORT_SYMBOL
+0x563fb5c8	__trace_bprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x7c904ded	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0xd963a74a	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0xd8458e49	p9_client_version	net/9p/9pnet	EXPORT_SYMBOL
+0x9d448d2a	sas_change_queue_depth	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x0a682918	ata_dummy_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x22a2690c	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x9e363b6b	acpi_disable_gpe	vmlinux	EXPORT_SYMBOL
+0x71e8be55	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x7882a115	snd_hda_parse_generic_codec	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL
+0x441be3c4	mmc_resume_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x85784142	videobuf_dvb_register_bus	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x0194837f	create_l1	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x11c4e61a	bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x082c3213	pci_root_buses	vmlinux	EXPORT_SYMBOL
+0x04547a6d	mmc_alloc_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x9a32204a	videobuf_iolock	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x5ec600e3	ib_find_cached_gid	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x27db5172	dca_add_requester	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0x7cd6728b	nf_log_unregister	vmlinux	EXPORT_SYMBOL
+0xf75f4327	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x986e6135	fb_pad_unaligned_buffer	vmlinux	EXPORT_SYMBOL
+0x3656bf5a	lock_kernel	vmlinux	EXPORT_SYMBOL
+0x5dafe96e	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x1b9981cc	set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x13f42152	system_entering_hibernation	vmlinux	EXPORT_SYMBOL
+0x70c15ac1	snd_dma_disable	sound/core/snd	EXPORT_SYMBOL
+0xc2a1ae72	snd_register_device_for_dev	sound/core/snd	EXPORT_SYMBOL
+0x3f26792f	snd_rawmidi_drain_input	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0xa2f2c345	dccp_death_row	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xf6875e76	ttpci_budget_set_video_port	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0x3abd88d8	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL
+0xba46906c	input_open_device	vmlinux	EXPORT_SYMBOL
+0xfe990052	gpio_free	vmlinux	EXPORT_SYMBOL_GPL
+0xea054b22	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x0407db1c	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x78a484c9	_read_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x454f7518	snd_ak4114_external_rate	sound/i2c/other/snd-ak4114	EXPORT_SYMBOL
+0xcde25f85	cfg80211_wext_giwrange	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x1ae3a6f2	cache_unregister	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xc74df137	xprt_set_retrans_timeout_def	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x57a3d3d5	ip6_dst_lookup	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x361251f8	ssb_pcihost_register	drivers/ssb/ssb	EXPORT_SYMBOL
+0x61599afb	osduld_path_lookup	drivers/scsi/osd/osd	EXPORT_SYMBOL
+0xf64277de	lbs_debug	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x9f1900eb	i2c_new_device	drivers/i2c/i2c-core	EXPORT_SYMBOL_GPL
+0xff420674	drm_mode_set_name	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xd75ac244	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0xbaaab8ae	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x9c50bb35	set_pages_uc	vmlinux	EXPORT_SYMBOL
+0xb9948d2c	snd_midi_channel_free_set	sound/core/seq/snd-seq-midi-emul	EXPORT_SYMBOL
+0x581ef503	ieee80211_free_hw	net/mac80211/mac80211	EXPORT_SYMBOL
+0x496a1a5f	dccp_close	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x13e69cea	hci_resume_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x7ce8c27e	iwl_leds_unregister	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x07d9b783	scsi_nl_send_vendor_msg	vmlinux	EXPORT_SYMBOL
+0xe8a3605f	acpi_processor_set_thermal_limit	vmlinux	EXPORT_SYMBOL
+0x6ad85887	acpi_enable_gpe	vmlinux	EXPORT_SYMBOL
+0xefbf7fb4	unregister_key_type	vmlinux	EXPORT_SYMBOL
+0x518c2fc6	hpet_rtc_dropped_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x8cfe9780	rpc_shutdown_client	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbb4c0577	pppox_ioctl	drivers/net/pppox	EXPORT_SYMBOL
+0x42f9fa70	i2c_dp_aux_add_bus	drivers/gpu/drm/i915/i915	EXPORT_SYMBOL
+0x8d3894f2	_ctype	vmlinux	EXPORT_SYMBOL
+0xa97f2237	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x99515d25	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x861e5509	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0xa4e24da4	pcmcia_write_cis_mem	vmlinux	EXPORT_SYMBOL
+0x23779f93	pci_set_dma_mask	vmlinux	EXPORT_SYMBOL
+0x2182019e	snd_pcm_stop	sound/core/snd-pcm	EXPORT_SYMBOL
+0x3511d8f8	svc_xprt_names	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xccda46bc	close_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x17e731dc	ib_alloc_fmr	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xac42de6c	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x330475ad	macvlan_handle_frame_hook	vmlinux	EXPORT_SYMBOL_GPL
+0x37e19066	skb_copy	vmlinux	EXPORT_SYMBOL
+0xf59b2a5e	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x97c49a70	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL
+0x27864d57	memparse	vmlinux	EXPORT_SYMBOL
+0xfa7c6a66	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0xb4aa1d09	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x1d2e87c6	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x5603cf43	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0xf1b36f80	iscsi_session_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x467614f9	mptscsih_host_attrs	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xb22fe6a3	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x85d3223c	uart_match_port	vmlinux	EXPORT_SYMBOL
+0xa7e895fb	snd_wss_in	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x3ce7caa4	iscsi_host_get_param	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x3678aa46	saa_dsp_writel	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0xe5ae8707	intlog10	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x31a2c8df	dca_get_tag	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0xb798b8e4	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x02594e07	alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x4131c8f8	pcie_port_service_register	vmlinux	EXPORT_SYMBOL
+0x0c16e6e4	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL
+0x80b42ce3	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x76813216	per_cpu__current_task	vmlinux	EXPORT_SYMBOL
+0x170c418a	__nf_ct_ext_destroy	net/netfilter/nf_conntrack	EXPORT_SYMBOL
+0x76e00b42	uwb_rc_post_reset	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x14caff48	scsi_is_sas_phy	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0xbf19bee7	rt2x00usb_resume	drivers/net/wireless/rt2x00/rt2x00usb	EXPORT_SYMBOL_GPL
+0xf6a9d498	stop_atmel_card	drivers/net/wireless/atmel	EXPORT_SYMBOL
+0xad3fd944	sdio_align_size	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xa5126287	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x5ec5b7e1	cpufreq_register_governor	vmlinux	EXPORT_SYMBOL_GPL
+0xf9ca3160	ata_id_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x516fba53	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x2cfe4473	xenbus_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xf7181efa	acpi_processor_register_performance	vmlinux	EXPORT_SYMBOL
+0x730c52ad	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x0c997a3f	dquot_release_reserved_space	vmlinux	EXPORT_SYMBOL
+0x1cd39ac4	lib80211_get_crypto_ops	net/wireless/lib80211	EXPORT_SYMBOL
+0x5cfede8b	wm8350_dcdc25_set_mode	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0xdc7486d6	stv0900_attach	drivers/media/dvb/frontends/stv0900	EXPORT_SYMBOL
+0x6477e082	stb6100_attach	drivers/media/dvb/frontends/stb6100	EXPORT_SYMBOL
+0xb6f4f3c8	stb6000_attach	drivers/media/dvb/frontends/stb6000	EXPORT_SYMBOL
+0x462043e0	lnbp21_attach	drivers/media/dvb/frontends/lnbp21	EXPORT_SYMBOL
+0xf14bf8b1	b1pcmcia_addcard_b1	drivers/isdn/hardware/avm/b1pcmcia	EXPORT_SYMBOL
+0xaec3240e	b1pcmcia_addcard_m1	drivers/isdn/hardware/avm/b1pcmcia	EXPORT_SYMBOL
+0xea620116	b1pcmcia_addcard_m2	drivers/isdn/hardware/avm/b1pcmcia	EXPORT_SYMBOL
+0xc08ec24c	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x57575f08	dmaengine_put	vmlinux	EXPORT_SYMBOL
+0x10ee20bb	default_blu	vmlinux	EXPORT_SYMBOL
+0xaae8ab0e	acpi_bus_power_manageable	vmlinux	EXPORT_SYMBOL
+0x76f02183	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x62e103d9	bio_put	vmlinux	EXPORT_SYMBOL
+0xd42b7232	_write_unlock_bh	vmlinux	EXPORT_SYMBOL
+0xa694b93c	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x16d0360b	ieee80211_rts_get	net/mac80211/mac80211	EXPORT_SYMBOL
+0x906d983f	journal_force_commit	fs/jbd/jbd	EXPORT_SYMBOL
+0x58b2e790	video_ioctl2	drivers/media/video/videodev	EXPORT_SYMBOL
+0xd53c31ad	smscore_get_device_mode	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x0349c9bd	ir_codes_proteus_2309_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xd285995f	mISDN_clock_get	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x0ed820e1	dev_unicast_sync	vmlinux	EXPORT_SYMBOL
+0xd111d754	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0xf5b7d24f	tpm_store_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x2c5c5514	rds_message_add_rdma_dest_extension	net/rds/rds	EXPORT_SYMBOL_GPL
+0x50766d69	v4l2_ctrl_query_menu_valid_items	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0xabd6f7a3	cx231xx_set_mode	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x8640eaeb	ib_modify_qp_is_ok	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xbe5da569	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x453c8403	pci_msi_enabled	vmlinux	EXPORT_SYMBOL
+0x6a76f3ac	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x77b0134e	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x95050d92	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x8c9d686d	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x617db606	snd_rawmidi_receive	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x2804dcb2	ssb_pmu_set_ldo_voltage	drivers/ssb/ssb	EXPORT_SYMBOL
+0x2077ab40	saa7134_tvaudio_setmute	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL
+0x7283f81d	ir_codes_purpletv_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x8826c13b	acpi_video_register	drivers/acpi/video	EXPORT_SYMBOL
+0x5f56b4cc	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x76a14552	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x8d6906d4	unregister_memory_notifier	vmlinux	EXPORT_SYMBOL
+0x25820c64	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0xe72994aa	wake_up_process	vmlinux	EXPORT_SYMBOL
+0xcac0a3be	snd_seq_kernel_client_enqueue	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x71f55436	__nf_ct_refresh_acct	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x7ba63e38	scsi_is_sas_port	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x13665977	flexcop_device_exit	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x4f476e96	init_cdrom_command	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0x1f311fca	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x1aafa8c1	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0xea418e0f	atapi_cmd_type	vmlinux	EXPORT_SYMBOL_GPL
+0x65f00f0c	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x42edab06	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00b43c3f	arch_debugfs_dir	vmlinux	EXPORT_SYMBOL
+0xdd61deba	srp_cmd_queue	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0x9fa1132f	wm831x_reg_read	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x41a52142	wm831x_set_bits	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0xc7bd23e7	videobuf_dma_unmap	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x54ab6f73	gigaset_handle_modem_response	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x47d3fc51	capi_info2str	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0xf11198e2	ttm_mem_global_release	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xb0d8b1ad	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x172bfca3	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x63ecad53	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x49a75ee2	pci_get_device	vmlinux	EXPORT_SYMBOL
+0x9585b4f1	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x808ec1a3	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0xa0c4c3db	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x6392243b	em28xx_audio_setup	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x2291bf4a	dm_rh_bio_to_region	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0xde858aed	edac_mc_free	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x80ca3453	ata_sff_drain_fifo	vmlinux	EXPORT_SYMBOL_GPL
+0xa3683aca	put_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x6451ec34	fail_migrate_page	vmlinux	EXPORT_SYMBOL
+0xdf4c8767	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x73aa7b7d	nf_ct_expect_register_notifier	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x260f6bcd	dccp_connect	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xd80c3603	crc7_syndrome_table	lib/crc7	EXPORT_SYMBOL
+0xfd9d4c09	isdnhdlc_encode	drivers/isdn/i4l/isdnhdlc	EXPORT_SYMBOL
+0x466c14a7	__delay	vmlinux	EXPORT_SYMBOL
+0x641fa0d9	get_sb_single	vmlinux	EXPORT_SYMBOL
+0xc46ee1bb	ring_buffer_swap_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xdc2adb35	add_taint	vmlinux	EXPORT_SYMBOL
+0x60a32ea9	pm_power_off	vmlinux	EXPORT_SYMBOL
+0xe7187727	snd_wss_mce_down	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x55c7c3eb	osd_req_add_get_attr_page	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xbb2c5741	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0xe862c4b7	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x01d03f2e	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x4d5e4ec1	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x1886ed82	user_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0xb444439d	dquot_alloc_inode	vmlinux	EXPORT_SYMBOL
+0x92e59365	bdget	vmlinux	EXPORT_SYMBOL
+0x807bad47	bdput	vmlinux	EXPORT_SYMBOL
+0x0e0795da	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x1a4521e8	nf_conntrack_untracked	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x4ed47eef	usb_usual_ignore_device	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xa207afa2	dm_table_get	drivers/md/dm-mod	EXPORT_SYMBOL
+0xd0b54f19	scsi_tgt_cmd_to_host	drivers/scsi/scsi_tgt	EXPORT_SYMBOL_GPL
+0x12d3b019	memstick_register_driver	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x5a4f7764	arp_broken_ops	vmlinux	EXPORT_SYMBOL
+0x910156c6	tcf_em_register	vmlinux	EXPORT_SYMBOL
+0xb99d5837	xenbus_read	vmlinux	EXPORT_SYMBOL_GPL
+0x4cb46d8a	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x0047d11f	drm_mode_debug_printmodeline	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x27ad7d7d	cdrom_ioctl	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xcf778d89	__vlan_hwaccel_rx	vmlinux	EXPORT_SYMBOL
+0x245ec8e8	strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x5af76f0b	crypto_alloc_ablkcipher	vmlinux	EXPORT_SYMBOL_GPL
+0xa807f258	bio_init	vmlinux	EXPORT_SYMBOL
+0x7278d328	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0xe354a34c	rpc_max_payload	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe89635a7	gss_mech_put	net/sunrpc/auth_gss/auth_rpcgss	EXPORT_SYMBOL_GPL
+0x14820c29	sdio_enable_func	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x9a571532	cx8802_buf_prepare	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0x4b81d47f	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0xad81cae6	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00258aa9	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0xe684a5bf	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0xe6723a51	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x8f595b11	snd_major	sound/core/snd	EXPORT_SYMBOL
+0x8490c15a	srp_release_transport	drivers/scsi/scsi_transport_srp	EXPORT_SYMBOL_GPL
+0x4e358fa6	cfi_qry_present	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL_GPL
+0x5720bc9f	videobuf_read_stop	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xc79bcd36	dm_vcalloc	drivers/md/dm-mod	EXPORT_SYMBOL
+0x1dcffa4f	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0xa51bf7af	skb_make_writable	vmlinux	EXPORT_SYMBOL
+0x53c0767c	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x20d22764	iommu_found	vmlinux	EXPORT_SYMBOL_GPL
+0x0a47f0db	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0xa1d2e222	__mod_zone_page_state	vmlinux	EXPORT_SYMBOL
+0xf6e30b35	__inc_zone_page_state	vmlinux	EXPORT_SYMBOL
+0xdc9a05f4	__dec_zone_page_state	vmlinux	EXPORT_SYMBOL
+0x4acd93d3	release_resource	vmlinux	EXPORT_SYMBOL
+0xb0942ffb	ppp_register_compressor	drivers/net/ppp_generic	EXPORT_SYMBOL
+0x73097207	register_sja1000dev	drivers/net/can/sja1000/sja1000	EXPORT_SYMBOL_GPL
+0xd558f6d2	videobuf_waiton	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x1326cce3	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x52ff9ec6	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x2fac557e	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0xfcaa04a0	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x4bbf5c05	rfkill_pause_polling	net/rfkill/rfkill	EXPORT_SYMBOL
+0x6c54d3ac	fat_remove_entries	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x539f3cd5	iwl_mac_beacon_update	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x3ea336fd	mISDN_FsmAddTimer	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x948cdd92	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0xaa92ade8	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x85670f1d	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0xf7840575	page_symlink	vmlinux	EXPORT_SYMBOL
+0x61589ed8	slow_work_sleep_till_thread_needed	vmlinux	EXPORT_SYMBOL
+0x982530be	freq_reg_info	net/wireless/cfg80211	EXPORT_SYMBOL
+0xe02a06e0	nfsacl_encode	fs/nfs_common/nfs_acl	EXPORT_SYMBOL_GPL
+0x82edca96	nfsacl_decode	fs/nfs_common/nfs_acl	EXPORT_SYMBOL_GPL
+0x671c6a99	tda10045_attach	drivers/media/dvb/frontends/tda1004x	EXPORT_SYMBOL
+0x6da79ff9	tda10046_attach	drivers/media/dvb/frontends/tda1004x	EXPORT_SYMBOL
+0x60879f03	tda10048_attach	drivers/media/dvb/frontends/tda10048	EXPORT_SYMBOL
+0x273db2b6	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x74ac7375	fc_get_host_port_state	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x4c1b965c	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x9e17db1f	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x72c3be87	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x9214ed8a	param_get_bool	vmlinux	EXPORT_SYMBOL
+0xb82dcf49	rpc_call_null	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x2550c49f	fc_exch_mgr_alloc	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xc422101e	sm501_misc_control	drivers/mfd/sm501	EXPORT_SYMBOL_GPL
+0xe70cb10d	rtc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xdf0da3cc	acpi_get_devices	vmlinux	EXPORT_SYMBOL
+0xd08310bc	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x053d90dd	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0xcde0cee0	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x740a1b95	reserve_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x032d3ad1	snd_opl3_init	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0xe6fb2de4	sunrpc_cache_lookup	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x4d2a941b	parport_ieee1284_interrupt	drivers/parport/parport	EXPORT_SYMBOL
+0x6eaf055a	af9013_attach	drivers/media/dvb/frontends/af9013	EXPORT_SYMBOL
+0xdec4130f	arp_tbl	vmlinux	EXPORT_SYMBOL
+0xb4498d15	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0xf7344309	phy_attach	vmlinux	EXPORT_SYMBOL
+0x6237f6b5	acpi_enable_event	vmlinux	EXPORT_SYMBOL
+0xfe7c4287	nr_cpu_ids	vmlinux	EXPORT_SYMBOL
+0x065994f1	xdr_encode_opaque_fixed	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xe6476b4a	net_vs_ctl_path	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL_GPL
+0xd4ce1735	recv_Bchannel	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x6e912aad	rdma_translate_ip	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0x0728a71f	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x32581880	xt_unregister_match	vmlinux	EXPORT_SYMBOL
+0xf28977c1	acpiphp_unregister_attention	vmlinux	EXPORT_SYMBOL_GPL
+0x581c7592	iscsi_prep_data_out_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x7fc8652c	em28xx_tuner_callback	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL_GPL
+0x5187ac4b	xen_store_evtchn	vmlinux	EXPORT_SYMBOL
+0xad13c689	acpi_os_execute	vmlinux	EXPORT_SYMBOL
+0xfac2faa3	mptscsih_suspend	drivers/message/fusion/mptscsih	EXPORT_SYMBOL
+0xdbb5d232	videobuf_cgmbuf	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x9a9a401c	gigaset_freecs	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x47717adf	drm_agp_acquire	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4330cb07	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL
+0xcc955d2d	regulator_put	vmlinux	EXPORT_SYMBOL_GPL
+0x28b715a6	isapnp_cfg_end	vmlinux	EXPORT_SYMBOL
+0x7f7b583e	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x30f80de6	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x28edf15b	register_kretprobes	vmlinux	EXPORT_SYMBOL_GPL
+0xc426b399	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x2dbb435b	rfkill_alloc	net/rfkill/rfkill	EXPORT_SYMBOL
+0x1283e5e3	__nf_conntrack_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xd3f714e5	hermes_bap_pread	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x5fc3f121	sdio_disable_func	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x8d033df4	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0xe78f67d8	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0xd9514cce	hid_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x74146510	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0xd951d6e3	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x57065e80	k_handler	vmlinux	EXPORT_SYMBOL_GPL
+0xf863e82a	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x49a45921	fc_seq_send	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x80bf4883	mlx4_db_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x41c4a5ff	cxgb3_alloc_atid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xad87b6c8	cxgb3_alloc_stid	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0x1657a37a	drm_mm_dump_table	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x1068004b	gf128mul_bbe	crypto/gf128mul	EXPORT_SYMBOL
+0xfaab20d1	skb_icv_walk	vmlinux	EXPORT_SYMBOL_GPL
+0x7e15083b	bitmap_close_sync	vmlinux	EXPORT_SYMBOL
+0xa1469289	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0xe44ae58c	ata_sff_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x62bc1629	ima_path_check	vmlinux	EXPORT_SYMBOL_GPL
+0x04cda566	snd_interval_refine	sound/core/snd-pcm	EXPORT_SYMBOL
+0x9c144eed	p54_parse_firmware	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0xbc2776e0	hostap_master_start_xmit	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xeb02f844	videobuf_dvb_dealloc_frontends	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x004de5dd	rdev_get_drvdata	vmlinux	EXPORT_SYMBOL_GPL
+0x2b2543c0	acpi_bus_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x7d0ab9ff	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x058462c2	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0xc744075b	set_security_override	vmlinux	EXPORT_SYMBOL
+0x6b2dc060	dump_stack	vmlinux	EXPORT_SYMBOL
+0x44d091b6	nfnetlink_subsys_unregister	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0xd5336e5d	hermes_init	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x732a0b25	hdlc_change_mtu	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x29ef1ed9	mlx4_qp_to_ready	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x636af174	cnic_unregister_driver	drivers/net/cnic	EXPORT_SYMBOL
+0xb6c43cb1	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x3139087e	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL
+0x3091fd50	ata_dev_pair	vmlinux	EXPORT_SYMBOL_GPL
+0xcb54998b	scsi_dh_activate	vmlinux	EXPORT_SYMBOL_GPL
+0x44df70e6	p9_client_create	net/9p/9pnet	EXPORT_SYMBOL
+0x59fddc2b	iwl_tt_exit	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x1ae2cef8	flexcop_dma_config	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x19d9869f	drm_fb_helper_free	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xd300b16e	drm_core_reclaim_buffers	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xa3bbcd80	acpi_set_gpe_type	vmlinux	EXPORT_SYMBOL
+0x34144221	kobject_del	vmlinux	EXPORT_SYMBOL
+0xe07de3b3	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL
+0xe4a8cf22	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x547c7699	snd_ctl_find_numid	sound/core/snd	EXPORT_SYMBOL
+0xff754586	rpc_exit_task	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x3dc74f29	nat_callforwarding_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0xac87b380	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x13b2a946	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0xb6a68816	find_last_bit	vmlinux	EXPORT_SYMBOL
+0xe07d3312	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x34275124	trace_current_buffer_unlock_commit	vmlinux	EXPORT_SYMBOL_GPL
+0x32ffb8b3	unregister_console	vmlinux	EXPORT_SYMBOL
+0x43216941	snd_hda_sequence_write_cache	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x57642c82	nf_ct_helper_ext_add	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x38633ad1	usb_stor_reset_resume	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x4935ce66	edac_device_handle_ce	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xd63ee624	edac_device_handle_ue	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xcf880e86	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
+0xa8f737a2	phy_disconnect	vmlinux	EXPORT_SYMBOL
+0x1bf0d490	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0xd8e484f0	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0xc4e85ec5	ieee80211_radiotap_iterator_next	net/wireless/cfg80211	EXPORT_SYMBOL
+0x10aef335	rate_control_send_low	net/mac80211/mac80211	EXPORT_SYMBOL
+0x41adbd94	iwl_set_tx_power	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x00d2e9bd	mlx4_unregister_interface	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x58c70b92	cx88_risc_buffer	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xa575a47f	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x4845978c	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x310917fe	sort	vmlinux	EXPORT_SYMBOL
+0xa8fef7bb	security_unix_may_send	vmlinux	EXPORT_SYMBOL
+0x6c49c4f2	clockevents_notify	vmlinux	EXPORT_SYMBOL_GPL
+0xcd57ff53	snd_rawmidi_kernel_read	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x75fe54ee	fscache_io_error	fs/fscache/fscache	EXPORT_SYMBOL
+0x31734ffd	iscsi_host_remove	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x5fbc7477	ib_register_mad_snoop	drivers/infiniband/core/ib_mad	EXPORT_SYMBOL
+0xe6c1f830	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x381b48cb	ddebug_remove_module	vmlinux	EXPORT_SYMBOL_GPL
+0x4e069249	security_tun_dev_post_create	vmlinux	EXPORT_SYMBOL
+0x35654710	kern_path	vmlinux	EXPORT_SYMBOL
+0x4e52f6a1	snd_emux_new	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0x389eae4d	iscsi_destroy_conn	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x35367874	sm501_find_clock	drivers/mfd/sm501	EXPORT_SYMBOL_GPL
+0x96e01632	ib_register_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x3cacf895	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL
+0xe7b3efd1	netpoll_print_options	vmlinux	EXPORT_SYMBOL
+0x9fec351f	dma_alloc_from_coherent	vmlinux	EXPORT_SYMBOL
+0x2685c3d7	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x060c66c0	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0xedd6cbbf	ivtv_udma_alloc	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x011cacbf	ib_register_event_handler	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x69d22243	ipmi_unregister_for_cmd	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x04dfcc3d	__pci_hp_register	vmlinux	EXPORT_SYMBOL_GPL
+0x148bdd5c	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x499043d3	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0xb17af5ca	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0xe513afc0	cache_k8_northbridges	vmlinux	EXPORT_SYMBOL_GPL
+0xe4f1695e	cookie_check_timestamp	vmlinux	EXPORT_SYMBOL
+0xc722227e	posix_acl_clone	vmlinux	EXPORT_SYMBOL
+0x36abaea8	generic_drop_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x68760c4a	find_inode_number	vmlinux	EXPORT_SYMBOL
+0xe109975e	oxygen_write16_masked	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xc4a1af32	oxygen_write32_masked	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0x62676a0b	rpcb_getport_async	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbba2ddce	rfkill_init_sw_state	net/rfkill/rfkill	EXPORT_SYMBOL
+0xe26d63b0	dccp_v4_request_recv_sock	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0x6cee4bb6	hci_unregister_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x23c8f257	slhc_uncompress	drivers/net/slhc	EXPORT_SYMBOL
+0x48f08eb9	mpt_findImVolumes	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xd5f111b0	iommu_unmap_range	vmlinux	EXPORT_SYMBOL_GPL
+0x656f69c1	get_agp_version	vmlinux	EXPORT_SYMBOL
+0x69d98919	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x25665501	rt2x00mac_configure_filter	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x35fd974e	libipw_rx_any	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL_GPL
+0x46e435cd	isdn_ppp_unregister_compressor	drivers/isdn/i4l/isdn	EXPORT_SYMBOL
+0x54cd9b04	dbgp_external_startup	vmlinux	EXPORT_SYMBOL_GPL
+0xfe5d4bb2	sys_tz	vmlinux	EXPORT_SYMBOL
+0x5dde5c63	cx231xx_set_alt_setting	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x95ec0cd4	acpi_processor_preregister_performance	vmlinux	EXPORT_SYMBOL
+0x21e0ea22	acpi_get_id	vmlinux	EXPORT_SYMBOL
+0x8793979f	lock_fb_info	vmlinux	EXPORT_SYMBOL
+0xb2f684f2	blk_integrity_register	vmlinux	EXPORT_SYMBOL
+0x67ac58f6	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x4347e8ff	unlock_page	vmlinux	EXPORT_SYMBOL
+0x14dcab53	lcd_device_register	drivers/video/backlight/lcd	EXPORT_SYMBOL
+0xbf318958	sdio_memcpy_fromio	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0xbe3c09cd	cx88_set_scale	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xf0199174	cx24116_attach	drivers/media/dvb/frontends/cx24116	EXPORT_SYMBOL
+0xcc9776a0	i2c_pca_add_numbered_bus	drivers/i2c/algos/i2c-algo-pca	EXPORT_SYMBOL
+0x9e92e7d2	drm_sysfs_hotplug_event	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x09eece9e	snd_info_register	sound/core/snd	EXPORT_SYMBOL
+0x0f668ba9	svc_auth_unregister	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x8dd51359	jbd2_log_wait_commit	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xf4610b9e	iwl_rx_reply_rx	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xac549191	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x3284861d	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
+0x777aec6b	tpm_show_pubek	vmlinux	EXPORT_SYMBOL_GPL
+0x55526907	xen_features	vmlinux	EXPORT_SYMBOL_GPL
+0x93cc224c	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x773a9c94	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x3f102ba3	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0xa13798f8	printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0xa2012dca	snd_hda_load_patch	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x0283dfe3	_snd_pcm_hw_params_any	sound/core/snd-pcm	EXPORT_SYMBOL
+0xc2cadb47	memstick_free_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x5aca771e	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x6c67b8c4	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0xb4e14553	gnttab_query_foreign_access	vmlinux	EXPORT_SYMBOL_GPL
+0x95c31ff5	__copy_from_user_ll_nozero	vmlinux	EXPORT_SYMBOL
+0x28ff0c78	user_path_at	vmlinux	EXPORT_SYMBOL
+0x639487a5	module_put	vmlinux	EXPORT_SYMBOL
+0x2459bbcc	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0xfc6c1da7	uwb_rc_vcmd	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x4bd81558	fc_change_queue_type	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0xd83c54d6	rt2x00mac_stop	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0xeffa8769	libipw_freq_to_channel	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xe3ca8f0e	videobuf_dqbuf	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0xbfc9492e	dm_rh_region_to_sector	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x2f6a4314	ipmi_register_for_cmd	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xdac38f29	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
+0x5149dc2b	genphy_resume	vmlinux	EXPORT_SYMBOL
+0xdc470de9	sata_link_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x6241fd2c	acpi_install_address_space_handler	vmlinux	EXPORT_SYMBOL
+0x19c14f04	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x642e54ac	__wake_up	vmlinux	EXPORT_SYMBOL
+0x6f401998	nf_conntrack_helper_unregister	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xbda9e18e	umc_bus_type	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0x4bdcda04	srp_iu_get	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0x755c4c37	srp_iu_put	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0x3164c774	mpt_put_msg_frame_hi_pri	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xbfb8bcac	mpt_free_msg_frame	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0xf1718100	edac_device_add_device	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x15a65809	edac_device_del_device	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x55df5835	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0xd6821c79	pcie_get_readrq	vmlinux	EXPORT_SYMBOL
+0x2787db00	vbin_printf	vmlinux	EXPORT_SYMBOL_GPL
+0xc5f9f31b	security_d_instantiate	vmlinux	EXPORT_SYMBOL
+0xc2bc4b1e	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x959b9d22	osd_start_request	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x50e438f3	drm_sysfs_connector_remove	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x218ea71d	cryptd_free_ahash	crypto/cryptd	EXPORT_SYMBOL_GPL
+0xba6b00cc	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x9cfd56c5	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x740c57fd	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x01139ffc	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x0ec210b8	xen_start_info	vmlinux	EXPORT_SYMBOL_GPL
+0x129b81ba	snd_opl3_reset	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0xf2e5e3e6	xprt_unregister_transport	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x61be0460	wlp_dev_prim_category_store	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x9dba972c	iscsi_conn_failure	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xd9a7fbfd	mISDN_FsmInitTimer	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x62a01747	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
+0xa437fa7d	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x80b72b31	snd_pcm_mmap_data	sound/core/snd-pcm	EXPORT_SYMBOL
+0x03670aae	wiphy_new	net/wireless/cfg80211	EXPORT_SYMBOL
+0xa0b8168a	dccp_insert_option	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x938967fb	mb_cache_create	fs/mbcache	EXPORT_SYMBOL
+0x870b5017	wusbhc_rh_start_port_reset	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xe0adc4ce	wl1251_init_ieee80211	drivers/net/wireless/wl12xx/wl1251	EXPORT_SYMBOL_GPL
+0x3656fa84	v4l2_int_ioctl_1	drivers/media/video/v4l2-int-device	EXPORT_SYMBOL_GPL
+0x6cbb9f72	dm_requeue_unmapped_request	drivers/md/dm-mod	EXPORT_SYMBOL_GPL
+0x409c58e7	gigaset_m10x_send_skb	drivers/isdn/gigaset/gigaset	EXPORT_SYMBOL_GPL
+0x22376362	hid_dump_input	vmlinux	EXPORT_SYMBOL_GPL
+0x8a4ec59b	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0xb27510ef	atomic64_inc_return	vmlinux	EXPORT_SYMBOL
+0x90ebca40	securityfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0xf53c0b64	inotify_find_update_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x70535e48	iunique	vmlinux	EXPORT_SYMBOL
+0x01a4ea6d	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x308ad6fb	snd_ac97_tune_hardware	sound/pci/ac97/snd-ac97-codec	EXPORT_SYMBOL
+0xd5263820	mb_cache_destroy	fs/mbcache	EXPORT_SYMBOL
+0x686de290	restore_vga	drivers/video/vgastate	EXPORT_SYMBOL
+0x5614b010	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x310e5bb6	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x4f5a882a	input_release_device	vmlinux	EXPORT_SYMBOL
+0x656c428a	ata_dev_next	vmlinux	EXPORT_SYMBOL_GPL
+0x5e1d8bf1	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x1830ef5f	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x32be8397	tda8261_attach	drivers/media/dvb/frontends/tda8261	EXPORT_SYMBOL
+0x0903c239	vid_from_reg	drivers/hwmon/hwmon-vid	EXPORT_SYMBOL
+0x99bfbe39	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x1dee2629	trace_current_buffer_lock_reserve	vmlinux	EXPORT_SYMBOL_GPL
+0xb84ed32f	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0xc931a03d	ieee80211_bss_get_ie	net/wireless/cfg80211	EXPORT_SYMBOL
+0x7b594080	rt2x00mac_set_tim	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x4b451dd8	isac_setup	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0x5998aa56	drm_fb_helper_blank	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x536173c5	drm_connector_attach_property	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3350fda5	drm_vblank_post_modeset	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xccb07665	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x088d0187	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x307088ab	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
+0xec408268	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0xc366fd33	pci_renumber_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x61051d0b	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0xca535e71	sas_ssp_task_response	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0xcbca1b63	dvb_usb_generic_rw	drivers/media/dvb/dvb-usb/dvb-usb	EXPORT_SYMBOL
+0x8651925b	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL
+0x30cec629	ata_pci_bmdma_clear_simplex	vmlinux	EXPORT_SYMBOL_GPL
+0x85c10896	rcu_batches_completed_bh	vmlinux	EXPORT_SYMBOL_GPL
+0xcc7fa952	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x2e75863a	isl6405_attach	drivers/media/dvb/frontends/isl6405	EXPORT_SYMBOL
+0xa7781a32	dibusb_pid_filter	drivers/media/dvb/dvb-usb/dvb-usb-dibusb-common	EXPORT_SYMBOL
+0xf8dec080	tt_msgs	drivers/edac/edac_mce_amd	EXPORT_SYMBOL_GPL
+0x51d33f0f	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x6710e9f5	udp_poll	vmlinux	EXPORT_SYMBOL
+0x48e499d0	pci_hp_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x3adc15b9	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL
+0x51ef33b8	kstrndup	vmlinux	EXPORT_SYMBOL
+0x20527511	console_stop	vmlinux	EXPORT_SYMBOL
+0xa2b6f54a	snd_device_register	sound/core/snd	EXPORT_SYMBOL
+0xda86da74	nf_conntrack_tuple_taken	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x0bf10295	inet6_getname	net/ipv6/ipv6	EXPORT_SYMBOL
+0x0488833c	mfd_add_devices	drivers/mfd/mfd-core	EXPORT_SYMBOL
+0x2a5417a0	b1_load_config	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x92a9d2d6	ib_find_cached_pkey	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x67e2d22e	rdma_copy_addr	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0x1562912c	sata_pmp_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x41c8ba06	xdr_encode_word	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x41412631	auth_domain_find	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x45eb36c5	rds_message_put	net/rds/rds	EXPORT_SYMBOL_GPL
+0xdca34e57	eip_set_multicast_list	drivers/net/8390p	EXPORT_SYMBOL
+0x38753714	acpi_smbus_register_callback	drivers/acpi/sbshc	EXPORT_SYMBOL_GPL
+0x182ae9e0	register_mtd_user	vmlinux	EXPORT_SYMBOL_GPL
+0x4fdc945d	sata_deb_timing_normal	vmlinux	EXPORT_SYMBOL_GPL
+0xa3a6c0d5	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x8ed513dc	new_inode	vmlinux	EXPORT_SYMBOL
+0x786e9c37	snd_ctl_find_id	sound/core/snd	EXPORT_SYMBOL
+0xd0123178	rpc_restart_call_prepare	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x89e773d5	rds_send_get_message	net/rds/rds	EXPORT_SYMBOL_GPL
+0xf7edd144	jbd2_journal_clear_err	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x05f97e36	__uio_register_device	drivers/uio/uio	EXPORT_SYMBOL_GPL
+0xedde6df2	ks0108_page	drivers/auxdisplay/ks0108	EXPORT_SYMBOL_GPL
+0x28a2ed02	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x5077809b	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x120507ac	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x8969b997	ida_get_new	vmlinux	EXPORT_SYMBOL
+0xe0b13336	argv_free	vmlinux	EXPORT_SYMBOL
+0x3455711e	p9_idpool_destroy	net/9p/9pnet	EXPORT_SYMBOL
+0x04e133fc	iTCO_vendor_check_noreboot_on	drivers/watchdog/iTCO_vendor_support	EXPORT_SYMBOL
+0x9fcb1ffe	mmc_suspend_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x9f046e2e	memstick_remove_host	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xd30c491f	ir_codes_norwood_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x390a0112	ttm_bo_clean_mm	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x0f38e99b	ipmi_get_maintenance_mode	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0x49439411	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0xfe769456	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x90c3d66c	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x8fde5204	slab_buffer_size	vmlinux	EXPORT_SYMBOL
+0x397d3d4d	sdio_release_host	drivers/mmc/core/mmc_core	EXPORT_SYMBOL_GPL
+0x3affe8e2	memstick_unregister_driver	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0xe0cb7753	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x838d5156	kset_unregister	vmlinux	EXPORT_SYMBOL
+0xe54f2149	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x9d3b3c55	llc_build_and_send_ui_pkt	net/llc/llc	EXPORT_SYMBOL
+0x1288358a	jbd2_journal_release_jbd_inode	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x0ef06974	spi_populate_ppr_msg	drivers/scsi/scsi_transport_spi	EXPORT_SYMBOL_GPL
+0xa3af44e9	hostap_remove_interface	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0xa6bbb7ab	eip_netdev_ops	drivers/net/8390p	EXPORT_SYMBOL
+0x47e38514	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x65d8ed45	ata_pio_queue_task	vmlinux	EXPORT_SYMBOL_GPL
+0x3d794d86	generic_detach_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x7ab6d569	iwl_hw_txq_ctx_free	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xee63568b	__alloc_ei_netdev	drivers/net/8390	EXPORT_SYMBOL
+0x0bb7deac	wm8400_reset_codec_reg_cache	drivers/mfd/wm8400-core	EXPORT_SYMBOL_GPL
+0x933dfb43	videobuf_vmalloc_to_sg	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x36f51998	videobuf_queue_sg_init	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x6ab36e98	ttpci_budget_debiwrite	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0x7c3c40ec	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x49603fb8	security_sb_copy_data	vmlinux	EXPORT_SYMBOL
+0xe039d4a8	user_read	vmlinux	EXPORT_SYMBOL_GPL
+0x53326531	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x27d8d45e	trace_define_field	vmlinux	EXPORT_SYMBOL_GPL
+0x267fc65b	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0xd365cd63	read_bytes_from_xdr_buf	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5ac66bf1	wlp_wss_remove	drivers/uwb/wlp/wlp	EXPORT_SYMBOL_GPL
+0x458c4233	cx24123_get_tuner_i2c_adapter	drivers/media/dvb/frontends/cx24123	EXPORT_SYMBOL
+0xf295a688	arp_send	vmlinux	EXPORT_SYMBOL
+0xef0367a2	xt_register_matches	vmlinux	EXPORT_SYMBOL
+0x873fbaea	edac_atomic_assert_error	vmlinux	EXPORT_SYMBOL_GPL
+0x13c745e9	sata_sff_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x3ed63055	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0xb19760c3	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x3e6dcf1e	cdev_del	vmlinux	EXPORT_SYMBOL
+0xf11fdbde	dccp_parse_options	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x04c348a6	ssb_driver_unregister	drivers/ssb/ssb	EXPORT_SYMBOL
+0xef74e5f6	raid_component_add	drivers/scsi/raid_class	EXPORT_SYMBOL
+0x3ecf6cfc	wmi_install_notify_handler	drivers/platform/x86/wmi	EXPORT_SYMBOL_GPL
+0x9670af2c	gspca_debug	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x07cf5a51	ib_copy_ah_attr_to_user	drivers/infiniband/core/ib_uverbs	EXPORT_SYMBOL
+0x184f3575	ib_copy_qp_attr_to_user	drivers/infiniband/core/ib_uverbs	EXPORT_SYMBOL
+0x6f2c94fa	async_xor	crypto/async_tx/async_xor	EXPORT_SYMBOL_GPL
+0x35afb9b8	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0xea99bfd1	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x0924c3c4	soft_cursor	vmlinux	EXPORT_SYMBOL
+0x1d30b70c	rwsem_wake	vmlinux	EXPORT_SYMBOL
+0x4a0062e0	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0xcf48469f	snd_ice1712_akm4xxx_free	sound/pci/ice1712/snd-ice17xx-ak4xxx	EXPORT_SYMBOL
+0x39d3d31e	iwlcore_eeprom_verify_signature	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x49d7767a	i2400m_release	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0xc248d772	dm_rh_dec	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x73baafcf	hisax_init_pcmcia	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0xf5ba3c4b	pcmcia_release_window	vmlinux	EXPORT_SYMBOL
+0xf1fa9bbf	vga_get	vmlinux	EXPORT_SYMBOL
+0x450f1050	pnp_find_card	vmlinux	EXPORT_SYMBOL
+0x1a35e476	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0xa415b384	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x77831f60	snd_hda_ch_mode_get	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xe5494a73	ipcomp_output	net/xfrm/xfrm_ipcomp	EXPORT_SYMBOL_GPL
+0xd099bd51	svc_addsock	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x09b0b5d7	nf_ct_expect_related_report	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x4cdd391d	dccp_feat_list_purge	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x36c9f053	usb_stor_bulk_transfer_buf	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xb4b94377	__nand_correct_data	drivers/mtd/nand/nand_ecc	EXPORT_SYMBOL
+0x0b7e0c72	dm_unregister_target	drivers/md/dm-mod	EXPORT_SYMBOL
+0x29562993	b1pcmcia_delcard	drivers/isdn/hardware/avm/b1pcmcia	EXPORT_SYMBOL
+0xb108c40e	dma_async_memcpy_buf_to_pg	vmlinux	EXPORT_SYMBOL
+0xdc7c6cae	isa_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x0545e389	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x23ccb2f4	xenbus_map_ring_valloc	vmlinux	EXPORT_SYMBOL_GPL
+0xc725cbcc	pci_enable_device_io	vmlinux	EXPORT_SYMBOL
+0x9789d55f	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x7d671ce9	snd_seq_device_register_driver	sound/core/seq/snd-seq-device	EXPORT_SYMBOL
+0x0fa393f2	jbd2_journal_revoke	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xdfe52016	config_group_find_item	fs/configfs/configfs	EXPORT_SYMBOL
+0x022e803c	dvb_dmx_release	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x8dee1f63	ata_sas_port_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0xb595a780	pm_runtime_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00fe1a89	pm_request_idle	vmlinux	EXPORT_SYMBOL_GPL
+0x3145216f	pci_dev_present	vmlinux	EXPORT_SYMBOL
+0xf7513332	pci_dev_get	vmlinux	EXPORT_SYMBOL
+0x0f034e92	pci_dev_put	vmlinux	EXPORT_SYMBOL
+0x763aca8a	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x3e453141	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0xbe7dd7dc	snd_array_new	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x8ddc67ba	journal_create	fs/jbd/jbd	EXPORT_SYMBOL
+0x99cd504a	srp_target_free	drivers/scsi/libsrp	EXPORT_SYMBOL_GPL
+0xebc88484	lpddr_cmdset	drivers/mtd/lpddr/lpddr_cmds	EXPORT_SYMBOL
+0x33ea698f	sms_board_power	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xbd3ce6f0	ir_codes_avermedia_cardbus_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x845c3378	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
+0x2cb970bd	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
+0x60a0ebad	__tracepoint_kmem_cache_alloc_node	vmlinux	EXPORT_SYMBOL
+0x6d332729	ring_buffer_record_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x7f4ba8bc	snd_rawmidi_transmit	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0x07440384	inet6_destroy_sock	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x74133bcb	mb_cache_entry_release	fs/mbcache	EXPORT_SYMBOL
+0xfdfc13f2	iscsi_tcp_cleanup_task	drivers/scsi/libiscsi_tcp	EXPORT_SYMBOL_GPL
+0x3df760df	enclosure_find	drivers/misc/enclosure	EXPORT_SYMBOL_GPL
+0xd4b57c7f	fw_cancel_transaction	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x2acc9f2a	cdrom_mode_sense	drivers/cdrom/cdrom	EXPORT_SYMBOL
+0xaef57de0	phy_device_create	vmlinux	EXPORT_SYMBOL
+0x061651be	strcat	vmlinux	EXPORT_SYMBOL
+0xebf00dda	qtree_delete_dquot	vmlinux	EXPORT_SYMBOL
+0xf4f52f93	dqstats	vmlinux	EXPORT_SYMBOL
+0x32f8747f	bio_integrity_set_tag	vmlinux	EXPORT_SYMBOL
+0x7449e743	bio_integrity_get_tag	vmlinux	EXPORT_SYMBOL
+0xbc9e9714	jbd2_journal_get_write_access	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x188e78f3	jbd2_journal_invalidatepage	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xcf39ff86	iscsi_conn_send_pdu	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xe8ad9bd1	capi_cmsg2str	drivers/isdn/capi/kernelcapi	EXPORT_SYMBOL
+0x5709c945	ib_query_qp	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xc7d059ad	xenbus_free_evtchn	vmlinux	EXPORT_SYMBOL_GPL
+0xd53e5cc3	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x5c1b4f54	rds_conn_drop	net/rds/rds	EXPORT_SYMBOL_GPL
+0xa1dbc2d8	ip_vs_proto_name	net/netfilter/ipvs/ip_vs	EXPORT_SYMBOL
+0xda39e234	inet6_unregister_protosw	net/ipv6/ipv6	EXPORT_SYMBOL
+0x3dcf6da2	uwb_phy_rate_store	drivers/uwb/i1480/i1480u-wlp/i1480u-wlp	EXPORT_SYMBOL_GPL
+0xb623f97d	fc_fabric_login	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x1c919b72	nf_register_hooks	vmlinux	EXPORT_SYMBOL
+0xba99e5ef	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
+0xd5688a7a	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x88beda13	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0xb11acdad	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0xf5384ac1	__trace_printk	vmlinux	EXPORT_SYMBOL_GPL
+0x87ce6a3c	snd_wss_chip_id	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xb8e448a0	snd_seq_set_queue_tempo	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0xacc2023a	ieee80211_tx_status	net/mac80211/mac80211	EXPORT_SYMBOL
+0x0b18cd29	dccp_v4_do_rcv	net/dccp/dccp_ipv4	EXPORT_SYMBOL_GPL
+0xef63fd1d	usbnet_defer_kevent	drivers/net/usb/usbnet	EXPORT_SYMBOL_GPL
+0xe2b92059	v4l2_video_std_construct	drivers/media/video/videodev	EXPORT_SYMBOL
+0x31c05ffe	ib_dispatch_event	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x4c33664e	ttm_bo_unreserve	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x866006e8	drm_agp_info	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x388f9128	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x8ebac06a	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0xcf7dc995	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x08c665b6	key_put	vmlinux	EXPORT_SYMBOL
+0xdfc46fb0	get_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x15a5b59d	bmap	vmlinux	EXPORT_SYMBOL
+0xe2fae716	kmemdup	vmlinux	EXPORT_SYMBOL
+0xaeb7f977	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x4e17f07a	dccp_sync_mss	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x3d9fec31	hostap_get_porttype	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x1d7039e8	drm_mode_vrefresh	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x4934d03f	drm_mode_set_crtcinfo	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x41645943	snd_wss_overrange	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xa7f2da59	nf_conntrack_alloc	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x7556b6da	uwb_notifs_register	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x43f5fe11	__umc_driver_register	drivers/uwb/umc	EXPORT_SYMBOL_GPL
+0x15ab1dc5	__ssb_driver_register	drivers/ssb/ssb	EXPORT_SYMBOL
+0x3b1e9b4f	iscsi_host_free	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0xf479e73a	dib7000p_set_wbd_ref	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x9c44c5dc	tda827x_attach	drivers/media/common/tuners/tda827x	EXPORT_SYMBOL_GPL
+0x404bd755	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x4d2cd3bc	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x7befbb95	register_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x59c833ff	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0xde75ba41	stv0299_attach	drivers/media/dvb/frontends/stv0299	EXPORT_SYMBOL
+0xa203ba3f	stb0899_attach	drivers/media/dvb/frontends/stb0899	EXPORT_SYMBOL
+0xd7a4f5e6	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x3b96135a	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x91aef823	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL
+0xae423331	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x93e72105	do_munmap	vmlinux	EXPORT_SYMBOL
+0xd0b9b8b8	snd_interval_list	sound/core/snd-pcm	EXPORT_SYMBOL
+0xcb1276e8	fuse_put_request	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x177f0adf	fat_flush_inodes	fs/fat/fat	EXPORT_SYMBOL_GPL
+0xbd9df40b	mmc_align_data_size	drivers/mmc/core/mmc_core	EXPORT_SYMBOL
+0x6427a3fb	ir_codes_pinnacle_grey_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x66e7c489	ib_dealloc_pd	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xa6efbeb0	drm_fb_helper_fill_var	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0xc48e9d95	cfag12864b_buffer	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0x6c8eb98f	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0xa2e7f6ab	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x3d73e486	pci_fixup_device	vmlinux	EXPORT_SYMBOL
+0x255dcbb4	snd_trident_write_voice_regs	sound/pci/trident/snd-trident	EXPORT_SYMBOL
+0x94d8eb36	snd_vx_load_boot_image	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xee06eaa6	sm501_unit_power	drivers/mfd/sm501	EXPORT_SYMBOL_GPL
+0xe27d8951	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x36d03196	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x2d967fb7	i8042_check_port_owner	vmlinux	EXPORT_SYMBOL
+0x09c55cec	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x361e2bcc	save_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x9d6bbeec	snd_ctl_make_virtual_master	sound/core/snd	EXPORT_SYMBOL
+0x0e0cdc69	wm8350_register_led	drivers/regulator/wm8350-regulator	EXPORT_SYMBOL_GPL
+0x768ad0f1	hdlc_ioctl	drivers/net/wan/hdlc	EXPORT_SYMBOL
+0x1ace138d	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x250113b4	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x7ecc463b	hci_alloc_dev	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xaa387478	ib_send_cm_req	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x7dc29c4d	ib_send_cm_rep	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x4c7b753c	ib_send_cm_rtu	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x58f8c94b	ib_send_cm_rej	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0xbb5d343d	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x7f19c836	unlock_policy_rwsem_write	vmlinux	EXPORT_SYMBOL_GPL
+0xd5326a2e	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x541dfef4	atomic64_inc	vmlinux	EXPORT_SYMBOL
+0xc6ff2027	svc_reserve	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbee28f6e	cx88_wakeup	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xc7e18ebf	fw_device_enable_phys_dma	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x03b784aa	bitmap_cond_end_sync	vmlinux	EXPORT_SYMBOL
+0xa8077323	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x42f8825b	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x5f442a62	snd_ice1712_akm4xxx_init	sound/pci/ice1712/snd-ice17xx-ak4xxx	EXPORT_SYMBOL
+0x3408e5ce	journal_restart	fs/jbd/jbd	EXPORT_SYMBOL
+0xc16583c4	journal_destroy	fs/jbd/jbd	EXPORT_SYMBOL
+0x85723039	iscsi_host_for_each_session	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0xcc077a0d	nand_scan_ident	drivers/mtd/nand/nand	EXPORT_SYMBOL_GPL
+0x0248f99b	netpoll_setup	vmlinux	EXPORT_SYMBOL
+0x8a948ff0	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0xd43e53fc	ata_port_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x2b0ba2b0	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x06fe3b14	default_grn	vmlinux	EXPORT_SYMBOL
+0x5857b225	ioread16_rep	vmlinux	EXPORT_SYMBOL
+0x6ef8fcd8	snd_pcm_format_linear	sound/core/snd-pcm	EXPORT_SYMBOL
+0x5d2d7efb	ieee80211_rate_control_unregister	net/mac80211/mac80211	EXPORT_SYMBOL
+0x491459ce	inet6_ioctl	net/ipv6/ipv6	EXPORT_SYMBOL
+0x712fb91b	fuse_get_req	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x61ada9d8	osd_req_add_set_attr_list	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xe99421d1	osd_req_add_get_attr_list	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0xb63bd21b	iwl_pci_suspend	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xc510bca3	hostap_setup_dev	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x42d7ddf0	ves1820_attach	drivers/media/dvb/frontends/ves1820	EXPORT_SYMBOL
+0xf324962a	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x34540306	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0xdfdccab7	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0xb1d1d77d	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0xc633495b	schedule_work	vmlinux	EXPORT_SYMBOL
+0x9d857350	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0xbff2c68f	display_device_unregister	drivers/video/display/display	EXPORT_SYMBOL
+0x20eeeba4	rt2x00mac_start	drivers/net/wireless/rt2x00/rt2x00lib	EXPORT_SYMBOL_GPL
+0x3b53ab19	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0xb98a857a	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x46bd3bd2	agp_generic_destroy_page	vmlinux	EXPORT_SYMBOL
+0xd1e1757d	acpi_get_hp_hw_control_from_firmware	vmlinux	EXPORT_SYMBOL
+0xebae2c37	crypto_ablkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0xe101b4ba	ip6t_register_table	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL
+0x7038f0b2	mlx4_qp_alloc	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xd61253a8	tveeprom_hauppauge_analog	drivers/media/video/tveeprom	EXPORT_SYMBOL
+0x0f29ade2	cx8800_ctrl_query	drivers/media/video/cx88/cx8800	EXPORT_SYMBOL
+0x92d1d181	ir_codes_flyvideo_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xd17ba9d1	ib_ud_header_init	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x100e3f0d	xfrm_bundle_ok	vmlinux	EXPORT_SYMBOL
+0x0067df75	ata_tf_from_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x6478134c	ec_burst_enable	vmlinux	EXPORT_SYMBOL
+0x1c2e045f	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0xc7ec11f6	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0xd46dc777	lbs_process_rxed_packet	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0x4c046f84	cx22702_attach	drivers/media/dvb/frontends/cx22702	EXPORT_SYMBOL
+0xb55f1a7f	nsc_gpio_dump	drivers/char/nsc_gpio	EXPORT_SYMBOL
+0x1d62007b	backlight_device_unregister	vmlinux	EXPORT_SYMBOL
+0x2491739f	rfkill_blocked	net/rfkill/rfkill	EXPORT_SYMBOL
+0xa92ddcd7	dccp_recvmsg	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x72c2992e	ir_codes_powercolor_real_angel_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x9df0cd27	FsmEvent	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x85ea4a60	ipmi_get_my_address	drivers/char/ipmi/ipmi_msghandler	EXPORT_SYMBOL
+0xfc02b7ad	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0xa7ae721f	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
+0x94c99114	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x9e03748e	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x57dc9184	unregister_mtd_user	vmlinux	EXPORT_SYMBOL_GPL
+0xc8e26327	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x749d1fe5	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x300b0745	usb_stor_pre_reset	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0xe98a5f6a	lbs_queue_event	drivers/net/wireless/libertas/libertas	EXPORT_SYMBOL_GPL
+0xbad74610	hostap_set_antsel	drivers/net/wireless/hostap/hostap	EXPORT_SYMBOL
+0x5d820a02	memstick_init_req_sg	drivers/memstick/core/memstick	EXPORT_SYMBOL
+0x04f0647f	videobuf_sg_dma_map	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x97c35dab	ir_codes_msi_tvanywhere_plus_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xc62fbe37	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x8624f4b8	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x2c6488fc	md_write_end	vmlinux	EXPORT_SYMBOL
+0xde75b689	set_irq_type	vmlinux	EXPORT_SYMBOL
+0x76dc1495	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x17d0ffd6	mce_chrdev_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x6219bc88	snd_hda_multi_out_dig_open	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xa286a234	snd_pcm_format_name	sound/core/snd-pcm	EXPORT_SYMBOL_GPL
+0xad7822de	cx88_dsp_detect_stereo_sap	drivers/media/video/cx88/cx88xx	EXPORT_SYMBOL
+0xf868502e	edac_mc_handle_ce	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x64316f87	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0xdbdb48f8	tty_insert_flip_string	vmlinux	EXPORT_SYMBOL
+0xab770678	rdmsr_safe_regs_on_cpu	vmlinux	EXPORT_SYMBOL
+0xfba0c2e0	llc_sap_list_lock	net/llc/llc	EXPORT_SYMBOL
+0x52dd7510	nf_nat_proto_find_get	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL_GPL
+0xb2a6f3c5	tifm_has_ms_pif	drivers/misc/tifm_core	EXPORT_SYMBOL
+0xfe9ff311	drm_fb_helper_add_connector	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x7f2c4946	unregister_pernet_gen_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0xbb99125c	get_default_font	vmlinux	EXPORT_SYMBOL
+0x3ae4424f	blk_get_request	vmlinux	EXPORT_SYMBOL
+0xfd492226	cfg80211_inform_bss	net/wireless/cfg80211	EXPORT_SYMBOL
+0x69084ddc	iwl_scan_cancel_timeout	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xcd21a386	sms_board_lna_control	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xd0c595e6	ttm_bo_device_init	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x40d46b21	crypto_ft_tab	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0x3dc916b6	crypto_fl_tab	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0x0cc1e40f	crypto_it_tab	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0x71dc9998	crypto_il_tab	crypto/aes_generic	EXPORT_SYMBOL_GPL
+0x6e7474fc	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x2f6d4d80	__cpufreq_driver_getavg	vmlinux	EXPORT_SYMBOL_GPL
+0x2005e68a	acpi_remove_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x424cbddd	down_timeout	vmlinux	EXPORT_SYMBOL
+0x10452bc1	xprt_update_rtt	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xeca95329	nfnetlink_has_listeners	net/netfilter/nfnetlink	EXPORT_SYMBOL_GPL
+0xd4da6d0e	ieee80211_get_tkip_key	net/mac80211/mac80211	EXPORT_SYMBOL
+0x87b0c420	__fscache_attr_changed	fs/fscache/fscache	EXPORT_SYMBOL
+0x2f11a149	cpufreq_frequency_table_target	vmlinux	EXPORT_SYMBOL_GPL
+0xaebb9957	ata_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x3bd1b1f6	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x4033b4ae	snd_pcm_suspend_all	sound/core/snd-pcm	EXPORT_SYMBOL
+0xdf1a5ef6	vmbus_loglevel	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL
+0xd8e1baa8	iwl_reset_qos	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x7c5fcfb2	wm8350_clear_bits	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0xb39d07f3	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x78492e95	acpi_match_device_ids	vmlinux	EXPORT_SYMBOL
+0x1ceb43a9	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x89ef97ee	relay_buf_full	vmlinux	EXPORT_SYMBOL_GPL
+0x009d258f	_write_lock	vmlinux	EXPORT_SYMBOL
+0xfe138b0c	set_pages_x	vmlinux	EXPORT_SYMBOL
+0x10621889	hpet_rtc_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x7afc9d8a	unregister_sound_mixer	sound/soundcore	EXPORT_SYMBOL
+0xd3ec22d2	inet6_bind	net/ipv6/ipv6	EXPORT_SYMBOL
+0x946bb1d9	ssb_dma_alloc_consistent	drivers/ssb/ssb	EXPORT_SYMBOL
+0x6e45ec25	iwl_rxon_add_station	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x514529ed	edac_pci_create_generic_ctl	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0x3e45e9ff	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x9c012508	fb_parse_edid	vmlinux	EXPORT_SYMBOL
+0x71c8bc95	kgdb_unregister_io_module	vmlinux	EXPORT_SYMBOL_GPL
+0x0b2d50ec	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x94f2a445	snd_pcm_lib_write	sound/core/snd-pcm	EXPORT_SYMBOL
+0xb2d14901	journal_wipe	fs/jbd/jbd	EXPORT_SYMBOL
+0x1611b53a	parport_pc_unregister_port	drivers/parport/parport_pc	EXPORT_SYMBOL
+0x60774702	iwl_queue_space	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xae0627b1	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x696b602d	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0xb1e181d6	ieee80211_data_to_8023	net/wireless/cfg80211	EXPORT_SYMBOL
+0x08b4b308	nf_nat_sdp_session_hook	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0x1e5d0188	bt_accept_enqueue	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x5e97bf42	fc_host_post_vendor_event	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xee1e40f3	orinoco_if_add	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x9e4ae9d9	v4l2_device_register_subdev	drivers/media/video/videodev	EXPORT_SYMBOL_GPL
+0xf067ef32	sms_board_led_feedback	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0xc6e06c40	lgdt330x_attach	drivers/media/dvb/frontends/lgdt330x	EXPORT_SYMBOL
+0x1000f096	lgdt3305_attach	drivers/media/dvb/frontends/lgdt3305	EXPORT_SYMBOL
+0x4a667fd4	pcmcia_parse_events	vmlinux	EXPORT_SYMBOL
+0x68daaff2	pci_set_mwi	vmlinux	EXPORT_SYMBOL
+0x5737075a	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x7485e15e	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0xa01144fa	generic_writepages	vmlinux	EXPORT_SYMBOL
+0xaec89aaa	register_8022_client	net/802/p8022	EXPORT_SYMBOL
+0x1508d1f1	sms_board_event	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x3ce8f753	bcm3510_attach	drivers/media/dvb/frontends/bcm3510	EXPORT_SYMBOL
+0xebf345b4	ir_codes_encore_enltv2_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x271cba95	acpi_bus_private_data_handler	vmlinux	EXPORT_SYMBOL
+0xa01c888f	gpiochip_is_requested	vmlinux	EXPORT_SYMBOL_GPL
+0x54aa77bd	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0xd8282ff0	posix_acl_equiv_mode	vmlinux	EXPORT_SYMBOL
+0x5e4bc088	__uwb_addr_print	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xfe2e17d7	wusb_et_name	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0x3c558e37	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0xe484e35f	ioread32	vmlinux	EXPORT_SYMBOL
+0xdcec325c	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x77a57db7	osd_req_read_kern	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x1877a40a	videobuf_dvb_alloc_frontend	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x04dd92ce	fw_core_add_descriptor	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0x8c7770fa	btmrvl_remove_card	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0x14090d31	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x8d12b3e9	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x9a9985be	percpu_counter_destroy	vmlinux	EXPORT_SYMBOL
+0xe208754c	create_mnt_ns	vmlinux	EXPORT_SYMBOL
+0xe3ae7cfa	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0xe54cd4b5	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x349a27ef	oxygen_read8	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xd0566182	tveeprom_read	drivers/media/video/tveeprom	EXPORT_SYMBOL
+0x1ca0c084	cx2341x_log_status	drivers/media/video/cx2341x	EXPORT_SYMBOL
+0x1d8e33ba	dm_io_client_resize	drivers/md/dm-mod	EXPORT_SYMBOL
+0xfbccd602	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x4e7ededb	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x87982fea	hidinput_report_event	vmlinux	EXPORT_SYMBOL_GPL
+0x2d45bcda	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x33871a15	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0xef6d2ea4	snd_hda_codec_new	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x404bdf88	rpc_call_async	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x17b86ed9	iwl_remove_default_wep_key	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x9a293192	read_dst	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x246650bc	t1pci_detect	drivers/isdn/hardware/avm/b1dma	EXPORT_SYMBOL
+0x57946ad0	alloc_fddidev	vmlinux	EXPORT_SYMBOL
+0xccfbbb80	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x54935666	acpi_os_read_port	vmlinux	EXPORT_SYMBOL
+0x5a1e7e0b	pci_unblock_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0xa9126bff	hpet_set_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0xb53ae573	cpu_idle_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x4b6d3b48	__uwb_rc_try_get	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0xad2fe38b	btcx_sort_clips	drivers/media/video/btcx-risc	EXPORT_SYMBOL
+0x760b437a	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x7864cb34	ata_sff_exec_command	vmlinux	EXPORT_SYMBOL_GPL
+0x81b5a381	hvc_instantiate	vmlinux	EXPORT_SYMBOL_GPL
+0x89d5538d	fb_pad_aligned_buffer	vmlinux	EXPORT_SYMBOL
+0x334eef98	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x842d376c	iwlcore_eeprom_acquire_semaphore	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xe66abe51	agp_generic_mask_memory	vmlinux	EXPORT_SYMBOL
+0x558b5d48	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0xd3f74cf1	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x8b5f4a2e	IO_APIC_get_PCI_irq_vector	vmlinux	EXPORT_SYMBOL
+0xd54998dc	snd_cs4236_ext_out	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x5d224a69	iscsi_register_transport	drivers/scsi/scsi_transport_iscsi	EXPORT_SYMBOL_GPL
+0x3738beac	eip_tx_timeout	drivers/net/8390p	EXPORT_SYMBOL
+0xfadf13ab	eip_poll	drivers/net/8390p	EXPORT_SYMBOL
+0x43d81cb5	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x58cc3d5d	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0xb8b17165	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0xa35c1f05	acpi_extract_package	vmlinux	EXPORT_SYMBOL
+0x4211c3c1	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x6ad065f4	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x06be4cf3	snd_wss_get_pcm_ops	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0xd5abc5a3	iscsi_session_failure	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x67db58a9	vlan_gro_frags	vmlinux	EXPORT_SYMBOL
+0x30e4e473	blk_plug_device_unlocked	vmlinux	EXPORT_SYMBOL
+0x96c74ea4	bio_free	vmlinux	EXPORT_SYMBOL
+0x3c6c45ca	__tracepoint_power_frequency	vmlinux	EXPORT_SYMBOL_GPL
+0x13970066	uwb_rsv_create	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x4c456983	iwl_connection_init_rx_config	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x8e72b37c	iwl_init_drv	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x6e070f7a	iwl_send_bt_config	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x78f64e19	libipw_rx	drivers/net/wireless/ipw2x00/libipw	EXPORT_SYMBOL
+0xef1c781c	vid_which_vrm	drivers/hwmon/hwmon-vid	EXPORT_SYMBOL
+0x81313287	fb_sys_read	vmlinux	EXPORT_SYMBOL_GPL
+0x3be7643e	security_xfrm_policy_free	vmlinux	EXPORT_SYMBOL
+0x3b041526	xip_file_read	vmlinux	EXPORT_SYMBOL_GPL
+0x8df3789f	snd_oss_info_register	sound/core/snd	EXPORT_SYMBOL
+0x0471bbc7	wpan_phy_unregister	net/ieee802154/wpan-class	EXPORT_SYMBOL
+0xdd855e72	fuse_request_alloc	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x6a927e18	orinoco_interrupt	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0x76ba9a9a	v4l2_prio_open	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x6bdcfd99	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL
+0xf77e3b30	__put_net	vmlinux	EXPORT_SYMBOL_GPL
+0xb86169c2	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x31a26df8	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x9958c138	iwl_activate_qos	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xdba35044	ttm_bo_move_ttm	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x0b87139b	lro_flush_pkt	vmlinux	EXPORT_SYMBOL
+0x34f44171	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0xa7046549	vprintk	vmlinux	EXPORT_SYMBOL
+0x2e2ce9e0	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x83e3023b	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x954cbb26	vsprintf	vmlinux	EXPORT_SYMBOL
+0x5b8ff06c	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0xd28c50db	videobuf_dvb_get_frontend	drivers/media/video/videobuf-dvb	EXPORT_SYMBOL
+0x96d022a2	gspca_resume	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0x07787990	ttm_bo_global_release	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0xec24f5f1	drm_lock_free	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xca078e8b	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x6767ce26	ddebug_add_module	vmlinux	EXPORT_SYMBOL_GPL
+0xef8d3d3d	register_key_type	vmlinux	EXPORT_SYMBOL
+0x640a7078	posix_acl_create_masq	vmlinux	EXPORT_SYMBOL
+0x6f01f8bd	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0xcfa2db08	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x167e7f9d	__get_user_1	vmlinux	EXPORT_SYMBOL
+0xc3aaf0a9	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x5efb7d3b	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x0cae232b	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x6eb0fdf3	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x33b65044	snd_rawmidi_output_params	sound/core/snd-rawmidi	EXPORT_SYMBOL
+0xce395ad3	rpc_get_mount	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xf548d33e	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x3ac187ef	pnp_unregister_driver	vmlinux	EXPORT_SYMBOL
+0xa89e33ac	blk_queue_max_sectors	vmlinux	EXPORT_SYMBOL
+0xee1bee68	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0xd5741e5b	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0xd40ce416	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x02e0527b	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x8ffe7e89	nf_conntrack_htable_size	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0xd587a8bb	ieee80211_ctstoself_get	net/mac80211/mac80211	EXPORT_SYMBOL
+0x248a1596	cxgb3_queue_tid_release	drivers/net/cxgb3/cxgb3	EXPORT_SYMBOL
+0xa336feb7	nand_manuf_ids	drivers/mtd/nand/nand_ids	EXPORT_SYMBOL
+0x86e07a2a	saa7134_ts_qops	drivers/media/video/saa7134/saa7134	EXPORT_SYMBOL_GPL
+0x31acdccb	em28xx_register_extension	drivers/media/video/em28xx/em28xx	EXPORT_SYMBOL
+0xb4173f41	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x2bda473d	ata_port_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x73659c32	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x8031b401	vfs_get_dqinfo	vmlinux	EXPORT_SYMBOL
+0x34bde576	vfs_set_dqinfo	vmlinux	EXPORT_SYMBOL
+0x160f4546	audit_log_end	vmlinux	EXPORT_SYMBOL
+0x6d40a921	need_ipv4_conntrack	net/ipv4/netfilter/nf_conntrack_ipv4	EXPORT_SYMBOL_GPL
+0xc77e33b8	cfi_varsize_frob	drivers/mtd/chips/cfi_util	EXPORT_SYMBOL
+0xd10ec494	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x7278bfc7	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x904409c6	acpi_set_firmware_waking_vector	vmlinux	EXPORT_SYMBOL
+0x716265c7	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL
+0x36875389	__timecompare_update	vmlinux	EXPORT_SYMBOL
+0x4d7c2922	snd_opl3_find_patch	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0x041f57c7	snd_pcm_lib_preallocate_pages	sound/core/snd-pcm	EXPORT_SYMBOL
+0xaf00aca6	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x26d8188c	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x4c759827	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0xab749d3b	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0xba139fbe	skcipher_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x4abc947c	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x9f424093	free_user_ns	vmlinux	EXPORT_SYMBOL
+0xa8db808d	wusbhc_destroy	drivers/usb/wusbcore/wusbcore	EXPORT_SYMBOL_GPL
+0xd38d8ae2	hermes_read_ltv	drivers/net/wireless/orinoco/orinoco	EXPORT_SYMBOL
+0xf93f0127	mISDN_register_Bprotocol	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0xe914e41e	strcpy	vmlinux	EXPORT_SYMBOL
+0x74b47136	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x38f490f4	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x1bc3edc2	usb_stor_sense_invalidCDB	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x4856a9fe	parport_ieee1284_read_byte	drivers/parport/parport	EXPORT_SYMBOL
+0x944a245c	parport_claim_or_block	drivers/parport/parport	EXPORT_SYMBOL
+0x085ec2bb	isac_init	drivers/isdn/hisax/hisax_isac	EXPORT_SYMBOL
+0x8d5aba5b	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x8b8d4e2f	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0xf240d0a9	fb_get_buffer_offset	vmlinux	EXPORT_SYMBOL
+0x876b3827	key_payload_reserve	vmlinux	EXPORT_SYMBOL
+0xbc1dfc07	inotify_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x8dd78d25	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x638b8002	nf_ct_insert_dying_list	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x130a310d	fuse_abort_conn	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0xb7b89dcc	recv_Bchannel_skb	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x097fe747	skb_unlink	vmlinux	EXPORT_SYMBOL
+0xf9872ec4	get_cpu_sysdev	vmlinux	EXPORT_SYMBOL_GPL
+0xdc525235	xenbus_grant_ring	vmlinux	EXPORT_SYMBOL_GPL
+0x05efbb85	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0xfcda63a3	node_states	vmlinux	EXPORT_SYMBOL
+0xb2e5ae4a	snd_lookup_minor_data	sound/core/snd	EXPORT_SYMBOL
+0xcd1bcd85	dccp_send_sync	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0x1935ce4c	uwb_rsv_destroy	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x5641485b	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0xba31b88f	auth_unix_lookup	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xdecc5ca3	iwl_ht_enabled	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x44e3b3c2	ttpci_budget_deinit	drivers/media/dvb/ttpci/budget-core	EXPORT_SYMBOL_GPL
+0xcb080a46	saa7146_stop_preview	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0xb21245fb	drm_fb_helper_set_par	drivers/gpu/drm/drm_kms_helper	EXPORT_SYMBOL
+0x390fd6dc	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0xdbf60c0d	usb_hcd_pci_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x3194d2ab	ata_cable_40wire	vmlinux	EXPORT_SYMBOL_GPL
+0xde9d88fb	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL
+0x524ca94c	cfg80211_wext_siwmlme	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x6e291aa8	cfg80211_wext_giwname	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x6a062004	cfg80211_wext_siwmode	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xa57bdd8b	cfg80211_wext_giwmode	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xe2af347f	cfg80211_wext_siwrate	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xd6622c34	cfg80211_wext_giwrate	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x4cc39341	cfg80211_send_auth_timeout	net/wireless/cfg80211	EXPORT_SYMBOL
+0x8bf1c846	iwl_mac_reset_tsf	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xce96cfaf	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x4fdee897	i8042_command	vmlinux	EXPORT_SYMBOL
+0x83c5582c	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x26fa38db	ata_cable_unknown	vmlinux	EXPORT_SYMBOL_GPL
+0x175ffd9e	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x6b94c408	enable_kprobe	vmlinux	EXPORT_SYMBOL_GPL
+0xf913c871	regulatory_hint	net/wireless/cfg80211	EXPORT_SYMBOL
+0xd65a9c42	wiphy_rfkill_start_polling	net/wireless/cfg80211	EXPORT_SYMBOL
+0x1b070ad3	osd_req_read	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x092f2a2b	videobuf_vmalloc_free	drivers/media/video/videobuf-vmalloc	EXPORT_SYMBOL_GPL
+0xfd165350	gspca_auto_gain_n_exposure	drivers/media/video/gspca/gspca_main	EXPORT_SYMBOL
+0xe6466ca5	ib_cm_init_qp_attr	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x9d5fffde	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x0c8c9e99	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0xe0ac8bd2	acpi_bus_generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0xc08cfdc6	__pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x075e535c	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x30fc6d04	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x734c6698	bt_sock_link	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0xa342f9ac	xt_register_target	vmlinux	EXPORT_SYMBOL
+0xf186c105	rndis_command	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0x1d7228ae	videobuf_to_dma	drivers/media/video/videobuf-dma-sg	EXPORT_SYMBOL_GPL
+0x93cf550e	dvb_unregister_device	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x6b71fe08	ib_get_cached_pkey	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x351541b4	nf_unregister_hooks	vmlinux	EXPORT_SYMBOL
+0x94847b23	nf_ct_destroy	vmlinux	EXPORT_SYMBOL
+0xcdbaab9c	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0xb6cd2d03	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0xc371ef21	pnp_disable_dev	vmlinux	EXPORT_SYMBOL
+0x552a37f5	framebuffer_release	vmlinux	EXPORT_SYMBOL
+0x45bf1ff3	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x8810ad5e	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x161e5180	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x2aa17774	rpc_free_iostats	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x550547a3	rpc_destroy_wait_queue	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x4b11de2c	saa7146_start_preview	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0x34274557	btmrvl_process_event	drivers/bluetooth/btmrvl	EXPORT_SYMBOL_GPL
+0x1b8b95ad	i8042_unlock_chip	vmlinux	EXPORT_SYMBOL
+0x0cd27596	wiphy_apply_custom_regulatory	net/wireless/cfg80211	EXPORT_SYMBOL
+0x6eea229d	svcauth_unix_purge	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xbeb23a4d	fat_getattr	fs/fat/fat	EXPORT_SYMBOL_GPL
+0xce1d4a7c	fat_setattr	fs/fat/fat	EXPORT_SYMBOL_GPL
+0xb48d860a	wm8350_read_auxadc	drivers/mfd/wm8350	EXPORT_SYMBOL_GPL
+0x4526289b	mpt_event_deregister	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x476e3cdf	cx24113_agc_callback	drivers/media/dvb/frontends/cx24113	EXPORT_SYMBOL
+0xc8b2a399	dm_table_get_md	drivers/md/dm-mod	EXPORT_SYMBOL
+0xe328d4a0	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
+0x54f8aa1b	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x5e6fead4	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0xd17cec02	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x58d6acf7	xprt_lookup_rqst	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x5d100357	ct_sip_parse_header_uri	net/netfilter/nf_conntrack_sip	EXPORT_SYMBOL_GPL
+0x3a937e88	fc_exch_seq_send	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x3f39bd1e	tpm_pm_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x7b117e44	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x58c96c47	ring_buffer_time_stamp	vmlinux	EXPORT_SYMBOL_GPL
+0xb34a7575	mdio45_ethtool_spauseparam_an	drivers/net/mdio	EXPORT_SYMBOL
+0x482b7874	NS8390_init	drivers/net/8390	EXPORT_SYMBOL
+0x2f639468	v4l2_prio_check	drivers/media/video/v4l2-common	EXPORT_SYMBOL
+0x5fcdec5d	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0xb41d66c3	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0xa8f2115f	vc_resize	vmlinux	EXPORT_SYMBOL
+0xfbe90586	acpi_bus_generate_proc_event	vmlinux	EXPORT_SYMBOL
+0x93dc8342	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0xb1acbcce	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x0799c50a	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0xee2d0fc7	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x3e219de6	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0xea89c0e0	nf_ct_expect_alloc	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x1a474901	tracepoint_probe_unregister_noupdate	vmlinux	EXPORT_SYMBOL_GPL
+0x639e91dc	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x3f6db159	p54_init_common	drivers/net/wireless/p54/p54common	EXPORT_SYMBOL_GPL
+0xee6c355e	iwl_get_sta_id	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x5a850f5a	ib_modify_qp	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xb9d37dd1	ttm_bo_kunmap	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x83e1e820	ethtool_op_get_rx_csum	vmlinux	EXPORT_SYMBOL
+0x3c2b0bd4	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x62827bec	security_secctx_to_secid	vmlinux	EXPORT_SYMBOL
+0x4541fe0d	mtrr_state	vmlinux	EXPORT_SYMBOL_GPL
+0x051f3b64	snd_timer_global_free	sound/core/snd-timer	EXPORT_SYMBOL
+0xcef149fa	usb_ftdi_elan_edset_flush	drivers/usb/misc/ftdi-elan	EXPORT_SYMBOL_GPL
+0x18278784	smscore_register_client	drivers/media/dvb/siano/smsmdtv	EXPORT_SYMBOL_GPL
+0x136807b3	flexcop_dma_allocate	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x20100553	nf_ct_attach	vmlinux	EXPORT_SYMBOL
+0x9330524f	snd_pcm_lib_writev	sound/core/snd-pcm	EXPORT_SYMBOL
+0x23aebbed	sas_target_destroy	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x8db84dcb	saa7146_unregister_device	drivers/media/common/saa7146_vv	EXPORT_SYMBOL_GPL
+0x50c2230c	mISDN_FsmChangeState	drivers/isdn/mISDN/mISDN_core	EXPORT_SYMBOL
+0x44928fc6	drm_mode_connector_list_update	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0xe5ed5467	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x961a8cd3	unlock_policy_rwsem_read	vmlinux	EXPORT_SYMBOL_GPL
+0x1fa33adb	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0xca8acc78	acpi_dbg_level	vmlinux	EXPORT_SYMBOL
+0x475f010b	acpi_purge_cached_objects	vmlinux	EXPORT_SYMBOL
+0xc5483dcc	textsearch_register	vmlinux	EXPORT_SYMBOL
+0x74baf17a	tracing_is_on	vmlinux	EXPORT_SYMBOL_GPL
+0x4f9ea495	commit_creds	vmlinux	EXPORT_SYMBOL
+0x1391184a	__nf_ct_expect_find	net/netfilter/nf_conntrack	EXPORT_SYMBOL_GPL
+0x5d27c361	dccp_rcv_state_process	net/dccp/dccp	EXPORT_SYMBOL_GPL
+0xfbb9691b	garp_init_applicant	net/802/garp	EXPORT_SYMBOL_GPL
+0x22d4b209	usbnet_generic_cdc_bind	drivers/net/usb/cdc_ether	EXPORT_SYMBOL_GPL
+0xbeaccbdc	ir_codes_gadmei_rm008z_table	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0x4d09c11b	ttm_agp_backend_init	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x72c333cb	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x5934392b	fb_register_client	vmlinux	EXPORT_SYMBOL
+0xad0413d4	match_hex	vmlinux	EXPORT_SYMBOL
+0x588a9513	snd_vx_suspend	sound/drivers/vx/snd-vx-lib	EXPORT_SYMBOL
+0xb7ad2aae	bt878_start	drivers/media/dvb/bt8xx/bt878	EXPORT_SYMBOL
+0xfad25288	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x81bac248	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL
+0xe38ed2aa	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x53ae137c	dev_attr_em_message	vmlinux	EXPORT_SYMBOL_GPL
+0x34de23eb	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0xc480d738	ipv6_find_hdr	net/ipv6/netfilter/ip6_tables	EXPORT_SYMBOL
+0xff7a8579	jbd2_journal_dirty_metadata	fs/jbd2/jbd2	EXPORT_SYMBOL
+0xb6b88585	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x97c0d5d1	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x6a47571d	__set_personality	vmlinux	EXPORT_SYMBOL
+0x8c8e4c76	sas_attach_transport	drivers/scsi/scsi_transport_sas	EXPORT_SYMBOL
+0x9dc0079f	sas_bios_param	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x38911952	iwl_get_channel_info	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x948e7a7e	mlx4_cq_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x14eb630c	dvb_ringbuffer_free	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0xca0eec6a	dvb_dmxdev_init	drivers/media/dvb/dvb-core/dvb-core	EXPORT_SYMBOL
+0x81eaf2ed	flexcop_dma_control_size_irq	drivers/media/dvb/b2c2/b2c2-flexcop	EXPORT_SYMBOL
+0x3ecd5358	ib_get_client_data	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x18ca7075	ib_set_client_data	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x14dd9084	drm_core_ioremap_wc	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x958cfcc4	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x6a1b1fc3	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0xbcb216e3	page_readlink	vmlinux	EXPORT_SYMBOL
+0xd4360807	cfg80211_wext_siwauth	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xe0fb104c	cfg80211_wext_giwauth	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x98413234	uwb_rsv_state_str	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x19f51a0b	osd_req_flush_partition	drivers/scsi/osd/libosd	EXPORT_SYMBOL
+0x7dcfd39f	ubi_is_mapped	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0xbb482deb	wm831x_enable_irq	drivers/mfd/wm831x	EXPORT_SYMBOL_GPL
+0x72bd000f	edac_mc_handle_ue	drivers/edac/edac_core	EXPORT_SYMBOL_GPL
+0xcfdf1c43	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0xc52da8c7	pcmcia_socket_dev_late_resume	vmlinux	EXPORT_SYMBOL
+0x1dd571e6	fb_copy_cmap	vmlinux	EXPORT_SYMBOL
+0xf5eb86ea	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0xc499ae1e	kstrdup	vmlinux	EXPORT_SYMBOL
+0x0c304ca4	snd_opl3_interrupt	sound/drivers/opl3/snd-opl3-lib	EXPORT_SYMBOL
+0xe51f8464	fcoe_libfc_config	drivers/scsi/fcoe/libfcoe	EXPORT_SYMBOL_GPL
+0x02ccea56	lock_policy_rwsem_write	vmlinux	EXPORT_SYMBOL_GPL
+0xe92917ec	ata_bmdma_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x1382720d	ata_host_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x2727da5d	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0xea7987f1	key_update	vmlinux	EXPORT_SYMBOL
+0x1f0747b3	iscsi_conn_bind	drivers/scsi/libiscsi	EXPORT_SYMBOL_GPL
+0x764ff273	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0xc5177b8d	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0xcb7131fb	fb_get_options	vmlinux	EXPORT_SYMBOL
+0xda1a7335	kasprintf	vmlinux	EXPORT_SYMBOL
+0x410ef0cb	simple_rename	vmlinux	EXPORT_SYMBOL
+0xe363d48e	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0xfd9e7030	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x501087b9	snd_ctl_free_one	sound/core/snd	EXPORT_SYMBOL
+0xd5d0bdef	bt878_num	drivers/media/dvb/bt8xx/bt878	EXPORT_SYMBOL
+0x947348de	iw_cm_reject	drivers/infiniband/core/iw_cm	EXPORT_SYMBOL
+0x1d7903d9	sock_init_data	vmlinux	EXPORT_SYMBOL
+0xc2424641	agp3_generic_cleanup	vmlinux	EXPORT_SYMBOL
+0xac58ea5e	acpi_unload_table_id	vmlinux	EXPORT_SYMBOL
+0x8d8d96c6	acpi_get_sleep_type_data	vmlinux	EXPORT_SYMBOL
+0xcbdd945e	ring_buffer_commit_overrun_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0xe02c79c4	ring_buffer_read_finish	vmlinux	EXPORT_SYMBOL_GPL
+0xb9f3525e	oxygen_write_uart	sound/pci/oxygen/snd-oxygen-lib	EXPORT_SYMBOL
+0xa186a9a2	unregister_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0x17e43977	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0xe06efd8b	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x748e7d99	pci_get_slot	vmlinux	EXPORT_SYMBOL
+0x69a0ca7d	iowrite16be	vmlinux	EXPORT_SYMBOL
+0x6acb973d	iowrite32be	vmlinux	EXPORT_SYMBOL
+0xd9042fa8	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x24624544	ftrace_print_flags_seq	vmlinux	EXPORT_SYMBOL
+0xcd285e15	jbd2_journal_force_commit	fs/jbd2/jbd2	EXPORT_SYMBOL
+0x415e0eeb	mpt_resume	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x7fbe8c01	videobuf_stop	drivers/media/video/videobuf-core	EXPORT_SYMBOL_GPL
+0x7818bbac	ib_find_pkey	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xf4de1bf0	alloc_dca_provider	drivers/dca/dca	EXPORT_SYMBOL_GPL
+0x4dc0dafe	km_query	vmlinux	EXPORT_SYMBOL
+0x0cea07dd	inet_release	vmlinux	EXPORT_SYMBOL
+0xef9da579	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x239178f2	log_start_commit	fs/jbd/jbd	EXPORT_SYMBOL
+0x5ee7c98a	usb_stor_CB_transport	drivers/usb/storage/usb-storage	EXPORT_SYMBOL_GPL
+0x4e20ee74	dm_rh_recovery_end	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x2d414656	rdma_addr_cancel	drivers/infiniband/core/ib_addr	EXPORT_SYMBOL
+0x54bd71e8	drm_connector_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x93a1ee30	neigh_create	vmlinux	EXPORT_SYMBOL
+0x9fce80db	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x01e1a8de	kgdb_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0xaa286175	ieee802154_nl_start_confirm	net/ieee802154/nl802154	EXPORT_SYMBOL
+0xd429403a	rt2x00pci_probe	drivers/net/wireless/rt2x00/rt2x00pci	EXPORT_SYMBOL_GPL
+0xa1a29548	mdio45_probe	drivers/net/mdio	EXPORT_SYMBOL
+0xdd805159	ioc_list	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x3d761fe4	cx231xx_send_usb_command	drivers/media/video/cx231xx/cx231xx	EXPORT_SYMBOL_GPL
+0x3cf36675	intelfb_resize	drivers/gpu/drm/i915/i915	EXPORT_SYMBOL
+0xbb50cea7	cpufreq_get_policy	vmlinux	EXPORT_SYMBOL
+0x8f6cee77	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x5f2da8c4	check_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x47338391	svc_pool_stats_open	net/sunrpc/sunrpc	EXPORT_SYMBOL
+0x9b3e6113	per_cpu__rds_stats	net/rds/rds	EXPORT_SYMBOL_GPL
+0xdb66c137	iwl_tt_exit_ct_kill	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xacbf328d	iwl_set_hw_params	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x94700ea4	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x2ae00fe3	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x0303eca9	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x037a0cba	kfree	vmlinux	EXPORT_SYMBOL
+0xf8aadd8d	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0xb9638db4	snd_pcm_rate_to_rate_bit	sound/core/snd-pcm	EXPORT_SYMBOL
+0x6f9f68d0	sas_target_alloc	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x3e2f4d42	ib_modify_device	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0xaf29788e	drm_sman_init	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9522a342	cfag12864b_getrate	drivers/auxdisplay/cfag12864b	EXPORT_SYMBOL_GPL
+0x7a4638db	vlan_dev_real_dev	vmlinux	EXPORT_SYMBOL
+0x3d6d2f14	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x0f3e1e0b	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
+0x65b00e32	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0xfc533f85	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x31a4a588	snd_hda_set_vmaster_tlv	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x398188bc	snd_wss_mixer	sound/isa/wss/snd-wss-lib	EXPORT_SYMBOL
+0x2aebfb0b	xprt_destroy_backchannel	net/sunrpc/sunrpc	EXPORT_SYMBOL
+0x6ca008a2	fat_fs_error	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x8e2dec0d	rndis_unbind	drivers/net/usb/rndis_host	EXPORT_SYMBOL_GPL
+0xbaa2bf51	mlx4_buf_free	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0xbc505df4	ubi_get_device_info	drivers/mtd/ubi/ubi	EXPORT_SYMBOL_GPL
+0xc4aa94a1	ip_route_output_key	vmlinux	EXPORT_SYMBOL
+0xe4cde519	pci_lost_interrupt	vmlinux	EXPORT_SYMBOL
+0xe7d4daac	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x538383c0	unregister_inet6addr_notifier	net/ipv6/ipv6	EXPORT_SYMBOL
+0xb0762b2a	dib7000p_set_gpio	drivers/media/dvb/frontends/dib7000p	EXPORT_SYMBOL
+0x91584cc8	ttm_bo_evict_mm	drivers/gpu/drm/ttm/ttm	EXPORT_SYMBOL
+0x90f28eeb	set_pages_array_wb	vmlinux	EXPORT_SYMBOL
+0x9a9c7704	ipv6_chk_addr	net/ipv6/ipv6	EXPORT_SYMBOL
+0x1fcedead	otg_put_transceiver	vmlinux	EXPORT_SYMBOL
+0x55f1708b	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x542965b1	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x41bfe8f7	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x68c5d752	dm_rh_get_region_size	drivers/md/dm-region-hash	EXPORT_SYMBOL_GPL
+0x3ceb38f0	lis3lv02d_remove_fs	drivers/hwmon/lis3lv02d	EXPORT_SYMBOL_GPL
+0xbceb6bb7	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0xa353fffc	xenbus_rm	vmlinux	EXPORT_SYMBOL_GPL
+0xfc273b68	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0xdaa57ec3	totalhigh_pages	vmlinux	EXPORT_SYMBOL
+0x41ab8a50	snd_emux_register	sound/synth/emux/snd-emux-synth	EXPORT_SYMBOL
+0x40ccfe2f	ipv6_find_tlv	net/ipv6/ipv6	EXPORT_SYMBOL_GPL
+0x2a7256d6	ivtv_udma_unmap	drivers/media/video/ivtv/ivtv	EXPORT_SYMBOL
+0x2456e513	ir_decode_pulsedistance	drivers/media/common/ir-common	EXPORT_SYMBOL_GPL
+0xcd03d947	b1_register_appl	drivers/isdn/hardware/avm/b1	EXPORT_SYMBOL
+0x2922c533	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x7eb9b9ba	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0xa120d33c	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x7dc5d0b6	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x2226cadb	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x72741f25	trace_vbprintk	vmlinux	EXPORT_SYMBOL_GPL
+0x874c6177	_snd_ctl_add_slave	sound/core/snd	EXPORT_SYMBOL
+0xe934da1d	snd_seq_dump_var_event	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x4eb3510f	cfg80211_michael_mic_failure	net/wireless/cfg80211	EXPORT_SYMBOL
+0x2a63f9f1	ipt_do_table	net/ipv4/netfilter/ip_tables	EXPORT_SYMBOL
+0xc288651c	ib_create_ah	drivers/infiniband/core/ib_core	EXPORT_SYMBOL
+0x646f7ef3	led_classdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0xcc41282a	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x65b91932	pnp_possible_config	vmlinux	EXPORT_SYMBOL
+0x2dc45af9	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0xba4fc45f	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x054aa28d	ring_buffer_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x79c115ae	x86_mce_decode_callback	vmlinux	EXPORT_SYMBOL
+0x040a55a6	snd_opl4_write_memory	sound/drivers/opl4/snd-opl4-lib	EXPORT_SYMBOL
+0x200598b7	usb_serial_disconnect	drivers/usb/serial/usbserial	EXPORT_SYMBOL_GPL
+0xf0a16657	FsmNew	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x647575fc	drm_mode_object_find	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x9bbd9dad	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x093e4d83	xt_find_target	vmlinux	EXPORT_SYMBOL
+0x16836e04	speedstep_detect_processor	vmlinux	EXPORT_SYMBOL_GPL
+0x1407a17c	snd_hda_sequence_write	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0xab0b0ecd	rpc_proc_register	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0x827cc6a1	pptp_msg_name	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL
+0x88e4cd26	vring_new_virtqueue	drivers/virtio/virtio_ring	EXPORT_SYMBOL_GPL
+0x31ba582b	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0xda637110	dget_locked	vmlinux	EXPORT_SYMBOL
+0x7c61340c	__release_region	vmlinux	EXPORT_SYMBOL
+0x3c7227bf	complete_all	vmlinux	EXPORT_SYMBOL
+0x2edb5638	snd_hda_bind_sw	sound/pci/hda/snd-hda-codec	EXPORT_SYMBOL_GPL
+0x23b2b930	snd_emu10k1_ptr_write	sound/pci/emu10k1/snd-emu10k1	EXPORT_SYMBOL
+0x7dcfcd23	uwb_ie_next	drivers/uwb/uwb	EXPORT_SYMBOL_GPL
+0x2b8fd674	iwl_tx_queue_init	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0xbcf2d2fb	bttv_read_gpio	drivers/media/video/bt8xx/bttv	EXPORT_SYMBOL
+0x5ed040b0	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x8a3bd556	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x54290dc9	nla_validate	vmlinux	EXPORT_SYMBOL
+0x339658e5	bdi_register	vmlinux	EXPORT_SYMBOL
+0xe4dd4a39	sysctl_data	vmlinux	EXPORT_SYMBOL
+0x52e3e4a5	snd_pcm_hw_param_value	sound/core/snd-pcm	EXPORT_SYMBOL
+0xf5872dfb	fat_time_unix2fat	fs/fat/fat	EXPORT_SYMBOL_GPL
+0x6ce89c28	dst_error_bailout	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0x3576a3a3	rdma_destroy_qp	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0x4a2bd07c	rdma_destroy_id	drivers/infiniband/core/rdma_cm	EXPORT_SYMBOL
+0xe83280ac	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0xf81f070f	pccard_get_next_tuple	vmlinux	EXPORT_SYMBOL
+0x7129e5f8	hex_asc	vmlinux	EXPORT_SYMBOL
+0xb6353555	per_cpu__x86_cpu_to_apicid	vmlinux	EXPORT_SYMBOL
+0x57cfaf44	nf_nat_follow_master	net/ipv4/netfilter/nf_nat	EXPORT_SYMBOL
+0x31915d16	fuse_dev_release	fs/fuse/fuse	EXPORT_SYMBOL_GPL
+0x208137db	srp_rport_add	drivers/scsi/scsi_transport_srp	EXPORT_SYMBOL_GPL
+0x98fcf2f8	fc_remote_port_rolechg	drivers/scsi/scsi_transport_fc	EXPORT_SYMBOL
+0xc33bca37	fw_iso_buffer_init	drivers/firewire/firewire-core	EXPORT_SYMBOL
+0xf8f3a0fb	ata_ratelimit	vmlinux	EXPORT_SYMBOL_GPL
+0x0627b4f5	agp_free_memory	vmlinux	EXPORT_SYMBOL
+0x794dba67	agp_copy_info	vmlinux	EXPORT_SYMBOL
+0x7ea8f00d	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x2aa0e4fc	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x4dd171d4	default_llseek	vmlinux	EXPORT_SYMBOL
+0x7621770a	snd_jack_new	sound/core/snd	EXPORT_SYMBOL
+0x89947013	snd_use_lock_sync_helper	sound/core/seq/snd-seq	EXPORT_SYMBOL
+0x82443037	cfg80211_wext_siwpower	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0x637e6537	cfg80211_wext_giwpower	net/wireless/cfg80211	EXPORT_SYMBOL_GPL
+0xd0faf92e	p9_idpool_check	net/9p/9pnet	EXPORT_SYMBOL
+0x8edc67ed	cx8802_register_driver	drivers/media/video/cx88/cx8802	EXPORT_SYMBOL
+0x782c7e9f	dst_comm_init	drivers/media/dvb/bt8xx/dst	EXPORT_SYMBOL
+0xc2b04efa	cm_class	drivers/infiniband/core/ib_cm	EXPORT_SYMBOL
+0x49114956	drm_do_probe_ddc_edid	drivers/gpu/drm/drm	EXPORT_SYMBOL
+0x3f944c6e	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x708c11da	lib80211_crypt_delayed_deinit	net/wireless/lib80211	EXPORT_SYMBOL
+0x953020f7	rpc_peeraddr	net/sunrpc/sunrpc	EXPORT_SYMBOL_GPL
+0xfc31fe88	l2cap_load	net/bluetooth/l2cap	EXPORT_SYMBOL
+0x10344bdd	iwl_set_dynamic_key	drivers/net/wireless/iwlwifi/iwlcore	EXPORT_SYMBOL
+0x2844a899	FsmInitTimer	drivers/isdn/hisax/hisax	EXPORT_SYMBOL
+0x2d36c18d	ip_fragment	vmlinux	EXPORT_SYMBOL
+0xf37f5155	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0xbee72c8e	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x280a1388	tpm_dev_vendor_release	vmlinux	EXPORT_SYMBOL_GPL
+0xf760db69	xenbus_dev_changed	vmlinux	EXPORT_SYMBOL_GPL
+0x815b5dd4	match_octal	vmlinux	EXPORT_SYMBOL
+0x88f62f6b	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x27000b29	crc32c	lib/libcrc32c	EXPORT_SYMBOL
+0x2f8deb4c	unregister_virtio_driver	drivers/virtio/virtio	EXPORT_SYMBOL_GPL
+0xc49f9186	i2400m_cmd_get_state	drivers/net/wimax/i2400m/i2400m	EXPORT_SYMBOL_GPL
+0x8cb8994a	i2c_smbus_write_byte	drivers/i2c/i2c-core	EXPORT_SYMBOL
+0x3d2cd45c	xt_register_targets	vmlinux	EXPORT_SYMBOL
+0x367f4268	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x5a9f5d3c	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x3fd6a04b	poll_freewait	vmlinux	EXPORT_SYMBOL
+0xb3a307c6	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x9e64fbfe	rtc_cmos_read	vmlinux	EXPORT_SYMBOL
+0xc1c1a2ee	snd_timer_pause	sound/core/snd-timer	EXPORT_SYMBOL
+0xe6c3a407	dib8000_attach	drivers/media/dvb/frontends/dib8000	EXPORT_SYMBOL
+0x5b6c00e6	xor_blocks	crypto/xor	EXPORT_SYMBOL
+0x5e95b1cd	current_umask	vmlinux	EXPORT_SYMBOL
+0xf660e423	get_fs_type	vmlinux	EXPORT_SYMBOL
+0xd8ecf336	snd_trident_free_voice	sound/pci/trident/snd-trident	EXPORT_SYMBOL
+0x2894f034	nf_nat_pptp_hook_outbound	net/netfilter/nf_conntrack_pptp	EXPORT_SYMBOL_GPL
+0xa41f942b	ieee80211_iterate_active_interfaces	net/mac80211/mac80211	EXPORT_SYMBOL_GPL
+0xa03968c3	mlx4_alloc_hwq_res	drivers/net/mlx4/mlx4_core	EXPORT_SYMBOL_GPL
+0x6f4ca1b8	free_candev	drivers/net/can/can-dev	EXPORT_SYMBOL_GPL
+0xc72644ad	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x88c2eb8b	regulator_bulk_free	vmlinux	EXPORT_SYMBOL_GPL
+0x6c389761	acpi_bus_get_private_data	vmlinux	EXPORT_SYMBOL
+0x0d157a64	dquot_acquire	vmlinux	EXPORT_SYMBOL
+0x0a1ee779	osd_WaitEventWait	drivers/staging/hv/hv_vmbus	EXPORT_SYMBOL_GPL
+0x76e4f15d	fc_exch_recv	drivers/scsi/libfc/libfc	EXPORT_SYMBOL
+0x221ef07e	mpt_send_handshake_request	drivers/message/fusion/mptbase	EXPORT_SYMBOL
+0x59cc8a7e	isdnhdlc_out_init	drivers/isdn/i4l/isdnhdlc	EXPORT_SYMBOL
+0xe2c70a12	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x42e67f5f	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x4b7029d4	aead_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x6b1f5389	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x362e23ec	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0xdc321e29	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x67955ce6	profile_hits	vmlinux	EXPORT_SYMBOL_GPL
+0xcd083b10	unregister_sound_dsp	sound/soundcore	EXPORT_SYMBOL
+0x5fa6f4f1	nat_t120_hook	net/netfilter/nf_conntrack_h323	EXPORT_SYMBOL_GPL
+0x95a45b4b	journal_check_used_features	fs/jbd/jbd	EXPORT_SYMBOL
+0x82506613	genphy_config_aneg	vmlinux	EXPORT_SYMBOL
+0xaad92074	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x6aede9fc	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x7a4497db	kzfree	vmlinux	EXPORT_SYMBOL
+0x94e36425	arpt_unregister_table	net/ipv4/netfilter/arp_tables	EXPORT_SYMBOL
+0xc0c6bf22	hci_send_acl	net/bluetooth/bluetooth	EXPORT_SYMBOL
+0x629a7412	sas_slave_destroy	drivers/scsi/libsas/libsas	EXPORT_SYMBOL_GPL
+0x62857b98	sk_filter	vmlinux	EXPORT_SYMBOL
+0xa2e67f08	acpi_bus_generate_proc_event4	vmlinux	EXPORT_SYMBOL_GPL
+0xa8f59416	gpio_direction_output	vmlinux	EXPORT_SYMBOL_GPL
+0x99cdb357	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x954188f0	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x14a3be0a	vmap	vmlinux	EXPORT_SYMBOL
diff -uNr linux-2.6.32/my_source/Makefile clean_modified/linux-2.6.32/my_source/Makefile
--- linux-2.6.32/my_source/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/Makefile	2019-04-14 13:23:51.359216596 -0500
@@ -0,0 +1,4 @@
+#
+#Makefile for the new hello world system calls
+#
+obj-y := sys_helloworld.o print_self.o print_other.o virtual_mem.o virtual_mem_status.o
diff -uNr linux-2.6.32/my_source/print_other.c clean_modified/linux-2.6.32/my_source/print_other.c
--- linux-2.6.32/my_source/print_other.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/print_other.c	2019-04-14 13:23:51.359216596 -0500
@@ -0,0 +1,79 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+
+asmlinkage int print_other(int pid)
+{
+	//using the function pid_task() we can find the pid faster
+	struct task_struct *finder_ptr; //this variable is where the pointer will be stored for the task_struct search
+	finder_ptr = pid_task(find_vpid(pid), PIDTYPE_PID); //returns a task_struct so this will replace all current
+
+	if(finder_ptr == NULL){
+		printk(KERN_INFO "Uh oh, the process %d could not be found", pid);
+	}
+	else{
+		struct timeval p_time;
+		struct tm p_readable;
+		do_gettimeofday(&p_time);
+		//subtracted -21600 because it equals 6hours
+		time_to_tm(p_time.tv_sec, -21600, &p_readable);
+	
+		//get the time the system booted up
+		struct sysinfo info;
+		do_sysinfo(&info);
+		long boottime = p_time.tv_sec - info.uptime;
+	
+		struct tm b_readable; //used to display boot time in a parsable format
+	
+		//print the pid
+		printk(KERN_INFO "process id: %u", finder_ptr->pid);
+	
+		//print running state
+		if(finder_ptr->state == 0){
+			printk(KERN_INFO "running state: runnable(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == -1){
+			printk(KERN_INFO "running state: unrunnable(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 1){
+			printk(KERN_INFO "running state: interruptible(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 2){
+			printk(KERN_INFO "running state: uninterrutible(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 4){
+			printk(KERN_INFO "running state: zombie(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 8){
+			printk(KERN_INFO "running state: stopped(%ld)", finder_ptr->state);
+		}
+		else{
+			printk(KERN_INFO "running state: stopped(%ld)", finder_ptr->state);
+		}
+	
+		//printing program name
+		printk(KERN_INFO "program name: %s", finder_ptr->comm);
+	
+		//print start time
+		boottime += finder_ptr->start_time.tv_sec; //update the start time of the process by adding the time the process started after the boot time
+		time_to_tm(boottime, -21600, &b_readable); //parse the time into readable output in CST
+		printk(KERN_INFO "Start time: %02d-%02d-%04ld %02d:%02d:%02d CST", b_readable.tm_mon + 1, b_readable.tm_mday, b_readable.tm_year + 1900, b_readable.tm_hour, b_readable.tm_min, b_readable.tm_sec);
+	
+		//print virtual run time
+		unsigned long long vruntime = finder_ptr->se.vruntime;
+		printk(KERN_INFO "virtual run time: %llu ns", vruntime);
+	
+		//print parent processes until init
+		//traverse the kernel linked list 
+		struct task_struct *traveler_ptr = finder_ptr;
+		//init_task is a statically allocated variable
+		printk(KERN_INFO "The parent-child relationship will be displayed as childPID(childName)->parentPID{parentName}: \n");		
+		while(traveler_ptr != &init_task){
+			printk(KERN_CONT "%d{%s}->", traveler_ptr->pid, traveler_ptr->comm); 	
+			//since the data structure is a doubly linked list we can traverse backwards until we get the parent.
+			traveler_ptr = traveler_ptr->parent;
+		}
+		printk(KERN_CONT "\b\b");
+	}
+	return 1;
+}
diff -uNr linux-2.6.32/my_source/print_other.c~ clean_modified/linux-2.6.32/my_source/print_other.c~
--- linux-2.6.32/my_source/print_other.c~	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/print_other.c~	2019-04-14 13:23:51.359216596 -0500
@@ -0,0 +1,79 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+
+asmlinkage int print_other(int pid)
+{
+	//using the function pid_task() we can find the pid faster
+	struct task_struct *finder_ptr; //this variable is where the pointer will be stored for the task_struct search
+	finder_ptr = pid_task(find_vpid(pid), PIDTYPE_PID); //returns a task_struct so this will replace all current
+
+	if(finder_ptr == NULL){
+		printk(KERN_INFO "Uh oh, the process %d could not be found", pid);
+	}
+	else{
+		struct timeval p_time;
+		struct tm p_readable;
+		do_gettimeofday(&p_time);
+		//subtracted -21600 because it equals 6hours
+		time_to_tm(p_time.tv_sec, -21600, &p_readable);
+	
+		//get the time the system booted up
+		struct sysinfo info;
+		do_sysinfo(&info);
+		long boottime = p_time.tv_sec - info.uptime;
+	
+		struct tm b_readable; //used to display boot time in a parsable format
+	
+		//print the pid
+		printk(KERN_INFO "process id: %u", finder_ptr->pid);
+	
+		//print running state
+		if(finder_ptr->state == 0){
+			printk(KERN_INFO "running state: runnable(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == -1){
+			printk(KERN_INFO "running state: unrunnable(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 1){
+			printk(KERN_INFO "running state: interruptible(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 2){
+			printk(KERN_INFO "running state: uninterrutible(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 4){
+			printk(KERN_INFO "running state: zombie(%ld)", finder_ptr->state);
+		}
+		else if (finder_ptr->state == 8){
+			printk(KERN_INFO "running state: stopped(%ld)", finder_ptr->state);
+		}
+		else{
+			printk(KERN_INFO "running state: stopped(%ld)", finder_ptr->state);
+		}
+	
+		//printing program name
+		printk(KERN_INFO "program name: %s", finder_ptr->comm);
+	
+		//print start time
+		boottime += finder_ptr->start_time.tv_sec; //update the start time of the process by adding the time the process started after the boot time
+		time_to_tm(boottime, -21600, &b_readable); //parse the time into readable output in CST
+		printk(KERN_INFO "Start time: %02d-%02d-%04ld %02d:%02d:%02d CST", b_readable.tm_mon + 1, b_readable.tm_mday, b_readable.tm_year + 1900, b_readable.tm_hour, b_readable.tm_min, b_readable.tm_sec);
+	
+		//print virtual run time
+		unsigned long long vruntime = finder_ptr->se.vruntime;
+		printk(KERN_INFO "virtual run time: %llu", vruntime);
+	
+		//print parent processes until init
+		//traverse the kernel linked list 
+		struct task_struct *traveler_ptr = finder_ptr;
+		//init_task is a statically allocated variable
+		printk(KERN_INFO "The parent-child relationship will be displayed as childPID(childName)->parentPID{parentName}: \n");		
+		while(traveler_ptr != &init_task){
+			printk(KERN_CONT "%d{%s}->", traveler_ptr->pid, traveler_ptr->comm); 	
+			//since the data structure is a doubly linked list we can traverse backwards until we get the parent.
+			traveler_ptr = traveler_ptr->parent;
+		}
+		printk(KERN_CONT "\b\b");
+	}
+	return 1;
+}
diff -uNr linux-2.6.32/my_source/print_self.c clean_modified/linux-2.6.32/my_source/print_self.c
--- linux-2.6.32/my_source/print_self.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/print_self.c	2019-04-14 13:23:51.362203572 -0500
@@ -0,0 +1,71 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+
+asmlinkage int print_self(void)
+{
+	struct timeval p_time;
+	struct tm p_readable;
+	do_gettimeofday(&p_time);
+	//subtracted -21600 because it equals 6hours
+	time_to_tm(p_time.tv_sec, -21600, &p_readable);
+	
+	//get the time the system booted up
+	struct sysinfo info;
+	do_sysinfo(&info);
+	long boottime = p_time.tv_sec - info.uptime;
+	
+	struct tm b_readable; //used to display boot time in a parsable format
+	
+	//print the pid
+	printk(KERN_INFO "process id: %u", current->pid);
+	
+	//print running state
+	if(current->state == 0){
+		printk(KERN_INFO "running state: runnable(%ld)", current->state);
+	}
+	else if (current->state == -1){
+		printk(KERN_INFO "running state: unrunnable(%ld)", current->state);
+	}
+	else if (current->state == 1){
+		printk(KERN_INFO "running state: interruptible(%ld)", current->state);
+	}
+	else if (current->state == 2){
+		printk(KERN_INFO "running state: uninterrutible(%ld)", current->state);
+	}
+	else if (current->state == 4){
+		printk(KERN_INFO "running state: zombie(%ld)", current->state);
+	}
+	else if (current->state == 8){
+		printk(KERN_INFO "running state: stopped(%ld)", current->state);
+	}
+	else{
+		printk(KERN_INFO "running state: stopped(%ld)", current->state);
+	}
+	
+	//printing program name
+	printk(KERN_INFO "program name: %s", current->comm);
+	
+	//print start time
+	boottime += current->start_time.tv_sec; //update the start time of the process by adding the time the process started after the boot time
+	time_to_tm(boottime, -21600, &b_readable); //parse the time into readable output in CST
+	printk(KERN_INFO "Start time: %02d-%02d-%04ld %02d:%02d:%02d CST", b_readable.tm_mon + 1, b_readable.tm_mday, b_readable.tm_year + 1900, b_readable.tm_hour, b_readable.tm_min, b_readable.tm_sec);
+	
+	//print virtual run time
+	unsigned long long vruntime = current->se.vruntime;
+	printk(KERN_INFO "virtual run time: %llu ns", vruntime);
+	
+	//print parent processes until init
+	//traverse the kernel linked list 
+	struct task_struct *traveler_ptr = current;
+	//init_task is a statically allocated variable
+	printk(KERN_INFO "The parent-child relationship will be displayed as childPID(childName)->parentPID{parentName}: \n");		
+	while(traveler_ptr != &init_task)
+	{
+		printk(KERN_CONT "%d{%s}->", traveler_ptr->pid, traveler_ptr->comm); 	
+		//since the data structure is a doubly linked list we can traverse backwards until we get the parent.
+		traveler_ptr = traveler_ptr->parent;
+	}
+	printk(KERN_CONT "\b\b");
+	return 1;
+}
diff -uNr linux-2.6.32/my_source/sys_helloworld.c clean_modified/linux-2.6.32/my_source/sys_helloworld.c
--- linux-2.6.32/my_source/sys_helloworld.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/sys_helloworld.c	2019-04-14 13:23:51.364027964 -0500
@@ -0,0 +1,8 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+asmlinkage int sys_helloworld(void)
+{
+    printk(KERN_EMERG "Hello world!\n");
+    return 1;
+}
diff -uNr linux-2.6.32/my_source/virtual_mem.c clean_modified/linux-2.6.32/my_source/virtual_mem.c
--- linux-2.6.32/my_source/virtual_mem.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/virtual_mem.c	2019-04-14 13:23:51.365984874 -0500
@@ -0,0 +1,68 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/fs.h>
+#include <asm/page.h>
+
+asmlinkage int virtual_mem(int pid){
+	//get task_struct of pid
+	struct task_struct *process_ts;
+	process_ts = pid_task(find_vpid(pid), PIDTYPE_PID); //reused from project1
+	if(!process_ts)
+	{
+		printk(KERN_INFO "could not find process with pid %d",pid); 
+		return 1;
+	}
+	//get memory struct
+	struct mm_struct *process_mem = process_ts->active_mm;
+	
+	//get number of virtual memories
+	int num_mem = process_mem->map_count;
+	printk(KERN_INFO "\nThe # of virtual memory areas = %d\n", num_mem);
+	
+	//get list sorted of all virtual memories, this way its easier to traverse.
+	struct vm_area_struct *list_virtualmem = process_mem->mmap;
+	
+	//traverse
+	int i = 0;
+	unsigned long total = 0;
+	struct vm_area_struct *i_vm; //traveler pointer
+	for(i_vm = list_virtualmem; i < num_mem; i++)
+	{
+		printk(KERN_INFO "Virtual memory (%d)\n", i);
+		
+		//find size of each area
+		unsigned long vma_size = i_vm->vm_end - i_vm->vm_start;
+		printk(KERN_INFO "Size = (end - start) = %lu - %lu = %lu\n", i_vm->vm_end, i_vm->vm_start, vma_size);	
+		total += vma_size;
+		
+		//determine permissions
+		unsigned long permissions = i_vm->vm_flags;
+		if(permissions & 1) //read
+			printk(KERN_INFO "Read permission = allowed\n");
+		else
+			printk(KERN_INFO "Read permission = denied\n");
+		if(permissions & 2) //write
+			printk(KERN_INFO "Write permission = allowed\n");
+		else 
+			printk(KERN_INFO "Write permission = denied\n");
+		if(permissions & 4)
+			printk(KERN_INFO "Execute permission = allowed\n");
+		else
+			printk(KERN_INFO "Execute permission = denied\n");		
+		
+		//get file name
+		if(i_vm->vm_file != NULL)
+		{
+			char *file_name = d_path(&(i_vm->vm_file->f_path), (char *)__get_free_page(GFP_TEMPORARY), PAGE_SIZE); 
+			printk(KERN_INFO "File Name: %s\n",file_name);		
+		} 	
+		//check bounds
+		if(i != num_mem-1)  
+			i_vm = i_vm->vm_next;
+	}
+	printk(KERN_INFO "Total size = %lu\n", total);
+	
+	return 1;
+}
diff -uNr linux-2.6.32/my_source/virtual_mem_status.c clean_modified/linux-2.6.32/my_source/virtual_mem_status.c
--- linux-2.6.32/my_source/virtual_mem_status.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/my_source/virtual_mem_status.c	2019-04-14 13:23:51.369054248 -0500
@@ -0,0 +1,39 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm_types.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+asmlinkage int virtual_mem_status(unsigned long v_mem, int pid)
+{
+	//get task_struct
+	struct task_struct *task = pid_task(find_vpid(pid), PIDTYPE_PID);
+	if(!task)
+	{
+		printk(KERN_INFO "could not find process with pid %d\n",pid);
+		return 0;
+	}	
+	//get memory struct
+	struct mm_struct *process_mem = task->active_mm;
+	
+	//get memory offset through "walking"
+	pgd_t *global = pgd_offset(process_mem, v_mem);
+	pud_t *upper = pud_offset(global, v_mem);
+	pmd_t *middle = pmd_offset(upper, v_mem);
+	pte_t *ptep = pte_offset_kernel(middle, v_mem);
+	
+	//check flags
+	if(pte_present(*ptep))
+		printk(KERN_INFO "PRESENT IN MEMORY\n");
+	else
+		printk(KERN_INFO "NOT PRESENT IN MEMORY, ON DISK\n");
+	if(pte_young(*ptep))
+		printk(KERN_INFO "REFERENCED\n");
+	else
+		printk(KERN_INFO "NOT REFERENCED\n");
+	if(pte_dirty(*ptep))
+		printk(KERN_INFO "DIRTY\n");
+	else
+		printk(KERN_INFO "NOT DIRTY\n");
+	return 0;
+}
diff -uNr linux-2.6.32/scripts/genksyms/keywords.c clean_modified/linux-2.6.32/scripts/genksyms/keywords.c
--- linux-2.6.32/scripts/genksyms/keywords.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/genksyms/keywords.c	2019-04-14 13:23:53.672550972 -0500
@@ -0,0 +1,217 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf -L ANSI-C -a -C -E -g -H is_reserved_hash -k '1,3,$' -N is_reserved_word -p -t scripts/genksyms/keywords.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "scripts/genksyms/keywords.gperf"
+
+struct resword;
+static const struct resword *is_reserved_word(register const char *str, register unsigned int len);
+#line 5 "scripts/genksyms/keywords.gperf"
+struct resword { const char *name; int token; };
+/* maximum key range = 62, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+is_reserved_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65,  5,
+      65, 65, 65, 65, 65, 65, 35, 65, 65, 65,
+       0, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65,  0, 65,  0, 65,  5,
+      20, 15, 10, 30, 65, 15, 65, 65, 20,  0,
+      10, 35, 20, 65, 10,  5,  0, 10,  5, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+      65, 65, 65, 65, 65, 65
+    };
+  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct resword *
+is_reserved_word (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 43,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 24,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 64
+    };
+
+  static const struct resword wordlist[] =
+    {
+      {""}, {""}, {""},
+#line 28 "scripts/genksyms/keywords.gperf"
+      {"asm", ASM_KEYW},
+      {""},
+#line 10 "scripts/genksyms/keywords.gperf"
+      {"__asm", ASM_KEYW},
+      {""},
+#line 11 "scripts/genksyms/keywords.gperf"
+      {"__asm__", ASM_KEYW},
+      {""}, {""},
+#line 54 "scripts/genksyms/keywords.gperf"
+      {"__typeof__", TYPEOF_KEYW},
+      {""},
+#line 14 "scripts/genksyms/keywords.gperf"
+      {"__const", CONST_KEYW},
+#line 13 "scripts/genksyms/keywords.gperf"
+      {"__attribute__", ATTRIBUTE_KEYW},
+#line 15 "scripts/genksyms/keywords.gperf"
+      {"__const__", CONST_KEYW},
+#line 20 "scripts/genksyms/keywords.gperf"
+      {"__signed__", SIGNED_KEYW},
+#line 46 "scripts/genksyms/keywords.gperf"
+      {"static", STATIC_KEYW},
+#line 22 "scripts/genksyms/keywords.gperf"
+      {"__volatile__", VOLATILE_KEYW},
+#line 41 "scripts/genksyms/keywords.gperf"
+      {"int", INT_KEYW},
+#line 34 "scripts/genksyms/keywords.gperf"
+      {"char", CHAR_KEYW},
+#line 35 "scripts/genksyms/keywords.gperf"
+      {"const", CONST_KEYW},
+#line 47 "scripts/genksyms/keywords.gperf"
+      {"struct", STRUCT_KEYW},
+#line 26 "scripts/genksyms/keywords.gperf"
+      {"__restrict__", RESTRICT_KEYW},
+#line 27 "scripts/genksyms/keywords.gperf"
+      {"restrict", RESTRICT_KEYW},
+#line 25 "scripts/genksyms/keywords.gperf"
+      {"_restrict", RESTRICT_KEYW},
+#line 18 "scripts/genksyms/keywords.gperf"
+      {"__inline__", INLINE_KEYW},
+#line 12 "scripts/genksyms/keywords.gperf"
+      {"__attribute", ATTRIBUTE_KEYW},
+      {""},
+#line 16 "scripts/genksyms/keywords.gperf"
+      {"__extension__", EXTENSION_KEYW},
+#line 37 "scripts/genksyms/keywords.gperf"
+      {"enum", ENUM_KEYW},
+#line 21 "scripts/genksyms/keywords.gperf"
+      {"__volatile", VOLATILE_KEYW},
+#line 38 "scripts/genksyms/keywords.gperf"
+      {"extern", EXTERN_KEYW},
+      {""},
+#line 19 "scripts/genksyms/keywords.gperf"
+      {"__signed", SIGNED_KEYW},
+#line 9 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW},
+      {""},
+#line 53 "scripts/genksyms/keywords.gperf"
+      {"typeof", TYPEOF_KEYW},
+#line 48 "scripts/genksyms/keywords.gperf"
+      {"typedef", TYPEDEF_KEYW},
+#line 17 "scripts/genksyms/keywords.gperf"
+      {"__inline", INLINE_KEYW},
+#line 33 "scripts/genksyms/keywords.gperf"
+      {"auto", AUTO_KEYW},
+#line 49 "scripts/genksyms/keywords.gperf"
+      {"union", UNION_KEYW},
+      {""}, {""},
+#line 50 "scripts/genksyms/keywords.gperf"
+      {"unsigned", UNSIGNED_KEYW},
+#line 51 "scripts/genksyms/keywords.gperf"
+      {"void", VOID_KEYW},
+#line 44 "scripts/genksyms/keywords.gperf"
+      {"short", SHORT_KEYW},
+      {""}, {""},
+#line 52 "scripts/genksyms/keywords.gperf"
+      {"volatile", VOLATILE_KEYW},
+      {""},
+#line 39 "scripts/genksyms/keywords.gperf"
+      {"float", FLOAT_KEYW},
+#line 36 "scripts/genksyms/keywords.gperf"
+      {"double", DOUBLE_KEYW},
+      {""},
+#line 7 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
+      {""}, {""},
+#line 40 "scripts/genksyms/keywords.gperf"
+      {"inline", INLINE_KEYW},
+#line 8 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
+#line 43 "scripts/genksyms/keywords.gperf"
+      {"register", REGISTER_KEYW},
+      {""},
+#line 24 "scripts/genksyms/keywords.gperf"
+      {"_Bool", BOOL_KEYW},
+#line 45 "scripts/genksyms/keywords.gperf"
+      {"signed", SIGNED_KEYW},
+      {""}, {""},
+#line 42 "scripts/genksyms/keywords.gperf"
+      {"long", LONG_KEYW}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = is_reserved_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key].name;
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return &wordlist[key];
+        }
+    }
+  return 0;
+}
diff -uNr linux-2.6.32/scripts/genksyms/lex.c clean_modified/linux-2.6.32/scripts/genksyms/lex.c
--- linux-2.6.32/scripts/genksyms/lex.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/genksyms/lex.c	2019-04-14 13:23:53.677991102 -0500
@@ -0,0 +1,2709 @@
+#line 2 "scripts/genksyms/lex.c"
+
+#line 4 "scripts/genksyms/lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+/* %not-for-header */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+
+/* %endif */
+/* %endif */
+/* %ok-for-header */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* %if-c++-only */
+/* %endif */
+
+/* %if-c-only */
+    
+/* %endif */
+
+/* %if-c-only */
+
+/* %endif */
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+/* %if-c-only */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+/* %endif */
+
+/* %if-tables-serialization */
+/* %endif */
+/* end standard C headers. */
+
+/* %if-c-or-c++ */
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* %not-for-header */
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+/* %ok-for-header */
+
+/* %if-reentrant */
+/* %endif */
+
+/* %if-not-reentrant */
+
+/* %endif */
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+/* %if-not-reentrant */
+extern int yyleng;
+/* %endif */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+extern FILE *yyin, *yyout;
+/* %endif */
+/* %endif */
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+/* %if-c-only */
+	FILE *yy_input_file;
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+/* %if-not-reentrant */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+/* %endif */
+/* %ok-for-header */
+
+/* %endif */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* %if-c-only Standard (non-C++) definition */
+
+/* %if-not-reentrant */
+/* %not-for-header */
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+/* %ok-for-header */
+
+/* %endif */
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+/* %endif */
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+/* %if-c-only Standard (non-C++) definition */
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* %endif */
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */\
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */\
+	(yy_c_buf_p) = yy_cp;
+
+/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
+#define YY_NUM_RULES 13
+#define YY_END_OF_BUFFER 14
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[76] =
+    {   0,
+        0,    0,    0,    0,   14,   12,    4,    3,   12,    7,
+       12,   12,    7,   12,   12,   12,   12,   12,    9,    9,
+       12,   12,   12,    4,    0,    5,    0,    7,    0,    6,
+        0,    0,    0,    0,    0,    0,    2,    8,   10,   10,
+        9,    0,    0,    9,    9,    0,    9,    0,    0,   11,
+        0,    0,    0,   10,    0,   10,    9,    9,    0,    0,
+        0,    0,    0,    0,    0,   10,   10,    0,    0,    0,
+        0,    0,    0,    1,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    6,    7,    8,    9,   10,    1,
+        1,    8,   11,    1,   12,   13,    8,   14,   15,   15,
+       15,   15,   15,   15,   15,   16,   16,    1,    1,   17,
+       18,   19,    1,    1,   20,   20,   20,   20,   21,   22,
+        7,    7,    7,    7,    7,   23,    7,    7,    7,    7,
+        7,    7,    7,    7,   24,    7,    7,   25,    7,    7,
+        1,   26,    1,    8,    7,    1,   20,   20,   20,   20,
+
+       21,   22,    7,    7,    7,    7,    7,   27,    7,    7,
+        7,    7,    7,    7,    7,    7,   24,    7,    7,   25,
+        7,    7,    1,   28,    1,    8,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[29] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
+        4,    4,    5,    6,    6,    6,    1,    1,    1,    7,
+        8,    7,    3,    3,    3,    1,    3,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[88] =
+    {   0,
+        0,  147,   21,  140,  145,  284,   39,  284,   26,    0,
+       32,  126,   40,   44,  115,   35,   36,   46,   50,   53,
+       39,   61,   54,   79,   65,  284,    0,    0,   66,  284,
+        0,  119,   79,   75,  123,  104,  284,  284,  107,    0,
+       79,   73,   76,   76,   66,    0,    0,   85,   86,  284,
+      133,   83,   91,  284,   99,  147,  284,  114,  122,   70,
+      107,  141,  172,  151,  135,  181,  284,  137,  114,  157,
+      149,   48,   45,  284,  284,  208,  214,  222,  230,  238,
+      246,  250,  255,  256,  261,  267,  275
+    } ;
+
+static yyconst flex_int16_t yy_def[88] =
+    {   0,
+       75,    1,    1,    3,   75,   75,   75,   75,   76,   77,
+       78,   75,   77,   79,   75,   75,   75,   75,   75,   19,
+       75,   75,   75,   75,   76,   75,   80,   77,   78,   75,
+       81,   75,   76,   78,   79,   79,   75,   75,   75,   39,
+       19,   82,   83,   75,   75,   84,   20,   76,   78,   75,
+       79,   51,   85,   75,   75,   75,   75,   84,   79,   51,
+       79,   79,   79,   51,   75,   75,   75,   86,   79,   63,
+       86,   87,   87,   75,    0,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75
+    } ;
+
+static yyconst flex_int16_t yy_nxt[313] =
+    {   0,
+        6,    7,    8,    7,    9,    6,   10,    6,    6,   11,
+        6,    6,   12,    6,    6,    6,    6,    6,    6,   10,
+       10,   10,   13,   10,   10,    6,   10,    6,   15,   16,
+       26,   15,   17,   18,   19,   20,   20,   21,   15,   22,
+       24,   30,   24,   38,   33,   36,   37,   74,   23,   34,
+       74,   27,   38,   38,   38,   38,   38,   31,   32,   39,
+       39,   39,   40,   41,   41,   42,   47,   47,   47,   26,
+       43,   38,   44,   45,   46,   30,   44,   75,   38,   38,
+       24,   38,   24,   26,   30,   40,   55,   55,   57,   26,
+       27,   31,   57,   43,   35,   30,   64,   64,   64,   57,
+
+       31,   65,   65,   75,   27,   36,   37,   35,   59,   37,
+       27,   31,   56,   56,   56,   59,   37,   51,   52,   52,
+       39,   39,   39,   59,   37,   37,   68,   53,   54,   54,
+       69,   50,   38,   54,   59,   37,   44,   45,   32,   37,
+       44,   35,   59,   37,   75,   14,   60,   60,   66,   66,
+       66,   37,   14,   72,   75,   61,   62,   63,   59,   61,
+       56,   56,   56,   69,   64,   64,   64,   69,   67,   67,
+       75,   75,   75,   67,   37,   35,   75,   75,   75,   61,
+       62,   75,   75,   61,   75,   70,   70,   70,   75,   75,
+       75,   70,   70,   70,   66,   66,   66,   75,   75,   75,
+
+       75,   75,   54,   54,   75,   75,   75,   54,   25,   25,
+       25,   25,   25,   25,   25,   25,   28,   75,   75,   28,
+       28,   28,   29,   29,   29,   29,   29,   29,   29,   29,
+       35,   35,   35,   35,   35,   35,   35,   35,   48,   75,
+       48,   48,   48,   48,   48,   48,   49,   75,   49,   49,
+       49,   49,   49,   49,   42,   42,   75,   42,   56,   75,
+       56,   58,   58,   58,   66,   75,   66,   71,   71,   71,
+       71,   71,   71,   71,   71,   73,   73,   73,   73,   73,
+       73,   73,   73,    5,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75
+    } ;
+
+static yyconst flex_int16_t yy_chk[313] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    3,    3,
+        9,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        7,   11,    7,   16,   13,   14,   14,   73,    3,   13,
+       72,    9,   16,   17,   17,   21,   21,   11,   18,   18,
+       18,   18,   19,   19,   19,   19,   20,   20,   20,   25,
+       19,   23,   19,   19,   19,   29,   19,   20,   22,   22,
+       24,   23,   24,   33,   34,   42,   43,   43,   45,   48,
+       25,   29,   45,   42,   60,   49,   52,   52,   52,   44,
+
+       34,   53,   53,   41,   33,   36,   36,   52,   61,   61,
+       48,   49,   55,   55,   55,   69,   69,   36,   36,   36,
+       39,   39,   39,   59,   59,   35,   59,   39,   39,   39,
+       61,   32,   15,   39,   51,   51,   58,   58,   12,   68,
+       58,   68,   62,   62,    5,    4,   51,   51,   65,   65,
+       65,   71,    2,   71,    0,   51,   51,   51,   70,   51,
+       56,   56,   56,   62,   64,   64,   64,   62,   56,   56,
+        0,    0,    0,   56,   63,   64,    0,    0,    0,   70,
+       70,    0,    0,   70,    0,   63,   63,   63,    0,    0,
+        0,   63,   63,   63,   66,   66,   66,    0,    0,    0,
+
+        0,    0,   66,   66,    0,    0,    0,   66,   76,   76,
+       76,   76,   76,   76,   76,   76,   77,    0,    0,   77,
+       77,   77,   78,   78,   78,   78,   78,   78,   78,   78,
+       79,   79,   79,   79,   79,   79,   79,   79,   80,    0,
+       80,   80,   80,   80,   80,   80,   81,    0,   81,   81,
+       81,   81,   81,   81,   82,   82,    0,   82,   83,    0,
+       83,   84,   84,   84,   85,    0,   85,   86,   86,   86,
+       86,   86,   86,   86,   86,   87,   87,   87,   87,   87,
+       87,   87,   87,   75,   75,   75,   75,   75,   75,   75,
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
+       75,   75
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 1;
+
+static yyconst flex_int16_t yy_rule_linenum[13] =
+    {   0,
+       71,   72,   73,   76,   79,   80,   81,   87,   88,   89,
+       91,   94
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scripts/genksyms/lex.l"
+/* Lexical analysis for genksyms.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   Taken from Linux modutils 2.4.22.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+#line 25 "scripts/genksyms/lex.l"
+
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "genksyms.h"
+#include "parse.h"
+
+/* We've got a two-level lexer here.  We let flex do basic tokenization
+   and then we categorize those basic tokens in the second stage.  */
+#define YY_DECL		static int yylex1(void)
+
+/* Version 2 checksumming does proper tokenization; version 1 wasn't
+   quite so pedantic.  */
+
+/* We don't do multiple input files.  */
+#define YY_NO_INPUT 1
+#line 676 "scripts/genksyms/lex.c"
+
+#define INITIAL 0
+#define V2_TOKENS 1
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+/* %if-c-only */
+#include <unistd.h>
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+/* %if-c-only Reentrant structure and macros (non-C++). */
+/* %if-reentrant */
+/* %if-c-only */
+
+static int yy_init_globals (void );
+
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %endif End reentrant structures and macros. */
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* %if-bison-bridge */
+/* %endif */
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+/* %not-for-header */
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+/* %ok-for-header */
+
+/* %endif */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+/* %ok-for-header */
+
+/* %endif */
+#endif
+
+/* %if-c-only */
+
+/* %endif */
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* %if-c-only Standard (non-C++) definition */
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+/* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */\
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+/* %if-c++-only C++ definition \ */\
+/* %endif */
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+/* %if-c-only */
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+/* %if-tables-serialization structures and prototypes */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* %tables-yydmap generated elements */
+/* %endif */
+/* end tables serialization structures and prototypes */
+
+/* %ok-for-header */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+/* %if-c-only Standard (non-C++) definition */
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+/* %% [6.0] YY_RULE_SETUP definition goes here */
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/* %not-for-header */
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+/* %% [7.0] user's declarations go here */
+#line 67 "scripts/genksyms/lex.l"
+
+
+
+ /* Keep track of our location in the original source files.  */
+#line 927 "scripts/genksyms/lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+/* %if-c-only */
+			yyin = stdin;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! yyout )
+/* %if-c-only */
+			yyout = stdout;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+/* %% [8.0] yymore()-related code goes here */
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+/* %% [9.0] code to set up and find next match goes here */
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 76 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 284 );
+
+yy_find_action:
+/* %% [10.0] code to find the action number goes here */
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+/* %% [11.0] code for yylineno update goes here */
+
+do_action:	/* This label is used only to access EOF actions. */
+
+/* %% [12.0] debug code goes here */
+		if ( yy_flex_debug )
+			{
+			if ( yy_act == 0 )
+				fprintf( stderr, "--scanner backing up\n" );
+			else if ( yy_act < 13 )
+				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
+				         (long)yy_rule_linenum[yy_act], yytext );
+			else if ( yy_act == 13 )
+				fprintf( stderr, "--accepting default rule (\"%s\")\n",
+				         yytext );
+			else if ( yy_act == 14 )
+				fprintf( stderr, "--(end of buffer or a NUL)\n" );
+			else
+				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
+			}
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+/* %% [13.0] actions go here */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 71 "scripts/genksyms/lex.l"
+return FILENAME;
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 72 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 73 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+/* Ignore all other whitespace.  */
+case 4:
+YY_RULE_SETUP
+#line 76 "scripts/genksyms/lex.l"
+;
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 79 "scripts/genksyms/lex.l"
+return STRING;
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 80 "scripts/genksyms/lex.l"
+return CHAR;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 81 "scripts/genksyms/lex.l"
+return IDENT;
+	YY_BREAK
+/* The Pedant requires that the other C multi-character tokens be
+    recognized as tokens.  We don't actually use them since we don't
+    parse expressions, but we do want whitespace to be arranged
+    around them properly.  */
+case 8:
+YY_RULE_SETUP
+#line 87 "scripts/genksyms/lex.l"
+return OTHER;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 88 "scripts/genksyms/lex.l"
+return INT;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 89 "scripts/genksyms/lex.l"
+return REAL;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 91 "scripts/genksyms/lex.l"
+return DOTS;
+	YY_BREAK
+/* All other tokens are single characters.  */
+case 12:
+YY_RULE_SETUP
+#line 94 "scripts/genksyms/lex.l"
+return yytext[0];
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 97 "scripts/genksyms/lex.l"
+ECHO;
+	YY_BREAK
+#line 1118 "scripts/genksyms/lex.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(V2_TOKENS):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+/* %ok-for-header */
+
+/* %if-c++-only */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %endif */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+/* %if-c-only */
+static int yy_get_next_buffer (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+/* %if-c-only */
+/* %not-for-header */
+
+    static yy_state_type yy_get_previous_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+/* %% [15.0] code to get the start state into yy_current_state goes here */
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+/* %% [16.0] code to find the next state goes here */
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 76 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+/* %if-c-only */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register int yy_is_jam;
+    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
+	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 76 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 75);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+/* %if-c-only */
+
+    static void yyunput (int c, register char * yy_bp )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+/* %% [18.0] update yylineno here */
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+/* %if-c-only */
+
+/* %endif */
+
+/* %if-c-only */
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+/* %% [19.0] update BOL and yylineno */
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+/* %if-c-only */
+#endif	/* ifndef YY_NO_INPUT */
+/* %endif */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+/* %if-c-only */
+    void yyrestart  (FILE * input_file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+/* %if-c-only */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/* %if-c-only */
+static void yy_load_buffer_state  (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+/* %if-c-only */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+/* %if-c-only */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* %if-c-only */
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+/* %if-c-only */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+/* %if-c-only */
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+/* %if-c-only */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/* %if-c-or-c++ */
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+/* %if-c-only */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+/* %if-c-only */
+void yypop_buffer_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+/* %if-c-only */
+static void yyensure_buffer_stack (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+/* %endif */
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+/* %if-c-only */
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/* %if-c-only */
+/* %if-reentrant */
+/* %endif */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/* %if-reentrant */
+/* %endif */
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+/* %endif */
+
+/* %if-reentrant */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif if-c-only */
+
+/* %if-c-only */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+/* %endif */
+
+/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+/* %if-reentrant */
+/* %endif */
+    return 0;
+}
+/* %endif */
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+/* %if-tables-serialization definitions */
+/* %define-yytables   The name for this specific scanner's tables. */
+#define YYTABLES_NAME "yytables"
+/* %endif */
+
+/* %ok-for-header */
+
+#line 97 "scripts/genksyms/lex.l"
+
+
+
+/* Bring in the keyword recognizer.  */
+
+#include "keywords.c"
+
+
+/* Macros to append to our phrase collection list.  */
+
+#define _APP(T,L)	do {						   \
+			  cur_node = next_node;				   \
+			  next_node = xmalloc(sizeof(*next_node));	   \
+			  next_node->next = cur_node;			   \
+			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
+			  cur_node->tag = SYM_NORMAL;			   \
+			} while (0)
+
+#define APP		_APP(yytext, yyleng)
+
+
+/* The second stage lexer.  Here we incorporate knowledge of the state
+   of the parser to tailor the tokens that are returned.  */
+
+int
+yylex(void)
+{
+  static enum {
+    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_BRACKET, ST_BRACE,
+    ST_EXPRESSION, ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
+    ST_TABLE_5, ST_TABLE_6
+  } lexstate = ST_NOTSTARTED;
+
+  static int suppress_type_lookup, dont_want_brace_phrase;
+  static struct string_list *next_node;
+
+  int token, count = 0;
+  struct string_list *cur_node;
+
+  if (lexstate == ST_NOTSTARTED)
+    {
+      BEGIN(V2_TOKENS);
+      next_node = xmalloc(sizeof(*next_node));
+      next_node->next = NULL;
+      lexstate = ST_NORMAL;
+    }
+
+repeat:
+  token = yylex1();
+
+  if (token == 0)
+    return 0;
+  else if (token == FILENAME)
+    {
+      char *file, *e;
+
+      /* Save the filename and line number for later error messages.  */
+
+      if (cur_filename)
+	free(cur_filename);
+
+      file = strchr(yytext, '\"')+1;
+      e = strchr(file, '\"');
+      *e = '\0';
+      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
+      cur_line = atoi(yytext+2);
+
+      goto repeat;
+    }
+
+  switch (lexstate)
+    {
+    case ST_NORMAL:
+      switch (token)
+	{
+	case IDENT:
+	  APP;
+	  {
+	    const struct resword *r = is_reserved_word(yytext, yyleng);
+	    if (r)
+	      {
+		switch (token = r->token)
+		  {
+		  case ATTRIBUTE_KEYW:
+		    lexstate = ST_ATTRIBUTE;
+		    count = 0;
+		    goto repeat;
+		  case ASM_KEYW:
+		    lexstate = ST_ASM;
+		    count = 0;
+		    goto repeat;
+
+		  case STRUCT_KEYW:
+		  case UNION_KEYW:
+		    dont_want_brace_phrase = 3;
+		  case ENUM_KEYW:
+		    suppress_type_lookup = 2;
+		    goto fini;
+
+		  case EXPORT_SYMBOL_KEYW:
+		      goto fini;
+		  }
+	      }
+	    if (!suppress_type_lookup)
+	      {
+		struct symbol *sym = find_symbol(yytext, SYM_TYPEDEF);
+		if (sym && sym->type == SYM_TYPEDEF)
+		  token = TYPE;
+	      }
+	  }
+	  break;
+
+	case '[':
+	  APP;
+	  lexstate = ST_BRACKET;
+	  count = 1;
+	  goto repeat;
+
+	case '{':
+	  APP;
+	  if (dont_want_brace_phrase)
+	    break;
+	  lexstate = ST_BRACE;
+	  count = 1;
+	  goto repeat;
+
+	case '=': case ':':
+	  APP;
+	  lexstate = ST_EXPRESSION;
+	  break;
+
+	case DOTS:
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    case ST_ATTRIBUTE:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ATTRIBUTE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_ASM:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ASM_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACKET:
+      APP;
+      switch (token)
+	{
+	case '[':
+	  ++count;
+	  goto repeat;
+	case ']':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACKET_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACE:
+      APP;
+      switch (token)
+	{
+	case '{':
+	  ++count;
+	  goto repeat;
+	case '}':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_EXPRESSION:
+      switch (token)
+	{
+	case '(': case '[': case '{':
+	  ++count;
+	  APP;
+	  goto repeat;
+	case ')': case ']': case '}':
+	  --count;
+	  APP;
+	  goto repeat;
+	case ',': case ';':
+	  if (count == 0)
+	    {
+	      /* Put back the token we just read so's we can find it again
+		 after registering the expression.  */
+	      unput(token);
+
+	      lexstate = ST_NORMAL;
+	      token = EXPRESSION_PHRASE;
+	      break;
+	    }
+	  APP;
+	  goto repeat;
+	default:
+	  APP;
+	  goto repeat;
+	}
+      break;
+
+    case ST_TABLE_1:
+      goto repeat;
+
+    case ST_TABLE_2:
+      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
+	{
+	  token = EXPORT_SYMBOL_KEYW;
+	  lexstate = ST_TABLE_5;
+	  APP;
+	  break;
+	}
+      lexstate = ST_TABLE_6;
+      /* FALLTHRU */
+
+    case ST_TABLE_6:
+      switch (token)
+	{
+	case '{': case '[': case '(':
+	  ++count;
+	  break;
+	case '}': case ']': case ')':
+	  --count;
+	  break;
+	case ',':
+	  if (count == 0)
+	    lexstate = ST_TABLE_2;
+	  break;
+	};
+      goto repeat;
+
+    case ST_TABLE_3:
+      goto repeat;
+
+    case ST_TABLE_4:
+      if (token == ';')
+	lexstate = ST_NORMAL;
+      goto repeat;
+
+    case ST_TABLE_5:
+      switch (token)
+	{
+	case ',':
+	  token = ';';
+	  lexstate = ST_TABLE_2;
+	  APP;
+	  break;
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    default:
+      exit(1);
+    }
+fini:
+
+  if (suppress_type_lookup > 0)
+    --suppress_type_lookup;
+  if (dont_want_brace_phrase > 0)
+    --dont_want_brace_phrase;
+
+  yylval = &next_node->next;
+
+  return token;
+}
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     EXTENSION_KEYW = 267,
+     FLOAT_KEYW = 268,
+     INLINE_KEYW = 269,
+     INT_KEYW = 270,
+     LONG_KEYW = 271,
+     REGISTER_KEYW = 272,
+     RESTRICT_KEYW = 273,
+     SHORT_KEYW = 274,
+     SIGNED_KEYW = 275,
+     STATIC_KEYW = 276,
+     STRUCT_KEYW = 277,
+     TYPEDEF_KEYW = 278,
+     UNION_KEYW = 279,
+     UNSIGNED_KEYW = 280,
+     VOID_KEYW = 281,
+     VOLATILE_KEYW = 282,
+     TYPEOF_KEYW = 283,
+     EXPORT_SYMBOL_KEYW = 284,
+     ASM_PHRASE = 285,
+     ATTRIBUTE_PHRASE = 286,
+     BRACE_PHRASE = 287,
+     BRACKET_PHRASE = 288,
+     EXPRESSION_PHRASE = 289,
+     CHAR = 290,
+     DOTS = 291,
+     IDENT = 292,
+     INT = 293,
+     REAL = 294,
+     STRING = 295,
+     TYPE = 296,
+     OTHER = 297,
+     FILENAME = 298
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define EXTENSION_KEYW 267
+#define FLOAT_KEYW 268
+#define INLINE_KEYW 269
+#define INT_KEYW 270
+#define LONG_KEYW 271
+#define REGISTER_KEYW 272
+#define RESTRICT_KEYW 273
+#define SHORT_KEYW 274
+#define SIGNED_KEYW 275
+#define STATIC_KEYW 276
+#define STRUCT_KEYW 277
+#define TYPEDEF_KEYW 278
+#define UNION_KEYW 279
+#define UNSIGNED_KEYW 280
+#define VOID_KEYW 281
+#define VOLATILE_KEYW 282
+#define TYPEOF_KEYW 283
+#define EXPORT_SYMBOL_KEYW 284
+#define ASM_PHRASE 285
+#define ATTRIBUTE_PHRASE 286
+#define BRACE_PHRASE 287
+#define BRACKET_PHRASE 288
+#define EXPRESSION_PHRASE 289
+#define CHAR 290
+#define DOTS 291
+#define IDENT 292
+#define INT 293
+#define REAL 294
+#define STRING 295
+#define TYPE 296
+#define OTHER 297
+#define FILENAME 298
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
diff -uNr linux-2.6.32/scripts/genksyms/parse.c clean_modified/linux-2.6.32/scripts/genksyms/parse.c
--- linux-2.6.32/scripts/genksyms/parse.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/genksyms/parse.c	2019-04-14 13:23:53.693266216 -0500
@@ -0,0 +1,2353 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     EXTENSION_KEYW = 267,
+     FLOAT_KEYW = 268,
+     INLINE_KEYW = 269,
+     INT_KEYW = 270,
+     LONG_KEYW = 271,
+     REGISTER_KEYW = 272,
+     RESTRICT_KEYW = 273,
+     SHORT_KEYW = 274,
+     SIGNED_KEYW = 275,
+     STATIC_KEYW = 276,
+     STRUCT_KEYW = 277,
+     TYPEDEF_KEYW = 278,
+     UNION_KEYW = 279,
+     UNSIGNED_KEYW = 280,
+     VOID_KEYW = 281,
+     VOLATILE_KEYW = 282,
+     TYPEOF_KEYW = 283,
+     EXPORT_SYMBOL_KEYW = 284,
+     ASM_PHRASE = 285,
+     ATTRIBUTE_PHRASE = 286,
+     BRACE_PHRASE = 287,
+     BRACKET_PHRASE = 288,
+     EXPRESSION_PHRASE = 289,
+     CHAR = 290,
+     DOTS = 291,
+     IDENT = 292,
+     INT = 293,
+     REAL = 294,
+     STRING = 295,
+     TYPE = 296,
+     OTHER = 297,
+     FILENAME = 298
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define EXTENSION_KEYW 267
+#define FLOAT_KEYW 268
+#define INLINE_KEYW 269
+#define INT_KEYW 270
+#define LONG_KEYW 271
+#define REGISTER_KEYW 272
+#define RESTRICT_KEYW 273
+#define SHORT_KEYW 274
+#define SIGNED_KEYW 275
+#define STATIC_KEYW 276
+#define STRUCT_KEYW 277
+#define TYPEDEF_KEYW 278
+#define UNION_KEYW 279
+#define UNSIGNED_KEYW 280
+#define VOID_KEYW 281
+#define VOLATILE_KEYW 282
+#define TYPEOF_KEYW 283
+#define EXPORT_SYMBOL_KEYW 284
+#define ASM_PHRASE 285
+#define ATTRIBUTE_PHRASE 286
+#define BRACE_PHRASE 287
+#define BRACKET_PHRASE 288
+#define EXPRESSION_PHRASE 289
+#define CHAR 290
+#define DOTS 291
+#define IDENT 292
+#define INT 293
+#define REAL 294
+#define STRING 295
+#define TYPE 296
+#define OTHER 297
+#define FILENAME 298
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 24 "scripts/genksyms/parse.y"
+
+
+#include <assert.h>
+#include <malloc.h>
+#include "genksyms.h"
+
+static int is_typedef;
+static int is_extern;
+static char *current_name;
+static struct string_list *decl_spec;
+
+static void yyerror(const char *);
+
+static inline void
+remove_node(struct string_list **p)
+{
+  struct string_list *node = *p;
+  *p = node->next;
+  free_node(node);
+}
+
+static inline void
+remove_list(struct string_list **pb, struct string_list **pe)
+{
+  struct string_list *b = *pb, *e = *pe;
+  *pb = e;
+  free_list(b, e);
+}
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 223 "scripts/genksyms/parse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   523
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  53
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  46
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  126
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  178
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   298
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      47,    49,    48,     2,    46,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    52,    44,
+       2,    50,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    51,     2,    45,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     8,     9,    12,    13,    18,    19,
+      23,    25,    27,    29,    31,    34,    37,    41,    42,    44,
+      46,    50,    55,    56,    58,    60,    63,    65,    67,    69,
+      71,    73,    75,    77,    79,    81,    87,    92,    95,    98,
+     101,   105,   109,   113,   116,   119,   122,   124,   126,   128,
+     130,   132,   134,   136,   138,   140,   142,   144,   147,   148,
+     150,   152,   155,   157,   159,   161,   163,   166,   168,   170,
+     175,   180,   183,   187,   191,   194,   196,   198,   200,   205,
+     210,   213,   217,   221,   224,   226,   230,   231,   233,   235,
+     239,   242,   245,   247,   248,   250,   252,   257,   262,   265,
+     269,   273,   277,   278,   280,   283,   287,   291,   292,   294,
+     296,   299,   303,   306,   307,   309,   311,   315,   318,   321,
+     323,   326,   327,   330,   333,   334,   336
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      54,     0,    -1,    55,    -1,    54,    55,    -1,    -1,    56,
+      57,    -1,    -1,    12,    23,    58,    60,    -1,    -1,    23,
+      59,    60,    -1,    60,    -1,    84,    -1,    96,    -1,    98,
+      -1,     1,    44,    -1,     1,    45,    -1,    64,    61,    44,
+      -1,    -1,    62,    -1,    63,    -1,    62,    46,    63,    -1,
+      74,    97,    95,    85,    -1,    -1,    65,    -1,    66,    -1,
+      65,    66,    -1,    67,    -1,    68,    -1,     5,    -1,    17,
+      -1,    21,    -1,    11,    -1,    14,    -1,    69,    -1,    73,
+      -1,    28,    47,    65,    48,    49,    -1,    28,    47,    65,
+      49,    -1,    22,    37,    -1,    24,    37,    -1,    10,    37,
+      -1,    22,    37,    87,    -1,    24,    37,    87,    -1,    10,
+      37,    32,    -1,    10,    32,    -1,    22,    87,    -1,    24,
+      87,    -1,     7,    -1,    19,    -1,    15,    -1,    16,    -1,
+      20,    -1,    25,    -1,    13,    -1,     9,    -1,    26,    -1,
+       6,    -1,    41,    -1,    48,    71,    -1,    -1,    72,    -1,
+      73,    -1,    72,    73,    -1,     8,    -1,    27,    -1,    31,
+      -1,    18,    -1,    70,    74,    -1,    75,    -1,    37,    -1,
+      75,    47,    78,    49,    -1,    75,    47,     1,    49,    -1,
+      75,    33,    -1,    47,    74,    49,    -1,    47,     1,    49,
+      -1,    70,    76,    -1,    77,    -1,    37,    -1,    41,    -1,
+      77,    47,    78,    49,    -1,    77,    47,     1,    49,    -1,
+      77,    33,    -1,    47,    76,    49,    -1,    47,     1,    49,
+      -1,    79,    36,    -1,    79,    -1,    80,    46,    36,    -1,
+      -1,    80,    -1,    81,    -1,    80,    46,    81,    -1,    65,
+      82,    -1,    70,    82,    -1,    83,    -1,    -1,    37,    -1,
+      41,    -1,    83,    47,    78,    49,    -1,    83,    47,     1,
+      49,    -1,    83,    33,    -1,    47,    82,    49,    -1,    47,
+       1,    49,    -1,    64,    74,    32,    -1,    -1,    86,    -1,
+      50,    34,    -1,    51,    88,    45,    -1,    51,     1,    45,
+      -1,    -1,    89,    -1,    90,    -1,    89,    90,    -1,    64,
+      91,    44,    -1,     1,    44,    -1,    -1,    92,    -1,    93,
+      -1,    92,    46,    93,    -1,    76,    95,    -1,    37,    94,
+      -1,    94,    -1,    52,    34,    -1,    -1,    95,    31,    -1,
+      30,    44,    -1,    -1,    30,    -1,    29,    47,    37,    49,
+      44,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   103,   103,   104,   108,   108,   114,   114,   116,   116,
+     118,   119,   120,   121,   122,   123,   127,   141,   142,   146,
+     154,   167,   173,   174,   178,   179,   183,   189,   193,   194,
+     195,   196,   197,   201,   202,   203,   204,   208,   210,   212,
+     216,   223,   230,   239,   240,   241,   245,   246,   247,   248,
+     249,   250,   251,   252,   253,   254,   255,   259,   264,   265,
+     269,   270,   274,   274,   274,   275,   283,   284,   288,   297,
+     299,   301,   303,   305,   312,   313,   317,   318,   319,   321,
+     323,   325,   327,   332,   333,   334,   338,   339,   343,   344,
+     349,   354,   356,   360,   361,   369,   373,   375,   377,   379,
+     381,   386,   395,   396,   401,   406,   407,   411,   412,   416,
+     417,   421,   423,   428,   429,   433,   434,   438,   439,   440,
+     444,   448,   449,   453,   457,   458,   462
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ASM_KEYW", "ATTRIBUTE_KEYW",
+  "AUTO_KEYW", "BOOL_KEYW", "CHAR_KEYW", "CONST_KEYW", "DOUBLE_KEYW",
+  "ENUM_KEYW", "EXTERN_KEYW", "EXTENSION_KEYW", "FLOAT_KEYW",
+  "INLINE_KEYW", "INT_KEYW", "LONG_KEYW", "REGISTER_KEYW", "RESTRICT_KEYW",
+  "SHORT_KEYW", "SIGNED_KEYW", "STATIC_KEYW", "STRUCT_KEYW",
+  "TYPEDEF_KEYW", "UNION_KEYW", "UNSIGNED_KEYW", "VOID_KEYW",
+  "VOLATILE_KEYW", "TYPEOF_KEYW", "EXPORT_SYMBOL_KEYW", "ASM_PHRASE",
+  "ATTRIBUTE_PHRASE", "BRACE_PHRASE", "BRACKET_PHRASE",
+  "EXPRESSION_PHRASE", "CHAR", "DOTS", "IDENT", "INT", "REAL", "STRING",
+  "TYPE", "OTHER", "FILENAME", "';'", "'}'", "','", "'('", "'*'", "')'",
+  "'='", "'{'", "':'", "$accept", "declaration_seq", "declaration", "@1",
+  "declaration1", "@2", "@3", "simple_declaration",
+  "init_declarator_list_opt", "init_declarator_list", "init_declarator",
+  "decl_specifier_seq_opt", "decl_specifier_seq", "decl_specifier",
+  "storage_class_specifier", "type_specifier", "simple_type_specifier",
+  "ptr_operator", "cvar_qualifier_seq_opt", "cvar_qualifier_seq",
+  "cvar_qualifier", "declarator", "direct_declarator", "nested_declarator",
+  "direct_nested_declarator", "parameter_declaration_clause",
+  "parameter_declaration_list_opt", "parameter_declaration_list",
+  "parameter_declaration", "m_abstract_declarator",
+  "direct_m_abstract_declarator", "function_definition", "initializer_opt",
+  "initializer", "class_body", "member_specification_opt",
+  "member_specification", "member_declaration",
+  "member_declarator_list_opt", "member_declarator_list",
+  "member_declarator", "member_bitfield_declarator", "attribute_opt",
+  "asm_definition", "asm_phrase_opt", "export_definition", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,    59,   125,    44,    40,    42,    41,
+      61,   123,    58
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    53,    54,    54,    56,    55,    58,    57,    59,    57,
+      57,    57,    57,    57,    57,    57,    60,    61,    61,    62,
+      62,    63,    64,    64,    65,    65,    66,    66,    67,    67,
+      67,    67,    67,    68,    68,    68,    68,    68,    68,    68,
+      68,    68,    68,    68,    68,    68,    69,    69,    69,    69,
+      69,    69,    69,    69,    69,    69,    69,    70,    71,    71,
+      72,    72,    73,    73,    73,    73,    74,    74,    75,    75,
+      75,    75,    75,    75,    76,    76,    77,    77,    77,    77,
+      77,    77,    77,    78,    78,    78,    79,    79,    80,    80,
+      81,    82,    82,    83,    83,    83,    83,    83,    83,    83,
+      83,    84,    85,    85,    86,    87,    87,    88,    88,    89,
+      89,    90,    90,    91,    91,    92,    92,    93,    93,    93,
+      94,    95,    95,    96,    97,    97,    98
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     0,     2,     0,     4,     0,     3,
+       1,     1,     1,     1,     2,     2,     3,     0,     1,     1,
+       3,     4,     0,     1,     1,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     5,     4,     2,     2,     2,
+       3,     3,     3,     2,     2,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     2,     0,     1,
+       1,     2,     1,     1,     1,     1,     2,     1,     1,     4,
+       4,     2,     3,     3,     2,     1,     1,     1,     4,     4,
+       2,     3,     3,     2,     1,     3,     0,     1,     1,     3,
+       2,     2,     1,     0,     1,     1,     4,     4,     2,     3,
+       3,     3,     0,     1,     2,     3,     3,     0,     1,     1,
+       2,     3,     2,     0,     1,     1,     3,     2,     2,     1,
+       2,     0,     2,     2,     0,     1,     5
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       4,     4,     2,     0,     1,     3,     0,    28,    55,    46,
+      62,    53,     0,    31,     0,    52,    32,    48,    49,    29,
+      65,    47,    50,    30,     0,     8,     0,    51,    54,    63,
+       0,     0,     0,    64,    56,     5,    10,    17,    23,    24,
+      26,    27,    33,    34,    11,    12,    13,    14,    15,    43,
+      39,     6,    37,     0,    44,    22,    38,    45,     0,     0,
+     123,    68,     0,    58,     0,    18,    19,     0,   124,    67,
+      25,    42,    22,    40,     0,   113,     0,     0,   109,     9,
+      17,    41,     0,     0,     0,     0,    57,    59,    60,    16,
+       0,    66,   125,   101,   121,    71,     0,     7,   112,   106,
+      76,    77,     0,     0,     0,   121,    75,     0,   114,   115,
+     119,   105,     0,   110,   124,     0,    36,     0,    73,    72,
+      61,    20,   102,     0,    93,     0,    84,    87,    88,   118,
+       0,    76,     0,   120,    74,   117,    80,     0,   111,     0,
+      35,   126,   122,     0,    21,   103,    70,    94,    56,     0,
+      93,    90,    92,    69,    83,     0,    82,    81,     0,     0,
+     116,   104,     0,    95,     0,    91,    98,     0,    85,    89,
+      79,    78,   100,    99,     0,     0,    97,    96
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,     3,    35,    72,    55,    36,    64,    65,
+      66,    75,    38,    39,    40,    41,    42,    67,    86,    87,
+      43,   114,    69,   105,   106,   125,   126,   127,   128,   151,
+     152,    44,   144,   145,    54,    76,    77,    78,   107,   108,
+     109,   110,   122,    45,    94,    46
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -134
+static const yytype_int16 yypact[] =
+{
+    -134,    16,  -134,   312,  -134,  -134,    20,  -134,  -134,  -134,
+    -134,  -134,   -18,  -134,    -3,  -134,  -134,  -134,  -134,  -134,
+    -134,  -134,  -134,  -134,   -26,  -134,   -25,  -134,  -134,  -134,
+      -7,     5,    27,  -134,  -134,  -134,  -134,    46,   482,  -134,
+    -134,  -134,  -134,  -134,  -134,  -134,  -134,  -134,  -134,  -134,
+      -8,  -134,    30,    97,  -134,   482,    30,  -134,   482,     7,
+    -134,  -134,    12,    10,    42,    55,  -134,    46,   -15,    15,
+    -134,  -134,   482,  -134,    25,    26,    47,   145,  -134,  -134,
+      46,  -134,   356,    39,    71,    77,  -134,    10,  -134,  -134,
+      46,  -134,  -134,  -134,  -134,  -134,   193,  -134,  -134,  -134,
+      75,  -134,     6,    95,    43,  -134,    28,    86,    85,  -134,
+    -134,  -134,    88,  -134,   103,    87,  -134,    91,  -134,  -134,
+    -134,  -134,   -23,    90,   401,    94,   101,   102,  -134,  -134,
+      98,  -134,   108,  -134,  -134,   109,  -134,   230,  -134,    26,
+    -134,  -134,  -134,   134,  -134,  -134,  -134,  -134,  -134,     9,
+      48,  -134,    35,  -134,  -134,   445,  -134,  -134,   125,   126,
+    -134,  -134,   128,  -134,   129,  -134,  -134,   267,  -134,  -134,
+    -134,  -134,  -134,  -134,   130,   131,  -134,  -134
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -134,  -134,   180,  -134,  -134,  -134,  -134,   -33,  -134,  -134,
+      93,     0,   -58,   -37,  -134,  -134,  -134,   -73,  -134,  -134,
+     -54,   -32,  -134,   -81,  -134,  -133,  -134,  -134,    29,   -50,
+    -134,  -134,  -134,  -134,   -20,  -134,  -134,   110,  -134,  -134,
+      49,    96,    80,  -134,  -134,  -134
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -109
+static const yytype_int16 yytable[] =
+{
+      82,    70,   104,    37,   159,    68,    57,   130,   142,    88,
+     162,    52,    56,    84,    49,    92,     4,    93,    10,    50,
+      51,   132,    79,   134,    71,    53,    53,   143,    20,   104,
+      85,   104,    73,   120,   175,    91,    81,    29,   124,    97,
+      58,    33,   -93,   131,    83,    70,   147,   101,    95,    61,
+     163,   150,    59,   102,    63,    80,   149,    63,   -93,    62,
+      63,   136,    96,   100,    47,    48,   104,   101,   166,    98,
+      99,    60,    80,   102,    63,   137,   150,   150,   103,   124,
+     131,    53,   167,    61,   101,   147,    89,    70,   117,   163,
+     102,    63,   111,    62,    63,   149,    63,   124,    74,   164,
+     165,    90,     7,     8,     9,    10,    11,    12,    13,   124,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+     118,    26,    27,    28,    29,    30,   119,   103,    33,   133,
+     138,   139,    98,    92,   -22,   141,   140,   154,    34,   146,
+     142,   -22,  -107,   153,   -22,   -22,   112,   156,   155,   -22,
+       7,     8,     9,    10,    11,    12,    13,   157,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,   161,    26,
+      27,    28,    29,    30,   170,   171,    33,   172,   173,   176,
+     177,     5,   -22,   121,   169,   135,    34,   113,   160,   -22,
+    -108,     0,   -22,   -22,   123,     0,   129,   -22,     7,     8,
+       9,    10,    11,    12,    13,     0,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,    27,    28,
+      29,    30,     0,     0,    33,     0,     0,     0,     0,   -86,
+       0,   158,     0,     0,    34,     7,     8,     9,    10,    11,
+      12,    13,   -86,    15,    16,    17,    18,    19,    20,    21,
+      22,    23,    24,     0,    26,    27,    28,    29,    30,     0,
+       0,    33,     0,     0,     0,     0,   -86,     0,   174,     0,
+       0,    34,     7,     8,     9,    10,    11,    12,    13,   -86,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+       0,    26,    27,    28,    29,    30,     0,     0,    33,     0,
+       0,     0,     0,   -86,     0,     0,     0,     0,    34,     0,
+       0,     0,     0,     6,     0,     0,   -86,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,     0,     0,     0,     0,     0,   -22,
+       0,     0,     0,    34,     0,     0,   -22,     0,     0,   -22,
+     -22,     7,     8,     9,    10,    11,    12,    13,     0,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,     0,
+      26,    27,    28,    29,    30,     0,     0,    33,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    34,     0,     0,
+       0,     0,     0,     0,   115,   116,     7,     8,     9,    10,
+      11,    12,    13,     0,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,     0,    26,    27,    28,    29,    30,
+       0,     0,    33,     0,     0,     0,     0,     0,   147,     0,
+       0,     0,   148,     0,     0,     0,     0,     0,   149,    63,
+       7,     8,     9,    10,    11,    12,    13,     0,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,     0,    26,
+      27,    28,    29,    30,     0,     0,    33,     0,     0,     0,
+       0,   168,     0,     0,     0,     0,    34,     7,     8,     9,
+      10,    11,    12,    13,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,     0,    26,    27,    28,    29,
+      30,     0,     0,    33,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    34
+};
+
+static const yytype_int16 yycheck[] =
+{
+      58,    38,    75,     3,   137,    37,    26,     1,    31,    63,
+       1,    37,    37,     1,    32,    30,     0,    32,     8,    37,
+      23,   102,    55,   104,    32,    51,    51,    50,    18,   102,
+      62,   104,    52,    87,   167,    67,    56,    27,    96,    72,
+      47,    31,    33,    37,    37,    82,    37,    41,    33,    37,
+      41,   124,    47,    47,    48,    55,    47,    48,    49,    47,
+      48,    33,    47,    37,    44,    45,   139,    41,    33,    44,
+      45,    44,    72,    47,    48,    47,   149,   150,    52,   137,
+      37,    51,    47,    37,    41,    37,    44,   124,    49,    41,
+      47,    48,    45,    47,    48,    47,    48,   155,     1,   149,
+     150,    46,     5,     6,     7,     8,     9,    10,    11,   167,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      49,    24,    25,    26,    27,    28,    49,    52,    31,    34,
+      44,    46,    44,    30,    37,    44,    49,    36,    41,    49,
+      31,    44,    45,    49,    47,    48,     1,    49,    46,    52,
+       5,     6,     7,     8,     9,    10,    11,    49,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    34,    24,
+      25,    26,    27,    28,    49,    49,    31,    49,    49,    49,
+      49,     1,    37,    90,   155,   105,    41,    77,   139,    44,
+      45,    -1,    47,    48,     1,    -1,   100,    52,     5,     6,
+       7,     8,     9,    10,    11,    -1,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    -1,    24,    25,    26,
+      27,    28,    -1,    -1,    31,    -1,    -1,    -1,    -1,    36,
+      -1,     1,    -1,    -1,    41,     5,     6,     7,     8,     9,
+      10,    11,    49,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    -1,    24,    25,    26,    27,    28,    -1,
+      -1,    31,    -1,    -1,    -1,    -1,    36,    -1,     1,    -1,
+      -1,    41,     5,     6,     7,     8,     9,    10,    11,    49,
+      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      -1,    24,    25,    26,    27,    28,    -1,    -1,    31,    -1,
+      -1,    -1,    -1,    36,    -1,    -1,    -1,    -1,    41,    -1,
+      -1,    -1,    -1,     1,    -1,    -1,    49,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    -1,    -1,    -1,    -1,    -1,    37,
+      -1,    -1,    -1,    41,    -1,    -1,    44,    -1,    -1,    47,
+      48,     5,     6,     7,     8,     9,    10,    11,    -1,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    -1,
+      24,    25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    41,    -1,    -1,
+      -1,    -1,    -1,    -1,    48,    49,     5,     6,     7,     8,
+       9,    10,    11,    -1,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    -1,    24,    25,    26,    27,    28,
+      -1,    -1,    31,    -1,    -1,    -1,    -1,    -1,    37,    -1,
+      -1,    -1,    41,    -1,    -1,    -1,    -1,    -1,    47,    48,
+       5,     6,     7,     8,     9,    10,    11,    -1,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    -1,    24,
+      25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,    -1,
+      -1,    36,    -1,    -1,    -1,    -1,    41,     5,     6,     7,
+       8,     9,    10,    11,    -1,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    -1,    24,    25,    26,    27,
+      28,    -1,    -1,    31,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    41
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    54,    55,    56,     0,    55,     1,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    41,    57,    60,    64,    65,    66,
+      67,    68,    69,    73,    84,    96,    98,    44,    45,    32,
+      37,    23,    37,    51,    87,    59,    37,    87,    47,    47,
+      44,    37,    47,    48,    61,    62,    63,    70,    74,    75,
+      66,    32,    58,    87,     1,    64,    88,    89,    90,    60,
+      64,    87,    65,    37,     1,    74,    71,    72,    73,    44,
+      46,    74,    30,    32,    97,    33,    47,    60,    44,    45,
+      37,    41,    47,    52,    70,    76,    77,    91,    92,    93,
+      94,    45,     1,    90,    74,    48,    49,    49,    49,    49,
+      73,    63,    95,     1,    65,    78,    79,    80,    81,    94,
+       1,    37,    76,    34,    76,    95,    33,    47,    44,    46,
+      49,    44,    31,    50,    85,    86,    49,    37,    41,    47,
+      70,    82,    83,    49,    36,    46,    49,    49,     1,    78,
+      93,    34,     1,    41,    82,    82,    33,    47,    36,    81,
+      49,    49,    49,    49,     1,    78,    49,    49
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+#line 108 "scripts/genksyms/parse.y"
+    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; ;}
+    break;
+
+  case 5:
+#line 110 "scripts/genksyms/parse.y"
+    { free_list(*(yyvsp[(2) - (2)]), NULL); *(yyvsp[(2) - (2)]) = NULL; ;}
+    break;
+
+  case 6:
+#line 114 "scripts/genksyms/parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 7:
+#line 115 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 8:
+#line 116 "scripts/genksyms/parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 9:
+#line 117 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 14:
+#line 122 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 15:
+#line 123 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 16:
+#line 128 "scripts/genksyms/parse.y"
+    { if (current_name) {
+		    struct string_list *decl = (*(yyvsp[(3) - (3)]))->next;
+		    (*(yyvsp[(3) - (3)]))->next = NULL;
+		    add_symbol(current_name,
+			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
+			       decl, is_extern);
+		    current_name = NULL;
+		  }
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 17:
+#line 141 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 19:
+#line 147 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(1) - (1)]);
+		  *(yyvsp[(1) - (1)]) = NULL;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 20:
+#line 155 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(3) - (3)]);
+		  *(yyvsp[(3) - (3)]) = NULL;
+		  free_list(*(yyvsp[(2) - (3)]), NULL);
+		  *(yyvsp[(2) - (3)]) = decl_spec;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 21:
+#line 168 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]) ? (yyvsp[(4) - (4)]) : (yyvsp[(3) - (4)]) ? (yyvsp[(3) - (4)]) : (yyvsp[(2) - (4)]) ? (yyvsp[(2) - (4)]) : (yyvsp[(1) - (4)]); ;}
+    break;
+
+  case 22:
+#line 173 "scripts/genksyms/parse.y"
+    { decl_spec = NULL; ;}
+    break;
+
+  case 24:
+#line 178 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 25:
+#line 179 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 26:
+#line 184 "scripts/genksyms/parse.y"
+    { /* Version 2 checksumming ignores storage class, as that
+		     is really irrelevant to the linkage.  */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 31:
+#line 196 "scripts/genksyms/parse.y"
+    { is_extern = 1; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 32:
+#line 197 "scripts/genksyms/parse.y"
+    { is_extern = 0; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 37:
+#line 209 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_STRUCT; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 38:
+#line 211 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_UNION; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 39:
+#line 213 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_ENUM; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 40:
+#line 217 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_STRUCT;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_STRUCT, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 41:
+#line 224 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_UNION;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_UNION, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 42:
+#line 231 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_ENUM;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_ENUM, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 43:
+#line 239 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 44:
+#line 240 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 45:
+#line 241 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 56:
+#line 255 "scripts/genksyms/parse.y"
+    { (*(yyvsp[(1) - (1)]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 57:
+#line 260 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 58:
+#line 264 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 61:
+#line 270 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 65:
+#line 276 "scripts/genksyms/parse.y"
+    { /* restrict has no effect in prototypes so ignore it */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 66:
+#line 283 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 68:
+#line 289 "scripts/genksyms/parse.y"
+    { if (current_name != NULL) {
+		    error_with_pos("unexpected second declaration name");
+		    YYERROR;
+		  } else {
+		    current_name = (*(yyvsp[(1) - (1)]))->string;
+		    (yyval) = (yyvsp[(1) - (1)]);
+		  }
+		;}
+    break;
+
+  case 69:
+#line 298 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 70:
+#line 300 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 71:
+#line 302 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 72:
+#line 304 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 73:
+#line 306 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 74:
+#line 312 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 78:
+#line 320 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 79:
+#line 322 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 80:
+#line 324 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 81:
+#line 326 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 82:
+#line 328 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 83:
+#line 332 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 85:
+#line 334 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 86:
+#line 338 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 89:
+#line 345 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 90:
+#line 350 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 91:
+#line 355 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 93:
+#line 360 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 94:
+#line 362 "scripts/genksyms/parse.y"
+    { /* For version 2 checksums, we don't want to remember
+		     private parameter names.  */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 95:
+#line 370 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 96:
+#line 374 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 97:
+#line 376 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 98:
+#line 378 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 99:
+#line 380 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 100:
+#line 382 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 101:
+#line 387 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(2) - (3)]);
+		  *(yyvsp[(2) - (3)]) = NULL;
+		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 102:
+#line 395 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 104:
+#line 402 "scripts/genksyms/parse.y"
+    { remove_list((yyvsp[(2) - (2)]), &(*(yyvsp[(1) - (2)]))->next); (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 105:
+#line 406 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 106:
+#line 407 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 107:
+#line 411 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 110:
+#line 417 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 111:
+#line 422 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 112:
+#line 424 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 113:
+#line 428 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 116:
+#line 434 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 117:
+#line 438 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 118:
+#line 439 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 120:
+#line 444 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 121:
+#line 448 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 123:
+#line 453 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 124:
+#line 457 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 126:
+#line 463 "scripts/genksyms/parse.y"
+    { export_symbol((*(yyvsp[(3) - (5)]))->string); (yyval) = (yyvsp[(5) - (5)]); ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 2132 "scripts/genksyms/parse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 467 "scripts/genksyms/parse.y"
+
+
+static void
+yyerror(const char *e)
+{
+  error_with_pos("%s", e);
+}
+
diff -uNr linux-2.6.32/scripts/genksyms/parse.h clean_modified/linux-2.6.32/scripts/genksyms/parse.h
--- linux-2.6.32/scripts/genksyms/parse.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/genksyms/parse.h	2019-04-14 13:23:53.693266216 -0500
@@ -0,0 +1,139 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     EXTENSION_KEYW = 267,
+     FLOAT_KEYW = 268,
+     INLINE_KEYW = 269,
+     INT_KEYW = 270,
+     LONG_KEYW = 271,
+     REGISTER_KEYW = 272,
+     RESTRICT_KEYW = 273,
+     SHORT_KEYW = 274,
+     SIGNED_KEYW = 275,
+     STATIC_KEYW = 276,
+     STRUCT_KEYW = 277,
+     TYPEDEF_KEYW = 278,
+     UNION_KEYW = 279,
+     UNSIGNED_KEYW = 280,
+     VOID_KEYW = 281,
+     VOLATILE_KEYW = 282,
+     TYPEOF_KEYW = 283,
+     EXPORT_SYMBOL_KEYW = 284,
+     ASM_PHRASE = 285,
+     ATTRIBUTE_PHRASE = 286,
+     BRACE_PHRASE = 287,
+     BRACKET_PHRASE = 288,
+     EXPRESSION_PHRASE = 289,
+     CHAR = 290,
+     DOTS = 291,
+     IDENT = 292,
+     INT = 293,
+     REAL = 294,
+     STRING = 295,
+     TYPE = 296,
+     OTHER = 297,
+     FILENAME = 298
+   };
+#endif
+/* Tokens.  */
+#define ASM_KEYW 258
+#define ATTRIBUTE_KEYW 259
+#define AUTO_KEYW 260
+#define BOOL_KEYW 261
+#define CHAR_KEYW 262
+#define CONST_KEYW 263
+#define DOUBLE_KEYW 264
+#define ENUM_KEYW 265
+#define EXTERN_KEYW 266
+#define EXTENSION_KEYW 267
+#define FLOAT_KEYW 268
+#define INLINE_KEYW 269
+#define INT_KEYW 270
+#define LONG_KEYW 271
+#define REGISTER_KEYW 272
+#define RESTRICT_KEYW 273
+#define SHORT_KEYW 274
+#define SIGNED_KEYW 275
+#define STATIC_KEYW 276
+#define STRUCT_KEYW 277
+#define TYPEDEF_KEYW 278
+#define UNION_KEYW 279
+#define UNSIGNED_KEYW 280
+#define VOID_KEYW 281
+#define VOLATILE_KEYW 282
+#define TYPEOF_KEYW 283
+#define EXPORT_SYMBOL_KEYW 284
+#define ASM_PHRASE 285
+#define ATTRIBUTE_PHRASE 286
+#define BRACE_PHRASE 287
+#define BRACKET_PHRASE 288
+#define EXPRESSION_PHRASE 289
+#define CHAR 290
+#define DOTS 291
+#define IDENT 292
+#define INT 293
+#define REAL 294
+#define STRING 295
+#define TYPE 296
+#define OTHER 297
+#define FILENAME 298
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
diff -uNr linux-2.6.32/scripts/kconfig/lex.zconf.c clean_modified/linux-2.6.32/scripts/kconfig/lex.zconf.c
--- linux-2.6.32/scripts/kconfig/lex.zconf.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/kconfig/lex.zconf.c	2019-04-14 13:23:53.699927145 -0500
@@ -0,0 +1,2429 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("%s:%d: do not source '%s' from itself\n",
+		       zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("%s:%d: file '%s' is already sourced from '%s'\n",
+		       zconf_curname(), zconf_lineno(), name,
+		       file->parent->name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -uNr linux-2.6.32/scripts/kconfig/zconf.hash.c clean_modified/linux-2.6.32/scripts/kconfig/zconf.hash.c
--- linux-2.6.32/scripts/kconfig/zconf.hash.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/kconfig/zconf.hash.c	2019-04-14 13:24:00.507243525 -0500
@@ -0,0 +1,239 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+
+static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 47, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 11,  5,
+       0,  0,  5, 49,  5, 20, 49, 49,  5, 20,
+       5,  0, 30, 49,  0, 15,  0, 10,  0, 49,
+      25, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
+      49, 49, 49, 49, 49, 49
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str3[sizeof("env")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str6[sizeof("option")];
+    char kconf_id_strings_str7[sizeof("endmenu")];
+    char kconf_id_strings_str8[sizeof("optional")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("choice")];
+    char kconf_id_strings_str12[sizeof("default")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("help")];
+    char kconf_id_strings_str15[sizeof("bool")];
+    char kconf_id_strings_str16[sizeof("config")];
+    char kconf_id_strings_str17[sizeof("def_tristate")];
+    char kconf_id_strings_str18[sizeof("boolean")];
+    char kconf_id_strings_str19[sizeof("defconfig_list")];
+    char kconf_id_strings_str21[sizeof("string")];
+    char kconf_id_strings_str22[sizeof("if")];
+    char kconf_id_strings_str23[sizeof("int")];
+    char kconf_id_strings_str26[sizeof("select")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("tristate")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("source")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("hex")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("prompt")];
+    char kconf_id_strings_str37[sizeof("depends")];
+    char kconf_id_strings_str48[sizeof("mainmenu")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "env",
+    "endif",
+    "option",
+    "endmenu",
+    "optional",
+    "endchoice",
+    "range",
+    "choice",
+    "default",
+    "def_bool",
+    "help",
+    "bool",
+    "config",
+    "def_tristate",
+    "boolean",
+    "defconfig_list",
+    "string",
+    "if",
+    "int",
+    "select",
+    "modules",
+    "tristate",
+    "menu",
+    "source",
+    "comment",
+    "hex",
+    "menuconfig",
+    "prompt",
+    "depends",
+    "mainmenu"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 31,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 48
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str15,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str26,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SOURCE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_DEPENDS,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
diff -uNr linux-2.6.32/scripts/kconfig/zconf.tab.c clean_modified/linux-2.6.32/scripts/kconfig/zconf.tab.c
--- linux-2.6.32/scripts/kconfig/zconf.tab.c	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/kconfig/zconf.tab.c	2019-04-14 13:24:00.511194530 -0500
@@ -0,0 +1,2455 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_OPTION = 278,
+     T_ON = 279,
+     T_WORD = 280,
+     T_WORD_QUOTE = 281,
+     T_UNEQUAL = 282,
+     T_CLOSE_PAREN = 283,
+     T_OPEN_PAREN = 284,
+     T_EOL = 285,
+     T_OR = 286,
+     T_AND = 287,
+     T_EQUAL = 288,
+     T_NOT = 289
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   259
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  35
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  46
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  110
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  180
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   289
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     6,     9,    12,    15,    20,    23,
+      28,    33,    37,    39,    41,    43,    45,    47,    49,    51,
+      53,    55,    57,    59,    61,    63,    67,    70,    74,    77,
+      81,    84,    85,    88,    91,    94,    97,   100,   103,   107,
+     112,   117,   122,   128,   132,   133,   137,   138,   141,   145,
+     148,   150,   154,   155,   158,   161,   164,   167,   170,   175,
+     179,   182,   187,   188,   191,   195,   197,   201,   202,   205,
+     208,   211,   215,   218,   220,   224,   225,   228,   231,   234,
+     238,   242,   245,   248,   251,   252,   255,   258,   261,   266,
+     267,   270,   272,   274,   277,   280,   283,   285,   288,   289,
+     292,   294,   298,   302,   306,   309,   313,   317,   319,   321,
+     322
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      36,     0,    -1,    37,    -1,    -1,    37,    39,    -1,    37,
+      53,    -1,    37,    64,    -1,    37,     3,    74,    76,    -1,
+      37,    75,    -1,    37,    25,     1,    30,    -1,    37,    38,
+       1,    30,    -1,    37,     1,    30,    -1,    16,    -1,    18,
+      -1,    19,    -1,    21,    -1,    17,    -1,    22,    -1,    20,
+      -1,    30,    -1,    59,    -1,    68,    -1,    42,    -1,    44,
+      -1,    66,    -1,    25,     1,    30,    -1,     1,    30,    -1,
+      10,    25,    30,    -1,    41,    45,    -1,    11,    25,    30,
+      -1,    43,    45,    -1,    -1,    45,    46,    -1,    45,    47,
+      -1,    45,    72,    -1,    45,    70,    -1,    45,    40,    -1,
+      45,    30,    -1,    19,    73,    30,    -1,    18,    74,    77,
+      30,    -1,    20,    78,    77,    30,    -1,    21,    25,    77,
+      30,    -1,    22,    79,    79,    77,    30,    -1,    23,    48,
+      30,    -1,    -1,    48,    25,    49,    -1,    -1,    33,    74,
+      -1,     7,    80,    30,    -1,    50,    54,    -1,    75,    -1,
+      51,    56,    52,    -1,    -1,    54,    55,    -1,    54,    72,
+      -1,    54,    70,    -1,    54,    30,    -1,    54,    40,    -1,
+      18,    74,    77,    30,    -1,    19,    73,    30,    -1,    17,
+      30,    -1,    20,    25,    77,    30,    -1,    -1,    56,    39,
+      -1,    14,    78,    76,    -1,    75,    -1,    57,    60,    58,
+      -1,    -1,    60,    39,    -1,    60,    64,    -1,    60,    53,
+      -1,     4,    74,    30,    -1,    61,    71,    -1,    75,    -1,
+      62,    65,    63,    -1,    -1,    65,    39,    -1,    65,    64,
+      -1,    65,    53,    -1,     6,    74,    30,    -1,     9,    74,
+      30,    -1,    67,    71,    -1,    12,    30,    -1,    69,    13,
+      -1,    -1,    71,    72,    -1,    71,    30,    -1,    71,    40,
+      -1,    16,    24,    78,    30,    -1,    -1,    74,    77,    -1,
+      25,    -1,    26,    -1,     5,    30,    -1,     8,    30,    -1,
+      15,    30,    -1,    30,    -1,    76,    30,    -1,    -1,    14,
+      78,    -1,    79,    -1,    79,    33,    79,    -1,    79,    27,
+      79,    -1,    29,    78,    28,    -1,    34,    78,    -1,    78,
+      31,    78,    -1,    78,    32,    78,    -1,    25,    -1,    26,
+      -1,    -1,    25,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   107,   107,   109,   111,   112,   113,   114,   115,   116,
+     117,   121,   125,   125,   125,   125,   125,   125,   125,   129,
+     130,   131,   132,   133,   134,   138,   139,   145,   153,   159,
+     167,   177,   179,   180,   181,   182,   183,   184,   187,   195,
+     201,   211,   217,   223,   226,   228,   239,   240,   245,   254,
+     259,   267,   270,   272,   273,   274,   275,   276,   279,   285,
+     296,   302,   312,   314,   319,   327,   335,   338,   340,   341,
+     342,   347,   354,   359,   367,   370,   372,   373,   374,   377,
+     385,   392,   399,   405,   412,   414,   415,   416,   419,   427,
+     429,   434,   435,   438,   439,   440,   444,   445,   448,   449,
+     452,   453,   454,   455,   456,   457,   458,   461,   462,   465,
+     466
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "stmt_list", "option_name", "common_stmt",
+  "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "menu", "menu_entry",
+  "menu_end", "menu_stmt", "menu_block", "source_stmt", "comment",
+  "comment_stmt", "help_start", "help", "depends_list", "depends",
+  "prompt_stmt_opt", "prompt", "end", "nl", "if_expr", "expr", "symbol",
+  "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    35,    36,    37,    37,    37,    37,    37,    37,    37,
+      37,    37,    38,    38,    38,    38,    38,    38,    38,    39,
+      39,    39,    39,    39,    39,    40,    40,    41,    42,    43,
+      44,    45,    45,    45,    45,    45,    45,    45,    46,    46,
+      46,    46,    46,    47,    48,    48,    49,    49,    50,    51,
+      52,    53,    54,    54,    54,    54,    54,    54,    55,    55,
+      55,    55,    56,    56,    57,    58,    59,    60,    60,    60,
+      60,    61,    62,    63,    64,    65,    65,    65,    65,    66,
+      67,    68,    69,    70,    71,    71,    71,    71,    72,    73,
+      73,    74,    74,    75,    75,    75,    76,    76,    77,    77,
+      78,    78,    78,    78,    78,    78,    78,    79,    79,    80,
+      80
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     0,     2,     2,     2,     4,     2,     4,
+       4,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     3,     2,     3,     2,     3,
+       2,     0,     2,     2,     2,     2,     2,     2,     3,     4,
+       4,     4,     5,     3,     0,     3,     0,     2,     3,     2,
+       1,     3,     0,     2,     2,     2,     2,     2,     4,     3,
+       2,     4,     0,     2,     3,     1,     3,     0,     2,     2,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     3,
+       3,     2,     2,     2,     0,     2,     2,     2,     4,     0,
+       2,     1,     1,     2,     2,     2,     1,     2,     0,     2,
+       1,     3,     3,     3,     2,     3,     3,     1,     1,     0,
+       1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       3,     0,     0,     1,     0,     0,     0,     0,     0,   109,
+       0,     0,     0,     0,     0,     0,    12,    16,    13,    14,
+      18,    15,    17,     0,    19,     0,     4,    31,    22,    31,
+      23,    52,    62,     5,    67,    20,    84,    75,     6,    24,
+      84,    21,     8,    11,    91,    92,     0,     0,    93,     0,
+     110,     0,    94,     0,     0,     0,   107,   108,     0,     0,
+       0,   100,    95,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    96,     7,    71,    79,    48,    80,    27,
+      29,     0,   104,     0,     0,    64,     0,     0,     9,    10,
+       0,     0,     0,     0,    89,     0,     0,     0,    44,     0,
+      37,    36,    32,    33,     0,    35,    34,     0,     0,    89,
+       0,    56,    57,    53,    55,    54,    63,    51,    50,    68,
+      70,    66,    69,    65,    86,    87,    85,    76,    78,    74,
+      77,    73,    97,   103,   105,   106,   102,   101,    26,    82,
+       0,    98,     0,    98,    98,    98,     0,     0,     0,    83,
+      60,    98,     0,    98,     0,     0,     0,    38,    90,     0,
+       0,    98,    46,    43,    25,     0,    59,     0,    88,    99,
+      39,    40,    41,     0,     0,    45,    58,    61,    42,    47
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,    25,    26,   101,    27,    28,    29,    30,
+      65,   102,   103,   147,   175,    31,    32,   117,    33,    67,
+     113,    68,    34,   121,    35,    69,    36,    37,   129,    38,
+      71,    39,    40,    41,   104,   105,    70,   106,   142,   143,
+      42,    74,   156,    60,    61,    51
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -80
+static const yytype_int16 yypact[] =
+{
+     -80,     2,   132,   -80,   -13,    -1,    -1,    -2,    -1,     9,
+      33,    -1,    27,    40,    -3,    38,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,    71,   -80,    77,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,    57,    61,   -80,    63,
+     -80,    76,   -80,    87,   101,   133,   -80,   -80,    -3,    -3,
+     195,    -6,   -80,   136,   149,    39,   104,    65,   150,     5,
+     194,     5,   167,   -80,   176,   -80,   -80,   -80,   -80,   -80,
+     -80,    68,   -80,    -3,    -3,   176,    72,    72,   -80,   -80,
+     177,   187,    78,    -1,    -1,    -3,   196,    72,   -80,   222,
+     -80,   -80,   -80,   -80,   221,   -80,   -80,   205,    -1,    -1,
+     211,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
+     -80,   -80,   -80,   -80,   206,   -80,   -80,   -80,   -80,   -80,
+      -3,   223,   209,   223,   197,   223,    72,     7,   210,   -80,
+     -80,   223,   212,   223,   201,    -3,   213,   -80,   -80,   214,
+     215,   223,   208,   -80,   -80,   216,   -80,   217,   -80,   113,
+     -80,   -80,   -80,   218,    -1,   -80,   -80,   -80,   -80,   -80
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -80,   -80,   -80,   -80,   122,   -34,   -80,   -80,   -80,   -80,
+     220,   -80,   -80,   -80,   -80,   -80,   -80,   -80,    59,   -80,
+     -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,   125,
+     -80,   -80,   -80,   -80,   -80,   183,   219,    22,   142,    -5,
+     147,   192,    69,   -54,   -79,   -80
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -82
+static const yytype_int16 yytable[] =
+{
+      46,    47,     3,    49,    81,    82,    53,   136,   137,     6,
+       7,     8,     9,    10,    11,    12,    13,    43,   146,    14,
+      15,    86,    56,    57,    44,    45,    58,    87,    48,   134,
+     135,    59,   162,   112,    50,    24,   125,   163,   125,   -28,
+      90,   144,   -28,   -28,   -28,   -28,   -28,   -28,   -28,   -28,
+     -28,    91,    54,   -28,   -28,    92,   -28,    93,    94,    95,
+      96,    97,    98,    52,    99,    55,    90,   161,    62,   100,
+     -49,   -49,    63,   -49,   -49,   -49,   -49,    91,    64,   -49,
+     -49,    92,   107,   108,   109,   110,   154,    73,   141,   115,
+      99,    75,   126,    76,   126,   111,   133,    56,    57,    83,
+      84,   169,   140,   151,   -30,    90,    77,   -30,   -30,   -30,
+     -30,   -30,   -30,   -30,   -30,   -30,    91,    78,   -30,   -30,
+      92,   -30,    93,    94,    95,    96,    97,    98,   120,    99,
+     128,    79,    -2,     4,   100,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    83,    84,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,     7,     8,    23,    10,    11,
+      12,    13,    24,    80,    14,    15,    88,   -81,    90,   179,
+     -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,   -81,    89,
+      24,   -81,   -81,    92,   -81,   -81,   -81,   -81,   -81,   -81,
+     116,   119,    99,   127,   122,    90,   130,   124,   -72,   -72,
+     -72,   -72,   -72,   -72,   -72,   -72,   132,   138,   -72,   -72,
+      92,   155,   158,   159,   160,   118,   123,   139,   131,    99,
+     165,   145,   167,   148,   124,    73,    83,    84,    83,    84,
+     173,   168,    83,    84,   149,   150,   153,   155,    84,   157,
+     164,   174,   166,   170,   171,   172,   176,   177,   178,    66,
+     114,   152,    85,     0,     0,     0,     0,     0,     0,    72
+};
+
+static const yytype_int16 yycheck[] =
+{
+       5,     6,     0,     8,    58,    59,    11,    86,    87,     4,
+       5,     6,     7,     8,     9,    10,    11,    30,    97,    14,
+      15,    27,    25,    26,    25,    26,    29,    33,    30,    83,
+      84,    34,    25,    67,    25,    30,    70,    30,    72,     0,
+       1,    95,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    25,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    30,    25,    25,     1,   146,    30,    30,
+       5,     6,     1,     8,     9,    10,    11,    12,     1,    14,
+      15,    16,    17,    18,    19,    20,   140,    30,    93,    67,
+      25,    30,    70,    30,    72,    30,    28,    25,    26,    31,
+      32,   155,    24,   108,     0,     1,    30,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    30,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    69,    25,
+      71,    30,     0,     1,    30,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    31,    32,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,     5,     6,    25,     8,     9,
+      10,    11,    30,    30,    14,    15,    30,     0,     1,   174,
+       3,     4,     5,     6,     7,     8,     9,    10,    11,    30,
+      30,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      68,    69,    25,    71,    69,     1,    71,    30,     4,     5,
+       6,     7,     8,     9,    10,    11,    30,    30,    14,    15,
+      16,    14,   143,   144,   145,    68,    69,    30,    71,    25,
+     151,    25,   153,     1,    30,    30,    31,    32,    31,    32,
+     161,    30,    31,    32,    13,    30,    25,    14,    32,    30,
+      30,    33,    30,    30,    30,    30,    30,    30,    30,    29,
+      67,   109,    60,    -1,    -1,    -1,    -1,    -1,    -1,    40
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    36,    37,     0,     1,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    25,    30,    38,    39,    41,    42,    43,
+      44,    50,    51,    53,    57,    59,    61,    62,    64,    66,
+      67,    68,    75,    30,    25,    26,    74,    74,    30,    74,
+      25,    80,    30,    74,    25,    25,    25,    26,    29,    34,
+      78,    79,    30,     1,     1,    45,    45,    54,    56,    60,
+      71,    65,    71,    30,    76,    30,    30,    30,    30,    30,
+      30,    78,    78,    31,    32,    76,    27,    33,    30,    30,
+       1,    12,    16,    18,    19,    20,    21,    22,    23,    25,
+      30,    40,    46,    47,    69,    70,    72,    17,    18,    19,
+      20,    30,    40,    55,    70,    72,    39,    52,    75,    39,
+      53,    58,    64,    75,    30,    40,    72,    39,    53,    63,
+      64,    75,    30,    28,    78,    78,    79,    79,    30,    30,
+      24,    74,    73,    74,    78,    25,    79,    48,     1,    13,
+      30,    74,    73,    25,    78,    14,    77,    30,    77,    77,
+      77,    79,    25,    30,    30,    77,    30,    77,    30,    78,
+      30,    30,    30,    77,    33,    49,    30,    30,    30,    74
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 51: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 57: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 62: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 9:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 10:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 11:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 25:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 26:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 27:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 28:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 29:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 30:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 38:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 39:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 40:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 46:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 47:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 48:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 49:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 50:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 58:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 59:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 60:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 61:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 64:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 65:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 71:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 72:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 73:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 79:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 80:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 81:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 82:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 83:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 88:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 90:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 93:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 94:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 95:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 98:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 99:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 100:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 101:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 102:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 103:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 104:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 105:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 107:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 108:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -uNr linux-2.6.32/scripts/mod/elfconfig.h clean_modified/linux-2.6.32/scripts/mod/elfconfig.h
--- linux-2.6.32/scripts/mod/elfconfig.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/scripts/mod/elfconfig.h	2019-04-14 13:24:00.511194530 -0500
@@ -0,0 +1,5 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS32
+#define HOST_ELFDATA ELFDATA2LSB
+#define MODULE_SYMBOL_PREFIX ""
diff -uNr linux-2.6.32/usr/include/asm/a.out.h clean_modified/linux-2.6.32/usr/include/asm/a.out.h
--- linux-2.6.32/usr/include/asm/a.out.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/a.out.h	2019-04-14 13:24:02.847028238 -0500
@@ -0,0 +1,20 @@
+#ifndef _ASM_X86_A_OUT_H
+#define _ASM_X86_A_OUT_H
+
+struct exec
+{
+	unsigned int a_info;	/* Use macros N_MAGIC, etc for access */
+	unsigned a_text;	/* length of text, in bytes */
+	unsigned a_data;	/* length of data, in bytes */
+	unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+	unsigned a_syms;	/* length of symbol table data in file, in bytes */
+	unsigned a_entry;	/* start address */
+	unsigned a_trsize;	/* length of relocation info for text, in bytes */
+	unsigned a_drsize;	/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#endif /* _ASM_X86_A_OUT_H */
diff -uNr linux-2.6.32/usr/include/asm/auxvec.h clean_modified/linux-2.6.32/usr/include/asm/auxvec.h
--- linux-2.6.32/usr/include/asm/auxvec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/auxvec.h	2019-04-14 13:24:02.847028238 -0500
@@ -0,0 +1,12 @@
+#ifndef _ASM_X86_AUXVEC_H
+#define _ASM_X86_AUXVEC_H
+/*
+ * Architecture-neutral AT_ values in 0-17, leave some room
+ * for more of them, start the x86-specific ones at 32.
+ */
+#ifdef __i386__
+#define AT_SYSINFO		32
+#endif
+#define AT_SYSINFO_EHDR		33
+
+#endif /* _ASM_X86_AUXVEC_H */
diff -uNr linux-2.6.32/usr/include/asm/bitsperlong.h clean_modified/linux-2.6.32/usr/include/asm/bitsperlong.h
--- linux-2.6.32/usr/include/asm/bitsperlong.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/bitsperlong.h	2019-04-14 13:24:02.847028238 -0500
@@ -0,0 +1,13 @@
+#ifndef __ASM_X86_BITSPERLONG_H
+#define __ASM_X86_BITSPERLONG_H
+
+#ifdef __x86_64__
+# define __BITS_PER_LONG 64
+#else
+# define __BITS_PER_LONG 32
+#endif
+
+#include <asm-generic/bitsperlong.h>
+
+#endif /* __ASM_X86_BITSPERLONG_H */
+
diff -uNr linux-2.6.32/usr/include/asm/boot.h clean_modified/linux-2.6.32/usr/include/asm/boot.h
--- linux-2.6.32/usr/include/asm/boot.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/boot.h	2019-04-14 13:24:02.848119487 -0500
@@ -0,0 +1,10 @@
+#ifndef _ASM_X86_BOOT_H
+#define _ASM_X86_BOOT_H
+
+/* Internal svga startup constants */
+#define NORMAL_VGA	0xffff		/* 80x25 mode */
+#define EXTENDED_VGA	0xfffe		/* 80x50 mode */
+#define ASK_VGA		0xfffd		/* ask for it at bootup */
+
+
+#endif /* _ASM_X86_BOOT_H */
diff -uNr linux-2.6.32/usr/include/asm/bootparam.h clean_modified/linux-2.6.32/usr/include/asm/bootparam.h
--- linux-2.6.32/usr/include/asm/bootparam.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/bootparam.h	2019-04-14 13:24:02.848119487 -0500
@@ -0,0 +1,123 @@
+#ifndef _ASM_X86_BOOTPARAM_H
+#define _ASM_X86_BOOTPARAM_H
+
+#include <linux/types.h>
+#include <linux/screen_info.h>
+#include <linux/apm_bios.h>
+#include <linux/edd.h>
+#include <asm/e820.h>
+#include <asm/ist.h>
+#include <video/edid.h>
+
+/* setup data types */
+#define SETUP_NONE			0
+#define SETUP_E820_EXT			1
+
+/* extensible setup data list node */
+struct setup_data {
+	__u64 next;
+	__u32 type;
+	__u32 len;
+	__u8 data[0];
+};
+
+struct setup_header {
+	__u8	setup_sects;
+	__u16	root_flags;
+	__u32	syssize;
+	__u16	ram_size;
+#define RAMDISK_IMAGE_START_MASK	0x07FF
+#define RAMDISK_PROMPT_FLAG		0x8000
+#define RAMDISK_LOAD_FLAG		0x4000
+	__u16	vid_mode;
+	__u16	root_dev;
+	__u16	boot_flag;
+	__u16	jump;
+	__u32	header;
+	__u16	version;
+	__u32	realmode_swtch;
+	__u16	start_sys;
+	__u16	kernel_version;
+	__u8	type_of_loader;
+	__u8	loadflags;
+#define LOADED_HIGH	(1<<0)
+#define QUIET_FLAG	(1<<5)
+#define KEEP_SEGMENTS	(1<<6)
+#define CAN_USE_HEAP	(1<<7)
+	__u16	setup_move_size;
+	__u32	code32_start;
+	__u32	ramdisk_image;
+	__u32	ramdisk_size;
+	__u32	bootsect_kludge;
+	__u16	heap_end_ptr;
+	__u8	ext_loader_ver;
+	__u8	ext_loader_type;
+	__u32	cmd_line_ptr;
+	__u32	initrd_addr_max;
+	__u32	kernel_alignment;
+	__u8	relocatable_kernel;
+	__u8	_pad2[3];
+	__u32	cmdline_size;
+	__u32	hardware_subarch;
+	__u64	hardware_subarch_data;
+	__u32	payload_offset;
+	__u32	payload_length;
+	__u64	setup_data;
+} __attribute__((packed));
+
+struct sys_desc_table {
+	__u16 length;
+	__u8  table[14];
+};
+
+struct efi_info {
+	__u32 efi_loader_signature;
+	__u32 efi_systab;
+	__u32 efi_memdesc_size;
+	__u32 efi_memdesc_version;
+	__u32 efi_memmap;
+	__u32 efi_memmap_size;
+	__u32 efi_systab_hi;
+	__u32 efi_memmap_hi;
+};
+
+/* The so-called "zeropage" */
+struct boot_params {
+	struct screen_info screen_info;			/* 0x000 */
+	struct apm_bios_info apm_bios_info;		/* 0x040 */
+	__u8  _pad2[4];					/* 0x054 */
+	__u64  tboot_addr;				/* 0x058 */
+	struct ist_info ist_info;			/* 0x060 */
+	__u8  _pad3[16];				/* 0x070 */
+	__u8  hd0_info[16];	/* obsolete! */		/* 0x080 */
+	__u8  hd1_info[16];	/* obsolete! */		/* 0x090 */
+	struct sys_desc_table sys_desc_table;		/* 0x0a0 */
+	__u8  _pad4[144];				/* 0x0b0 */
+	struct edid_info edid_info;			/* 0x140 */
+	struct efi_info efi_info;			/* 0x1c0 */
+	__u32 alt_mem_k;				/* 0x1e0 */
+	__u32 scratch;		/* Scratch field! */	/* 0x1e4 */
+	__u8  e820_entries;				/* 0x1e8 */
+	__u8  eddbuf_entries;				/* 0x1e9 */
+	__u8  edd_mbr_sig_buf_entries;			/* 0x1ea */
+	__u8  _pad6[6];					/* 0x1eb */
+	struct setup_header hdr;    /* setup header */	/* 0x1f1 */
+	__u8  _pad7[0x290-0x1f1-sizeof(struct setup_header)];
+	__u32 edd_mbr_sig_buffer[EDD_MBR_SIG_MAX];	/* 0x290 */
+	struct e820entry e820_map[E820MAX];		/* 0x2d0 */
+	__u8  _pad8[48];				/* 0xcd0 */
+	struct edd_info eddbuf[EDDMAXNR];		/* 0xd00 */
+	__u8  _pad9[276];				/* 0xeec */
+} __attribute__((packed));
+
+enum {
+	X86_SUBARCH_PC = 0,
+	X86_SUBARCH_LGUEST,
+	X86_SUBARCH_XEN,
+	X86_SUBARCH_MRST,
+	X86_NR_SUBARCHS,
+};
+
+
+
+#endif /* _ASM_X86_BOOTPARAM_H */
diff -uNr linux-2.6.32/usr/include/asm/byteorder.h clean_modified/linux-2.6.32/usr/include/asm/byteorder.h
--- linux-2.6.32/usr/include/asm/byteorder.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/byteorder.h	2019-04-14 13:24:02.849032321 -0500
@@ -0,0 +1,6 @@
+#ifndef _ASM_X86_BYTEORDER_H
+#define _ASM_X86_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _ASM_X86_BYTEORDER_H */
diff -uNr linux-2.6.32/usr/include/asm/debugreg.h clean_modified/linux-2.6.32/usr/include/asm/debugreg.h
--- linux-2.6.32/usr/include/asm/debugreg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/debugreg.h	2019-04-14 13:24:02.849032321 -0500
@@ -0,0 +1,70 @@
+#ifndef _ASM_X86_DEBUGREG_H
+#define _ASM_X86_DEBUGREG_H
+
+
+/* Indicate the register numbers for a number of the specific
+   debug registers.  Registers 0-3 contain the addresses we wish to trap on */
+#define DR_FIRSTADDR 0        /* u_debugreg[DR_FIRSTADDR] */
+#define DR_LASTADDR 3         /* u_debugreg[DR_LASTADDR]  */
+
+#define DR_STATUS 6           /* u_debugreg[DR_STATUS]     */
+#define DR_CONTROL 7          /* u_debugreg[DR_CONTROL] */
+
+/* Define a few things for the status register.  We can use this to determine
+   which debugging register was responsible for the trap.  The other bits
+   are either reserved or not of interest to us. */
+
+#define DR_TRAP0	(0x1)		/* db0 */
+#define DR_TRAP1	(0x2)		/* db1 */
+#define DR_TRAP2	(0x4)		/* db2 */
+#define DR_TRAP3	(0x8)		/* db3 */
+
+#define DR_STEP		(0x4000)	/* single-step */
+#define DR_SWITCH	(0x8000)	/* task switch */
+
+/* Now define a bunch of things for manipulating the control register.
+   The top two bytes of the control register consist of 4 fields of 4
+   bits - each field corresponds to one of the four debug registers,
+   and indicates what types of access we trap on, and how large the data
+   field is that we are looking at */
+
+#define DR_CONTROL_SHIFT 16 /* Skip this many bits in ctl register */
+#define DR_CONTROL_SIZE 4   /* 4 control bits per register */
+
+#define DR_RW_EXECUTE (0x0)   /* Settings for the access types to trap on */
+#define DR_RW_WRITE (0x1)
+#define DR_RW_READ (0x3)
+
+#define DR_LEN_1 (0x0) /* Settings for data length to trap on */
+#define DR_LEN_2 (0x4)
+#define DR_LEN_4 (0xC)
+#define DR_LEN_8 (0x8)
+
+/* The low byte to the control register determine which registers are
+   enabled.  There are 4 fields of two bits.  One bit is "local", meaning
+   that the processor will reset the bit after a task switch and the other
+   is global meaning that we have to explicitly reset the bit.  With linux,
+   you can use either one, since we explicitly zero the register when we enter
+   kernel mode. */
+
+#define DR_LOCAL_ENABLE_SHIFT 0    /* Extra shift to the local enable bit */
+#define DR_GLOBAL_ENABLE_SHIFT 1   /* Extra shift to the global enable bit */
+#define DR_ENABLE_SIZE 2           /* 2 enable bits per register */
+
+#define DR_LOCAL_ENABLE_MASK (0x55)  /* Set  local bits for all 4 regs */
+#define DR_GLOBAL_ENABLE_MASK (0xAA) /* Set global bits for all 4 regs */
+
+/* The second byte to the control register has a few special things.
+   We can slow the instruction pipeline for instructions coming via the
+   gdt or the ldt if we want to.  I am not sure why this is an advantage */
+
+#ifdef __i386__
+#define DR_CONTROL_RESERVED (0xFC00) /* Reserved by Intel */
+#else
+#define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#endif
+
+#define DR_LOCAL_SLOWDOWN (0x100)   /* Local slow the pipeline */
+#define DR_GLOBAL_SLOWDOWN (0x200)  /* Global slow the pipeline */
+
+#endif /* _ASM_X86_DEBUGREG_H */
diff -uNr linux-2.6.32/usr/include/asm/e820.h clean_modified/linux-2.6.32/usr/include/asm/e820.h
--- linux-2.6.32/usr/include/asm/e820.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/e820.h	2019-04-14 13:24:02.849032321 -0500
@@ -0,0 +1,65 @@
+#ifndef _ASM_X86_E820_H
+#define _ASM_X86_E820_H
+#define E820MAP	0x2d0		/* our map */
+#define E820MAX	128		/* number of entries in E820MAP */
+
+/*
+ * Legacy E820 BIOS limits us to 128 (E820MAX) nodes due to the
+ * constrained space in the zeropage.  If we have more nodes than
+ * that, and if we've booted off EFI firmware, then the EFI tables
+ * passed us from the EFI firmware can list more nodes.  Size our
+ * internal memory map tables to have room for these additional
+ * nodes, based on up to three entries per node for which the
+ * kernel was built: MAX_NUMNODES == (1 << CONFIG_NODES_SHIFT),
+ * plus E820MAX, allowing space for the possible duplicate E820
+ * entries that might need room in the same arrays, prior to the
+ * call to sanitize_e820_map() to remove duplicates.  The allowance
+ * of three memory map entries per node is "enough" entries for
+ * the initial hardware platform motivating this mechanism to make
+ * use of additional EFI map entries.  Future platforms may want
+ * to allow more than three entries per node or otherwise refine
+ * this size.
+ */
+
+/*
+ * Odd: 'make headers_check' complains about numa.h if I try
+ * to collapse the next two #ifdef lines to a single line:
+ *	#if defined(__KERNEL__) && defined(CONFIG_EFI)
+ */
+#define E820_X_MAX E820MAX
+
+#define E820NR	0x1e8		/* # entries in E820MAP */
+
+#define E820_RAM	1
+#define E820_RESERVED	2
+#define E820_ACPI	3
+#define E820_NVS	4
+#define E820_UNUSABLE	5
+
+/* reserved RAM used by kernel itself */
+#define E820_RESERVED_KERN        128
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+struct e820entry {
+	__u64 addr;	/* start of memory segment */
+	__u64 size;	/* size of memory segment */
+	__u32 type;	/* type of memory segment */
+} __attribute__((packed));
+
+struct e820map {
+	__u32 nr_map;
+	struct e820entry map[E820_X_MAX];
+};
+
+#endif /* __ASSEMBLY__ */
+
+#define ISA_START_ADDRESS	0xa0000
+#define ISA_END_ADDRESS		0x100000
+#define is_ISA_range(s, e) ((s) >= ISA_START_ADDRESS && (e) < ISA_END_ADDRESS)
+
+#define BIOS_BEGIN		0x000a0000
+#define BIOS_END		0x00100000
+
+
+#endif /* _ASM_X86_E820_H */
diff -uNr linux-2.6.32/usr/include/asm/errno.h clean_modified/linux-2.6.32/usr/include/asm/errno.h
--- linux-2.6.32/usr/include/asm/errno.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/errno.h	2019-04-14 13:24:02.849032321 -0500
@@ -0,0 +1 @@
+#include <asm-generic/errno.h>
diff -uNr linux-2.6.32/usr/include/asm/fcntl.h clean_modified/linux-2.6.32/usr/include/asm/fcntl.h
--- linux-2.6.32/usr/include/asm/fcntl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/fcntl.h	2019-04-14 13:24:02.849968905 -0500
@@ -0,0 +1 @@
+#include <asm-generic/fcntl.h>
diff -uNr linux-2.6.32/usr/include/asm/ioctl.h clean_modified/linux-2.6.32/usr/include/asm/ioctl.h
--- linux-2.6.32/usr/include/asm/ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ioctl.h	2019-04-14 13:24:02.849968905 -0500
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
diff -uNr linux-2.6.32/usr/include/asm/ioctls.h clean_modified/linux-2.6.32/usr/include/asm/ioctls.h
--- linux-2.6.32/usr/include/asm/ioctls.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ioctls.h	2019-04-14 13:24:02.849968905 -0500
@@ -0,0 +1 @@
+#include <asm-generic/ioctls.h>
diff -uNr linux-2.6.32/usr/include/asm/ipcbuf.h clean_modified/linux-2.6.32/usr/include/asm/ipcbuf.h
--- linux-2.6.32/usr/include/asm/ipcbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ipcbuf.h	2019-04-14 13:24:02.849968905 -0500
@@ -0,0 +1 @@
+#include <asm-generic/ipcbuf.h>
diff -uNr linux-2.6.32/usr/include/asm/ist.h clean_modified/linux-2.6.32/usr/include/asm/ist.h
--- linux-2.6.32/usr/include/asm/ist.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ist.h	2019-04-14 13:24:02.850932519 -0500
@@ -0,0 +1,29 @@
+#ifndef _ASM_X86_IST_H
+#define _ASM_X86_IST_H
+
+/*
+ * Include file for the interface to IST BIOS
+ * Copyright 2002 Andy Grover <andrew.grover@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#include <linux/types.h>
+
+struct ist_info {
+	__u32 signature;
+	__u32 command;
+	__u32 event;
+	__u32 perf_level;
+};
+
+#endif /* _ASM_X86_IST_H */
diff -uNr linux-2.6.32/usr/include/asm/kvm.h clean_modified/linux-2.6.32/usr/include/asm/kvm.h
--- linux-2.6.32/usr/include/asm/kvm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/kvm.h	2019-04-14 13:24:02.850932519 -0500
@@ -0,0 +1,253 @@
+#ifndef _ASM_X86_KVM_H
+#define _ASM_X86_KVM_H
+
+/*
+ * KVM x86 specific structures and definitions
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/* Select x86 specific features in <linux/kvm.h> */
+#define __KVM_HAVE_PIT
+#define __KVM_HAVE_IOAPIC
+#define __KVM_HAVE_DEVICE_ASSIGNMENT
+#define __KVM_HAVE_MSI
+#define __KVM_HAVE_USER_NMI
+#define __KVM_HAVE_GUEST_DEBUG
+#define __KVM_HAVE_MSIX
+#define __KVM_HAVE_MCE
+#define __KVM_HAVE_PIT_STATE2
+
+/* Architectural interrupt line count. */
+#define KVM_NR_INTERRUPTS 256
+
+struct kvm_memory_alias {
+	__u32 slot;  /* this has a different namespace than memory slots */
+	__u32 flags;
+	__u64 guest_phys_addr;
+	__u64 memory_size;
+	__u64 target_phys_addr;
+};
+
+/* for KVM_GET_IRQCHIP and KVM_SET_IRQCHIP */
+struct kvm_pic_state {
+	__u8 last_irr;	/* edge detection */
+	__u8 irr;		/* interrupt request register */
+	__u8 imr;		/* interrupt mask register */
+	__u8 isr;		/* interrupt service register */
+	__u8 priority_add;	/* highest irq priority */
+	__u8 irq_base;
+	__u8 read_reg_select;
+	__u8 poll;
+	__u8 special_mask;
+	__u8 init_state;
+	__u8 auto_eoi;
+	__u8 rotate_on_auto_eoi;
+	__u8 special_fully_nested_mode;
+	__u8 init4;		/* true if 4 byte init */
+	__u8 elcr;		/* PIIX edge/trigger selection */
+	__u8 elcr_mask;
+};
+
+#define KVM_IOAPIC_NUM_PINS  24
+struct kvm_ioapic_state {
+	__u64 base_address;
+	__u32 ioregsel;
+	__u32 id;
+	__u32 irr;
+	__u32 pad;
+	union {
+		__u64 bits;
+		struct {
+			__u8 vector;
+			__u8 delivery_mode:3;
+			__u8 dest_mode:1;
+			__u8 delivery_status:1;
+			__u8 polarity:1;
+			__u8 remote_irr:1;
+			__u8 trig_mode:1;
+			__u8 mask:1;
+			__u8 reserve:7;
+			__u8 reserved[4];
+			__u8 dest_id;
+		} fields;
+	} redirtbl[KVM_IOAPIC_NUM_PINS];
+};
+
+#define KVM_IRQCHIP_PIC_MASTER   0
+#define KVM_IRQCHIP_PIC_SLAVE    1
+#define KVM_IRQCHIP_IOAPIC       2
+
+/* for KVM_GET_REGS and KVM_SET_REGS */
+struct kvm_regs {
+	/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */
+	__u64 rax, rbx, rcx, rdx;
+	__u64 rsi, rdi, rsp, rbp;
+	__u64 r8,  r9,  r10, r11;
+	__u64 r12, r13, r14, r15;
+	__u64 rip, rflags;
+};
+
+/* for KVM_GET_LAPIC and KVM_SET_LAPIC */
+#define KVM_APIC_REG_SIZE 0x400
+struct kvm_lapic_state {
+	char regs[KVM_APIC_REG_SIZE];
+};
+
+struct kvm_segment {
+	__u64 base;
+	__u32 limit;
+	__u16 selector;
+	__u8  type;
+	__u8  present, dpl, db, s, l, g, avl;
+	__u8  unusable;
+	__u8  padding;
+};
+
+struct kvm_dtable {
+	__u64 base;
+	__u16 limit;
+	__u16 padding[3];
+};
+
+
+/* for KVM_GET_SREGS and KVM_SET_SREGS */
+struct kvm_sregs {
+	/* out (KVM_GET_SREGS) / in (KVM_SET_SREGS) */
+	struct kvm_segment cs, ds, es, fs, gs, ss;
+	struct kvm_segment tr, ldt;
+	struct kvm_dtable gdt, idt;
+	__u64 cr0, cr2, cr3, cr4, cr8;
+	__u64 efer;
+	__u64 apic_base;
+	__u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];
+};
+
+/* for KVM_GET_FPU and KVM_SET_FPU */
+struct kvm_fpu {
+	__u8  fpr[8][16];
+	__u16 fcw;
+	__u16 fsw;
+	__u8  ftwx;  /* in fxsave format */
+	__u8  pad1;
+	__u16 last_opcode;
+	__u64 last_ip;
+	__u64 last_dp;
+	__u8  xmm[16][16];
+	__u32 mxcsr;
+	__u32 pad2;
+};
+
+struct kvm_msr_entry {
+	__u32 index;
+	__u32 reserved;
+	__u64 data;
+};
+
+/* for KVM_GET_MSRS and KVM_SET_MSRS */
+struct kvm_msrs {
+	__u32 nmsrs; /* number of msrs in entries */
+	__u32 pad;
+
+	struct kvm_msr_entry entries[0];
+};
+
+/* for KVM_GET_MSR_INDEX_LIST */
+struct kvm_msr_list {
+	__u32 nmsrs; /* number of msrs in entries */
+	__u32 indices[0];
+};
+
+
+struct kvm_cpuid_entry {
+	__u32 function;
+	__u32 eax;
+	__u32 ebx;
+	__u32 ecx;
+	__u32 edx;
+	__u32 padding;
+};
+
+/* for KVM_SET_CPUID */
+struct kvm_cpuid {
+	__u32 nent;
+	__u32 padding;
+	struct kvm_cpuid_entry entries[0];
+};
+
+struct kvm_cpuid_entry2 {
+	__u32 function;
+	__u32 index;
+	__u32 flags;
+	__u32 eax;
+	__u32 ebx;
+	__u32 ecx;
+	__u32 edx;
+	__u32 padding[3];
+};
+
+#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX 1
+#define KVM_CPUID_FLAG_STATEFUL_FUNC    2
+#define KVM_CPUID_FLAG_STATE_READ_NEXT  4
+
+/* for KVM_SET_CPUID2 */
+struct kvm_cpuid2 {
+	__u32 nent;
+	__u32 padding;
+	struct kvm_cpuid_entry2 entries[0];
+};
+
+/* for KVM_GET_PIT and KVM_SET_PIT */
+struct kvm_pit_channel_state {
+	__u32 count; /* can be 65536 */
+	__u16 latched_count;
+	__u8 count_latched;
+	__u8 status_latched;
+	__u8 status;
+	__u8 read_state;
+	__u8 write_state;
+	__u8 write_latch;
+	__u8 rw_mode;
+	__u8 mode;
+	__u8 bcd;
+	__u8 gate;
+	__s64 count_load_time;
+};
+
+struct kvm_debug_exit_arch {
+	__u32 exception;
+	__u32 pad;
+	__u64 pc;
+	__u64 dr6;
+	__u64 dr7;
+};
+
+#define KVM_GUESTDBG_USE_SW_BP		0x00010000
+#define KVM_GUESTDBG_USE_HW_BP		0x00020000
+#define KVM_GUESTDBG_INJECT_DB		0x00040000
+#define KVM_GUESTDBG_INJECT_BP		0x00080000
+
+/* for KVM_SET_GUEST_DEBUG */
+struct kvm_guest_debug_arch {
+	__u64 debugreg[8];
+};
+
+struct kvm_pit_state {
+	struct kvm_pit_channel_state channels[3];
+};
+
+#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001
+
+struct kvm_pit_state2 {
+	struct kvm_pit_channel_state channels[3];
+	__u32 flags;
+	__u32 reserved[9];
+};
+
+struct kvm_reinject_control {
+	__u8 pit_reinject;
+	__u8 reserved[31];
+};
+#endif /* _ASM_X86_KVM_H */
diff -uNr linux-2.6.32/usr/include/asm/kvm_para.h clean_modified/linux-2.6.32/usr/include/asm/kvm_para.h
--- linux-2.6.32/usr/include/asm/kvm_para.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/kvm_para.h	2019-04-14 13:24:02.850932519 -0500
@@ -0,0 +1,51 @@
+#ifndef _ASM_X86_KVM_PARA_H
+#define _ASM_X86_KVM_PARA_H
+
+#include <linux/types.h>
+
+/* This CPUID returns the signature 'KVMKVMKVM' in ebx, ecx, and edx.  It
+ * should be used to determine that a VM is running under KVM.
+ */
+#define KVM_CPUID_SIGNATURE	0x40000000
+
+/* This CPUID returns a feature bitmap in eax.  Before enabling a particular
+ * paravirtualization, the appropriate feature bit should be checked.
+ */
+#define KVM_CPUID_FEATURES	0x40000001
+#define KVM_FEATURE_CLOCKSOURCE		0
+#define KVM_FEATURE_NOP_IO_DELAY	1
+#define KVM_FEATURE_MMU_OP		2
+
+#define MSR_KVM_WALL_CLOCK  0x11
+#define MSR_KVM_SYSTEM_TIME 0x12
+
+#define KVM_MAX_MMU_OP_BATCH           32
+
+/* Operations for KVM_HC_MMU_OP */
+#define KVM_MMU_OP_WRITE_PTE            1
+#define KVM_MMU_OP_FLUSH_TLB	        2
+#define KVM_MMU_OP_RELEASE_PT	        3
+
+/* Payload for KVM_HC_MMU_OP */
+struct kvm_mmu_op_header {
+	__u32 op;
+	__u32 pad;
+};
+
+struct kvm_mmu_op_write_pte {
+	struct kvm_mmu_op_header header;
+	__u64 pte_phys;
+	__u64 pte_val;
+};
+
+struct kvm_mmu_op_flush_tlb {
+	struct kvm_mmu_op_header header;
+};
+
+struct kvm_mmu_op_release_pt {
+	struct kvm_mmu_op_header header;
+	__u64 pt_phys;
+};
+
+
+#endif /* _ASM_X86_KVM_PARA_H */
diff -uNr linux-2.6.32/usr/include/asm/ldt.h clean_modified/linux-2.6.32/usr/include/asm/ldt.h
--- linux-2.6.32/usr/include/asm/ldt.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ldt.h	2019-04-14 13:24:02.850932519 -0500
@@ -0,0 +1,40 @@
+/*
+ * ldt.h
+ *
+ * Definitions of structures used with the modify_ldt system call.
+ */
+#ifndef _ASM_X86_LDT_H
+#define _ASM_X86_LDT_H
+
+/* Maximum number of LDT entries supported. */
+#define LDT_ENTRIES	8192
+/* The size of each LDT entry. */
+#define LDT_ENTRY_SIZE	8
+
+#ifndef __ASSEMBLY__
+/*
+ * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS
+ * not to the default values if you still want to do syscalls. This
+ * call is more for 32bit mode therefore.
+ */
+struct user_desc {
+	unsigned int  entry_number;
+	unsigned int  base_addr;
+	unsigned int  limit;
+	unsigned int  seg_32bit:1;
+	unsigned int  contents:2;
+	unsigned int  read_exec_only:1;
+	unsigned int  limit_in_pages:1;
+	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
+#ifdef __x86_64__
+	unsigned int  lm:1;
+#endif
+};
+
+#define MODIFY_LDT_CONTENTS_DATA	0
+#define MODIFY_LDT_CONTENTS_STACK	1
+#define MODIFY_LDT_CONTENTS_CODE	2
+
+#endif /* !__ASSEMBLY__ */
+#endif /* _ASM_X86_LDT_H */
diff -uNr linux-2.6.32/usr/include/asm/mce.h clean_modified/linux-2.6.32/usr/include/asm/mce.h
--- linux-2.6.32/usr/include/asm/mce.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/mce.h	2019-04-14 13:24:02.851956391 -0500
@@ -0,0 +1,111 @@
+#ifndef _ASM_X86_MCE_H
+#define _ASM_X86_MCE_H
+
+#include <linux/types.h>
+#include <asm/ioctls.h>
+
+/*
+ * Machine Check support for x86
+ */
+
+#define MCG_BANKCNT_MASK	0xff         /* Number of Banks */
+#define MCG_CTL_P		(1ULL<<8)    /* MCG_CTL register available */
+#define MCG_EXT_P		(1ULL<<9)    /* Extended registers available */
+#define MCG_CMCI_P		(1ULL<<10)   /* CMCI supported */
+#define MCG_EXT_CNT_MASK	0xff0000     /* Number of Extended registers */
+#define MCG_EXT_CNT_SHIFT	16
+#define MCG_EXT_CNT(c)		(((c) & MCG_EXT_CNT_MASK) >> MCG_EXT_CNT_SHIFT)
+#define MCG_SER_P	 	(1ULL<<24)   /* MCA recovery/new status bits */
+
+#define MCG_STATUS_RIPV  (1ULL<<0)   /* restart ip valid */
+#define MCG_STATUS_EIPV  (1ULL<<1)   /* ip points to correct instruction */
+#define MCG_STATUS_MCIP  (1ULL<<2)   /* machine check in progress */
+
+#define MCI_STATUS_VAL   (1ULL<<63)  /* valid error */
+#define MCI_STATUS_OVER  (1ULL<<62)  /* previous errors lost */
+#define MCI_STATUS_UC    (1ULL<<61)  /* uncorrected error */
+#define MCI_STATUS_EN    (1ULL<<60)  /* error enabled */
+#define MCI_STATUS_MISCV (1ULL<<59)  /* misc error reg. valid */
+#define MCI_STATUS_ADDRV (1ULL<<58)  /* addr reg. valid */
+#define MCI_STATUS_PCC   (1ULL<<57)  /* processor context corrupt */
+#define MCI_STATUS_S	 (1ULL<<56)  /* Signaled machine check */
+#define MCI_STATUS_AR	 (1ULL<<55)  /* Action required */
+
+/* MISC register defines */
+#define MCM_ADDR_SEGOFF  0	/* segment offset */
+#define MCM_ADDR_LINEAR  1	/* linear address */
+#define MCM_ADDR_PHYS	 2	/* physical address */
+#define MCM_ADDR_MEM	 3	/* memory address */
+#define MCM_ADDR_GENERIC 7	/* generic */
+
+#define MCJ_CTX_MASK		3
+#define MCJ_CTX(flags)		((flags) & MCJ_CTX_MASK)
+#define MCJ_CTX_RANDOM		0    /* inject context: random */
+#define MCJ_CTX_PROCESS		1    /* inject context: process */
+#define MCJ_CTX_IRQ		2    /* inject context: IRQ */
+#define MCJ_NMI_BROADCAST	4    /* do NMI broadcasting */
+#define MCJ_EXCEPTION		8    /* raise as exception */
+
+/* Fields are zero when not available */
+struct mce {
+	__u64 status;
+	__u64 misc;
+	__u64 addr;
+	__u64 mcgstatus;
+	__u64 ip;
+	__u64 tsc;	/* cpu time stamp counter */
+	__u64 time;	/* wall time_t when error was detected */
+	__u8  cpuvendor;	/* cpu vendor as encoded in system.h */
+	__u8  inject_flags;	/* software inject flags */
+	__u16  pad;
+	__u32 cpuid;	/* CPUID 1 EAX */
+	__u8  cs;		/* code segment */
+	__u8  bank;	/* machine check bank */
+	__u8  cpu;	/* cpu number; obsolete; use extcpu now */
+	__u8  finished;   /* entry is valid */
+	__u32 extcpu;	/* linux cpu number that detected the error */
+	__u32 socketid;	/* CPU socket ID */
+	__u32 apicid;	/* CPU initial apic ID */
+	__u64 mcgcap;	/* MCGCAP MSR: machine check capabilities of CPU */
+};
+
+/*
+ * This structure contains all data related to the MCE log.  Also
+ * carries a signature to make it easier to find from external
+ * debugging tools.  Each entry is only valid when its finished flag
+ * is set.
+ */
+
+#define MCE_LOG_LEN 32
+
+struct mce_log {
+	char signature[12]; /* "MACHINECHECK" */
+	unsigned len;	    /* = MCE_LOG_LEN */
+	unsigned next;
+	unsigned flags;
+	unsigned recordlen;	/* length of struct mce */
+	struct mce entry[MCE_LOG_LEN];
+};
+
+#define MCE_OVERFLOW 0		/* bit 0 in flags means overflow */
+
+#define MCE_LOG_SIGNATURE	"MACHINECHECK"
+
+#define MCE_GET_RECORD_LEN   _IOR('M', 1, int)
+#define MCE_GET_LOG_LEN      _IOR('M', 2, int)
+#define MCE_GETCLEAR_FLAGS   _IOR('M', 3, int)
+
+/* Software defined banks */
+#define MCE_EXTENDED_BANK	128
+#define MCE_THERMAL_BANK	MCE_EXTENDED_BANK + 0
+
+#define K8_MCE_THRESHOLD_BASE      (MCE_EXTENDED_BANK + 1)      /* MCE_AMD */
+#define K8_MCE_THRESHOLD_BANK_0    (MCE_THRESHOLD_BASE + 0 * 9)
+#define K8_MCE_THRESHOLD_BANK_1    (MCE_THRESHOLD_BASE + 1 * 9)
+#define K8_MCE_THRESHOLD_BANK_2    (MCE_THRESHOLD_BASE + 2 * 9)
+#define K8_MCE_THRESHOLD_BANK_3    (MCE_THRESHOLD_BASE + 3 * 9)
+#define K8_MCE_THRESHOLD_BANK_4    (MCE_THRESHOLD_BASE + 4 * 9)
+#define K8_MCE_THRESHOLD_BANK_5    (MCE_THRESHOLD_BASE + 5 * 9)
+#define K8_MCE_THRESHOLD_DRAM_ECC  (MCE_THRESHOLD_BANK_4 + 0)
+
+#endif /* _ASM_X86_MCE_H */
diff -uNr linux-2.6.32/usr/include/asm/mman.h clean_modified/linux-2.6.32/usr/include/asm/mman.h
--- linux-2.6.32/usr/include/asm/mman.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/mman.h	2019-04-14 13:24:02.851956391 -0500
@@ -0,0 +1,8 @@
+#ifndef _ASM_X86_MMAN_H
+#define _ASM_X86_MMAN_H
+
+#define MAP_32BIT	0x40		/* only give out 32bit addresses */
+
+#include <asm-generic/mman.h>
+
+#endif /* _ASM_X86_MMAN_H */
diff -uNr linux-2.6.32/usr/include/asm/msgbuf.h clean_modified/linux-2.6.32/usr/include/asm/msgbuf.h
--- linux-2.6.32/usr/include/asm/msgbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/msgbuf.h	2019-04-14 13:24:02.851956391 -0500
@@ -0,0 +1 @@
+#include <asm-generic/msgbuf.h>
diff -uNr linux-2.6.32/usr/include/asm/msr.h clean_modified/linux-2.6.32/usr/include/asm/msr.h
--- linux-2.6.32/usr/include/asm/msr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/msr.h	2019-04-14 13:24:02.852987460 -0500
@@ -0,0 +1,15 @@
+#ifndef _ASM_X86_MSR_H
+#define _ASM_X86_MSR_H
+
+#include <asm/msr-index.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define X86_IOC_RDMSR_REGS	_IOWR('c', 0xA0, __u32[8])
+#define X86_IOC_WRMSR_REGS	_IOWR('c', 0xA1, __u32[8])
+
+#endif /* __ASSEMBLY__ */
+#endif /* _ASM_X86_MSR_H */
diff -uNr linux-2.6.32/usr/include/asm/msr-index.h clean_modified/linux-2.6.32/usr/include/asm/msr-index.h
--- linux-2.6.32/usr/include/asm/msr-index.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/msr-index.h	2019-04-14 13:24:02.853903410 -0500
@@ -0,0 +1,391 @@
+#ifndef _ASM_X86_MSR_INDEX_H
+#define _ASM_X86_MSR_INDEX_H
+
+/* CPU model specific register (MSR) numbers */
+
+/* x86-64 specific MSRs */
+#define MSR_EFER		0xc0000080 /* extended feature register */
+#define MSR_STAR		0xc0000081 /* legacy mode SYSCALL target */
+#define MSR_LSTAR		0xc0000082 /* long mode SYSCALL target */
+#define MSR_CSTAR		0xc0000083 /* compat mode SYSCALL target */
+#define MSR_SYSCALL_MASK	0xc0000084 /* EFLAGS mask for syscall */
+#define MSR_FS_BASE		0xc0000100 /* 64bit FS base */
+#define MSR_GS_BASE		0xc0000101 /* 64bit GS base */
+#define MSR_KERNEL_GS_BASE	0xc0000102 /* SwapGS GS shadow */
+
+/* EFER bits: */
+#define _EFER_SCE		0  /* SYSCALL/SYSRET */
+#define _EFER_LME		8  /* Long mode enable */
+#define _EFER_LMA		10 /* Long mode active (read-only) */
+#define _EFER_NX		11 /* No execute enable */
+#define _EFER_SVME		12 /* Enable virtualization */
+#define _EFER_FFXSR		14 /* Enable Fast FXSAVE/FXRSTOR */
+
+#define EFER_SCE		(1<<_EFER_SCE)
+#define EFER_LME		(1<<_EFER_LME)
+#define EFER_LMA		(1<<_EFER_LMA)
+#define EFER_NX			(1<<_EFER_NX)
+#define EFER_SVME		(1<<_EFER_SVME)
+#define EFER_FFXSR		(1<<_EFER_FFXSR)
+
+/* Intel MSRs. Some also available on other CPUs */
+#define MSR_IA32_PERFCTR0		0x000000c1
+#define MSR_IA32_PERFCTR1		0x000000c2
+#define MSR_FSB_FREQ			0x000000cd
+
+#define MSR_MTRRcap			0x000000fe
+#define MSR_IA32_BBL_CR_CTL		0x00000119
+
+#define MSR_IA32_SYSENTER_CS		0x00000174
+#define MSR_IA32_SYSENTER_ESP		0x00000175
+#define MSR_IA32_SYSENTER_EIP		0x00000176
+
+#define MSR_IA32_MCG_CAP		0x00000179
+#define MSR_IA32_MCG_STATUS		0x0000017a
+#define MSR_IA32_MCG_CTL		0x0000017b
+
+#define MSR_IA32_PEBS_ENABLE		0x000003f1
+#define MSR_IA32_DS_AREA		0x00000600
+#define MSR_IA32_PERF_CAPABILITIES	0x00000345
+
+#define MSR_MTRRfix64K_00000		0x00000250
+#define MSR_MTRRfix16K_80000		0x00000258
+#define MSR_MTRRfix16K_A0000		0x00000259
+#define MSR_MTRRfix4K_C0000		0x00000268
+#define MSR_MTRRfix4K_C8000		0x00000269
+#define MSR_MTRRfix4K_D0000		0x0000026a
+#define MSR_MTRRfix4K_D8000		0x0000026b
+#define MSR_MTRRfix4K_E0000		0x0000026c
+#define MSR_MTRRfix4K_E8000		0x0000026d
+#define MSR_MTRRfix4K_F0000		0x0000026e
+#define MSR_MTRRfix4K_F8000		0x0000026f
+#define MSR_MTRRdefType			0x000002ff
+
+#define MSR_IA32_CR_PAT			0x00000277
+
+#define MSR_IA32_DEBUGCTLMSR		0x000001d9
+#define MSR_IA32_LASTBRANCHFROMIP	0x000001db
+#define MSR_IA32_LASTBRANCHTOIP		0x000001dc
+#define MSR_IA32_LASTINTFROMIP		0x000001dd
+#define MSR_IA32_LASTINTTOIP		0x000001de
+
+/* DEBUGCTLMSR bits (others vary by model): */
+#define _DEBUGCTLMSR_LBR	0 /* last branch recording */
+#define _DEBUGCTLMSR_BTF	1 /* single-step on branches */
+
+#define DEBUGCTLMSR_LBR		(1UL << _DEBUGCTLMSR_LBR)
+#define DEBUGCTLMSR_BTF		(1UL << _DEBUGCTLMSR_BTF)
+
+#define MSR_IA32_MC0_CTL		0x00000400
+#define MSR_IA32_MC0_STATUS		0x00000401
+#define MSR_IA32_MC0_ADDR		0x00000402
+#define MSR_IA32_MC0_MISC		0x00000403
+
+#define MSR_IA32_MCx_CTL(x)		(MSR_IA32_MC0_CTL + 4*(x))
+#define MSR_IA32_MCx_STATUS(x)		(MSR_IA32_MC0_STATUS + 4*(x))
+#define MSR_IA32_MCx_ADDR(x)		(MSR_IA32_MC0_ADDR + 4*(x))
+#define MSR_IA32_MCx_MISC(x)		(MSR_IA32_MC0_MISC + 4*(x))
+
+/* These are consecutive and not in the normal 4er MCE bank block */
+#define MSR_IA32_MC0_CTL2		0x00000280
+#define MSR_IA32_MCx_CTL2(x)		(MSR_IA32_MC0_CTL2 + (x))
+
+#define CMCI_EN			(1ULL << 30)
+#define CMCI_THRESHOLD_MASK		0xffffULL
+
+#define MSR_P6_PERFCTR0			0x000000c1
+#define MSR_P6_PERFCTR1			0x000000c2
+#define MSR_P6_EVNTSEL0			0x00000186
+#define MSR_P6_EVNTSEL1			0x00000187
+
+/* AMD64 MSRs. Not complete. See the architecture manual for a more
+   complete list. */
+
+#define MSR_AMD64_PATCH_LEVEL		0x0000008b
+#define MSR_AMD64_NB_CFG		0xc001001f
+#define MSR_AMD64_PATCH_LOADER		0xc0010020
+#define MSR_AMD64_IBSFETCHCTL		0xc0011030
+#define MSR_AMD64_IBSFETCHLINAD		0xc0011031
+#define MSR_AMD64_IBSFETCHPHYSAD	0xc0011032
+#define MSR_AMD64_IBSOPCTL		0xc0011033
+#define MSR_AMD64_IBSOPRIP		0xc0011034
+#define MSR_AMD64_IBSOPDATA		0xc0011035
+#define MSR_AMD64_IBSOPDATA2		0xc0011036
+#define MSR_AMD64_IBSOPDATA3		0xc0011037
+#define MSR_AMD64_IBSDCLINAD		0xc0011038
+#define MSR_AMD64_IBSDCPHYSAD		0xc0011039
+#define MSR_AMD64_IBSCTL		0xc001103a
+
+/* Fam 10h MSRs */
+#define MSR_FAM10H_MMIO_CONF_BASE	0xc0010058
+#define FAM10H_MMIO_CONF_ENABLE		(1<<0)
+#define FAM10H_MMIO_CONF_BUSRANGE_MASK	0xf
+#define FAM10H_MMIO_CONF_BUSRANGE_SHIFT 2
+#define FAM10H_MMIO_CONF_BASE_MASK	0xfffffff
+#define FAM10H_MMIO_CONF_BASE_SHIFT	20
+
+/* K8 MSRs */
+#define MSR_K8_TOP_MEM1			0xc001001a
+#define MSR_K8_TOP_MEM2			0xc001001d
+#define MSR_K8_SYSCFG			0xc0010010
+#define MSR_K8_INT_PENDING_MSG		0xc0010055
+/* C1E active bits in int pending message */
+#define K8_INTP_C1E_ACTIVE_MASK		0x18000000
+#define MSR_K8_TSEG_ADDR		0xc0010112
+#define K8_MTRRFIXRANGE_DRAM_ENABLE	0x00040000 /* MtrrFixDramEn bit    */
+#define K8_MTRRFIXRANGE_DRAM_MODIFY	0x00080000 /* MtrrFixDramModEn bit */
+#define K8_MTRR_RDMEM_WRMEM_MASK	0x18181818 /* Mask: RdMem|WrMem    */
+
+/* K7 MSRs */
+#define MSR_K7_EVNTSEL0			0xc0010000
+#define MSR_K7_PERFCTR0			0xc0010004
+#define MSR_K7_EVNTSEL1			0xc0010001
+#define MSR_K7_PERFCTR1			0xc0010005
+#define MSR_K7_EVNTSEL2			0xc0010002
+#define MSR_K7_PERFCTR2			0xc0010006
+#define MSR_K7_EVNTSEL3			0xc0010003
+#define MSR_K7_PERFCTR3			0xc0010007
+#define MSR_K7_CLK_CTL			0xc001001b
+#define MSR_K7_HWCR			0xc0010015
+#define MSR_K7_FID_VID_CTL		0xc0010041
+#define MSR_K7_FID_VID_STATUS		0xc0010042
+
+/* K6 MSRs */
+#define MSR_K6_EFER			0xc0000080
+#define MSR_K6_STAR			0xc0000081
+#define MSR_K6_WHCR			0xc0000082
+#define MSR_K6_UWCCR			0xc0000085
+#define MSR_K6_EPMR			0xc0000086
+#define MSR_K6_PSOR			0xc0000087
+#define MSR_K6_PFIR			0xc0000088
+
+/* Centaur-Hauls/IDT defined MSRs. */
+#define MSR_IDT_FCR1			0x00000107
+#define MSR_IDT_FCR2			0x00000108
+#define MSR_IDT_FCR3			0x00000109
+#define MSR_IDT_FCR4			0x0000010a
+
+#define MSR_IDT_MCR0			0x00000110
+#define MSR_IDT_MCR1			0x00000111
+#define MSR_IDT_MCR2			0x00000112
+#define MSR_IDT_MCR3			0x00000113
+#define MSR_IDT_MCR4			0x00000114
+#define MSR_IDT_MCR5			0x00000115
+#define MSR_IDT_MCR6			0x00000116
+#define MSR_IDT_MCR7			0x00000117
+#define MSR_IDT_MCR_CTRL		0x00000120
+
+/* VIA Cyrix defined MSRs*/
+#define MSR_VIA_FCR			0x00001107
+#define MSR_VIA_LONGHAUL		0x0000110a
+#define MSR_VIA_RNG			0x0000110b
+#define MSR_VIA_BCR2			0x00001147
+
+/* Transmeta defined MSRs */
+#define MSR_TMTA_LONGRUN_CTRL		0x80868010
+#define MSR_TMTA_LONGRUN_FLAGS		0x80868011
+#define MSR_TMTA_LRTI_READOUT		0x80868018
+#define MSR_TMTA_LRTI_VOLT_MHZ		0x8086801a
+
+/* Intel defined MSRs. */
+#define MSR_IA32_P5_MC_ADDR		0x00000000
+#define MSR_IA32_P5_MC_TYPE		0x00000001
+#define MSR_IA32_TSC			0x00000010
+#define MSR_IA32_PLATFORM_ID		0x00000017
+#define MSR_IA32_EBL_CR_POWERON		0x0000002a
+#define MSR_IA32_FEATURE_CONTROL        0x0000003a
+
+#define FEATURE_CONTROL_LOCKED		(1<<0)
+#define FEATURE_CONTROL_VMXON_ENABLED	(1<<2)
+
+#define MSR_IA32_APICBASE		0x0000001b
+#define MSR_IA32_APICBASE_BSP		(1<<8)
+#define MSR_IA32_APICBASE_ENABLE	(1<<11)
+#define MSR_IA32_APICBASE_BASE		(0xfffff<<12)
+
+#define MSR_IA32_UCODE_WRITE		0x00000079
+#define MSR_IA32_UCODE_REV		0x0000008b
+
+#define MSR_IA32_PERF_STATUS		0x00000198
+#define MSR_IA32_PERF_CTL		0x00000199
+
+#define MSR_IA32_MPERF			0x000000e7
+#define MSR_IA32_APERF			0x000000e8
+
+#define MSR_IA32_THERM_CONTROL		0x0000019a
+#define MSR_IA32_THERM_INTERRUPT	0x0000019b
+
+#define THERM_INT_LOW_ENABLE		(1 << 0)
+#define THERM_INT_HIGH_ENABLE		(1 << 1)
+
+#define MSR_IA32_THERM_STATUS		0x0000019c
+
+#define THERM_STATUS_PROCHOT		(1 << 0)
+
+#define MSR_THERM2_CTL			0x0000019d
+
+#define MSR_THERM2_CTL_TM_SELECT	(1ULL << 16)
+
+#define MSR_IA32_MISC_ENABLE		0x000001a0
+
+/* MISC_ENABLE bits: architectural */
+#define MSR_IA32_MISC_ENABLE_FAST_STRING	(1ULL << 0)
+#define MSR_IA32_MISC_ENABLE_TCC		(1ULL << 1)
+#define MSR_IA32_MISC_ENABLE_EMON		(1ULL << 7)
+#define MSR_IA32_MISC_ENABLE_BTS_UNAVAIL	(1ULL << 11)
+#define MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL	(1ULL << 12)
+#define MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP	(1ULL << 16)
+#define MSR_IA32_MISC_ENABLE_MWAIT		(1ULL << 18)
+#define MSR_IA32_MISC_ENABLE_LIMIT_CPUID	(1ULL << 22)
+#define MSR_IA32_MISC_ENABLE_XTPR_DISABLE	(1ULL << 23)
+#define MSR_IA32_MISC_ENABLE_XD_DISABLE		(1ULL << 34)
+
+/* MISC_ENABLE bits: model-specific, meaning may vary from core to core */
+#define MSR_IA32_MISC_ENABLE_X87_COMPAT		(1ULL << 2)
+#define MSR_IA32_MISC_ENABLE_TM1		(1ULL << 3)
+#define MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE	(1ULL << 4)
+#define MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE	(1ULL << 6)
+#define MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK	(1ULL << 8)
+#define MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE	(1ULL << 9)
+#define MSR_IA32_MISC_ENABLE_FERR		(1ULL << 10)
+#define MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX	(1ULL << 10)
+#define MSR_IA32_MISC_ENABLE_TM2		(1ULL << 13)
+#define MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE	(1ULL << 19)
+#define MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK	(1ULL << 20)
+#define MSR_IA32_MISC_ENABLE_L1D_CONTEXT	(1ULL << 24)
+#define MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE	(1ULL << 37)
+#define MSR_IA32_MISC_ENABLE_TURBO_DISABLE	(1ULL << 38)
+#define MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE	(1ULL << 39)
+
+/* P4/Xeon+ specific */
+#define MSR_IA32_MCG_EAX		0x00000180
+#define MSR_IA32_MCG_EBX		0x00000181
+#define MSR_IA32_MCG_ECX		0x00000182
+#define MSR_IA32_MCG_EDX		0x00000183
+#define MSR_IA32_MCG_ESI		0x00000184
+#define MSR_IA32_MCG_EDI		0x00000185
+#define MSR_IA32_MCG_EBP		0x00000186
+#define MSR_IA32_MCG_ESP		0x00000187
+#define MSR_IA32_MCG_EFLAGS		0x00000188
+#define MSR_IA32_MCG_EIP		0x00000189
+#define MSR_IA32_MCG_RESERVED		0x0000018a
+
+/* Pentium IV performance counter MSRs */
+#define MSR_P4_BPU_PERFCTR0		0x00000300
+#define MSR_P4_BPU_PERFCTR1		0x00000301
+#define MSR_P4_BPU_PERFCTR2		0x00000302
+#define MSR_P4_BPU_PERFCTR3		0x00000303
+#define MSR_P4_MS_PERFCTR0		0x00000304
+#define MSR_P4_MS_PERFCTR1		0x00000305
+#define MSR_P4_MS_PERFCTR2		0x00000306
+#define MSR_P4_MS_PERFCTR3		0x00000307
+#define MSR_P4_FLAME_PERFCTR0		0x00000308
+#define MSR_P4_FLAME_PERFCTR1		0x00000309
+#define MSR_P4_FLAME_PERFCTR2		0x0000030a
+#define MSR_P4_FLAME_PERFCTR3		0x0000030b
+#define MSR_P4_IQ_PERFCTR0		0x0000030c
+#define MSR_P4_IQ_PERFCTR1		0x0000030d
+#define MSR_P4_IQ_PERFCTR2		0x0000030e
+#define MSR_P4_IQ_PERFCTR3		0x0000030f
+#define MSR_P4_IQ_PERFCTR4		0x00000310
+#define MSR_P4_IQ_PERFCTR5		0x00000311
+#define MSR_P4_BPU_CCCR0		0x00000360
+#define MSR_P4_BPU_CCCR1		0x00000361
+#define MSR_P4_BPU_CCCR2		0x00000362
+#define MSR_P4_BPU_CCCR3		0x00000363
+#define MSR_P4_MS_CCCR0			0x00000364
+#define MSR_P4_MS_CCCR1			0x00000365
+#define MSR_P4_MS_CCCR2			0x00000366
+#define MSR_P4_MS_CCCR3			0x00000367
+#define MSR_P4_FLAME_CCCR0		0x00000368
+#define MSR_P4_FLAME_CCCR1		0x00000369
+#define MSR_P4_FLAME_CCCR2		0x0000036a
+#define MSR_P4_FLAME_CCCR3		0x0000036b
+#define MSR_P4_IQ_CCCR0			0x0000036c
+#define MSR_P4_IQ_CCCR1			0x0000036d
+#define MSR_P4_IQ_CCCR2			0x0000036e
+#define MSR_P4_IQ_CCCR3			0x0000036f
+#define MSR_P4_IQ_CCCR4			0x00000370
+#define MSR_P4_IQ_CCCR5			0x00000371
+#define MSR_P4_ALF_ESCR0		0x000003ca
+#define MSR_P4_ALF_ESCR1		0x000003cb
+#define MSR_P4_BPU_ESCR0		0x000003b2
+#define MSR_P4_BPU_ESCR1		0x000003b3
+#define MSR_P4_BSU_ESCR0		0x000003a0
+#define MSR_P4_BSU_ESCR1		0x000003a1
+#define MSR_P4_CRU_ESCR0		0x000003b8
+#define MSR_P4_CRU_ESCR1		0x000003b9
+#define MSR_P4_CRU_ESCR2		0x000003cc
+#define MSR_P4_CRU_ESCR3		0x000003cd
+#define MSR_P4_CRU_ESCR4		0x000003e0
+#define MSR_P4_CRU_ESCR5		0x000003e1
+#define MSR_P4_DAC_ESCR0		0x000003a8
+#define MSR_P4_DAC_ESCR1		0x000003a9
+#define MSR_P4_FIRM_ESCR0		0x000003a4
+#define MSR_P4_FIRM_ESCR1		0x000003a5
+#define MSR_P4_FLAME_ESCR0		0x000003a6
+#define MSR_P4_FLAME_ESCR1		0x000003a7
+#define MSR_P4_FSB_ESCR0		0x000003a2
+#define MSR_P4_FSB_ESCR1		0x000003a3
+#define MSR_P4_IQ_ESCR0			0x000003ba
+#define MSR_P4_IQ_ESCR1			0x000003bb
+#define MSR_P4_IS_ESCR0			0x000003b4
+#define MSR_P4_IS_ESCR1			0x000003b5
+#define MSR_P4_ITLB_ESCR0		0x000003b6
+#define MSR_P4_ITLB_ESCR1		0x000003b7
+#define MSR_P4_IX_ESCR0			0x000003c8
+#define MSR_P4_IX_ESCR1			0x000003c9
+#define MSR_P4_MOB_ESCR0		0x000003aa
+#define MSR_P4_MOB_ESCR1		0x000003ab
+#define MSR_P4_MS_ESCR0			0x000003c0
+#define MSR_P4_MS_ESCR1			0x000003c1
+#define MSR_P4_PMH_ESCR0		0x000003ac
+#define MSR_P4_PMH_ESCR1		0x000003ad
+#define MSR_P4_RAT_ESCR0		0x000003bc
+#define MSR_P4_RAT_ESCR1		0x000003bd
+#define MSR_P4_SAAT_ESCR0		0x000003ae
+#define MSR_P4_SAAT_ESCR1		0x000003af
+#define MSR_P4_SSU_ESCR0		0x000003be
+#define MSR_P4_SSU_ESCR1		0x000003bf /* guess: not in manual */
+
+#define MSR_P4_TBPU_ESCR0		0x000003c2
+#define MSR_P4_TBPU_ESCR1		0x000003c3
+#define MSR_P4_TC_ESCR0			0x000003c4
+#define MSR_P4_TC_ESCR1			0x000003c5
+#define MSR_P4_U2L_ESCR0		0x000003b0
+#define MSR_P4_U2L_ESCR1		0x000003b1
+
+/* Intel Core-based CPU performance counters */
+#define MSR_CORE_PERF_FIXED_CTR0	0x00000309
+#define MSR_CORE_PERF_FIXED_CTR1	0x0000030a
+#define MSR_CORE_PERF_FIXED_CTR2	0x0000030b
+#define MSR_CORE_PERF_FIXED_CTR_CTRL	0x0000038d
+#define MSR_CORE_PERF_GLOBAL_STATUS	0x0000038e
+#define MSR_CORE_PERF_GLOBAL_CTRL	0x0000038f
+#define MSR_CORE_PERF_GLOBAL_OVF_CTRL	0x00000390
+
+/* Geode defined MSRs */
+#define MSR_GEODE_BUSCONT_CONF0		0x00001900
+
+/* Intel VT MSRs */
+#define MSR_IA32_VMX_BASIC              0x00000480
+#define MSR_IA32_VMX_PINBASED_CTLS      0x00000481
+#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482
+#define MSR_IA32_VMX_EXIT_CTLS          0x00000483
+#define MSR_IA32_VMX_ENTRY_CTLS         0x00000484
+#define MSR_IA32_VMX_MISC               0x00000485
+#define MSR_IA32_VMX_CR0_FIXED0         0x00000486
+#define MSR_IA32_VMX_CR0_FIXED1         0x00000487
+#define MSR_IA32_VMX_CR4_FIXED0         0x00000488
+#define MSR_IA32_VMX_CR4_FIXED1         0x00000489
+#define MSR_IA32_VMX_VMCS_ENUM          0x0000048a
+#define MSR_IA32_VMX_PROCBASED_CTLS2    0x0000048b
+#define MSR_IA32_VMX_EPT_VPID_CAP       0x0000048c
+
+/* AMD-V MSRs */
+
+#define MSR_VM_CR                       0xc0010114
+#define MSR_VM_IGNNE                    0xc0010115
+#define MSR_VM_HSAVE_PA                 0xc0010117
+
+#endif /* _ASM_X86_MSR_INDEX_H */
diff -uNr linux-2.6.32/usr/include/asm/mtrr.h clean_modified/linux-2.6.32/usr/include/asm/mtrr.h
--- linux-2.6.32/usr/include/asm/mtrr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/mtrr.h	2019-04-14 13:24:02.854872074 -0500
@@ -0,0 +1,109 @@
+/*  Generic MTRR (Memory Type Range Register) ioctls.
+
+    Copyright (C) 1997-1999  Richard Gooch
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au
+    The postal address is:
+      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.
+*/
+#ifndef _ASM_X86_MTRR_H
+#define _ASM_X86_MTRR_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/errno.h>
+
+#define	MTRR_IOCTL_BASE	'M'
+
+struct mtrr_sentry {
+    unsigned long base;    /*  Base address     */
+    unsigned int size;    /*  Size of region   */
+    unsigned int type;     /*  Type of region   */
+};
+
+/* Warning: this structure has a different order from i386
+   on x86-64. The 32bit emulation code takes care of that.
+   But you need to use this for 64bit, otherwise your X server
+   will break. */
+
+#ifdef __i386__
+struct mtrr_gentry {
+    unsigned int regnum;   /*  Register number  */
+    unsigned long base;    /*  Base address     */
+    unsigned int size;    /*  Size of region   */
+    unsigned int type;     /*  Type of region   */
+};
+
+#else /* __i386__ */
+
+struct mtrr_gentry {
+    unsigned long base;    /*  Base address     */
+    unsigned int size;    /*  Size of region   */
+    unsigned int regnum;   /*  Register number  */
+    unsigned int type;     /*  Type of region   */
+};
+#endif /* !__i386__ */
+
+struct mtrr_var_range {
+	__u32 base_lo;
+	__u32 base_hi;
+	__u32 mask_lo;
+	__u32 mask_hi;
+};
+
+/* In the Intel processor's MTRR interface, the MTRR type is always held in
+   an 8 bit field: */
+typedef __u8 mtrr_type;
+
+#define MTRR_NUM_FIXED_RANGES 88
+#define MTRR_MAX_VAR_RANGES 256
+
+struct mtrr_state_type {
+	struct mtrr_var_range var_ranges[MTRR_MAX_VAR_RANGES];
+	mtrr_type fixed_ranges[MTRR_NUM_FIXED_RANGES];
+	unsigned char enabled;
+	unsigned char have_fixed;
+	mtrr_type def_type;
+};
+
+#define MTRRphysBase_MSR(reg) (0x200 + 2 * (reg))
+#define MTRRphysMask_MSR(reg) (0x200 + 2 * (reg) + 1)
+
+/*  These are the various ioctls  */
+#define MTRRIOC_ADD_ENTRY        _IOW(MTRR_IOCTL_BASE,  0, struct mtrr_sentry)
+#define MTRRIOC_SET_ENTRY        _IOW(MTRR_IOCTL_BASE,  1, struct mtrr_sentry)
+#define MTRRIOC_DEL_ENTRY        _IOW(MTRR_IOCTL_BASE,  2, struct mtrr_sentry)
+#define MTRRIOC_GET_ENTRY        _IOWR(MTRR_IOCTL_BASE, 3, struct mtrr_gentry)
+#define MTRRIOC_KILL_ENTRY       _IOW(MTRR_IOCTL_BASE,  4, struct mtrr_sentry)
+#define MTRRIOC_ADD_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  5, struct mtrr_sentry)
+#define MTRRIOC_SET_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  6, struct mtrr_sentry)
+#define MTRRIOC_DEL_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  7, struct mtrr_sentry)
+#define MTRRIOC_GET_PAGE_ENTRY   _IOWR(MTRR_IOCTL_BASE, 8, struct mtrr_gentry)
+#define MTRRIOC_KILL_PAGE_ENTRY  _IOW(MTRR_IOCTL_BASE,  9, struct mtrr_sentry)
+
+/*  These are the region types  */
+#define MTRR_TYPE_UNCACHABLE 0
+#define MTRR_TYPE_WRCOMB     1
+/*#define MTRR_TYPE_         2*/
+/*#define MTRR_TYPE_         3*/
+#define MTRR_TYPE_WRTHROUGH  4
+#define MTRR_TYPE_WRPROT     5
+#define MTRR_TYPE_WRBACK     6
+#define MTRR_NUM_TYPES       7
+
+
+#endif /* _ASM_X86_MTRR_H */
diff -uNr linux-2.6.32/usr/include/asm/param.h clean_modified/linux-2.6.32/usr/include/asm/param.h
--- linux-2.6.32/usr/include/asm/param.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/param.h	2019-04-14 13:24:02.854872074 -0500
@@ -0,0 +1 @@
+#include <asm-generic/param.h>
diff -uNr linux-2.6.32/usr/include/asm/poll.h clean_modified/linux-2.6.32/usr/include/asm/poll.h
--- linux-2.6.32/usr/include/asm/poll.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/poll.h	2019-04-14 13:24:02.854872074 -0500
@@ -0,0 +1 @@
+#include <asm-generic/poll.h>
diff -uNr linux-2.6.32/usr/include/asm/posix_types_32.h clean_modified/linux-2.6.32/usr/include/asm/posix_types_32.h
--- linux-2.6.32/usr/include/asm/posix_types_32.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/posix_types_32.h	2019-04-14 13:24:02.854872074 -0500
@@ -0,0 +1,46 @@
+#ifndef _ASM_X86_POSIX_TYPES_32_H
+#define _ASM_X86_POSIX_TYPES_32_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+
+#endif /* _ASM_X86_POSIX_TYPES_32_H */
diff -uNr linux-2.6.32/usr/include/asm/posix_types_64.h clean_modified/linux-2.6.32/usr/include/asm/posix_types_64.h
--- linux-2.6.32/usr/include/asm/posix_types_64.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/posix_types_64.h	2019-04-14 13:24:02.855846472 -0500
@@ -0,0 +1,47 @@
+#ifndef _ASM_X86_POSIX_TYPES_64_H
+#define _ASM_X86_POSIX_TYPES_64_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+typedef unsigned long	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef int		__kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef __kernel_uid_t __kernel_uid32_t;
+typedef __kernel_gid_t __kernel_gid32_t;
+
+typedef unsigned long	__kernel_old_dev_t;
+
+
+#endif /* _ASM_X86_POSIX_TYPES_64_H */
diff -uNr linux-2.6.32/usr/include/asm/posix_types.h clean_modified/linux-2.6.32/usr/include/asm/posix_types.h
--- linux-2.6.32/usr/include/asm/posix_types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/posix_types.h	2019-04-14 13:24:02.855846472 -0500
@@ -0,0 +1,5 @@
+# ifdef __i386__
+#  include "posix_types_32.h"
+# else
+#  include "posix_types_64.h"
+# endif
diff -uNr linux-2.6.32/usr/include/asm/prctl.h clean_modified/linux-2.6.32/usr/include/asm/prctl.h
--- linux-2.6.32/usr/include/asm/prctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/prctl.h	2019-04-14 13:24:02.855846472 -0500
@@ -0,0 +1,9 @@
+#ifndef _ASM_X86_PRCTL_H
+#define _ASM_X86_PRCTL_H
+
+#define ARCH_SET_GS 0x1001
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+#define ARCH_GET_GS 0x1004
+
+#endif /* _ASM_X86_PRCTL_H */
diff -uNr linux-2.6.32/usr/include/asm/processor-flags.h clean_modified/linux-2.6.32/usr/include/asm/processor-flags.h
--- linux-2.6.32/usr/include/asm/processor-flags.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/processor-flags.h	2019-04-14 13:24:02.855846472 -0500
@@ -0,0 +1,93 @@
+#ifndef _ASM_X86_PROCESSOR_FLAGS_H
+#define _ASM_X86_PROCESSOR_FLAGS_H
+/* Various flags defined: can be included from assembler. */
+
+/*
+ * EFLAGS bits
+ */
+#define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
+#define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
+#define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
+#define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
+#define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
+#define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
+#define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
+#define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
+#define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
+#define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
+#define X86_EFLAGS_NT	0x00004000 /* Nested Task */
+#define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
+#define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
+#define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
+#define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
+#define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
+#define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+
+/*
+ * Basic CPU control in CR0
+ */
+#define X86_CR0_PE	0x00000001 /* Protection Enable */
+#define X86_CR0_MP	0x00000002 /* Monitor Coprocessor */
+#define X86_CR0_EM	0x00000004 /* Emulation */
+#define X86_CR0_TS	0x00000008 /* Task Switched */
+#define X86_CR0_ET	0x00000010 /* Extension Type */
+#define X86_CR0_NE	0x00000020 /* Numeric Error */
+#define X86_CR0_WP	0x00010000 /* Write Protect */
+#define X86_CR0_AM	0x00040000 /* Alignment Mask */
+#define X86_CR0_NW	0x20000000 /* Not Write-through */
+#define X86_CR0_CD	0x40000000 /* Cache Disable */
+#define X86_CR0_PG	0x80000000 /* Paging */
+
+/*
+ * Paging options in CR3
+ */
+#define X86_CR3_PWT	0x00000008 /* Page Write Through */
+#define X86_CR3_PCD	0x00000010 /* Page Cache Disable */
+
+/*
+ * Intel CPU features in CR4
+ */
+#define X86_CR4_VME	0x00000001 /* enable vm86 extensions */
+#define X86_CR4_PVI	0x00000002 /* virtual interrupts flag enable */
+#define X86_CR4_TSD	0x00000004 /* disable time stamp at ipl 3 */
+#define X86_CR4_DE	0x00000008 /* enable debugging extensions */
+#define X86_CR4_PSE	0x00000010 /* enable page size extensions */
+#define X86_CR4_PAE	0x00000020 /* enable physical address extensions */
+#define X86_CR4_MCE	0x00000040 /* Machine check enable */
+#define X86_CR4_PGE	0x00000080 /* enable global pages */
+#define X86_CR4_PCE	0x00000100 /* enable performance counters at ipl 3 */
+#define X86_CR4_OSFXSR	0x00000200 /* enable fast FPU save and restore */
+#define X86_CR4_OSXMMEXCPT 0x00000400 /* enable unmasked SSE exceptions */
+#define X86_CR4_VMXE	0x00002000 /* enable VMX virtualization */
+#define X86_CR4_OSXSAVE 0x00040000 /* enable xsave and xrestore */
+
+/*
+ * x86-64 Task Priority Register, CR8
+ */
+#define X86_CR8_TPR	0x0000000F /* task priority register */
+
+/*
+ * AMD and Transmeta use MSRs for configuration; see <asm/msr-index.h>
+ */
+
+/*
+ *      NSC/Cyrix CPU configuration register indexes
+ */
+#define CX86_PCR0	0x20
+#define CX86_GCR	0xb8
+#define CX86_CCR0	0xc0
+#define CX86_CCR1	0xc1
+#define CX86_CCR2	0xc2
+#define CX86_CCR3	0xc3
+#define CX86_CCR4	0xe8
+#define CX86_CCR5	0xe9
+#define CX86_CCR6	0xea
+#define CX86_CCR7	0xeb
+#define CX86_PCR1	0xf0
+#define CX86_DIR0	0xfe
+#define CX86_DIR1	0xff
+#define CX86_ARR_BASE	0xc4
+#define CX86_RCR_BASE	0xdc
+
+
+#endif /* _ASM_X86_PROCESSOR_FLAGS_H */
diff -uNr linux-2.6.32/usr/include/asm/ptrace-abi.h clean_modified/linux-2.6.32/usr/include/asm/ptrace-abi.h
--- linux-2.6.32/usr/include/asm/ptrace-abi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ptrace-abi.h	2019-04-14 13:24:02.862565766 -0500
@@ -0,0 +1,142 @@
+#ifndef _ASM_X86_PTRACE_ABI_H
+#define _ASM_X86_PTRACE_ABI_H
+
+#ifdef __i386__
+
+#define EBX 0
+#define ECX 1
+#define EDX 2
+#define ESI 3
+#define EDI 4
+#define EBP 5
+#define EAX 6
+#define DS 7
+#define ES 8
+#define FS 9
+#define GS 10
+#define ORIG_EAX 11
+#define EIP 12
+#define CS  13
+#define EFL 14
+#define UESP 15
+#define SS   16
+#define FRAME_SIZE 17
+
+#else /* __i386__ */
+
+#if defined(__ASSEMBLY__) || defined(__FRAME_OFFSETS)
+#define R15 0
+#define R14 8
+#define R13 16
+#define R12 24
+#define RBP 32
+#define RBX 40
+/* arguments: interrupts/non tracing syscalls only save upto here*/
+#define R11 48
+#define R10 56
+#define R9 64
+#define R8 72
+#define RAX 80
+#define RCX 88
+#define RDX 96
+#define RSI 104
+#define RDI 112
+#define ORIG_RAX 120       /* = ERROR */
+/* end of arguments */
+/* cpu exception frame or undefined in case of fast syscall. */
+#define RIP 128
+#define CS 136
+#define EFLAGS 144
+#define RSP 152
+#define SS 160
+#define ARGOFFSET R11
+#endif /* __ASSEMBLY__ */
+
+/* top of stack page */
+#define FRAME_SIZE 168
+
+#endif /* !__i386__ */
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS            12
+#define PTRACE_SETREGS            13
+#define PTRACE_GETFPREGS          14
+#define PTRACE_SETFPREGS          15
+#define PTRACE_GETFPXREGS         18
+#define PTRACE_SETFPXREGS         19
+
+#define PTRACE_OLDSETOPTIONS      21
+
+/* only useful for access 32bit programs / kernels */
+#define PTRACE_GET_THREAD_AREA    25
+#define PTRACE_SET_THREAD_AREA    26
+
+#ifdef __x86_64__
+# define PTRACE_ARCH_PRCTL	  30
+#endif
+
+#define PTRACE_SYSEMU		  31
+#define PTRACE_SYSEMU_SINGLESTEP  32
+
+#define PTRACE_SINGLEBLOCK	33	/* resume execution until next branch */
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+
+/* configuration/status structure used in PTRACE_BTS_CONFIG and
+   PTRACE_BTS_STATUS commands.
+*/
+struct ptrace_bts_config {
+	/* requested or actual size of BTS buffer in bytes */
+	__u32 size;
+	/* bitmask of below flags */
+	__u32 flags;
+	/* buffer overflow signal */
+	__u32 signal;
+	/* actual size of bts_struct in bytes */
+	__u32 bts_size;
+};
+#endif /* __ASSEMBLY__ */
+
+#define PTRACE_BTS_O_TRACE	0x1 /* branch trace */
+#define PTRACE_BTS_O_SCHED	0x2 /* scheduling events w/ jiffies */
+#define PTRACE_BTS_O_SIGNAL     0x4 /* send SIG<signal> on buffer overflow
+				       instead of wrapping around */
+#define PTRACE_BTS_O_ALLOC	0x8 /* (re)allocate buffer */
+
+#define PTRACE_BTS_CONFIG	40
+/* Configure branch trace recording.
+   ADDR points to a struct ptrace_bts_config.
+   DATA gives the size of that buffer.
+   A new buffer is allocated, if requested in the flags.
+   An overflow signal may only be requested for new buffers.
+   Returns the number of bytes read.
+*/
+#define PTRACE_BTS_STATUS	41
+/* Return the current configuration in a struct ptrace_bts_config
+   pointed to by ADDR; DATA gives the size of that buffer.
+   Returns the number of bytes written.
+*/
+#define PTRACE_BTS_SIZE		42
+/* Return the number of available BTS records for draining.
+   DATA and ADDR are ignored.
+*/
+#define PTRACE_BTS_GET		43
+/* Get a single BTS record.
+   DATA defines the index into the BTS array, where 0 is the newest
+   entry, and higher indices refer to older entries.
+   ADDR is pointing to struct bts_struct (see asm/ds.h).
+*/
+#define PTRACE_BTS_CLEAR	44
+/* Clear the BTS buffer.
+   DATA and ADDR are ignored.
+*/
+#define PTRACE_BTS_DRAIN	45
+/* Read all available BTS records and clear the buffer.
+   ADDR points to an array of struct bts_struct.
+   DATA gives the size of that buffer.
+   BTS records are read from oldest to newest.
+   Returns number of BTS records drained.
+*/
+
+#endif /* _ASM_X86_PTRACE_ABI_H */
diff -uNr linux-2.6.32/usr/include/asm/ptrace.h clean_modified/linux-2.6.32/usr/include/asm/ptrace.h
--- linux-2.6.32/usr/include/asm/ptrace.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ptrace.h	2019-04-14 13:24:02.862565766 -0500
@@ -0,0 +1,74 @@
+#ifndef _ASM_X86_PTRACE_H
+#define _ASM_X86_PTRACE_H
+
+	/* For */
+#include <asm/ptrace-abi.h>
+#include <asm/processor-flags.h>
+
+
+#ifndef __ASSEMBLY__
+
+#ifdef __i386__
+/* this struct defines the way the registers are stored on the
+   stack during a system call. */
+
+
+struct pt_regs {
+	long ebx;
+	long ecx;
+	long edx;
+	long esi;
+	long edi;
+	long ebp;
+	long eax;
+	int  xds;
+	int  xes;
+	int  xfs;
+	int  xgs;
+	long orig_eax;
+	long eip;
+	int  xcs;
+	long eflags;
+	long esp;
+	int  xss;
+};
+
+
+#else /* __i386__ */
+
+
+struct pt_regs {
+	unsigned long r15;
+	unsigned long r14;
+	unsigned long r13;
+	unsigned long r12;
+	unsigned long rbp;
+	unsigned long rbx;
+/* arguments: non interrupts/non tracing syscalls only save upto here*/
+	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long rax;
+	unsigned long rcx;
+	unsigned long rdx;
+	unsigned long rsi;
+	unsigned long rdi;
+	unsigned long orig_rax;
+/* end of arguments */
+/* cpu exception frame or undefined */
+	unsigned long rip;
+	unsigned long cs;
+	unsigned long eflags;
+	unsigned long rsp;
+	unsigned long ss;
+/* top of stack page */
+};
+
+#endif /* !__i386__ */
+
+
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* _ASM_X86_PTRACE_H */
diff -uNr linux-2.6.32/usr/include/asm/resource.h clean_modified/linux-2.6.32/usr/include/asm/resource.h
--- linux-2.6.32/usr/include/asm/resource.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/resource.h	2019-04-14 13:24:02.863139910 -0500
@@ -0,0 +1 @@
+#include <asm-generic/resource.h>
diff -uNr linux-2.6.32/usr/include/asm/sembuf.h clean_modified/linux-2.6.32/usr/include/asm/sembuf.h
--- linux-2.6.32/usr/include/asm/sembuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/sembuf.h	2019-04-14 13:24:02.863139910 -0500
@@ -0,0 +1,24 @@
+#ifndef _ASM_X86_SEMBUF_H
+#define _ASM_X86_SEMBUF_H
+
+/*
+ * The semid64_ds structure for x86 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+struct semid64_ds {
+	struct ipc64_perm sem_perm;	/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;	/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;	/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;	/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_X86_SEMBUF_H */
diff -uNr linux-2.6.32/usr/include/asm/setup.h clean_modified/linux-2.6.32/usr/include/asm/setup.h
--- linux-2.6.32/usr/include/asm/setup.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/setup.h	2019-04-14 13:24:02.863807591 -0500
@@ -0,0 +1,5 @@
+#ifndef _ASM_X86_SETUP_H
+#define _ASM_X86_SETUP_H
+
+
+#endif /* _ASM_X86_SETUP_H */
diff -uNr linux-2.6.32/usr/include/asm/shmbuf.h clean_modified/linux-2.6.32/usr/include/asm/shmbuf.h
--- linux-2.6.32/usr/include/asm/shmbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/shmbuf.h	2019-04-14 13:24:02.863807591 -0500
@@ -0,0 +1 @@
+#include <asm-generic/shmbuf.h>
diff -uNr linux-2.6.32/usr/include/asm/sigcontext32.h clean_modified/linux-2.6.32/usr/include/asm/sigcontext32.h
--- linux-2.6.32/usr/include/asm/sigcontext32.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/sigcontext32.h	2019-04-14 13:24:02.863807591 -0500
@@ -0,0 +1,77 @@
+#ifndef _ASM_X86_SIGCONTEXT32_H
+#define _ASM_X86_SIGCONTEXT32_H
+
+#include <linux/types.h>
+
+/* signal context for 32bit programs. */
+
+#define X86_FXSR_MAGIC		0x0000
+
+struct _fpreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+};
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	__u32	element[4];
+};
+
+/* FSAVE frame with extensions */
+struct _fpstate_ia32 {
+	/* Regular FPU environment */
+	__u32 	cw;
+	__u32	sw;
+	__u32	tag;	/* not compatible to 64bit twd */
+	__u32	ipoff;
+	__u32	cssel;
+	__u32	dataoff;
+	__u32	datasel;
+	struct _fpreg	_st[8];
+	unsigned short	status;
+	unsigned short	magic;		/* 0xffff = regular FPU data only */
+
+	/* FXSR FPU environment */
+	__u32	_fxsr_env[6];
+	__u32	mxcsr;
+	__u32	reserved;
+	struct _fpxreg	_fxsr_st[8];
+	struct _xmmreg	_xmm[8];	/* It's actually 16 */
+	__u32	padding[44];
+	union {
+		__u32 padding2[12];
+		struct _fpx_sw_bytes sw_reserved;
+	};
+};
+
+struct sigcontext_ia32 {
+       unsigned short gs, __gsh;
+       unsigned short fs, __fsh;
+       unsigned short es, __esh;
+       unsigned short ds, __dsh;
+       unsigned int di;
+       unsigned int si;
+       unsigned int bp;
+       unsigned int sp;
+       unsigned int bx;
+       unsigned int dx;
+       unsigned int cx;
+       unsigned int ax;
+       unsigned int trapno;
+       unsigned int err;
+       unsigned int ip;
+       unsigned short cs, __csh;
+       unsigned int flags;
+       unsigned int sp_at_signal;
+       unsigned short ss, __ssh;
+       unsigned int fpstate;		/* really (struct _fpstate_ia32 *) */
+       unsigned int oldmask;
+       unsigned int cr2;
+};
+
+#endif /* _ASM_X86_SIGCONTEXT32_H */
diff -uNr linux-2.6.32/usr/include/asm/sigcontext.h clean_modified/linux-2.6.32/usr/include/asm/sigcontext.h
--- linux-2.6.32/usr/include/asm/sigcontext.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/sigcontext.h	2019-04-14 13:24:02.865122224 -0500
@@ -0,0 +1,214 @@
+#ifndef _ASM_X86_SIGCONTEXT_H
+#define _ASM_X86_SIGCONTEXT_H
+
+
+#include <linux/types.h>
+
+#define FP_XSTATE_MAGIC1	0x46505853U
+#define FP_XSTATE_MAGIC2	0x46505845U
+#define FP_XSTATE_MAGIC2_SIZE	sizeof(FP_XSTATE_MAGIC2)
+
+/*
+ * bytes 464..511 in the current 512byte layout of fxsave/fxrstor frame
+ * are reserved for SW usage. On cpu's supporting xsave/xrstor, these bytes
+ * are used to extended the fpstate pointer in the sigcontext, which now
+ * includes the extended state information along with fpstate information.
+ *
+ * Presence of FP_XSTATE_MAGIC1 at the beginning of this SW reserved
+ * area and FP_XSTATE_MAGIC2 at the end of memory layout
+ * (extended_size - FP_XSTATE_MAGIC2_SIZE) indicates the presence of the
+ * extended state information in the memory layout pointed by the fpstate
+ * pointer in sigcontext.
+ */
+struct _fpx_sw_bytes {
+	__u32 magic1;		/* FP_XSTATE_MAGIC1 */
+	__u32 extended_size;	/* total size of the layout referred by
+				 * fpstate pointer in the sigcontext.
+				 */
+	__u64 xstate_bv;
+				/* feature bit mask (including fp/sse/extended
+				 * state) that is present in the memory
+				 * layout.
+				 */
+	__u32 xstate_size;	/* actual xsave state size, based on the
+				 * features saved in the layout.
+				 * 'extended_size' will be greater than
+				 * 'xstate_size'.
+				 */
+	__u32 padding[7];	/*  for future use. */
+};
+
+#ifdef __i386__
+/*
+ * As documented in the iBCS2 standard..
+ *
+ * The first part of "struct _fpstate" is just the normal i387
+ * hardware setup, the extra "status" word is used to save the
+ * coprocessor status word before entering the handler.
+ *
+ * Pentium III FXSR, SSE support
+ *	Gareth Hughes <gareth@valinux.com>, May 2000
+ *
+ * The FPU state data structure has had to grow to accommodate the
+ * extended FPU state required by the Streaming SIMD Extensions.
+ * There is no documented standard to accomplish this at the moment.
+ */
+struct _fpreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+};
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	unsigned long element[4];
+};
+
+struct _fpstate {
+	/* Regular FPU environment */
+	unsigned long	cw;
+	unsigned long	sw;
+	unsigned long	tag;
+	unsigned long	ipoff;
+	unsigned long	cssel;
+	unsigned long	dataoff;
+	unsigned long	datasel;
+	struct _fpreg	_st[8];
+	unsigned short	status;
+	unsigned short	magic;		/* 0xffff = regular FPU data only */
+
+	/* FXSR FPU environment */
+	unsigned long	_fxsr_env[6];	/* FXSR FPU env is ignored */
+	unsigned long	mxcsr;
+	unsigned long	reserved;
+	struct _fpxreg	_fxsr_st[8];	/* FXSR FPU reg data is ignored */
+	struct _xmmreg	_xmm[8];
+	unsigned long	padding1[44];
+
+	union {
+		unsigned long	padding2[12];
+		struct _fpx_sw_bytes sw_reserved; /* represents the extended
+						   * state info */
+	};
+};
+
+#define X86_FXSR_MAGIC		0x0000
+
+/*
+ * User-space might still rely on the old definition:
+ */
+struct sigcontext {
+	unsigned short gs, __gsh;
+	unsigned short fs, __fsh;
+	unsigned short es, __esh;
+	unsigned short ds, __dsh;
+	unsigned long edi;
+	unsigned long esi;
+	unsigned long ebp;
+	unsigned long esp;
+	unsigned long ebx;
+	unsigned long edx;
+	unsigned long ecx;
+	unsigned long eax;
+	unsigned long trapno;
+	unsigned long err;
+	unsigned long eip;
+	unsigned short cs, __csh;
+	unsigned long eflags;
+	unsigned long esp_at_signal;
+	unsigned short ss, __ssh;
+	struct _fpstate *fpstate;
+	unsigned long oldmask;
+	unsigned long cr2;
+};
+
+#else /* __i386__ */
+
+/* FXSAVE frame */
+/* Note: reserved1/2 may someday contain valuable data. Always save/restore
+   them when you change signal frames. */
+struct _fpstate {
+	__u16	cwd;
+	__u16	swd;
+	__u16	twd;		/* Note this is not the same as the
+				   32bit/x87/FSAVE twd */
+	__u16	fop;
+	__u64	rip;
+	__u64	rdp;
+	__u32	mxcsr;
+	__u32	mxcsr_mask;
+	__u32	st_space[32];	/* 8*16 bytes for each FP-reg */
+	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg  */
+	__u32	reserved2[12];
+	union {
+		__u32	reserved3[12];
+		struct _fpx_sw_bytes sw_reserved; /* represents the extended
+						   * state information */
+	};
+};
+
+/*
+ * User-space might still rely on the old definition:
+ */
+struct sigcontext {
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long r10;
+	unsigned long r11;
+	unsigned long r12;
+	unsigned long r13;
+	unsigned long r14;
+	unsigned long r15;
+	unsigned long rdi;
+	unsigned long rsi;
+	unsigned long rbp;
+	unsigned long rbx;
+	unsigned long rdx;
+	unsigned long rax;
+	unsigned long rcx;
+	unsigned long rsp;
+	unsigned long rip;
+	unsigned long eflags;		/* RFLAGS */
+	unsigned short cs;
+	unsigned short gs;
+	unsigned short fs;
+	unsigned short __pad0;
+	unsigned long err;
+	unsigned long trapno;
+	unsigned long oldmask;
+	unsigned long cr2;
+	struct _fpstate *fpstate;	/* zero when no FPU context */
+	unsigned long reserved1[8];
+};
+
+#endif /* !__i386__ */
+
+struct _xsave_hdr {
+	__u64 xstate_bv;
+	__u64 reserved1[2];
+	__u64 reserved2[5];
+};
+
+struct _ymmh_state {
+	/* 16 * 16 bytes for each YMMH-reg */
+	__u32 ymmh_space[64];
+};
+
+/*
+ * Extended state pointed by the fpstate pointer in the sigcontext.
+ * In addition to the fpstate, information encoded in the xstate_hdr
+ * indicates the presence of other extended state information
+ * supported by the processor and OS.
+ */
+struct _xstate {
+	struct _fpstate fpstate;
+	struct _xsave_hdr xstate_hdr;
+	struct _ymmh_state ymmh;
+	/* new processor state extensions go here */
+};
+
+#endif /* _ASM_X86_SIGCONTEXT_H */
diff -uNr linux-2.6.32/usr/include/asm/siginfo.h clean_modified/linux-2.6.32/usr/include/asm/siginfo.h
--- linux-2.6.32/usr/include/asm/siginfo.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/siginfo.h	2019-04-14 13:24:02.865788481 -0500
@@ -0,0 +1,10 @@
+#ifndef _ASM_X86_SIGINFO_H
+#define _ASM_X86_SIGINFO_H
+
+#ifdef __x86_64__
+# define __ARCH_SI_PREAMBLE_SIZE	(4 * sizeof(int))
+#endif
+
+#include <asm-generic/siginfo.h>
+
+#endif /* _ASM_X86_SIGINFO_H */
diff -uNr linux-2.6.32/usr/include/asm/signal.h clean_modified/linux-2.6.32/usr/include/asm/signal.h
--- linux-2.6.32/usr/include/asm/signal.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/signal.h	2019-04-14 13:24:02.865788481 -0500
@@ -0,0 +1,140 @@
+#ifndef _ASM_X86_SIGNAL_H
+#define _ASM_X86_SIGNAL_H
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#include <linux/time.h>
+
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __ASSEMBLY__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001u
+#define SA_NOCLDWAIT	0x00000002u
+#define SA_SIGINFO	0x00000004u
+#define SA_ONSTACK	0x08000000u
+#define SA_RESTART	0x10000000u
+#define SA_NODEFER	0x40000000u
+#define SA_RESETHAND	0x80000000u
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+#define SA_RESTORER	0x04000000
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal-defs.h>
+
+#ifndef __ASSEMBLY__
+
+
+#ifdef __i386__
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+	  __sighandler_t _sa_handler;
+	  void (*_sa_sigaction)(int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#else /* __i386__ */
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+
+#endif /* !__i386__ */
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_X86_SIGNAL_H */
diff -uNr linux-2.6.32/usr/include/asm/socket.h clean_modified/linux-2.6.32/usr/include/asm/socket.h
--- linux-2.6.32/usr/include/asm/socket.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/socket.h	2019-04-14 13:24:02.865788481 -0500
@@ -0,0 +1 @@
+#include <asm-generic/socket.h>
diff -uNr linux-2.6.32/usr/include/asm/sockios.h clean_modified/linux-2.6.32/usr/include/asm/sockios.h
--- linux-2.6.32/usr/include/asm/sockios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/sockios.h	2019-04-14 13:24:02.865788481 -0500
@@ -0,0 +1 @@
+#include <asm-generic/sockios.h>
diff -uNr linux-2.6.32/usr/include/asm/statfs.h clean_modified/linux-2.6.32/usr/include/asm/statfs.h
--- linux-2.6.32/usr/include/asm/statfs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/statfs.h	2019-04-14 13:24:02.867042617 -0500
@@ -0,0 +1,12 @@
+#ifndef _ASM_X86_STATFS_H
+#define _ASM_X86_STATFS_H
+
+/*
+ * We need compat_statfs64 to be packed, because the i386 ABI won't
+ * add padding at the end to bring it to a multiple of 8 bytes, but
+ * the x86_64 ABI will.
+ */
+#define ARCH_PACK_COMPAT_STATFS64 __attribute__((packed,aligned(4)))
+
+#include <asm-generic/statfs.h>
+#endif /* _ASM_X86_STATFS_H */
diff -uNr linux-2.6.32/usr/include/asm/stat.h clean_modified/linux-2.6.32/usr/include/asm/stat.h
--- linux-2.6.32/usr/include/asm/stat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/stat.h	2019-04-14 13:24:02.867042617 -0500
@@ -0,0 +1,114 @@
+#ifndef _ASM_X86_STAT_H
+#define _ASM_X86_STAT_H
+
+#define STAT_HAVE_NSEC 1
+
+#ifdef __i386__
+struct stat {
+	unsigned long  st_dev;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned long  st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  st_atime_nsec;
+	unsigned long  st_mtime;
+	unsigned long  st_mtime_nsec;
+	unsigned long  st_ctime;
+	unsigned long  st_ctime_nsec;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char	__pad0[4];
+
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char	__pad3[4];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+	/* Number 512-byte blocks allocated. */
+	unsigned long long	st_blocks;
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned int	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#else /* __i386__ */
+
+struct stat {
+	unsigned long	st_dev;
+	unsigned long	st_ino;
+	unsigned long	st_nlink;
+
+	unsigned int	st_mode;
+	unsigned int	st_uid;
+	unsigned int	st_gid;
+	unsigned int	__pad0;
+	unsigned long	st_rdev;
+	long		st_size;
+	long		st_blksize;
+	long		st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+	unsigned long	st_ctime;
+	unsigned long   st_ctime_nsec;
+	long		__unused[3];
+};
+#endif
+
+/* for 32bit emulation and 32 bit kernels */
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+#ifdef __i386__
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+#else
+	unsigned int  st_size;
+	unsigned int  st_atime;
+	unsigned int  st_mtime;
+	unsigned int  st_ctime;
+#endif
+};
+
+#endif /* _ASM_X86_STAT_H */
diff -uNr linux-2.6.32/usr/include/asm/swab.h clean_modified/linux-2.6.32/usr/include/asm/swab.h
--- linux-2.6.32/usr/include/asm/swab.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/swab.h	2019-04-14 13:24:02.867042617 -0500
@@ -0,0 +1,61 @@
+#ifndef _ASM_X86_SWAB_H
+#define _ASM_X86_SWAB_H
+
+#include <linux/types.h>
+
+
+static __inline__ __u32 __arch_swab32(__u32 val)
+{
+#ifdef __i386__
+# ifdef CONFIG_X86_BSWAP
+	__asm__("bswap %0" : "=r" (val) : "0" (val));
+# else
+	__asm__("xchgb %b0,%h0\n\t"	/* swap lower bytes	*/
+	    "rorl $16,%0\n\t"	/* swap words		*/
+	    "xchgb %b0,%h0"	/* swap higher bytes	*/
+	    : "=q" (val)
+	    : "0" (val));
+# endif
+
+#else /* __i386__ */
+	__asm__("bswapl %0"
+	    : "=r" (val)
+	    : "0" (val));
+#endif
+	return val;
+}
+#define __arch_swab32 __arch_swab32
+
+static __inline__ __u64 __arch_swab64(__u64 val)
+{
+#ifdef __i386__
+	union {
+		struct {
+			__u32 a;
+			__u32 b;
+		} s;
+		__u64 u;
+	} v;
+	v.u = val;
+# ifdef CONFIG_X86_BSWAP
+	__asm__("bswapl %0 ; bswapl %1 ; xchgl %0,%1"
+	    : "=r" (v.s.a), "=r" (v.s.b)
+	    : "0" (v.s.a), "1" (v.s.b));
+# else
+	v.s.a = __arch_swab32(v.s.a);
+	v.s.b = __arch_swab32(v.s.b);
+	__asm__("xchgl %0,%1"
+	    : "=r" (v.s.a), "=r" (v.s.b)
+	    : "0" (v.s.a), "1" (v.s.b));
+# endif
+	return v.u;
+#else /* __i386__ */
+	__asm__("bswapq %0"
+	    : "=r" (val)
+	    : "0" (val));
+	return val;
+#endif
+}
+#define __arch_swab64 __arch_swab64
+
+#endif /* _ASM_X86_SWAB_H */
diff -uNr linux-2.6.32/usr/include/asm/termbits.h clean_modified/linux-2.6.32/usr/include/asm/termbits.h
--- linux-2.6.32/usr/include/asm/termbits.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/termbits.h	2019-04-14 13:24:02.867042617 -0500
@@ -0,0 +1 @@
+#include <asm-generic/termbits.h>
diff -uNr linux-2.6.32/usr/include/asm/termios.h clean_modified/linux-2.6.32/usr/include/asm/termios.h
--- linux-2.6.32/usr/include/asm/termios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/termios.h	2019-04-14 13:24:02.868016253 -0500
@@ -0,0 +1 @@
+#include <asm-generic/termios.h>
diff -uNr linux-2.6.32/usr/include/asm/types.h clean_modified/linux-2.6.32/usr/include/asm/types.h
--- linux-2.6.32/usr/include/asm/types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/types.h	2019-04-14 13:24:02.868016253 -0500
@@ -0,0 +1,9 @@
+#ifndef _ASM_X86_TYPES_H
+#define _ASM_X86_TYPES_H
+
+#define dma_addr_t	dma_addr_t
+
+#include <asm-generic/types.h>
+
+
+#endif /* _ASM_X86_TYPES_H */
diff -uNr linux-2.6.32/usr/include/asm/ucontext.h clean_modified/linux-2.6.32/usr/include/asm/ucontext.h
--- linux-2.6.32/usr/include/asm/ucontext.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/ucontext.h	2019-04-14 13:24:02.868016253 -0500
@@ -0,0 +1,12 @@
+#ifndef _ASM_X86_UCONTEXT_H
+#define _ASM_X86_UCONTEXT_H
+
+#define UC_FP_XSTATE	0x1	/* indicates the presence of extended state
+				 * information in the memory layout pointed
+				 * by the fpstate pointer in the ucontext's
+				 * sigcontext struct (uc_mcontext).
+				 */
+
+#include <asm-generic/ucontext.h>
+
+#endif /* _ASM_X86_UCONTEXT_H */
diff -uNr linux-2.6.32/usr/include/asm/unistd_32.h clean_modified/linux-2.6.32/usr/include/asm/unistd_32.h
--- linux-2.6.32/usr/include/asm/unistd_32.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/unistd_32.h	2019-04-14 13:24:02.869849953 -0500
@@ -0,0 +1,351 @@
+#ifndef _ASM_X86_UNISTD_32_H
+#define _ASM_X86_UNISTD_32_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall      0
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+#define __NR_waitpid		  7
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+#define __NR_lchown		 16
+#define __NR_break		 17
+#define __NR_oldstat		 18
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+#define __NR_umount		 22
+#define __NR_setuid		 23
+#define __NR_getuid		 24
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+#define __NR_oldfstat		 28
+#define __NR_pause		 29
+#define __NR_utime		 30
+#define __NR_stty		 31
+#define __NR_gtty		 32
+#define __NR_access		 33
+#define __NR_nice		 34
+#define __NR_ftime		 35
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+#define __NR_prof		 44
+#define __NR_brk		 45
+#define __NR_setgid		 46
+#define __NR_getgid		 47
+#define __NR_signal		 48
+#define __NR_geteuid		 49
+#define __NR_getegid		 50
+#define __NR_acct		 51
+#define __NR_umount2		 52
+#define __NR_lock		 53
+#define __NR_ioctl		 54
+#define __NR_fcntl		 55
+#define __NR_mpx		 56
+#define __NR_setpgid		 57
+#define __NR_ulimit		 58
+#define __NR_oldolduname	 59
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+#define __NR_sigaction		 67
+#define __NR_sgetmask		 68
+#define __NR_ssetmask		 69
+#define __NR_setreuid		 70
+#define __NR_setregid		 71
+#define __NR_sigsuspend		 72
+#define __NR_sigpending		 73
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+#define __NR_getrlimit		 76   /* Back compatible 2Gig limited rlimit */
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+#define __NR_getgroups		 80
+#define __NR_setgroups		 81
+#define __NR_select		 82
+#define __NR_symlink		 83
+#define __NR_oldlstat		 84
+#define __NR_readlink		 85
+#define __NR_uselib		 86
+#define __NR_swapon		 87
+#define __NR_reboot		 88
+#define __NR_readdir		 89
+#define __NR_mmap		 90
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+#define __NR_fchown		 95
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+#define __NR_profil		 98
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+#define __NR_ioperm		101
+#define __NR_socketcall		102
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+#define __NR_olduname		109
+#define __NR_iopl		110
+#define __NR_vhangup		111
+#define __NR_idle		112
+#define __NR_vm86old		113
+#define __NR_wait4		114
+#define __NR_swapoff		115
+#define __NR_sysinfo		116
+#define __NR_ipc		117
+#define __NR_fsync		118
+#define __NR_sigreturn		119
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+#define __NR_modify_ldt		123
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+#define __NR_sysfs		135
+#define __NR_personality	136
+#define __NR_afs_syscall	137 /* Syscall for Andrew File System */
+#define __NR_setfsuid		138
+#define __NR_setfsgid		139
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect		142
+#define __NR_flock		143
+#define __NR_msync		144
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+#define __NR_mlock		150
+#define __NR_munlock		151
+#define __NR_mlockall		152
+#define __NR_munlockall		153
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+#define __NR_mremap		163
+#define __NR_setresuid		164
+#define __NR_getresuid		165
+#define __NR_vm86		166
+#define __NR_query_module	167
+#define __NR_poll		168
+#define __NR_nfsservctl		169
+#define __NR_setresgid		170
+#define __NR_getresgid		171
+#define __NR_prctl              172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64		180
+#define __NR_pwrite64		181
+#define __NR_chown		182
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+#define __NR_getpmsg		188	/* some people actually want streams */
+#define __NR_putpmsg		189	/* some people actually want streams */
+#define __NR_vfork		190
+#define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_lchown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_chown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+#define __NR_mincore		218
+#define __NR_madvise		219
+#define __NR_madvise1		219	/* delete when C lib stub is removed */
+#define __NR_getdents64		220
+#define __NR_fcntl64		221
+/* 223 is unused */
+#define __NR_gettid		224
+#define __NR_readahead		225
+#define __NR_setxattr		226
+#define __NR_lsetxattr		227
+#define __NR_fsetxattr		228
+#define __NR_getxattr		229
+#define __NR_lgetxattr		230
+#define __NR_fgetxattr		231
+#define __NR_listxattr		232
+#define __NR_llistxattr		233
+#define __NR_flistxattr		234
+#define __NR_removexattr	235
+#define __NR_lremovexattr	236
+#define __NR_fremovexattr	237
+#define __NR_tkill		238
+#define __NR_sendfile64		239
+#define __NR_futex		240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_set_thread_area	243
+#define __NR_get_thread_area	244
+#define __NR_io_setup		245
+#define __NR_io_destroy		246
+#define __NR_io_getevents	247
+#define __NR_io_submit		248
+#define __NR_io_cancel		249
+#define __NR_fadvise64		250
+/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
+#define __NR_exit_group		252
+#define __NR_lookup_dcookie	253
+#define __NR_epoll_create	254
+#define __NR_epoll_ctl		255
+#define __NR_epoll_wait		256
+#define __NR_remap_file_pages	257
+#define __NR_set_tid_address	258
+#define __NR_timer_create	259
+#define __NR_timer_settime	(__NR_timer_create+1)
+#define __NR_timer_gettime	(__NR_timer_create+2)
+#define __NR_timer_getoverrun	(__NR_timer_create+3)
+#define __NR_timer_delete	(__NR_timer_create+4)
+#define __NR_clock_settime	(__NR_timer_create+5)
+#define __NR_clock_gettime	(__NR_timer_create+6)
+#define __NR_clock_getres	(__NR_timer_create+7)
+#define __NR_clock_nanosleep	(__NR_timer_create+8)
+#define __NR_statfs64		268
+#define __NR_fstatfs64		269
+#define __NR_tgkill		270
+#define __NR_utimes		271
+#define __NR_fadvise64_64	272
+#define __NR_vserver		273
+#define __NR_mbind		274
+#define __NR_get_mempolicy	275
+#define __NR_set_mempolicy	276
+#define __NR_mq_open 		277
+#define __NR_mq_unlink		(__NR_mq_open+1)
+#define __NR_mq_timedsend	(__NR_mq_open+2)
+#define __NR_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_mq_notify		(__NR_mq_open+4)
+#define __NR_mq_getsetattr	(__NR_mq_open+5)
+#define __NR_kexec_load		283
+#define __NR_waitid		284
+/* #define __NR_sys_setaltroot	285 */
+#define __NR_add_key		286
+#define __NR_request_key	287
+#define __NR_keyctl		288
+#define __NR_ioprio_set		289
+#define __NR_ioprio_get		290
+#define __NR_inotify_init	291
+#define __NR_inotify_add_watch	292
+#define __NR_inotify_rm_watch	293
+#define __NR_migrate_pages	294
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+#define __NR_set_robust_list	311
+#define __NR_get_robust_list	312
+#define __NR_splice		313
+#define __NR_sync_file_range	314
+#define __NR_tee		315
+#define __NR_vmsplice		316
+#define __NR_move_pages		317
+#define __NR_getcpu		318
+#define __NR_epoll_pwait	319
+#define __NR_utimensat		320
+#define __NR_signalfd		321
+#define __NR_timerfd_create	322
+#define __NR_eventfd		323
+#define __NR_fallocate		324
+#define __NR_timerfd_settime	325
+#define __NR_timerfd_gettime	326
+#define __NR_signalfd4		327
+#define __NR_eventfd2		328
+#define __NR_epoll_create1	329
+#define __NR_dup3		330
+#define __NR_pipe2		331
+#define __NR_inotify_init1	332
+#define __NR_preadv		333
+#define __NR_pwritev		334
+#define __NR_rt_tgsigqueueinfo	335
+#define __NR_perf_event_open	336
+#define __NR_helloworld		337
+#define __NR_printself		338
+#define __NR_printother		339
+#define __NR_virtualmem		340
+#define __NR_virtualmemstatus	341
+
+#endif /* _ASM_X86_UNISTD_32_H */
diff -uNr linux-2.6.32/usr/include/asm/unistd_64.h clean_modified/linux-2.6.32/usr/include/asm/unistd_64.h
--- linux-2.6.32/usr/include/asm/unistd_64.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/unistd_64.h	2019-04-14 13:24:02.871001603 -0500
@@ -0,0 +1,691 @@
+#ifndef _ASM_X86_UNISTD_64_H
+#define _ASM_X86_UNISTD_64_H
+
+#ifndef __SYSCALL
+#define __SYSCALL(a, b)
+#endif
+
+/*
+ * This file contains the system call numbers.
+ *
+ * Note: holes are not allowed.
+ */
+
+/* at least 8 syscall per cacheline */
+#define __NR_read				0
+__SYSCALL(__NR_read, sys_read)
+#define __NR_write				1
+__SYSCALL(__NR_write, sys_write)
+#define __NR_open				2
+__SYSCALL(__NR_open, sys_open)
+#define __NR_close				3
+__SYSCALL(__NR_close, sys_close)
+#define __NR_stat				4
+__SYSCALL(__NR_stat, sys_newstat)
+#define __NR_fstat				5
+__SYSCALL(__NR_fstat, sys_newfstat)
+#define __NR_lstat				6
+__SYSCALL(__NR_lstat, sys_newlstat)
+#define __NR_poll				7
+__SYSCALL(__NR_poll, sys_poll)
+
+#define __NR_lseek				8
+__SYSCALL(__NR_lseek, sys_lseek)
+#define __NR_mmap				9
+__SYSCALL(__NR_mmap, sys_mmap)
+#define __NR_mprotect				10
+__SYSCALL(__NR_mprotect, sys_mprotect)
+#define __NR_munmap				11
+__SYSCALL(__NR_munmap, sys_munmap)
+#define __NR_brk				12
+__SYSCALL(__NR_brk, sys_brk)
+#define __NR_rt_sigaction			13
+__SYSCALL(__NR_rt_sigaction, sys_rt_sigaction)
+#define __NR_rt_sigprocmask			14
+__SYSCALL(__NR_rt_sigprocmask, sys_rt_sigprocmask)
+#define __NR_rt_sigreturn			15
+__SYSCALL(__NR_rt_sigreturn, stub_rt_sigreturn)
+
+#define __NR_ioctl				16
+__SYSCALL(__NR_ioctl, sys_ioctl)
+#define __NR_pread64				17
+__SYSCALL(__NR_pread64, sys_pread64)
+#define __NR_pwrite64				18
+__SYSCALL(__NR_pwrite64, sys_pwrite64)
+#define __NR_readv				19
+__SYSCALL(__NR_readv, sys_readv)
+#define __NR_writev				20
+__SYSCALL(__NR_writev, sys_writev)
+#define __NR_access				21
+__SYSCALL(__NR_access, sys_access)
+#define __NR_pipe				22
+__SYSCALL(__NR_pipe, sys_pipe)
+#define __NR_select				23
+__SYSCALL(__NR_select, sys_select)
+
+#define __NR_sched_yield			24
+__SYSCALL(__NR_sched_yield, sys_sched_yield)
+#define __NR_mremap				25
+__SYSCALL(__NR_mremap, sys_mremap)
+#define __NR_msync				26
+__SYSCALL(__NR_msync, sys_msync)
+#define __NR_mincore				27
+__SYSCALL(__NR_mincore, sys_mincore)
+#define __NR_madvise				28
+__SYSCALL(__NR_madvise, sys_madvise)
+#define __NR_shmget				29
+__SYSCALL(__NR_shmget, sys_shmget)
+#define __NR_shmat				30
+__SYSCALL(__NR_shmat, sys_shmat)
+#define __NR_shmctl				31
+__SYSCALL(__NR_shmctl, sys_shmctl)
+
+#define __NR_dup				32
+__SYSCALL(__NR_dup, sys_dup)
+#define __NR_dup2				33
+__SYSCALL(__NR_dup2, sys_dup2)
+#define __NR_pause				34
+__SYSCALL(__NR_pause, sys_pause)
+#define __NR_nanosleep				35
+__SYSCALL(__NR_nanosleep, sys_nanosleep)
+#define __NR_getitimer				36
+__SYSCALL(__NR_getitimer, sys_getitimer)
+#define __NR_alarm				37
+__SYSCALL(__NR_alarm, sys_alarm)
+#define __NR_setitimer				38
+__SYSCALL(__NR_setitimer, sys_setitimer)
+#define __NR_getpid				39
+__SYSCALL(__NR_getpid, sys_getpid)
+
+#define __NR_sendfile				40
+__SYSCALL(__NR_sendfile, sys_sendfile64)
+#define __NR_socket				41
+__SYSCALL(__NR_socket, sys_socket)
+#define __NR_connect				42
+__SYSCALL(__NR_connect, sys_connect)
+#define __NR_accept				43
+__SYSCALL(__NR_accept, sys_accept)
+#define __NR_sendto				44
+__SYSCALL(__NR_sendto, sys_sendto)
+#define __NR_recvfrom				45
+__SYSCALL(__NR_recvfrom, sys_recvfrom)
+#define __NR_sendmsg				46
+__SYSCALL(__NR_sendmsg, sys_sendmsg)
+#define __NR_recvmsg				47
+__SYSCALL(__NR_recvmsg, sys_recvmsg)
+
+#define __NR_shutdown				48
+__SYSCALL(__NR_shutdown, sys_shutdown)
+#define __NR_bind				49
+__SYSCALL(__NR_bind, sys_bind)
+#define __NR_listen				50
+__SYSCALL(__NR_listen, sys_listen)
+#define __NR_getsockname			51
+__SYSCALL(__NR_getsockname, sys_getsockname)
+#define __NR_getpeername			52
+__SYSCALL(__NR_getpeername, sys_getpeername)
+#define __NR_socketpair				53
+__SYSCALL(__NR_socketpair, sys_socketpair)
+#define __NR_setsockopt				54
+__SYSCALL(__NR_setsockopt, sys_setsockopt)
+#define __NR_getsockopt				55
+__SYSCALL(__NR_getsockopt, sys_getsockopt)
+
+#define __NR_clone				56
+__SYSCALL(__NR_clone, stub_clone)
+#define __NR_fork				57
+__SYSCALL(__NR_fork, stub_fork)
+#define __NR_vfork				58
+__SYSCALL(__NR_vfork, stub_vfork)
+#define __NR_execve				59
+__SYSCALL(__NR_execve, stub_execve)
+#define __NR_exit				60
+__SYSCALL(__NR_exit, sys_exit)
+#define __NR_wait4				61
+__SYSCALL(__NR_wait4, sys_wait4)
+#define __NR_kill				62
+__SYSCALL(__NR_kill, sys_kill)
+#define __NR_uname				63
+__SYSCALL(__NR_uname, sys_uname)
+
+#define __NR_semget				64
+__SYSCALL(__NR_semget, sys_semget)
+#define __NR_semop				65
+__SYSCALL(__NR_semop, sys_semop)
+#define __NR_semctl				66
+__SYSCALL(__NR_semctl, sys_semctl)
+#define __NR_shmdt				67
+__SYSCALL(__NR_shmdt, sys_shmdt)
+#define __NR_msgget				68
+__SYSCALL(__NR_msgget, sys_msgget)
+#define __NR_msgsnd				69
+__SYSCALL(__NR_msgsnd, sys_msgsnd)
+#define __NR_msgrcv				70
+__SYSCALL(__NR_msgrcv, sys_msgrcv)
+#define __NR_msgctl				71
+__SYSCALL(__NR_msgctl, sys_msgctl)
+
+#define __NR_fcntl				72
+__SYSCALL(__NR_fcntl, sys_fcntl)
+#define __NR_flock				73
+__SYSCALL(__NR_flock, sys_flock)
+#define __NR_fsync				74
+__SYSCALL(__NR_fsync, sys_fsync)
+#define __NR_fdatasync				75
+__SYSCALL(__NR_fdatasync, sys_fdatasync)
+#define __NR_truncate				76
+__SYSCALL(__NR_truncate, sys_truncate)
+#define __NR_ftruncate				77
+__SYSCALL(__NR_ftruncate, sys_ftruncate)
+#define __NR_getdents				78
+__SYSCALL(__NR_getdents, sys_getdents)
+#define __NR_getcwd				79
+__SYSCALL(__NR_getcwd, sys_getcwd)
+
+#define __NR_chdir				80
+__SYSCALL(__NR_chdir, sys_chdir)
+#define __NR_fchdir				81
+__SYSCALL(__NR_fchdir, sys_fchdir)
+#define __NR_rename				82
+__SYSCALL(__NR_rename, sys_rename)
+#define __NR_mkdir				83
+__SYSCALL(__NR_mkdir, sys_mkdir)
+#define __NR_rmdir				84
+__SYSCALL(__NR_rmdir, sys_rmdir)
+#define __NR_creat				85
+__SYSCALL(__NR_creat, sys_creat)
+#define __NR_link				86
+__SYSCALL(__NR_link, sys_link)
+#define __NR_unlink				87
+__SYSCALL(__NR_unlink, sys_unlink)
+
+#define __NR_symlink				88
+__SYSCALL(__NR_symlink, sys_symlink)
+#define __NR_readlink				89
+__SYSCALL(__NR_readlink, sys_readlink)
+#define __NR_chmod				90
+__SYSCALL(__NR_chmod, sys_chmod)
+#define __NR_fchmod				91
+__SYSCALL(__NR_fchmod, sys_fchmod)
+#define __NR_chown				92
+__SYSCALL(__NR_chown, sys_chown)
+#define __NR_fchown				93
+__SYSCALL(__NR_fchown, sys_fchown)
+#define __NR_lchown				94
+__SYSCALL(__NR_lchown, sys_lchown)
+#define __NR_umask				95
+__SYSCALL(__NR_umask, sys_umask)
+
+#define __NR_gettimeofday			96
+__SYSCALL(__NR_gettimeofday, sys_gettimeofday)
+#define __NR_getrlimit				97
+__SYSCALL(__NR_getrlimit, sys_getrlimit)
+#define __NR_getrusage				98
+__SYSCALL(__NR_getrusage, sys_getrusage)
+#define __NR_sysinfo				99
+__SYSCALL(__NR_sysinfo, sys_sysinfo)
+#define __NR_times				100
+__SYSCALL(__NR_times, sys_times)
+#define __NR_ptrace				101
+__SYSCALL(__NR_ptrace, sys_ptrace)
+#define __NR_getuid				102
+__SYSCALL(__NR_getuid, sys_getuid)
+#define __NR_syslog				103
+__SYSCALL(__NR_syslog, sys_syslog)
+
+/* at the very end the stuff that never runs during the benchmarks */
+#define __NR_getgid				104
+__SYSCALL(__NR_getgid, sys_getgid)
+#define __NR_setuid				105
+__SYSCALL(__NR_setuid, sys_setuid)
+#define __NR_setgid				106
+__SYSCALL(__NR_setgid, sys_setgid)
+#define __NR_geteuid				107
+__SYSCALL(__NR_geteuid, sys_geteuid)
+#define __NR_getegid				108
+__SYSCALL(__NR_getegid, sys_getegid)
+#define __NR_setpgid				109
+__SYSCALL(__NR_setpgid, sys_setpgid)
+#define __NR_getppid				110
+__SYSCALL(__NR_getppid, sys_getppid)
+#define __NR_getpgrp				111
+__SYSCALL(__NR_getpgrp, sys_getpgrp)
+
+#define __NR_setsid				112
+__SYSCALL(__NR_setsid, sys_setsid)
+#define __NR_setreuid				113
+__SYSCALL(__NR_setreuid, sys_setreuid)
+#define __NR_setregid				114
+__SYSCALL(__NR_setregid, sys_setregid)
+#define __NR_getgroups				115
+__SYSCALL(__NR_getgroups, sys_getgroups)
+#define __NR_setgroups				116
+__SYSCALL(__NR_setgroups, sys_setgroups)
+#define __NR_setresuid				117
+__SYSCALL(__NR_setresuid, sys_setresuid)
+#define __NR_getresuid				118
+__SYSCALL(__NR_getresuid, sys_getresuid)
+#define __NR_setresgid				119
+__SYSCALL(__NR_setresgid, sys_setresgid)
+
+#define __NR_getresgid				120
+__SYSCALL(__NR_getresgid, sys_getresgid)
+#define __NR_getpgid				121
+__SYSCALL(__NR_getpgid, sys_getpgid)
+#define __NR_setfsuid				122
+__SYSCALL(__NR_setfsuid, sys_setfsuid)
+#define __NR_setfsgid				123
+__SYSCALL(__NR_setfsgid, sys_setfsgid)
+#define __NR_getsid				124
+__SYSCALL(__NR_getsid, sys_getsid)
+#define __NR_capget				125
+__SYSCALL(__NR_capget, sys_capget)
+#define __NR_capset				126
+__SYSCALL(__NR_capset, sys_capset)
+
+#define __NR_rt_sigpending			127
+__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)
+#define __NR_rt_sigtimedwait			128
+__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)
+#define __NR_rt_sigqueueinfo			129
+__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)
+#define __NR_rt_sigsuspend			130
+__SYSCALL(__NR_rt_sigsuspend, sys_rt_sigsuspend)
+#define __NR_sigaltstack			131
+__SYSCALL(__NR_sigaltstack, stub_sigaltstack)
+#define __NR_utime				132
+__SYSCALL(__NR_utime, sys_utime)
+#define __NR_mknod				133
+__SYSCALL(__NR_mknod, sys_mknod)
+
+/* Only needed for a.out */
+#define __NR_uselib				134
+__SYSCALL(__NR_uselib, sys_ni_syscall)
+#define __NR_personality			135
+__SYSCALL(__NR_personality, sys_personality)
+
+#define __NR_ustat				136
+__SYSCALL(__NR_ustat, sys_ustat)
+#define __NR_statfs				137
+__SYSCALL(__NR_statfs, sys_statfs)
+#define __NR_fstatfs				138
+__SYSCALL(__NR_fstatfs, sys_fstatfs)
+#define __NR_sysfs				139
+__SYSCALL(__NR_sysfs, sys_sysfs)
+
+#define __NR_getpriority			140
+__SYSCALL(__NR_getpriority, sys_getpriority)
+#define __NR_setpriority			141
+__SYSCALL(__NR_setpriority, sys_setpriority)
+#define __NR_sched_setparam			142
+__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
+#define __NR_sched_getparam			143
+__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
+#define __NR_sched_setscheduler			144
+__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
+#define __NR_sched_getscheduler			145
+__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
+#define __NR_sched_get_priority_max		146
+__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)
+#define __NR_sched_get_priority_min		147
+__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)
+#define __NR_sched_rr_get_interval		148
+__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)
+
+#define __NR_mlock				149
+__SYSCALL(__NR_mlock, sys_mlock)
+#define __NR_munlock				150
+__SYSCALL(__NR_munlock, sys_munlock)
+#define __NR_mlockall				151
+__SYSCALL(__NR_mlockall, sys_mlockall)
+#define __NR_munlockall				152
+__SYSCALL(__NR_munlockall, sys_munlockall)
+
+#define __NR_vhangup				153
+__SYSCALL(__NR_vhangup, sys_vhangup)
+
+#define __NR_modify_ldt				154
+__SYSCALL(__NR_modify_ldt, sys_modify_ldt)
+
+#define __NR_pivot_root				155
+__SYSCALL(__NR_pivot_root, sys_pivot_root)
+
+#define __NR__sysctl				156
+__SYSCALL(__NR__sysctl, sys_sysctl)
+
+#define __NR_prctl				157
+__SYSCALL(__NR_prctl, sys_prctl)
+#define __NR_arch_prctl				158
+__SYSCALL(__NR_arch_prctl, sys_arch_prctl)
+
+#define __NR_adjtimex				159
+__SYSCALL(__NR_adjtimex, sys_adjtimex)
+
+#define __NR_setrlimit				160
+__SYSCALL(__NR_setrlimit, sys_setrlimit)
+
+#define __NR_chroot				161
+__SYSCALL(__NR_chroot, sys_chroot)
+
+#define __NR_sync				162
+__SYSCALL(__NR_sync, sys_sync)
+
+#define __NR_acct				163
+__SYSCALL(__NR_acct, sys_acct)
+
+#define __NR_settimeofday			164
+__SYSCALL(__NR_settimeofday, sys_settimeofday)
+
+#define __NR_mount				165
+__SYSCALL(__NR_mount, sys_mount)
+#define __NR_umount2				166
+__SYSCALL(__NR_umount2, sys_umount)
+
+#define __NR_swapon				167
+__SYSCALL(__NR_swapon, sys_swapon)
+#define __NR_swapoff				168
+__SYSCALL(__NR_swapoff, sys_swapoff)
+
+#define __NR_reboot				169
+__SYSCALL(__NR_reboot, sys_reboot)
+
+#define __NR_sethostname			170
+__SYSCALL(__NR_sethostname, sys_sethostname)
+#define __NR_setdomainname			171
+__SYSCALL(__NR_setdomainname, sys_setdomainname)
+
+#define __NR_iopl				172
+__SYSCALL(__NR_iopl, stub_iopl)
+#define __NR_ioperm				173
+__SYSCALL(__NR_ioperm, sys_ioperm)
+
+#define __NR_create_module			174
+__SYSCALL(__NR_create_module, sys_ni_syscall)
+#define __NR_init_module			175
+__SYSCALL(__NR_init_module, sys_init_module)
+#define __NR_delete_module			176
+__SYSCALL(__NR_delete_module, sys_delete_module)
+#define __NR_get_kernel_syms			177
+__SYSCALL(__NR_get_kernel_syms, sys_ni_syscall)
+#define __NR_query_module			178
+__SYSCALL(__NR_query_module, sys_ni_syscall)
+
+#define __NR_quotactl				179
+__SYSCALL(__NR_quotactl, sys_quotactl)
+
+#define __NR_nfsservctl				180
+__SYSCALL(__NR_nfsservctl, sys_nfsservctl)
+
+/* reserved for LiS/STREAMS */
+#define __NR_getpmsg				181
+__SYSCALL(__NR_getpmsg, sys_ni_syscall)
+#define __NR_putpmsg				182
+__SYSCALL(__NR_putpmsg, sys_ni_syscall)
+
+/* reserved for AFS */
+#define __NR_afs_syscall			183
+__SYSCALL(__NR_afs_syscall, sys_ni_syscall)
+
+/* reserved for tux */
+#define __NR_tuxcall				184
+__SYSCALL(__NR_tuxcall, sys_ni_syscall)
+
+#define __NR_security				185
+__SYSCALL(__NR_security, sys_ni_syscall)
+
+#define __NR_gettid				186
+__SYSCALL(__NR_gettid, sys_gettid)
+
+#define __NR_readahead				187
+__SYSCALL(__NR_readahead, sys_readahead)
+#define __NR_setxattr				188
+__SYSCALL(__NR_setxattr, sys_setxattr)
+#define __NR_lsetxattr				189
+__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
+#define __NR_fsetxattr				190
+__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
+#define __NR_getxattr				191
+__SYSCALL(__NR_getxattr, sys_getxattr)
+#define __NR_lgetxattr				192
+__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
+#define __NR_fgetxattr				193
+__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
+#define __NR_listxattr				194
+__SYSCALL(__NR_listxattr, sys_listxattr)
+#define __NR_llistxattr				195
+__SYSCALL(__NR_llistxattr, sys_llistxattr)
+#define __NR_flistxattr				196
+__SYSCALL(__NR_flistxattr, sys_flistxattr)
+#define __NR_removexattr			197
+__SYSCALL(__NR_removexattr, sys_removexattr)
+#define __NR_lremovexattr			198
+__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
+#define __NR_fremovexattr			199
+__SYSCALL(__NR_fremovexattr, sys_fremovexattr)
+#define __NR_tkill				200
+__SYSCALL(__NR_tkill, sys_tkill)
+#define __NR_time				201
+__SYSCALL(__NR_time, sys_time)
+#define __NR_futex				202
+__SYSCALL(__NR_futex, sys_futex)
+#define __NR_sched_setaffinity			203
+__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)
+#define __NR_sched_getaffinity			204
+__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)
+#define __NR_set_thread_area			205
+__SYSCALL(__NR_set_thread_area, sys_ni_syscall)	/* use arch_prctl */
+#define __NR_io_setup				206
+__SYSCALL(__NR_io_setup, sys_io_setup)
+#define __NR_io_destroy				207
+__SYSCALL(__NR_io_destroy, sys_io_destroy)
+#define __NR_io_getevents			208
+__SYSCALL(__NR_io_getevents, sys_io_getevents)
+#define __NR_io_submit				209
+__SYSCALL(__NR_io_submit, sys_io_submit)
+#define __NR_io_cancel				210
+__SYSCALL(__NR_io_cancel, sys_io_cancel)
+#define __NR_get_thread_area			211
+__SYSCALL(__NR_get_thread_area, sys_ni_syscall)	/* use arch_prctl */
+#define __NR_lookup_dcookie			212
+__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
+#define __NR_epoll_create			213
+__SYSCALL(__NR_epoll_create, sys_epoll_create)
+#define __NR_epoll_ctl_old			214
+__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)
+#define __NR_epoll_wait_old			215
+__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)
+#define __NR_remap_file_pages			216
+__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
+#define __NR_getdents64				217
+__SYSCALL(__NR_getdents64, sys_getdents64)
+#define __NR_set_tid_address			218
+__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
+#define __NR_restart_syscall			219
+__SYSCALL(__NR_restart_syscall, sys_restart_syscall)
+#define __NR_semtimedop				220
+__SYSCALL(__NR_semtimedop, sys_semtimedop)
+#define __NR_fadvise64				221
+__SYSCALL(__NR_fadvise64, sys_fadvise64)
+#define __NR_timer_create			222
+__SYSCALL(__NR_timer_create, sys_timer_create)
+#define __NR_timer_settime			223
+__SYSCALL(__NR_timer_settime, sys_timer_settime)
+#define __NR_timer_gettime			224
+__SYSCALL(__NR_timer_gettime, sys_timer_gettime)
+#define __NR_timer_getoverrun			225
+__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)
+#define __NR_timer_delete			226
+__SYSCALL(__NR_timer_delete, sys_timer_delete)
+#define __NR_clock_settime			227
+__SYSCALL(__NR_clock_settime, sys_clock_settime)
+#define __NR_clock_gettime			228
+__SYSCALL(__NR_clock_gettime, sys_clock_gettime)
+#define __NR_clock_getres			229
+__SYSCALL(__NR_clock_getres, sys_clock_getres)
+#define __NR_clock_nanosleep			230
+__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)
+#define __NR_exit_group				231
+__SYSCALL(__NR_exit_group, sys_exit_group)
+#define __NR_epoll_wait				232
+__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_epoll_ctl				233
+__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
+#define __NR_tgkill				234
+__SYSCALL(__NR_tgkill, sys_tgkill)
+#define __NR_utimes				235
+__SYSCALL(__NR_utimes, sys_utimes)
+#define __NR_vserver				236
+__SYSCALL(__NR_vserver, sys_ni_syscall)
+#define __NR_mbind				237
+__SYSCALL(__NR_mbind, sys_mbind)
+#define __NR_set_mempolicy			238
+__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)
+#define __NR_get_mempolicy			239
+__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)
+#define __NR_mq_open				240
+__SYSCALL(__NR_mq_open, sys_mq_open)
+#define __NR_mq_unlink				241
+__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
+#define __NR_mq_timedsend			242
+__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)
+#define __NR_mq_timedreceive			243
+__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)
+#define __NR_mq_notify				244
+__SYSCALL(__NR_mq_notify, sys_mq_notify)
+#define __NR_mq_getsetattr			245
+__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)
+#define __NR_kexec_load				246
+__SYSCALL(__NR_kexec_load, sys_kexec_load)
+#define __NR_waitid				247
+__SYSCALL(__NR_waitid, sys_waitid)
+#define __NR_add_key				248
+__SYSCALL(__NR_add_key, sys_add_key)
+#define __NR_request_key			249
+__SYSCALL(__NR_request_key, sys_request_key)
+#define __NR_keyctl				250
+__SYSCALL(__NR_keyctl, sys_keyctl)
+#define __NR_ioprio_set				251
+__SYSCALL(__NR_ioprio_set, sys_ioprio_set)
+#define __NR_ioprio_get				252
+__SYSCALL(__NR_ioprio_get, sys_ioprio_get)
+#define __NR_inotify_init			253
+__SYSCALL(__NR_inotify_init, sys_inotify_init)
+#define __NR_inotify_add_watch			254
+__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
+#define __NR_inotify_rm_watch			255
+__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
+#define __NR_migrate_pages			256
+__SYSCALL(__NR_migrate_pages, sys_migrate_pages)
+#define __NR_openat				257
+__SYSCALL(__NR_openat, sys_openat)
+#define __NR_mkdirat				258
+__SYSCALL(__NR_mkdirat, sys_mkdirat)
+#define __NR_mknodat				259
+__SYSCALL(__NR_mknodat, sys_mknodat)
+#define __NR_fchownat				260
+__SYSCALL(__NR_fchownat, sys_fchownat)
+#define __NR_futimesat				261
+__SYSCALL(__NR_futimesat, sys_futimesat)
+#define __NR_newfstatat				262
+__SYSCALL(__NR_newfstatat, sys_newfstatat)
+#define __NR_unlinkat				263
+__SYSCALL(__NR_unlinkat, sys_unlinkat)
+#define __NR_renameat				264
+__SYSCALL(__NR_renameat, sys_renameat)
+#define __NR_linkat				265
+__SYSCALL(__NR_linkat, sys_linkat)
+#define __NR_symlinkat				266
+__SYSCALL(__NR_symlinkat, sys_symlinkat)
+#define __NR_readlinkat				267
+__SYSCALL(__NR_readlinkat, sys_readlinkat)
+#define __NR_fchmodat				268
+__SYSCALL(__NR_fchmodat, sys_fchmodat)
+#define __NR_faccessat				269
+__SYSCALL(__NR_faccessat, sys_faccessat)
+#define __NR_pselect6				270
+__SYSCALL(__NR_pselect6, sys_pselect6)
+#define __NR_ppoll				271
+__SYSCALL(__NR_ppoll,	sys_ppoll)
+#define __NR_unshare				272
+__SYSCALL(__NR_unshare,	sys_unshare)
+#define __NR_set_robust_list			273
+__SYSCALL(__NR_set_robust_list, sys_set_robust_list)
+#define __NR_get_robust_list			274
+__SYSCALL(__NR_get_robust_list, sys_get_robust_list)
+#define __NR_splice				275
+__SYSCALL(__NR_splice, sys_splice)
+#define __NR_tee				276
+__SYSCALL(__NR_tee, sys_tee)
+#define __NR_sync_file_range			277
+__SYSCALL(__NR_sync_file_range, sys_sync_file_range)
+#define __NR_vmsplice				278
+__SYSCALL(__NR_vmsplice, sys_vmsplice)
+#define __NR_move_pages				279
+__SYSCALL(__NR_move_pages, sys_move_pages)
+#define __NR_utimensat				280
+__SYSCALL(__NR_utimensat, sys_utimensat)
+#define __IGNORE_getcpu		/* implemented as a vsyscall */
+#define __NR_epoll_pwait			281
+__SYSCALL(__NR_epoll_pwait, sys_epoll_pwait)
+#define __NR_signalfd				282
+__SYSCALL(__NR_signalfd, sys_signalfd)
+#define __NR_timerfd_create			283
+__SYSCALL(__NR_timerfd_create, sys_timerfd_create)
+#define __NR_eventfd				284
+__SYSCALL(__NR_eventfd, sys_eventfd)
+#define __NR_fallocate				285
+__SYSCALL(__NR_fallocate, sys_fallocate)
+#define __NR_timerfd_settime			286
+__SYSCALL(__NR_timerfd_settime, sys_timerfd_settime)
+#define __NR_timerfd_gettime			287
+__SYSCALL(__NR_timerfd_gettime, sys_timerfd_gettime)
+#define __NR_accept4				288
+__SYSCALL(__NR_accept4, sys_accept4)
+#define __NR_signalfd4				289
+__SYSCALL(__NR_signalfd4, sys_signalfd4)
+#define __NR_eventfd2				290
+__SYSCALL(__NR_eventfd2, sys_eventfd2)
+#define __NR_epoll_create1			291
+__SYSCALL(__NR_epoll_create1, sys_epoll_create1)
+#define __NR_dup3				292
+__SYSCALL(__NR_dup3, sys_dup3)
+#define __NR_pipe2				293
+__SYSCALL(__NR_pipe2, sys_pipe2)
+#define __NR_inotify_init1			294
+__SYSCALL(__NR_inotify_init1, sys_inotify_init1)
+#define __NR_preadv				295
+__SYSCALL(__NR_preadv, sys_preadv)
+#define __NR_pwritev				296
+__SYSCALL(__NR_pwritev, sys_pwritev)
+#define __NR_rt_tgsigqueueinfo			297
+__SYSCALL(__NR_rt_tgsigqueueinfo, sys_rt_tgsigqueueinfo)
+#define __NR_perf_event_open			298
+__SYSCALL(__NR_perf_event_open, sys_perf_event_open)
+
+#ifndef __NO_STUBS
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#define __ARCH_WANT_SYS_RT_SIGSUSPEND
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_COMPAT_SYS_TIME
+#endif	/* __NO_STUBS */
+
+
+#endif /* _ASM_X86_UNISTD_64_H */
diff -uNr linux-2.6.32/usr/include/asm/unistd.h clean_modified/linux-2.6.32/usr/include/asm/unistd.h
--- linux-2.6.32/usr/include/asm/unistd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/unistd.h	2019-04-14 13:24:02.872096900 -0500
@@ -0,0 +1,5 @@
+# ifdef __i386__
+#  include "unistd_32.h"
+# else
+#  include "unistd_64.h"
+# endif
diff -uNr linux-2.6.32/usr/include/asm/vm86.h clean_modified/linux-2.6.32/usr/include/asm/vm86.h
--- linux-2.6.32/usr/include/asm/vm86.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/vm86.h	2019-04-14 13:24:02.872096900 -0500
@@ -0,0 +1,129 @@
+#ifndef _ASM_X86_VM86_H
+#define _ASM_X86_VM86_H
+
+/*
+ * I'm guessing at the VIF/VIP flag usage, but hope that this is how
+ * the Pentium uses them. Linux will return from vm86 mode when both
+ * VIF and VIP is set.
+ *
+ * On a Pentium, we could probably optimize the virtual flags directly
+ * in the eflags register instead of doing it "by hand" in vflags...
+ *
+ * Linus
+ */
+
+#include <asm/processor-flags.h>
+
+#define BIOSSEG		0x0f000
+
+#define CPU_086		0
+#define CPU_186		1
+#define CPU_286		2
+#define CPU_386		3
+#define CPU_486		4
+#define CPU_586		5
+
+/*
+ * Return values for the 'vm86()' system call
+ */
+#define VM86_TYPE(retval)	((retval) & 0xff)
+#define VM86_ARG(retval)	((retval) >> 8)
+
+#define VM86_SIGNAL	0	/* return due to signal */
+#define VM86_UNKNOWN	1	/* unhandled GP fault
+				   - IO-instruction or similar */
+#define VM86_INTx	2	/* int3/int x instruction (ARG = x) */
+#define VM86_STI	3	/* sti/popf/iret instruction enabled
+				   virtual interrupts */
+
+/*
+ * Additional return values when invoking new vm86()
+ */
+#define VM86_PICRETURN	4	/* return due to pending PIC request */
+#define VM86_TRAP	6	/* return due to DOS-debugger request */
+
+/*
+ * function codes when invoking new vm86()
+ */
+#define VM86_PLUS_INSTALL_CHECK	0
+#define VM86_ENTER		1
+#define VM86_ENTER_NO_BYPASS	2
+#define	VM86_REQUEST_IRQ	3
+#define VM86_FREE_IRQ		4
+#define VM86_GET_IRQ_BITS	5
+#define VM86_GET_AND_RESET_IRQ	6
+
+/*
+ * This is the stack-layout seen by the user space program when we have
+ * done a translation of "SAVE_ALL" from vm86 mode. The real kernel layout
+ * is 'kernel_vm86_regs' (see below).
+ */
+
+struct vm86_regs {
+/*
+ * normal regs, with special meaning for the segment descriptors..
+ */
+	long ebx;
+	long ecx;
+	long edx;
+	long esi;
+	long edi;
+	long ebp;
+	long eax;
+	long __null_ds;
+	long __null_es;
+	long __null_fs;
+	long __null_gs;
+	long orig_eax;
+	long eip;
+	unsigned short cs, __csh;
+	long eflags;
+	long esp;
+	unsigned short ss, __ssh;
+/*
+ * these are specific to v86 mode:
+ */
+	unsigned short es, __esh;
+	unsigned short ds, __dsh;
+	unsigned short fs, __fsh;
+	unsigned short gs, __gsh;
+};
+
+struct revectored_struct {
+	unsigned long __map[8];			/* 256 bits */
+};
+
+struct vm86_struct {
+	struct vm86_regs regs;
+	unsigned long flags;
+	unsigned long screen_bitmap;
+	unsigned long cpu_type;
+	struct revectored_struct int_revectored;
+	struct revectored_struct int21_revectored;
+};
+
+/*
+ * flags masks
+ */
+#define VM86_SCREEN_BITMAP	0x0001
+
+struct vm86plus_info_struct {
+	unsigned long force_return_for_pic:1;
+	unsigned long vm86dbg_active:1;       /* for debugger */
+	unsigned long vm86dbg_TFpendig:1;     /* for debugger */
+	unsigned long unused:28;
+	unsigned long is_vm86pus:1;	      /* for vm86 internal use */
+	unsigned char vm86dbg_intxxtab[32];   /* for debugger */
+};
+struct vm86plus_struct {
+	struct vm86_regs regs;
+	unsigned long flags;
+	unsigned long screen_bitmap;
+	unsigned long cpu_type;
+	struct revectored_struct int_revectored;
+	struct revectored_struct int21_revectored;
+	struct vm86plus_info_struct vm86plus;
+};
+
+
+#endif /* _ASM_X86_VM86_H */
diff -uNr linux-2.6.32/usr/include/asm/vsyscall.h clean_modified/linux-2.6.32/usr/include/asm/vsyscall.h
--- linux-2.6.32/usr/include/asm/vsyscall.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm/vsyscall.h	2019-04-14 13:24:02.872096900 -0500
@@ -0,0 +1,17 @@
+#ifndef _ASM_X86_VSYSCALL_H
+#define _ASM_X86_VSYSCALL_H
+
+enum vsyscall_num {
+	__NR_vgettimeofday,
+	__NR_vtime,
+	__NR_vgetcpu,
+};
+
+#define VSYSCALL_START (-10UL << 20)
+#define VSYSCALL_SIZE 1024
+#define VSYSCALL_END (-2UL << 20)
+#define VSYSCALL_MAPPED_PAGES 1
+#define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))
+
+
+#endif /* _ASM_X86_VSYSCALL_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/auxvec.h clean_modified/linux-2.6.32/usr/include/asm-generic/auxvec.h
--- linux-2.6.32/usr/include/asm-generic/auxvec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/auxvec.h	2019-04-14 13:24:02.872926677 -0500
@@ -0,0 +1,8 @@
+#ifndef __ASM_GENERIC_AUXVEC_H
+#define __ASM_GENERIC_AUXVEC_H
+/*
+ * Not all architectures need their own auxvec.h, the most
+ * common definitions are already in linux/auxvec.h.
+ */
+
+#endif /* __ASM_GENERIC_AUXVEC_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/bitsperlong.h clean_modified/linux-2.6.32/usr/include/asm-generic/bitsperlong.h
--- linux-2.6.32/usr/include/asm-generic/bitsperlong.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/bitsperlong.h	2019-04-14 13:24:02.872926677 -0500
@@ -0,0 +1,15 @@
+#ifndef __ASM_GENERIC_BITS_PER_LONG
+#define __ASM_GENERIC_BITS_PER_LONG
+
+/*
+ * There seems to be no way of detecting this automatically from user
+ * space, so 64 bit architectures should override this in their
+ * bitsperlong.h. In particular, an architecture that supports
+ * both 32 and 64 bit user space must not rely on CONFIG_64BIT
+ * to decide it, but rather check a compiler provided macro.
+ */
+#ifndef __BITS_PER_LONG
+#define __BITS_PER_LONG 32
+#endif
+
+#endif /* __ASM_GENERIC_BITS_PER_LONG */
diff -uNr linux-2.6.32/usr/include/asm-generic/errno-base.h clean_modified/linux-2.6.32/usr/include/asm-generic/errno-base.h
--- linux-2.6.32/usr/include/asm-generic/errno-base.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/errno-base.h	2019-04-14 13:24:02.873895262 -0500
@@ -0,0 +1,39 @@
+#ifndef _ASM_GENERIC_ERRNO_BASE_H
+#define _ASM_GENERIC_ERRNO_BASE_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Argument list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+
+#endif
diff -uNr linux-2.6.32/usr/include/asm-generic/errno.h clean_modified/linux-2.6.32/usr/include/asm-generic/errno.h
--- linux-2.6.32/usr/include/asm-generic/errno.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/errno.h	2019-04-14 13:24:02.873895262 -0500
@@ -0,0 +1,111 @@
+#ifndef _ASM_GENERIC_ERRNO_H
+#define _ASM_GENERIC_ERRNO_H
+
+#include <asm-generic/errno-base.h>
+
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+
+#define	EDEADLOCK	EDEADLK
+
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+#define	ECANCELED	125	/* Operation Canceled */
+#define	ENOKEY		126	/* Required key not available */
+#define	EKEYEXPIRED	127	/* Key has expired */
+#define	EKEYREVOKED	128	/* Key has been revoked */
+#define	EKEYREJECTED	129	/* Key was rejected by service */
+
+/* for robust mutexes */
+#define	EOWNERDEAD	130	/* Owner died */
+#define	ENOTRECOVERABLE	131	/* State not recoverable */
+
+#define ERFKILL		132	/* Operation not possible due to RF-kill */
+
+#endif
diff -uNr linux-2.6.32/usr/include/asm-generic/fcntl.h clean_modified/linux-2.6.32/usr/include/asm-generic/fcntl.h
--- linux-2.6.32/usr/include/asm-generic/fcntl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/fcntl.h	2019-04-14 13:24:02.873895262 -0500
@@ -0,0 +1,167 @@
+#ifndef _ASM_GENERIC_FCNTL_H
+#define _ASM_GENERIC_FCNTL_H
+
+#include <linux/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	00000003
+#define O_RDONLY	00000000
+#define O_WRONLY	00000001
+#define O_RDWR		00000002
+#ifndef O_CREAT
+#define O_CREAT		00000100	/* not fcntl */
+#endif
+#ifndef O_EXCL
+#define O_EXCL		00000200	/* not fcntl */
+#endif
+#ifndef O_NOCTTY
+#define O_NOCTTY	00000400	/* not fcntl */
+#endif
+#ifndef O_TRUNC
+#define O_TRUNC		00001000	/* not fcntl */
+#endif
+#ifndef O_APPEND
+#define O_APPEND	00002000
+#endif
+#ifndef O_NONBLOCK
+#define O_NONBLOCK	00004000
+#endif
+#ifndef O_SYNC
+#define O_SYNC		00010000
+#endif
+#ifndef FASYNC
+#define FASYNC		00020000	/* fcntl, for BSD compatibility */
+#endif
+#ifndef O_DIRECT
+#define O_DIRECT	00040000	/* direct disk access hint */
+#endif
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	00100000
+#endif
+#ifndef O_DIRECTORY
+#define O_DIRECTORY	00200000	/* must be a directory */
+#endif
+#ifndef O_NOFOLLOW
+#define O_NOFOLLOW	00400000	/* don't follow links */
+#endif
+#ifndef O_NOATIME
+#define O_NOATIME	01000000
+#endif
+#ifndef O_CLOEXEC
+#define O_CLOEXEC	02000000	/* set close_on_exec */
+#endif
+#ifndef O_NDELAY
+#define O_NDELAY	O_NONBLOCK
+#endif
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+#ifndef F_GETLK
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+#endif
+#ifndef F_SETOWN
+#define F_SETOWN	8	/* for sockets. */
+#define F_GETOWN	9	/* for sockets. */
+#endif
+#ifndef F_SETSIG
+#define F_SETSIG	10	/* for sockets. */
+#define F_GETSIG	11	/* for sockets. */
+#endif
+
+#ifndef CONFIG_64BIT
+#ifndef F_GETLK64
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+#endif
+#endif
+
+#ifndef F_SETOWN_EX
+#define F_SETOWN_EX	15
+#define F_GETOWN_EX	16
+#endif
+
+#define F_OWNER_TID	0
+#define F_OWNER_PID	1
+#define F_OWNER_PGRP	2
+
+struct f_owner_ex {
+	int	type;
+	pid_t	pid;
+};
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#ifndef F_RDLCK
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+#endif
+
+/* for old implementation of bsd flock () */
+#ifndef F_EXLCK
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+#endif
+
+/* for leases */
+#ifndef F_INPROGRESS
+#define F_INPROGRESS	16
+#endif
+
+/* operations for bsd flock(), also used by the kernel implementation */
+#define LOCK_SH		1	/* shared lock */
+#define LOCK_EX		2	/* exclusive lock */
+#define LOCK_NB		4	/* or'd with one of the above to prevent
+				   blocking */
+#define LOCK_UN		8	/* remove lock */
+
+#define LOCK_MAND	32	/* This is a mandatory flock ... */
+#define LOCK_READ	64	/* which allows concurrent read operations */
+#define LOCK_WRITE	128	/* which allows concurrent write operations */
+#define LOCK_RW		192	/* which allows concurrent read & write ops */
+
+#define F_LINUX_SPECIFIC_BASE	1024
+
+#ifndef HAVE_ARCH_STRUCT_FLOCK
+#ifndef __ARCH_FLOCK_PAD
+#define __ARCH_FLOCK_PAD
+#endif
+
+struct flock {
+	short	l_type;
+	short	l_whence;
+	__kernel_off_t	l_start;
+	__kernel_off_t	l_len;
+	__kernel_pid_t	l_pid;
+	__ARCH_FLOCK_PAD
+};
+#endif
+
+#ifndef CONFIG_64BIT
+
+#ifndef HAVE_ARCH_STRUCT_FLOCK64
+#ifndef __ARCH_FLOCK64_PAD
+#define __ARCH_FLOCK64_PAD
+#endif
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	__kernel_loff_t l_start;
+	__kernel_loff_t l_len;
+	__kernel_pid_t  l_pid;
+	__ARCH_FLOCK64_PAD
+};
+#endif
+#endif /* !CONFIG_64BIT */
+
+#endif /* _ASM_GENERIC_FCNTL_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/int-l64.h clean_modified/linux-2.6.32/usr/include/asm-generic/int-l64.h
--- linux-2.6.32/usr/include/asm-generic/int-l64.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/int-l64.h	2019-04-14 13:24:02.874886551 -0500
@@ -0,0 +1,34 @@
+/*
+ * asm-generic/int-l64.h
+ *
+ * Integer declarations for architectures which use "long"
+ * for 64-bit types.
+ */
+
+#ifndef _ASM_GENERIC_INT_L64_H
+#define _ASM_GENERIC_INT_L64_H
+
+#include <asm/bitsperlong.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+typedef __signed__ long __s64;
+typedef unsigned long __u64;
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* _ASM_GENERIC_INT_L64_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/int-ll64.h clean_modified/linux-2.6.32/usr/include/asm-generic/int-ll64.h
--- linux-2.6.32/usr/include/asm-generic/int-ll64.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/int-ll64.h	2019-04-14 13:24:02.874886551 -0500
@@ -0,0 +1,39 @@
+/*
+ * asm-generic/int-ll64.h
+ *
+ * Integer declarations for architectures which use "long long"
+ * for 64-bit types.
+ */
+
+#ifndef _ASM_GENERIC_INT_LL64_H
+#define _ASM_GENERIC_INT_LL64_H
+
+#include <asm/bitsperlong.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#ifdef __GNUC__
+__extension__ typedef __signed__ long long __s64;
+__extension__ typedef unsigned long long __u64;
+#else
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* _ASM_GENERIC_INT_LL64_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/ioctl.h clean_modified/linux-2.6.32/usr/include/asm-generic/ioctl.h
--- linux-2.6.32/usr/include/asm-generic/ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/ioctl.h	2019-04-14 13:24:02.874886551 -0500
@@ -0,0 +1,96 @@
+#ifndef _ASM_GENERIC_IOCTL_H
+#define _ASM_GENERIC_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The generic ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+
+/*
+ * Let any architecture override either of the following before
+ * including this file.
+ */
+
+#ifndef _IOC_SIZEBITS
+# define _IOC_SIZEBITS	14
+#endif
+
+#ifndef _IOC_DIRBITS
+# define _IOC_DIRBITS	2
+#endif
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits, which any architecture can choose to override
+ * before including this file.
+ */
+
+#ifndef _IOC_NONE
+# define _IOC_NONE	0U
+#endif
+
+#ifndef _IOC_WRITE
+# define _IOC_WRITE	1U
+#endif
+
+#ifndef _IOC_READ
+# define _IOC_READ	2U
+#endif
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+#define _IOC_TYPECHECK(t) (sizeof(t))
+
+/* used to create numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_GENERIC_IOCTL_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/ioctls.h clean_modified/linux-2.6.32/usr/include/asm-generic/ioctls.h
--- linux-2.6.32/usr/include/asm-generic/ioctls.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/ioctls.h	2019-04-14 13:24:02.875857574 -0500
@@ -0,0 +1,110 @@
+#ifndef __ASM_GENERIC_IOCTLS_H
+#define __ASM_GENERIC_IOCTLS_H
+
+#include <linux/ioctl.h>
+
+/*
+ * These are the most common definitions for tty ioctl numbers.
+ * Most of them do not use the recommended _IOC(), but there is
+ * probably some source code out there hardcoding the number,
+ * so we might as well use them for all new platforms.
+ *
+ * The architectures that use different values here typically
+ * try to be compatible with some Unix variants for the same
+ * architecture.
+ */
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T', 0x2A, struct termios2)
+#define TCSETS2		_IOW('T', 0x2B, struct termios2)
+#define TCSETSW2	_IOW('T', 0x2C, struct termios2)
+#define TCSETSF2	_IOW('T', 0x2D, struct termios2)
+#define TIOCGRS485	0x542E
+#define TIOCSRS485	0x542F
+#define TIOCGPTN	_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T', 0x31, int)  /* Lock/unlock Pty */
+#define TCGETX		0x5432 /* SYS5 TCGETX compatibility */
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port __inline__ interrupt counts */
+
+/*
+ * some architectures define FIOQSIZE as 0x545E, which is used for
+ * TIOCGHAYESESP on others
+ */
+#ifndef FIOQSIZE
+# define TIOCGHAYESESP	0x545E  /* Get Hayes ESP configuration */
+# define TIOCSHAYESESP	0x545F  /* Set Hayes ESP configuration */
+# define FIOQSIZE	0x5460
+#endif
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+
+#endif /* __ASM_GENERIC_IOCTLS_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/ipcbuf.h clean_modified/linux-2.6.32/usr/include/asm-generic/ipcbuf.h
--- linux-2.6.32/usr/include/asm-generic/ipcbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/ipcbuf.h	2019-04-14 13:24:02.875857574 -0500
@@ -0,0 +1,34 @@
+#ifndef __ASM_GENERIC_IPCBUF_H
+#define __ASM_GENERIC_IPCBUF_H
+
+/*
+ * The generic ipc64_perm structure:
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * ipc64_perm was originally meant to be architecture specific, but
+ * everyone just ended up making identical copies without specific
+ * optimizations, so we may just as well all use the same one.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t on architectures that only had 16 bit
+ * - 32-bit seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm {
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+				/* pad if mode_t is u16: */
+	unsigned char		__pad1[4 - sizeof(__kernel_mode_t)];
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* __ASM_GENERIC_IPCBUF_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/mman-common.h clean_modified/linux-2.6.32/usr/include/asm-generic/mman-common.h
--- linux-2.6.32/usr/include/asm-generic/mman-common.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/mman-common.h	2019-04-14 13:24:02.875857574 -0500
@@ -0,0 +1,45 @@
+#ifndef __ASM_GENERIC_MMAN_COMMON_H
+#define __ASM_GENERIC_MMAN_COMMON_H
+
+/*
+ Author: Michael S. Tsirkin <mst@mellanox.co.il>, Mellanox Technologies Ltd.
+ Based on: asm-xxx/mman.h
+*/
+
+#define PROT_READ	0x1		/* page can be read */
+#define PROT_WRITE	0x2		/* page can be written */
+#define PROT_EXEC	0x4		/* page can be executed */
+#define PROT_SEM	0x8		/* page may be used for atomic ops */
+#define PROT_NONE	0x0		/* page can not be accessed */
+#define PROT_GROWSDOWN	0x01000000	/* mprotect flag: extend change to start of growsdown vma */
+#define PROT_GROWSUP	0x02000000	/* mprotect flag: extend change to end of growsup vma */
+
+#define MAP_SHARED	0x01		/* Share changes */
+#define MAP_PRIVATE	0x02		/* Changes are private */
+#define MAP_TYPE	0x0f		/* Mask for type of mapping */
+#define MAP_FIXED	0x10		/* Interpret addr exactly */
+#define MAP_ANONYMOUS	0x20		/* don't use a file */
+
+#define MS_ASYNC	1		/* sync memory asynchronously */
+#define MS_INVALIDATE	2		/* invalidate the caches */
+#define MS_SYNC		4		/* synchronous memory sync */
+
+#define MADV_NORMAL	0		/* no further special treatment */
+#define MADV_RANDOM	1		/* expect random page references */
+#define MADV_SEQUENTIAL	2		/* expect sequential page references */
+#define MADV_WILLNEED	3		/* will need these pages */
+#define MADV_DONTNEED	4		/* don't need these pages */
+
+/* common parameters: try to keep these consistent across architectures */
+#define MADV_REMOVE	9		/* remove these pages & resources */
+#define MADV_DONTFORK	10		/* don't inherit across fork */
+#define MADV_DOFORK	11		/* do inherit across fork */
+#define MADV_HWPOISON	100		/* poison a page for testing */
+
+#define MADV_MERGEABLE   12		/* KSM may merge identical pages */
+#define MADV_UNMERGEABLE 13		/* KSM may not merge identical pages */
+
+/* compatibility flags */
+#define MAP_FILE	0
+
+#endif /* __ASM_GENERIC_MMAN_COMMON_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/mman.h clean_modified/linux-2.6.32/usr/include/asm-generic/mman.h
--- linux-2.6.32/usr/include/asm-generic/mman.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/mman.h	2019-04-14 13:24:02.875857574 -0500
@@ -0,0 +1,19 @@
+#ifndef __ASM_GENERIC_MMAN_H
+#define __ASM_GENERIC_MMAN_H
+
+#include <asm-generic/mman-common.h>
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+#define MAP_STACK	0x20000		/* give out an address that is best suited for process/thread stacks */
+#define MAP_HUGETLB	0x40000		/* create a huge page mapping */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif /* __ASM_GENERIC_MMAN_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/msgbuf.h clean_modified/linux-2.6.32/usr/include/asm-generic/msgbuf.h
--- linux-2.6.32/usr/include/asm-generic/msgbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/msgbuf.h	2019-04-14 13:24:02.876891149 -0500
@@ -0,0 +1,47 @@
+#ifndef __ASM_GENERIC_MSGBUF_H
+#define __ASM_GENERIC_MSGBUF_H
+
+#include <asm/bitsperlong.h>
+/*
+ * generic msqid64_ds structure.
+ *
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * msqid64_ds was originally meant to be architecture specific, but
+ * everyone just ended up making identical copies without specific
+ * optimizations, so we may just as well all use the same one.
+ *
+ * 64 bit architectures typically define a 64 bit __kernel_time_t,
+ * so they do not need the first three padding words.
+ * On big-endian systems, the padding is in the wrong place.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+#if __BITS_PER_LONG != 64
+	unsigned long	__unused1;
+#endif
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+#if __BITS_PER_LONG != 64
+	unsigned long	__unused2;
+#endif
+	__kernel_time_t msg_ctime;	/* last change time */
+#if __BITS_PER_LONG != 64
+	unsigned long	__unused3;
+#endif
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* __ASM_GENERIC_MSGBUF_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/param.h clean_modified/linux-2.6.32/usr/include/asm-generic/param.h
--- linux-2.6.32/usr/include/asm-generic/param.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/param.h	2019-04-14 13:24:02.876891149 -0500
@@ -0,0 +1,19 @@
+#ifndef __ASM_GENERIC_PARAM_H
+#define __ASM_GENERIC_PARAM_H
+
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#ifndef EXEC_PAGESIZE
+#define EXEC_PAGESIZE	4096
+#endif
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* __ASM_GENERIC_PARAM_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/poll.h clean_modified/linux-2.6.32/usr/include/asm-generic/poll.h
--- linux-2.6.32/usr/include/asm-generic/poll.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/poll.h	2019-04-14 13:24:02.877821854 -0500
@@ -0,0 +1,37 @@
+#ifndef __ASM_GENERIC_POLL_H
+#define __ASM_GENERIC_POLL_H
+
+/* These are specified by iBCS2 */
+#define POLLIN		0x0001
+#define POLLPRI		0x0002
+#define POLLOUT		0x0004
+#define POLLERR		0x0008
+#define POLLHUP		0x0010
+#define POLLNVAL	0x0020
+
+/* The rest seem to be more-or-less nonstandard. Check them! */
+#define POLLRDNORM	0x0040
+#define POLLRDBAND	0x0080
+#ifndef POLLWRNORM
+#define POLLWRNORM	0x0100
+#endif
+#ifndef POLLWRBAND
+#define POLLWRBAND	0x0200
+#endif
+#ifndef POLLMSG
+#define POLLMSG		0x0400
+#endif
+#ifndef POLLREMOVE
+#define POLLREMOVE	0x1000
+#endif
+#ifndef POLLRDHUP
+#define POLLRDHUP       0x2000
+#endif
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif	/* __ASM_GENERIC_POLL_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/posix_types.h clean_modified/linux-2.6.32/usr/include/asm-generic/posix_types.h
--- linux-2.6.32/usr/include/asm-generic/posix_types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/posix_types.h	2019-04-14 13:24:02.877821854 -0500
@@ -0,0 +1,94 @@
+#ifndef __ASM_GENERIC_POSIX_TYPES_H
+#define __ASM_GENERIC_POSIX_TYPES_H
+
+#include <asm/bitsperlong.h>
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.
+ *
+ * First the types that are often defined in different ways across
+ * architectures, so that you can override them.
+ */
+
+#ifndef __kernel_ino_t
+typedef unsigned long	__kernel_ino_t;
+#endif
+
+#ifndef __kernel_mode_t
+typedef unsigned int	__kernel_mode_t;
+#endif
+
+#ifndef __kernel_nlink_t
+typedef unsigned long	__kernel_nlink_t;
+#endif
+
+#ifndef __kernel_pid_t
+typedef int		__kernel_pid_t;
+#endif
+
+#ifndef __kernel_ipc_pid_t
+typedef int		__kernel_ipc_pid_t;
+#endif
+
+#ifndef __kernel_uid_t
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+#endif
+
+#ifndef __kernel_suseconds_t
+typedef long		__kernel_suseconds_t;
+#endif
+
+#ifndef __kernel_daddr_t
+typedef int		__kernel_daddr_t;
+#endif
+
+#ifndef __kernel_uid32_t
+typedef __kernel_uid_t	__kernel_uid32_t;
+typedef __kernel_gid_t	__kernel_gid32_t;
+#endif
+
+#ifndef __kernel_old_uid_t
+typedef __kernel_uid_t	__kernel_old_uid_t;
+typedef __kernel_gid_t	__kernel_old_gid_t;
+#endif
+
+#ifndef __kernel_old_dev_t
+typedef unsigned int	__kernel_old_dev_t;
+#endif
+
+/*
+ * Most 32 bit architectures use "unsigned int" size_t,
+ * and all 64 bit architectures use "unsigned long" size_t.
+ */
+#ifndef __kernel_size_t
+#if __BITS_PER_LONG != 64
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+#else
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+#endif
+#endif
+
+/*
+ * anything below here should be completely generic
+ */
+typedef long		__kernel_off_t;
+typedef long long	__kernel_loff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+
+#endif /* __ASM_GENERIC_POSIX_TYPES_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/resource.h clean_modified/linux-2.6.32/usr/include/asm-generic/resource.h
--- linux-2.6.32/usr/include/asm-generic/resource.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/resource.h	2019-04-14 13:24:02.877821854 -0500
@@ -0,0 +1,68 @@
+#ifndef _ASM_GENERIC_RESOURCE_H
+#define _ASM_GENERIC_RESOURCE_H
+
+/*
+ * Resource limit IDs
+ *
+ * ( Compatibility detail: there are architectures that have
+ *   a different rlimit ID order in the 5-9 range and want
+ *   to keep that order for binary compatibility. The reasons
+ *   are historic and all new rlimits are identical across all
+ *   arches. If an arch has such special order for some rlimits
+ *   then it defines them prior including asm-generic/resource.h. )
+ */
+
+#define RLIMIT_CPU		0	/* CPU time in sec */
+#define RLIMIT_FSIZE		1	/* Maximum filesize */
+#define RLIMIT_DATA		2	/* max data size */
+#define RLIMIT_STACK		3	/* max stack size */
+#define RLIMIT_CORE		4	/* max core file size */
+
+#ifndef RLIMIT_RSS
+# define RLIMIT_RSS		5	/* max resident set size */
+#endif
+
+#ifndef RLIMIT_NPROC
+# define RLIMIT_NPROC		6	/* max number of processes */
+#endif
+
+#ifndef RLIMIT_NOFILE
+# define RLIMIT_NOFILE		7	/* max number of open files */
+#endif
+
+#ifndef RLIMIT_MEMLOCK
+# define RLIMIT_MEMLOCK		8	/* max locked-in-memory address space */
+#endif
+
+#ifndef RLIMIT_AS
+# define RLIMIT_AS		9	/* address space limit */
+#endif
+
+#define RLIMIT_LOCKS		10	/* maximum file locks held */
+#define RLIMIT_SIGPENDING	11	/* max number of pending signals */
+#define RLIMIT_MSGQUEUE		12	/* maximum bytes in POSIX mqueues */
+#define RLIMIT_NICE		13	/* max nice prio allowed to raise to
+					   0-39 for nice level 19 .. -20 */
+#define RLIMIT_RTPRIO		14	/* maximum realtime priority */
+#define RLIMIT_RTTIME		15	/* timeout for RT tasks in us */
+#define RLIM_NLIMITS		16
+
+/*
+ * SuS says limits have to be unsigned.
+ * Which makes a ton more sense anyway.
+ *
+ * Some architectures override this (for compatibility reasons):
+ */
+#ifndef RLIM_INFINITY
+# define RLIM_INFINITY		(~0UL)
+#endif
+
+/*
+ * RLIMIT_STACK default maximum - some architectures override it:
+ */
+#ifndef _STK_LIM_MAX
+# define _STK_LIM_MAX		RLIM_INFINITY
+#endif
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/asm-generic/sembuf.h clean_modified/linux-2.6.32/usr/include/asm-generic/sembuf.h
--- linux-2.6.32/usr/include/asm-generic/sembuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/sembuf.h	2019-04-14 13:24:02.877821854 -0500
@@ -0,0 +1,38 @@
+#ifndef __ASM_GENERIC_SEMBUF_H
+#define __ASM_GENERIC_SEMBUF_H
+
+#include <asm/bitsperlong.h>
+
+/*
+ * The semid64_ds structure for x86 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * semid64_ds was originally meant to be architecture specific, but
+ * everyone just ended up making identical copies without specific
+ * optimizations, so we may just as well all use the same one.
+ *
+ * 64 bit architectures typically define a 64 bit __kernel_time_t,
+ * so they do not need the first two padding words.
+ * On big-endian systems, the padding is in the wrong place.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+struct semid64_ds {
+	struct ipc64_perm sem_perm;	/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;	/* last semop time */
+#if __BITS_PER_LONG != 64
+	unsigned long	__unused1;
+#endif
+	__kernel_time_t	sem_ctime;	/* last change time */
+#if __BITS_PER_LONG != 64
+	unsigned long	__unused2;
+#endif
+	unsigned long	sem_nsems;	/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* __ASM_GENERIC_SEMBUF_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/setup.h clean_modified/linux-2.6.32/usr/include/asm-generic/setup.h
--- linux-2.6.32/usr/include/asm-generic/setup.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/setup.h	2019-04-14 13:24:02.878783197 -0500
@@ -0,0 +1,6 @@
+#ifndef __ASM_GENERIC_SETUP_H
+#define __ASM_GENERIC_SETUP_H
+
+#define COMMAND_LINE_SIZE	512
+
+#endif	/* __ASM_GENERIC_SETUP_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/shmbuf.h clean_modified/linux-2.6.32/usr/include/asm-generic/shmbuf.h
--- linux-2.6.32/usr/include/asm-generic/shmbuf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/shmbuf.h	2019-04-14 13:24:02.878783197 -0500
@@ -0,0 +1,59 @@
+#ifndef __ASM_GENERIC_SHMBUF_H
+#define __ASM_GENERIC_SHMBUF_H
+
+#include <asm/bitsperlong.h>
+
+/*
+ * The shmid64_ds structure for x86 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * shmid64_ds was originally meant to be architecture specific, but
+ * everyone just ended up making identical copies without specific
+ * optimizations, so we may just as well all use the same one.
+ *
+ * 64 bit architectures typically define a 64 bit __kernel_time_t,
+ * so they do not need the first two padding words.
+ * On big-endian systems, the padding is in the wrong place.
+ *
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+#if __BITS_PER_LONG != 64
+	unsigned long		__unused1;
+#endif
+	__kernel_time_t		shm_dtime;	/* last detach time */
+#if __BITS_PER_LONG != 64
+	unsigned long		__unused2;
+#endif
+	__kernel_time_t		shm_ctime;	/* last change time */
+#if __BITS_PER_LONG != 64
+	unsigned long		__unused3;
+#endif
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* __ASM_GENERIC_SHMBUF_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/shmparam.h clean_modified/linux-2.6.32/usr/include/asm-generic/shmparam.h
--- linux-2.6.32/usr/include/asm-generic/shmparam.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/shmparam.h	2019-04-14 13:24:02.878783197 -0500
@@ -0,0 +1,6 @@
+#ifndef __ASM_GENERIC_SHMPARAM_H
+#define __ASM_GENERIC_SHMPARAM_H
+
+#define SHMLBA PAGE_SIZE	 /* attach addr a multiple of this */
+
+#endif /* _ASM_GENERIC_SHMPARAM_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/siginfo.h clean_modified/linux-2.6.32/usr/include/asm-generic/siginfo.h
--- linux-2.6.32/usr/include/asm-generic/siginfo.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/siginfo.h	2019-04-14 13:24:02.878783197 -0500
@@ -0,0 +1,267 @@
+#ifndef _ASM_GENERIC_SIGINFO_H
+#define _ASM_GENERIC_SIGINFO_H
+
+
+#include <linux/types.h>
+
+typedef union sigval {
+	int sival_int;
+	void *sival_ptr;
+} sigval_t;
+
+/*
+ * This is the size (including padding) of the part of the
+ * struct siginfo that is before the union.
+ */
+#ifndef __ARCH_SI_PREAMBLE_SIZE
+#define __ARCH_SI_PREAMBLE_SIZE	(3 * sizeof(int))
+#endif
+
+#define SI_MAX_SIZE	128
+#ifndef SI_PAD_SIZE
+#define SI_PAD_SIZE	((SI_MAX_SIZE - __ARCH_SI_PREAMBLE_SIZE) / sizeof(int))
+#endif
+
+#ifndef __ARCH_SI_UID_T
+#define __ARCH_SI_UID_T	__kernel_uid32_t
+#endif
+
+/*
+ * The default "si_band" type is "long", as specified by POSIX.
+ * However, some architectures want to override this to "int"
+ * for historical compatibility reasons, so we allow that.
+ */
+#ifndef __ARCH_SI_BAND_T
+#define __ARCH_SI_BAND_T long
+#endif
+
+#ifndef HAVE_ARCH_SIGINFO_T
+
+typedef struct siginfo {
+	int si_signo;
+	int si_errno;
+	int si_code;
+
+	union {
+		int _pad[SI_PAD_SIZE];
+
+		/* kill() */
+		struct {
+			__kernel_pid_t _pid;	/* sender's pid */
+			__ARCH_SI_UID_T _uid;	/* sender's uid */
+		} _kill;
+
+		/* POSIX.1b timers */
+		struct {
+			__kernel_timer_t _tid;	/* timer id */
+			int _overrun;		/* overrun count */
+			char _pad[sizeof( __ARCH_SI_UID_T) - sizeof(int)];
+			sigval_t _sigval;	/* same as below */
+			int _sys_private;       /* not to be passed to user */
+		} _timer;
+
+		/* POSIX.1b signals */
+		struct {
+			__kernel_pid_t _pid;	/* sender's pid */
+			__ARCH_SI_UID_T _uid;	/* sender's uid */
+			sigval_t _sigval;
+		} _rt;
+
+		/* SIGCHLD */
+		struct {
+			__kernel_pid_t _pid;	/* which child */
+			__ARCH_SI_UID_T _uid;	/* sender's uid */
+			int _status;		/* exit code */
+			__kernel_clock_t _utime;
+			__kernel_clock_t _stime;
+		} _sigchld;
+
+		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
+		struct {
+			void *_addr; /* faulting insn/memory ref. */
+#ifdef __ARCH_SI_TRAPNO
+			int _trapno;	/* TRAP # which caused the signal */
+#endif
+			short _addr_lsb; /* LSB of the reported address */
+		} _sigfault;
+
+		/* SIGPOLL */
+		struct {
+			__ARCH_SI_BAND_T _band;	/* POLL_IN, POLL_OUT, POLL_MSG */
+			int _fd;
+		} _sigpoll;
+	} _sifields;
+} siginfo_t;
+
+#endif
+
+/*
+ * How these fields are to be accessed.
+ */
+#define si_pid		_sifields._kill._pid
+#define si_uid		_sifields._kill._uid
+#define si_tid		_sifields._timer._tid
+#define si_overrun	_sifields._timer._overrun
+#define si_sys_private  _sifields._timer._sys_private
+#define si_status	_sifields._sigchld._status
+#define si_utime	_sifields._sigchld._utime
+#define si_stime	_sifields._sigchld._stime
+#define si_value	_sifields._rt._sigval
+#define si_int		_sifields._rt._sigval.sival_int
+#define si_ptr		_sifields._rt._sigval.sival_ptr
+#define si_addr		_sifields._sigfault._addr
+#ifdef __ARCH_SI_TRAPNO
+#define si_trapno	_sifields._sigfault._trapno
+#endif
+#define si_addr_lsb	_sifields._sigfault._addr_lsb
+#define si_band		_sifields._sigpoll._band
+#define si_fd		_sifields._sigpoll._fd
+
+#define __SI_KILL	0
+#define __SI_TIMER	0
+#define __SI_POLL	0
+#define __SI_FAULT	0
+#define __SI_CHLD	0
+#define __SI_RT		0
+#define __SI_MESGQ	0
+#define __SI_CODE(T,N)	(N)
+
+/*
+ * si_code values
+ * Digital reserves positive values for kernel-generated signals.
+ */
+#define SI_USER		0		/* sent by kill, sigsend, raise */
+#define SI_KERNEL	0x80		/* sent by the kernel from somewhere */
+#define SI_QUEUE	-1		/* sent by sigqueue */
+#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
+#define SI_MESGQ __SI_CODE(__SI_MESGQ,-3) /* sent by real time mesq state change */
+#define SI_ASYNCIO	-4		/* sent by AIO completion */
+#define SI_SIGIO	-5		/* sent by queued SIGIO */
+#define SI_TKILL	-6		/* sent by tkill system call */
+#define SI_DETHREAD	-7		/* sent by execve() killing subsidiary threads */
+
+#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
+#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
+
+/*
+ * SIGILL si_codes
+ */
+#define ILL_ILLOPC	(__SI_FAULT|1)	/* illegal opcode */
+#define ILL_ILLOPN	(__SI_FAULT|2)	/* illegal operand */
+#define ILL_ILLADR	(__SI_FAULT|3)	/* illegal addressing mode */
+#define ILL_ILLTRP	(__SI_FAULT|4)	/* illegal trap */
+#define ILL_PRVOPC	(__SI_FAULT|5)	/* privileged opcode */
+#define ILL_PRVREG	(__SI_FAULT|6)	/* privileged register */
+#define ILL_COPROC	(__SI_FAULT|7)	/* coprocessor error */
+#define ILL_BADSTK	(__SI_FAULT|8)	/* internal stack error */
+#define NSIGILL		8
+
+/*
+ * SIGFPE si_codes
+ */
+#define FPE_INTDIV	(__SI_FAULT|1)	/* integer divide by zero */
+#define FPE_INTOVF	(__SI_FAULT|2)	/* integer overflow */
+#define FPE_FLTDIV	(__SI_FAULT|3)	/* floating point divide by zero */
+#define FPE_FLTOVF	(__SI_FAULT|4)	/* floating point overflow */
+#define FPE_FLTUND	(__SI_FAULT|5)	/* floating point underflow */
+#define FPE_FLTRES	(__SI_FAULT|6)	/* floating point inexact result */
+#define FPE_FLTINV	(__SI_FAULT|7)	/* floating point invalid operation */
+#define FPE_FLTSUB	(__SI_FAULT|8)	/* subscript out of range */
+#define NSIGFPE		8
+
+/*
+ * SIGSEGV si_codes
+ */
+#define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */
+#define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */
+#define NSIGSEGV	2
+
+/*
+ * SIGBUS si_codes
+ */
+#define BUS_ADRALN	(__SI_FAULT|1)	/* invalid address alignment */
+#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
+#define BUS_OBJERR	(__SI_FAULT|3)	/* object specific hardware error */
+/* hardware memory error consumed on a machine check: action required */
+#define BUS_MCEERR_AR	(__SI_FAULT|4)
+/* hardware memory error detected in process but not consumed: action optional*/
+#define BUS_MCEERR_AO	(__SI_FAULT|5)
+#define NSIGBUS		5
+
+/*
+ * SIGTRAP si_codes
+ */
+#define TRAP_BRKPT	(__SI_FAULT|1)	/* process breakpoint */
+#define TRAP_TRACE	(__SI_FAULT|2)	/* process trace trap */
+#define TRAP_BRANCH     (__SI_FAULT|3)  /* process taken branch trap */
+#define TRAP_HWBKPT     (__SI_FAULT|4)  /* hardware breakpoint/watchpoint */
+#define NSIGTRAP	4
+
+/*
+ * SIGCHLD si_codes
+ */
+#define CLD_EXITED	(__SI_CHLD|1)	/* child has exited */
+#define CLD_KILLED	(__SI_CHLD|2)	/* child was killed */
+#define CLD_DUMPED	(__SI_CHLD|3)	/* child terminated abnormally */
+#define CLD_TRAPPED	(__SI_CHLD|4)	/* traced child has trapped */
+#define CLD_STOPPED	(__SI_CHLD|5)	/* child has stopped */
+#define CLD_CONTINUED	(__SI_CHLD|6)	/* stopped child has continued */
+#define NSIGCHLD	6
+
+/*
+ * SIGPOLL si_codes
+ */
+#define POLL_IN		(__SI_POLL|1)	/* data input available */
+#define POLL_OUT	(__SI_POLL|2)	/* output buffers available */
+#define POLL_MSG	(__SI_POLL|3)	/* input message available */
+#define POLL_ERR	(__SI_POLL|4)	/* i/o error */
+#define POLL_PRI	(__SI_POLL|5)	/* high priority input available */
+#define POLL_HUP	(__SI_POLL|6)	/* device disconnected */
+#define NSIGPOLL	6
+
+/*
+ * sigevent definitions
+ * 
+ * It seems likely that SIGEV_THREAD will have to be handled from 
+ * userspace, libpthread transmuting it to SIGEV_SIGNAL, which the
+ * thread manager then catches and does the appropriate nonsense.
+ * However, everything is written out here so as to not get lost.
+ */
+#define SIGEV_SIGNAL	0	/* notify via signal */
+#define SIGEV_NONE	1	/* other notification: meaningless */
+#define SIGEV_THREAD	2	/* deliver via thread creation */
+#define SIGEV_THREAD_ID 4	/* deliver to thread */
+
+/*
+ * This works because the alignment is ok on all current architectures
+ * but we leave open this being overridden in the future
+ */
+#ifndef __ARCH_SIGEV_PREAMBLE_SIZE
+#define __ARCH_SIGEV_PREAMBLE_SIZE	(sizeof(int) * 2 + sizeof(sigval_t))
+#endif
+
+#define SIGEV_MAX_SIZE	64
+#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE - __ARCH_SIGEV_PREAMBLE_SIZE) \
+		/ sizeof(int))
+
+typedef struct sigevent {
+	sigval_t sigev_value;
+	int sigev_signo;
+	int sigev_notify;
+	union {
+		int _pad[SIGEV_PAD_SIZE];
+		 int _tid;
+
+		struct {
+			void (*_function)(sigval_t);
+			void *_attribute;	/* really pthread_attr_t */
+		} _sigev_thread;
+	} _sigev_un;
+} sigevent_t;
+
+#define sigev_notify_function	_sigev_un._sigev_thread._function
+#define sigev_notify_attributes	_sigev_un._sigev_thread._attribute
+#define sigev_notify_thread_id	 _sigev_un._tid
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/asm-generic/signal-defs.h clean_modified/linux-2.6.32/usr/include/asm-generic/signal-defs.h
--- linux-2.6.32/usr/include/asm-generic/signal-defs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/signal-defs.h	2019-04-14 13:24:02.878783197 -0500
@@ -0,0 +1,28 @@
+#ifndef __ASM_GENERIC_SIGNAL_DEFS_H
+#define __ASM_GENERIC_SIGNAL_DEFS_H
+
+
+
+#ifndef SIG_BLOCK
+#define SIG_BLOCK          0	/* for blocking signals */
+#endif
+#ifndef SIG_UNBLOCK
+#define SIG_UNBLOCK        1	/* for unblocking signals */
+#endif
+#ifndef SIG_SETMASK
+#define SIG_SETMASK        2	/* for setting the signal mask */
+#endif
+
+#ifndef __ASSEMBLY__
+typedef void __signalfn_t(int);
+typedef __signalfn_t *__sighandler_t;
+
+typedef void __restorefn_t(void);
+typedef __restorefn_t *__sigrestore_t;
+
+#define SIG_DFL	((__sighandler_t)0)	/* default signal handling */
+#define SIG_IGN	((__sighandler_t)1)	/* ignore signal */
+#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
+#endif
+
+#endif /* __ASM_GENERIC_SIGNAL_DEFS_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/signal.h clean_modified/linux-2.6.32/usr/include/asm-generic/signal.h
--- linux-2.6.32/usr/include/asm-generic/signal.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/signal.h	2019-04-14 13:24:02.880305440 -0500
@@ -0,0 +1,123 @@
+#ifndef __ASM_GENERIC_SIGNAL_H
+#define __ASM_GENERIC_SIGNAL_H
+
+#include <linux/types.h>
+
+#define _NSIG		64
+#define _NSIG_BPW	__BITS_PER_LONG
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#ifndef SIGRTMAX
+#define SIGRTMAX	_NSIG
+#endif
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002
+#define SA_SIGINFO	0x00000004
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+/*
+ * New architectures should not define the obsolete
+ *	SA_RESTORER	0x04000000
+ */
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#ifndef __ASSEMBLY__
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+/* not actually used, but required for linux/syscalls.h */
+typedef unsigned long old_sigset_t;
+
+#include <asm-generic/signal-defs.h>
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+#ifdef SA_RESTORER
+	__sigrestore_t sa_restorer;
+#endif
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_GENERIC_SIGNAL_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/socket.h clean_modified/linux-2.6.32/usr/include/asm-generic/socket.h
--- linux-2.6.32/usr/include/asm-generic/socket.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/socket.h	2019-04-14 13:24:02.880305440 -0500
@@ -0,0 +1,66 @@
+#ifndef __ASM_GENERIC_SOCKET_H
+#define __ASM_GENERIC_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockopt(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+
+#ifndef SO_PASSCRED /* powerpc only differs in these */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+#endif
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER	26
+#define SO_DETACH_FILTER	27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC		31
+#define SO_PASSSEC		34
+#define SO_TIMESTAMPNS		35
+#define SCM_TIMESTAMPNS		SO_TIMESTAMPNS
+
+#define SO_MARK			36
+
+#define SO_TIMESTAMPING		37
+#define SCM_TIMESTAMPING	SO_TIMESTAMPING
+
+#define SO_PROTOCOL		38
+#define SO_DOMAIN		39
+
+#endif /* __ASM_GENERIC_SOCKET_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/sockios.h clean_modified/linux-2.6.32/usr/include/asm-generic/sockios.h
--- linux-2.6.32/usr/include/asm-generic/sockios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/sockios.h	2019-04-14 13:24:02.880305440 -0500
@@ -0,0 +1,13 @@
+#ifndef __ASM_GENERIC_SOCKIOS_H
+#define __ASM_GENERIC_SOCKIOS_H
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp (timeval) */
+#define SIOCGSTAMPNS	0x8907		/* Get stamp (timespec) */
+
+#endif /* __ASM_GENERIC_SOCKIOS_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/statfs.h clean_modified/linux-2.6.32/usr/include/asm-generic/statfs.h
--- linux-2.6.32/usr/include/asm-generic/statfs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/statfs.h	2019-04-14 13:24:02.880305440 -0500
@@ -0,0 +1,80 @@
+#ifndef _GENERIC_STATFS_H
+#define _GENERIC_STATFS_H
+
+#include <linux/types.h>
+
+
+/*
+ * Most 64-bit platforms use 'long', while most 32-bit platforms use '__u32'.
+ * Yes, they differ in signedness as well as size.
+ * Special cases can override it for themselves -- except for S390x, which
+ * is just a little too special for us. And MIPS, which I'm not touching
+ * with a 10' pole.
+ */
+#ifndef __statfs_word
+#if BITS_PER_LONG == 64
+#define __statfs_word long
+#else
+#define __statfs_word __u32
+#endif
+#endif
+
+struct statfs {
+	__statfs_word f_type;
+	__statfs_word f_bsize;
+	__statfs_word f_blocks;
+	__statfs_word f_bfree;
+	__statfs_word f_bavail;
+	__statfs_word f_files;
+	__statfs_word f_ffree;
+	__kernel_fsid_t f_fsid;
+	__statfs_word f_namelen;
+	__statfs_word f_frsize;
+	__statfs_word f_spare[5];
+};
+
+/*
+ * ARM needs to avoid the 32-bit padding at the end, for consistency
+ * between EABI and OABI 
+ */
+#ifndef ARCH_PACK_STATFS64
+#define ARCH_PACK_STATFS64
+#endif
+
+struct statfs64 {
+	__statfs_word f_type;
+	__statfs_word f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__statfs_word f_namelen;
+	__statfs_word f_frsize;
+	__statfs_word f_spare[5];
+} ARCH_PACK_STATFS64;
+
+/* 
+ * IA64 and x86_64 need to avoid the 32-bit padding at the end,
+ * to be compatible with the i386 ABI
+ */
+#ifndef ARCH_PACK_COMPAT_STATFS64
+#define ARCH_PACK_COMPAT_STATFS64
+#endif
+
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+} ARCH_PACK_COMPAT_STATFS64;
+
+#endif
diff -uNr linux-2.6.32/usr/include/asm-generic/stat.h clean_modified/linux-2.6.32/usr/include/asm-generic/stat.h
--- linux-2.6.32/usr/include/asm-generic/stat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/stat.h	2019-04-14 13:24:02.881251537 -0500
@@ -0,0 +1,72 @@
+#ifndef __ASM_GENERIC_STAT_H
+#define __ASM_GENERIC_STAT_H
+
+/*
+ * Everybody gets this wrong and has to stick with it for all
+ * eternity. Hopefully, this version gets used by new architectures
+ * so they don't fall into the same traps.
+ *
+ * stat64 is copied from powerpc64, with explicit padding added.
+ * stat is the same structure layout on 64-bit, without the 'long long'
+ * types.
+ *
+ * By convention, 64 bit architectures use the stat interface, while
+ * 32 bit architectures use the stat64 interface. Note that we don't
+ * provide an __old_kernel_stat here, which new architecture should
+ * not have to start with.
+ */
+
+#include <asm/bitsperlong.h>
+
+#define STAT_HAVE_NSEC 1
+
+struct stat {
+	unsigned long	st_dev;		/* Device.  */
+	unsigned long	st_ino;		/* File serial number.  */
+	unsigned int	st_mode;	/* File mode.  */
+	unsigned int	st_nlink;	/* Link count.  */
+	unsigned int	st_uid;		/* User ID of the file's owner.  */
+	unsigned int	st_gid;		/* Group ID of the file's group. */
+	unsigned long	st_rdev;	/* Device number, if device.  */
+	unsigned long	__pad1;
+	long		st_size;	/* Size of file, in bytes.  */
+	int		st_blksize;	/* Optimal block size for I/O.  */
+	int		__pad2;
+	long		st_blocks;	/* Number 512-byte blocks allocated. */
+	int		st_atime;	/* Time of last access.  */
+	unsigned int	st_atime_nsec;
+	int		st_mtime;	/* Time of last modification.  */
+	unsigned int	st_mtime_nsec;
+	int		st_ctime;	/* Time of last status change.  */
+	unsigned int	st_ctime_nsec;
+	unsigned int	__unused4;
+	unsigned int	__unused5;
+};
+
+#if __BITS_PER_LONG != 64
+/* This matches struct stat64 in glibc2.1. Only used for 32 bit. */
+struct stat64 {
+	unsigned long long st_dev;	/* Device.  */
+	unsigned long long st_ino;	/* File serial number.  */
+	unsigned int	st_mode;	/* File mode.  */
+	unsigned int	st_nlink;	/* Link count.  */
+	unsigned int	st_uid;		/* User ID of the file's owner.  */
+	unsigned int	st_gid;		/* Group ID of the file's group. */
+	unsigned long long st_rdev;	/* Device number, if device.  */
+	unsigned long long __pad1;
+	long long	st_size;	/* Size of file, in bytes.  */
+	int		st_blksize;	/* Optimal block size for I/O.  */
+	int		__pad2;
+	long long	st_blocks;	/* Number 512-byte blocks allocated. */
+	int		st_atime;	/* Time of last access.  */
+	unsigned int	st_atime_nsec;
+	int		st_mtime;	/* Time of last modification.  */
+	unsigned int	st_mtime_nsec;
+	int		st_ctime;	/* Time of last status change.  */
+	unsigned int	st_ctime_nsec;
+	unsigned int	__unused4;
+	unsigned int	__unused5;
+};
+#endif
+
+#endif /* __ASM_GENERIC_STAT_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/swab.h clean_modified/linux-2.6.32/usr/include/asm-generic/swab.h
--- linux-2.6.32/usr/include/asm-generic/swab.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/swab.h	2019-04-14 13:24:02.881251537 -0500
@@ -0,0 +1,18 @@
+#ifndef _ASM_GENERIC_SWAB_H
+#define _ASM_GENERIC_SWAB_H
+
+#include <asm/bitsperlong.h>
+
+/*
+ * 32 bit architectures typically (but not always) want to
+ * set __SWAB_64_THRU_32__. In user space, this is only
+ * valid if the compiler supports 64 bit data types.
+ */
+
+#if __BITS_PER_LONG == 32
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#define __SWAB_64_THRU_32__
+#endif
+#endif
+
+#endif /* _ASM_GENERIC_SWAB_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/termbits.h clean_modified/linux-2.6.32/usr/include/asm-generic/termbits.h
--- linux-2.6.32/usr/include/asm-generic/termbits.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/termbits.h	2019-04-14 13:24:02.881874426 -0500
@@ -0,0 +1,198 @@
+#ifndef __ASM_GENERIC_TERMBITS_H
+#define __ASM_GENERIC_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct termios2 {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    BOTHER 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+#define IBSHIFT	  16		/* Shift from CBAUD to CIBAUD */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* __ASM_GENERIC_TERMBITS_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/termios.h clean_modified/linux-2.6.32/usr/include/asm-generic/termios.h
--- linux-2.6.32/usr/include/asm-generic/termios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/termios.h	2019-04-14 13:24:02.882794854 -0500
@@ -0,0 +1,50 @@
+#ifndef _ASM_GENERIC_TERMIOS_H
+#define _ASM_GENERIC_TERMIOS_H
+/*
+ * Most architectures have straight copies of the x86 code, with
+ * varying levels of bug fixes on top. Usually it's a good idea
+ * to use this generic version instead, but be careful to avoid
+ * ABI changes.
+ * New architectures should not provide their own version.
+ */
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+
+#endif /* _ASM_GENERIC_TERMIOS_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/types.h clean_modified/linux-2.6.32/usr/include/asm-generic/types.h
--- linux-2.6.32/usr/include/asm-generic/types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/types.h	2019-04-14 13:24:02.882794854 -0500
@@ -0,0 +1,19 @@
+#ifndef _ASM_GENERIC_TYPES_H
+#define _ASM_GENERIC_TYPES_H
+/*
+ * int-ll64 is used practically everywhere now,
+ * so use it as a reasonable default.
+ */
+#include <asm-generic/int-ll64.h>
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+
+#endif /* _ASM_GENERIC_TYPES_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/ucontext.h clean_modified/linux-2.6.32/usr/include/asm-generic/ucontext.h
--- linux-2.6.32/usr/include/asm-generic/ucontext.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/ucontext.h	2019-04-14 13:24:02.882794854 -0500
@@ -0,0 +1,12 @@
+#ifndef __ASM_GENERIC_UCONTEXT_H
+#define __ASM_GENERIC_UCONTEXT_H
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif /* __ASM_GENERIC_UCONTEXT_H */
diff -uNr linux-2.6.32/usr/include/asm-generic/unistd.h clean_modified/linux-2.6.32/usr/include/asm-generic/unistd.h
--- linux-2.6.32/usr/include/asm-generic/unistd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/asm-generic/unistd.h	2019-04-14 13:24:02.884622648 -0500
@@ -0,0 +1,834 @@
+#if !defined(_ASM_GENERIC_UNISTD_H) || defined(__SYSCALL)
+#define _ASM_GENERIC_UNISTD_H
+
+#include <asm/bitsperlong.h>
+
+/*
+ * This file contains the system call numbers, based on the
+ * layout of the x86-64 architecture, which embeds the
+ * pointer to the syscall in the table.
+ *
+ * As a basic principle, no duplication of functionality
+ * should be added, e.g. we don't use lseek when llseek
+ * is present. New architectures should use this file
+ * and implement the less feature-full calls in user space.
+ */
+
+#ifndef __SYSCALL
+#define __SYSCALL(x, y)
+#endif
+
+#if __BITS_PER_LONG == 32
+#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _32)
+#else
+#define __SC_3264(_nr, _32, _64) __SYSCALL(_nr, _64)
+#endif
+
+#define __NR_io_setup 0
+__SYSCALL(__NR_io_setup, sys_io_setup)
+#define __NR_io_destroy 1
+__SYSCALL(__NR_io_destroy, sys_io_destroy)
+#define __NR_io_submit 2
+__SYSCALL(__NR_io_submit, sys_io_submit)
+#define __NR_io_cancel 3
+__SYSCALL(__NR_io_cancel, sys_io_cancel)
+#define __NR_io_getevents 4
+__SYSCALL(__NR_io_getevents, sys_io_getevents)
+
+/* fs/xattr.c */
+#define __NR_setxattr 5
+__SYSCALL(__NR_setxattr, sys_setxattr)
+#define __NR_lsetxattr 6
+__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
+#define __NR_fsetxattr 7
+__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
+#define __NR_getxattr 8
+__SYSCALL(__NR_getxattr, sys_getxattr)
+#define __NR_lgetxattr 9
+__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
+#define __NR_fgetxattr 10
+__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
+#define __NR_listxattr 11
+__SYSCALL(__NR_listxattr, sys_listxattr)
+#define __NR_llistxattr 12
+__SYSCALL(__NR_llistxattr, sys_llistxattr)
+#define __NR_flistxattr 13
+__SYSCALL(__NR_flistxattr, sys_flistxattr)
+#define __NR_removexattr 14
+__SYSCALL(__NR_removexattr, sys_removexattr)
+#define __NR_lremovexattr 15
+__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
+#define __NR_fremovexattr 16
+__SYSCALL(__NR_fremovexattr, sys_fremovexattr)
+
+/* fs/dcache.c */
+#define __NR_getcwd 17
+__SYSCALL(__NR_getcwd, sys_getcwd)
+
+/* fs/cookies.c */
+#define __NR_lookup_dcookie 18
+__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
+
+/* fs/eventfd.c */
+#define __NR_eventfd2 19
+__SYSCALL(__NR_eventfd2, sys_eventfd2)
+
+/* fs/eventpoll.c */
+#define __NR_epoll_create1 20
+__SYSCALL(__NR_epoll_create1, sys_epoll_create1)
+#define __NR_epoll_ctl 21
+__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
+#define __NR_epoll_pwait 22
+__SYSCALL(__NR_epoll_pwait, sys_epoll_pwait)
+
+/* fs/fcntl.c */
+#define __NR_dup 23
+__SYSCALL(__NR_dup, sys_dup)
+#define __NR_dup3 24
+__SYSCALL(__NR_dup3, sys_dup3)
+#define __NR3264_fcntl 25
+__SC_3264(__NR3264_fcntl, sys_fcntl64, sys_fcntl)
+
+/* fs/inotify_user.c */
+#define __NR_inotify_init1 26
+__SYSCALL(__NR_inotify_init1, sys_inotify_init1)
+#define __NR_inotify_add_watch 27
+__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
+#define __NR_inotify_rm_watch 28
+__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
+
+/* fs/ioctl.c */
+#define __NR_ioctl 29
+__SYSCALL(__NR_ioctl, sys_ioctl)
+
+/* fs/ioprio.c */
+#define __NR_ioprio_set 30
+__SYSCALL(__NR_ioprio_set, sys_ioprio_set)
+#define __NR_ioprio_get 31
+__SYSCALL(__NR_ioprio_get, sys_ioprio_get)
+
+/* fs/locks.c */
+#define __NR_flock 32
+__SYSCALL(__NR_flock, sys_flock)
+
+/* fs/namei.c */
+#define __NR_mknodat 33
+__SYSCALL(__NR_mknodat, sys_mknodat)
+#define __NR_mkdirat 34
+__SYSCALL(__NR_mkdirat, sys_mkdirat)
+#define __NR_unlinkat 35
+__SYSCALL(__NR_unlinkat, sys_unlinkat)
+#define __NR_symlinkat 36
+__SYSCALL(__NR_symlinkat, sys_symlinkat)
+#define __NR_linkat 37
+__SYSCALL(__NR_linkat, sys_linkat)
+#define __NR_renameat 38
+__SYSCALL(__NR_renameat, sys_renameat)
+
+/* fs/namespace.c */
+#define __NR_umount2 39
+__SYSCALL(__NR_umount2, sys_umount)
+#define __NR_mount 40
+__SYSCALL(__NR_mount, sys_mount)
+#define __NR_pivot_root 41
+__SYSCALL(__NR_pivot_root, sys_pivot_root)
+
+/* fs/nfsctl.c */
+#define __NR_nfsservctl 42
+__SYSCALL(__NR_nfsservctl, sys_nfsservctl)
+
+/* fs/open.c */
+#define __NR3264_statfs 43
+__SC_3264(__NR3264_statfs, sys_statfs64, sys_statfs)
+#define __NR3264_fstatfs 44
+__SC_3264(__NR3264_fstatfs, sys_fstatfs64, sys_fstatfs)
+#define __NR3264_truncate 45
+__SC_3264(__NR3264_truncate, sys_truncate64, sys_truncate)
+#define __NR3264_ftruncate 46
+__SC_3264(__NR3264_ftruncate, sys_ftruncate64, sys_ftruncate)
+
+#define __NR_fallocate 47
+__SYSCALL(__NR_fallocate, sys_fallocate)
+#define __NR_faccessat 48
+__SYSCALL(__NR_faccessat, sys_faccessat)
+#define __NR_chdir 49
+__SYSCALL(__NR_chdir, sys_chdir)
+#define __NR_fchdir 50
+__SYSCALL(__NR_fchdir, sys_fchdir)
+#define __NR_chroot 51
+__SYSCALL(__NR_chroot, sys_chroot)
+#define __NR_fchmod 52
+__SYSCALL(__NR_fchmod, sys_fchmod)
+#define __NR_fchmodat 53
+__SYSCALL(__NR_fchmodat, sys_fchmodat)
+#define __NR_fchownat 54
+__SYSCALL(__NR_fchownat, sys_fchownat)
+#define __NR_fchown 55
+__SYSCALL(__NR_fchown, sys_fchown)
+#define __NR_openat 56
+__SYSCALL(__NR_openat, sys_openat)
+#define __NR_close 57
+__SYSCALL(__NR_close, sys_close)
+#define __NR_vhangup 58
+__SYSCALL(__NR_vhangup, sys_vhangup)
+
+/* fs/pipe.c */
+#define __NR_pipe2 59
+__SYSCALL(__NR_pipe2, sys_pipe2)
+
+/* fs/quota.c */
+#define __NR_quotactl 60
+__SYSCALL(__NR_quotactl, sys_quotactl)
+
+/* fs/readdir.c */
+#define __NR_getdents64 61
+__SYSCALL(__NR_getdents64, sys_getdents64)
+
+/* fs/read_write.c */
+#define __NR3264_lseek 62
+__SC_3264(__NR3264_lseek, sys_llseek, sys_lseek)
+#define __NR_read 63
+__SYSCALL(__NR_read, sys_read)
+#define __NR_write 64
+__SYSCALL(__NR_write, sys_write)
+#define __NR_readv 65
+__SYSCALL(__NR_readv, sys_readv)
+#define __NR_writev 66
+__SYSCALL(__NR_writev, sys_writev)
+#define __NR_pread64 67
+__SYSCALL(__NR_pread64, sys_pread64)
+#define __NR_pwrite64 68
+__SYSCALL(__NR_pwrite64, sys_pwrite64)
+#define __NR_preadv 69
+__SYSCALL(__NR_preadv, sys_preadv)
+#define __NR_pwritev 70
+__SYSCALL(__NR_pwritev, sys_pwritev)
+
+/* fs/sendfile.c */
+#define __NR3264_sendfile 71
+__SC_3264(__NR3264_sendfile, sys_sendfile64, sys_sendfile)
+
+/* fs/select.c */
+#define __NR_pselect6 72
+__SYSCALL(__NR_pselect6, sys_pselect6)
+#define __NR_ppoll 73
+__SYSCALL(__NR_ppoll, sys_ppoll)
+
+/* fs/signalfd.c */
+#define __NR_signalfd4 74
+__SYSCALL(__NR_signalfd4, sys_signalfd4)
+
+/* fs/splice.c */
+#define __NR_vmsplice 75
+__SYSCALL(__NR_vmsplice, sys_vmsplice)
+#define __NR_splice 76
+__SYSCALL(__NR_splice, sys_splice)
+#define __NR_tee 77
+__SYSCALL(__NR_tee, sys_tee)
+
+/* fs/stat.c */
+#define __NR_readlinkat 78
+__SYSCALL(__NR_readlinkat, sys_readlinkat)
+#define __NR3264_fstatat 79
+__SC_3264(__NR3264_fstatat, sys_fstatat64, sys_newfstatat)
+#define __NR3264_fstat 80
+__SC_3264(__NR3264_fstat, sys_fstat64, sys_newfstat)
+
+/* fs/sync.c */
+#define __NR_sync 81
+__SYSCALL(__NR_sync, sys_sync)
+#define __NR_fsync 82
+__SYSCALL(__NR_fsync, sys_fsync)
+#define __NR_fdatasync 83
+__SYSCALL(__NR_fdatasync, sys_fdatasync)
+#define __NR_sync_file_range 84
+__SYSCALL(__NR_sync_file_range, sys_sync_file_range) /* .long sys_sync_file_range2, */
+
+/* fs/timerfd.c */
+#define __NR_timerfd_create 85
+__SYSCALL(__NR_timerfd_create, sys_timerfd_create)
+#define __NR_timerfd_settime 86
+__SYSCALL(__NR_timerfd_settime, sys_timerfd_settime)
+#define __NR_timerfd_gettime 87
+__SYSCALL(__NR_timerfd_gettime, sys_timerfd_gettime)
+
+/* fs/utimes.c */
+#define __NR_utimensat 88
+__SYSCALL(__NR_utimensat, sys_utimensat)
+
+/* kernel/acct.c */
+#define __NR_acct 89
+__SYSCALL(__NR_acct, sys_acct)
+
+/* kernel/capability.c */
+#define __NR_capget 90
+__SYSCALL(__NR_capget, sys_capget)
+#define __NR_capset 91
+__SYSCALL(__NR_capset, sys_capset)
+
+/* kernel/exec_domain.c */
+#define __NR_personality 92
+__SYSCALL(__NR_personality, sys_personality)
+
+/* kernel/exit.c */
+#define __NR_exit 93
+__SYSCALL(__NR_exit, sys_exit)
+#define __NR_exit_group 94
+__SYSCALL(__NR_exit_group, sys_exit_group)
+#define __NR_waitid 95
+__SYSCALL(__NR_waitid, sys_waitid)
+
+/* kernel/fork.c */
+#define __NR_set_tid_address 96
+__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
+#define __NR_unshare 97
+__SYSCALL(__NR_unshare, sys_unshare)
+
+/* kernel/futex.c */
+#define __NR_futex 98
+__SYSCALL(__NR_futex, sys_futex)
+#define __NR_set_robust_list 99
+__SYSCALL(__NR_set_robust_list, sys_set_robust_list)
+#define __NR_get_robust_list 100
+__SYSCALL(__NR_get_robust_list, sys_get_robust_list)
+
+/* kernel/hrtimer.c */
+#define __NR_nanosleep 101
+__SYSCALL(__NR_nanosleep, sys_nanosleep)
+
+/* kernel/itimer.c */
+#define __NR_getitimer 102
+__SYSCALL(__NR_getitimer, sys_getitimer)
+#define __NR_setitimer 103
+__SYSCALL(__NR_setitimer, sys_setitimer)
+
+/* kernel/kexec.c */
+#define __NR_kexec_load 104
+__SYSCALL(__NR_kexec_load, sys_kexec_load)
+
+/* kernel/module.c */
+#define __NR_init_module 105
+__SYSCALL(__NR_init_module, sys_init_module)
+#define __NR_delete_module 106
+__SYSCALL(__NR_delete_module, sys_delete_module)
+
+/* kernel/posix-timers.c */
+#define __NR_timer_create 107
+__SYSCALL(__NR_timer_create, sys_timer_create)
+#define __NR_timer_gettime 108
+__SYSCALL(__NR_timer_gettime, sys_timer_gettime)
+#define __NR_timer_getoverrun 109
+__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)
+#define __NR_timer_settime 110
+__SYSCALL(__NR_timer_settime, sys_timer_settime)
+#define __NR_timer_delete 111
+__SYSCALL(__NR_timer_delete, sys_timer_delete)
+#define __NR_clock_settime 112
+__SYSCALL(__NR_clock_settime, sys_clock_settime)
+#define __NR_clock_gettime 113
+__SYSCALL(__NR_clock_gettime, sys_clock_gettime)
+#define __NR_clock_getres 114
+__SYSCALL(__NR_clock_getres, sys_clock_getres)
+#define __NR_clock_nanosleep 115
+__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)
+
+/* kernel/printk.c */
+#define __NR_syslog 116
+__SYSCALL(__NR_syslog, sys_syslog)
+
+/* kernel/ptrace.c */
+#define __NR_ptrace 117
+__SYSCALL(__NR_ptrace, sys_ptrace)
+
+/* kernel/sched.c */
+#define __NR_sched_setparam 118
+__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
+#define __NR_sched_setscheduler 119
+__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
+#define __NR_sched_getscheduler 120
+__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
+#define __NR_sched_getparam 121
+__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
+#define __NR_sched_setaffinity 122
+__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)
+#define __NR_sched_getaffinity 123
+__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)
+#define __NR_sched_yield 124
+__SYSCALL(__NR_sched_yield, sys_sched_yield)
+#define __NR_sched_get_priority_max 125
+__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)
+#define __NR_sched_get_priority_min 126
+__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)
+#define __NR_sched_rr_get_interval 127
+__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)
+
+/* kernel/signal.c */
+#define __NR_restart_syscall 128
+__SYSCALL(__NR_restart_syscall, sys_restart_syscall)
+#define __NR_kill 129
+__SYSCALL(__NR_kill, sys_kill)
+#define __NR_tkill 130
+__SYSCALL(__NR_tkill, sys_tkill)
+#define __NR_tgkill 131
+__SYSCALL(__NR_tgkill, sys_tgkill)
+#define __NR_sigaltstack 132
+__SYSCALL(__NR_sigaltstack, sys_sigaltstack)
+#define __NR_rt_sigsuspend 133
+__SYSCALL(__NR_rt_sigsuspend, sys_rt_sigsuspend) /* __ARCH_WANT_SYS_RT_SIGSUSPEND */
+#define __NR_rt_sigaction 134
+__SYSCALL(__NR_rt_sigaction, sys_rt_sigaction) /* __ARCH_WANT_SYS_RT_SIGACTION */
+#define __NR_rt_sigprocmask 135
+__SYSCALL(__NR_rt_sigprocmask, sys_rt_sigprocmask)
+#define __NR_rt_sigpending 136
+__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)
+#define __NR_rt_sigtimedwait 137
+__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)
+#define __NR_rt_sigqueueinfo 138
+__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)
+#define __NR_rt_sigreturn 139
+__SYSCALL(__NR_rt_sigreturn, sys_rt_sigreturn) /* sys_rt_sigreturn_wrapper, */
+
+/* kernel/sys.c */
+#define __NR_setpriority 140
+__SYSCALL(__NR_setpriority, sys_setpriority)
+#define __NR_getpriority 141
+__SYSCALL(__NR_getpriority, sys_getpriority)
+#define __NR_reboot 142
+__SYSCALL(__NR_reboot, sys_reboot)
+#define __NR_setregid 143
+__SYSCALL(__NR_setregid, sys_setregid)
+#define __NR_setgid 144
+__SYSCALL(__NR_setgid, sys_setgid)
+#define __NR_setreuid 145
+__SYSCALL(__NR_setreuid, sys_setreuid)
+#define __NR_setuid 146
+__SYSCALL(__NR_setuid, sys_setuid)
+#define __NR_setresuid 147
+__SYSCALL(__NR_setresuid, sys_setresuid)
+#define __NR_getresuid 148
+__SYSCALL(__NR_getresuid, sys_getresuid)
+#define __NR_setresgid 149
+__SYSCALL(__NR_setresgid, sys_setresgid)
+#define __NR_getresgid 150
+__SYSCALL(__NR_getresgid, sys_getresgid)
+#define __NR_setfsuid 151
+__SYSCALL(__NR_setfsuid, sys_setfsuid)
+#define __NR_setfsgid 152
+__SYSCALL(__NR_setfsgid, sys_setfsgid)
+#define __NR_times 153
+__SYSCALL(__NR_times, sys_times)
+#define __NR_setpgid 154
+__SYSCALL(__NR_setpgid, sys_setpgid)
+#define __NR_getpgid 155
+__SYSCALL(__NR_getpgid, sys_getpgid)
+#define __NR_getsid 156
+__SYSCALL(__NR_getsid, sys_getsid)
+#define __NR_setsid 157
+__SYSCALL(__NR_setsid, sys_setsid)
+#define __NR_getgroups 158
+__SYSCALL(__NR_getgroups, sys_getgroups)
+#define __NR_setgroups 159
+__SYSCALL(__NR_setgroups, sys_setgroups)
+#define __NR_uname 160
+__SYSCALL(__NR_uname, sys_newuname)
+#define __NR_sethostname 161
+__SYSCALL(__NR_sethostname, sys_sethostname)
+#define __NR_setdomainname 162
+__SYSCALL(__NR_setdomainname, sys_setdomainname)
+#define __NR_getrlimit 163
+__SYSCALL(__NR_getrlimit, sys_getrlimit)
+#define __NR_setrlimit 164
+__SYSCALL(__NR_setrlimit, sys_setrlimit)
+#define __NR_getrusage 165
+__SYSCALL(__NR_getrusage, sys_getrusage)
+#define __NR_umask 166
+__SYSCALL(__NR_umask, sys_umask)
+#define __NR_prctl 167
+__SYSCALL(__NR_prctl, sys_prctl)
+#define __NR_getcpu 168
+__SYSCALL(__NR_getcpu, sys_getcpu)
+
+/* kernel/time.c */
+#define __NR_gettimeofday 169
+__SYSCALL(__NR_gettimeofday, sys_gettimeofday)
+#define __NR_settimeofday 170
+__SYSCALL(__NR_settimeofday, sys_settimeofday)
+#define __NR_adjtimex 171
+__SYSCALL(__NR_adjtimex, sys_adjtimex)
+
+/* kernel/timer.c */
+#define __NR_getpid 172
+__SYSCALL(__NR_getpid, sys_getpid)
+#define __NR_getppid 173
+__SYSCALL(__NR_getppid, sys_getppid)
+#define __NR_getuid 174
+__SYSCALL(__NR_getuid, sys_getuid)
+#define __NR_geteuid 175
+__SYSCALL(__NR_geteuid, sys_geteuid)
+#define __NR_getgid 176
+__SYSCALL(__NR_getgid, sys_getgid)
+#define __NR_getegid 177
+__SYSCALL(__NR_getegid, sys_getegid)
+#define __NR_gettid 178
+__SYSCALL(__NR_gettid, sys_gettid)
+#define __NR_sysinfo 179
+__SYSCALL(__NR_sysinfo, sys_sysinfo)
+
+/* ipc/mqueue.c */
+#define __NR_mq_open 180
+__SYSCALL(__NR_mq_open, sys_mq_open)
+#define __NR_mq_unlink 181
+__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
+#define __NR_mq_timedsend 182
+__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)
+#define __NR_mq_timedreceive 183
+__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)
+#define __NR_mq_notify 184
+__SYSCALL(__NR_mq_notify, sys_mq_notify)
+#define __NR_mq_getsetattr 185
+__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)
+
+/* ipc/msg.c */
+#define __NR_msgget 186
+__SYSCALL(__NR_msgget, sys_msgget)
+#define __NR_msgctl 187
+__SYSCALL(__NR_msgctl, sys_msgctl)
+#define __NR_msgrcv 188
+__SYSCALL(__NR_msgrcv, sys_msgrcv)
+#define __NR_msgsnd 189
+__SYSCALL(__NR_msgsnd, sys_msgsnd)
+
+/* ipc/sem.c */
+#define __NR_semget 190
+__SYSCALL(__NR_semget, sys_semget)
+#define __NR_semctl 191
+__SYSCALL(__NR_semctl, sys_semctl)
+#define __NR_semtimedop 192
+__SYSCALL(__NR_semtimedop, sys_semtimedop)
+#define __NR_semop 193
+__SYSCALL(__NR_semop, sys_semop)
+
+/* ipc/shm.c */
+#define __NR_shmget 194
+__SYSCALL(__NR_shmget, sys_shmget)
+#define __NR_shmctl 195
+__SYSCALL(__NR_shmctl, sys_shmctl)
+#define __NR_shmat 196
+__SYSCALL(__NR_shmat, sys_shmat)
+#define __NR_shmdt 197
+__SYSCALL(__NR_shmdt, sys_shmdt)
+
+/* net/socket.c */
+#define __NR_socket 198
+__SYSCALL(__NR_socket, sys_socket)
+#define __NR_socketpair 199
+__SYSCALL(__NR_socketpair, sys_socketpair)
+#define __NR_bind 200
+__SYSCALL(__NR_bind, sys_bind)
+#define __NR_listen 201
+__SYSCALL(__NR_listen, sys_listen)
+#define __NR_accept 202
+__SYSCALL(__NR_accept, sys_accept)
+#define __NR_connect 203
+__SYSCALL(__NR_connect, sys_connect)
+#define __NR_getsockname 204
+__SYSCALL(__NR_getsockname, sys_getsockname)
+#define __NR_getpeername 205
+__SYSCALL(__NR_getpeername, sys_getpeername)
+#define __NR_sendto 206
+__SYSCALL(__NR_sendto, sys_sendto)
+#define __NR_recvfrom 207
+__SYSCALL(__NR_recvfrom, sys_recvfrom)
+#define __NR_setsockopt 208
+__SYSCALL(__NR_setsockopt, sys_setsockopt)
+#define __NR_getsockopt 209
+__SYSCALL(__NR_getsockopt, sys_getsockopt)
+#define __NR_shutdown 210
+__SYSCALL(__NR_shutdown, sys_shutdown)
+#define __NR_sendmsg 211
+__SYSCALL(__NR_sendmsg, sys_sendmsg)
+#define __NR_recvmsg 212
+__SYSCALL(__NR_recvmsg, sys_recvmsg)
+
+/* mm/filemap.c */
+#define __NR_readahead 213
+__SYSCALL(__NR_readahead, sys_readahead)
+
+/* mm/nommu.c, also with MMU */
+#define __NR_brk 214
+__SYSCALL(__NR_brk, sys_brk)
+#define __NR_munmap 215
+__SYSCALL(__NR_munmap, sys_munmap)
+#define __NR_mremap 216
+__SYSCALL(__NR_mremap, sys_mremap)
+
+/* security/keys/keyctl.c */
+#define __NR_add_key 217
+__SYSCALL(__NR_add_key, sys_add_key)
+#define __NR_request_key 218
+__SYSCALL(__NR_request_key, sys_request_key)
+#define __NR_keyctl 219
+__SYSCALL(__NR_keyctl, sys_keyctl)
+
+/* arch/example/kernel/sys_example.c */
+#define __NR_clone 220
+__SYSCALL(__NR_clone, sys_clone)	/* .long sys_clone_wrapper */
+#define __NR_execve 221
+__SYSCALL(__NR_execve, sys_execve)	/* .long sys_execve_wrapper */
+
+#define __NR3264_mmap 222
+__SC_3264(__NR3264_mmap, sys_mmap2, sys_mmap)
+/* mm/fadvise.c */
+#define __NR3264_fadvise64 223
+__SC_3264(__NR3264_fadvise64, sys_fadvise64_64, sys_fadvise64)
+
+/* mm/, CONFIG_MMU only */
+#ifndef __ARCH_NOMMU
+#define __NR_swapon 224
+__SYSCALL(__NR_swapon, sys_swapon)
+#define __NR_swapoff 225
+__SYSCALL(__NR_swapoff, sys_swapoff)
+#define __NR_mprotect 226
+__SYSCALL(__NR_mprotect, sys_mprotect)
+#define __NR_msync 227
+__SYSCALL(__NR_msync, sys_msync)
+#define __NR_mlock 228
+__SYSCALL(__NR_mlock, sys_mlock)
+#define __NR_munlock 229
+__SYSCALL(__NR_munlock, sys_munlock)
+#define __NR_mlockall 230
+__SYSCALL(__NR_mlockall, sys_mlockall)
+#define __NR_munlockall 231
+__SYSCALL(__NR_munlockall, sys_munlockall)
+#define __NR_mincore 232
+__SYSCALL(__NR_mincore, sys_mincore)
+#define __NR_madvise 233
+__SYSCALL(__NR_madvise, sys_madvise)
+#define __NR_remap_file_pages 234
+__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
+#define __NR_mbind 235
+__SYSCALL(__NR_mbind, sys_mbind)
+#define __NR_get_mempolicy 236
+__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)
+#define __NR_set_mempolicy 237
+__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)
+#define __NR_migrate_pages 238
+__SYSCALL(__NR_migrate_pages, sys_migrate_pages)
+#define __NR_move_pages 239
+__SYSCALL(__NR_move_pages, sys_move_pages)
+#endif
+
+#define __NR_rt_tgsigqueueinfo 240
+__SYSCALL(__NR_rt_tgsigqueueinfo, sys_rt_tgsigqueueinfo)
+#define __NR_perf_event_open 241
+__SYSCALL(__NR_perf_event_open, sys_perf_event_open)
+
+#undef __NR_syscalls
+#define __NR_syscalls 242
+
+/*
+ * All syscalls below here should go away really,
+ * these are provided for both review and as a porting
+ * help for the C library version.
+*
+ * Last chance: are any of these important enought to
+ * enable by default?
+ */
+#ifdef __ARCH_WANT_SYSCALL_NO_AT
+#define __NR_open 1024
+__SYSCALL(__NR_open, sys_open)
+#define __NR_link 1025
+__SYSCALL(__NR_link, sys_link)
+#define __NR_unlink 1026
+__SYSCALL(__NR_unlink, sys_unlink)
+#define __NR_mknod 1027
+__SYSCALL(__NR_mknod, sys_mknod)
+#define __NR_chmod 1028
+__SYSCALL(__NR_chmod, sys_chmod)
+#define __NR_chown 1029
+__SYSCALL(__NR_chown, sys_chown)
+#define __NR_mkdir 1030
+__SYSCALL(__NR_mkdir, sys_mkdir)
+#define __NR_rmdir 1031
+__SYSCALL(__NR_rmdir, sys_rmdir)
+#define __NR_lchown 1032
+__SYSCALL(__NR_lchown, sys_lchown)
+#define __NR_access 1033
+__SYSCALL(__NR_access, sys_access)
+#define __NR_rename 1034
+__SYSCALL(__NR_rename, sys_rename)
+#define __NR_readlink 1035
+__SYSCALL(__NR_readlink, sys_readlink)
+#define __NR_symlink 1036
+__SYSCALL(__NR_symlink, sys_symlink)
+#define __NR_utimes 1037
+__SYSCALL(__NR_utimes, sys_utimes)
+#define __NR3264_stat 1038
+__SC_3264(__NR3264_stat, sys_stat64, sys_newstat)
+#define __NR3264_lstat 1039
+__SC_3264(__NR3264_lstat, sys_lstat64, sys_newlstat)
+
+#undef __NR_syscalls
+#define __NR_syscalls (__NR3264_lstat+1)
+#endif /* __ARCH_WANT_SYSCALL_NO_AT */
+
+#ifdef __ARCH_WANT_SYSCALL_NO_FLAGS
+#define __NR_pipe 1040
+__SYSCALL(__NR_pipe, sys_pipe)
+#define __NR_dup2 1041
+__SYSCALL(__NR_dup2, sys_dup2)
+#define __NR_epoll_create 1042
+__SYSCALL(__NR_epoll_create, sys_epoll_create)
+#define __NR_inotify_init 1043
+__SYSCALL(__NR_inotify_init, sys_inotify_init)
+#define __NR_eventfd 1044
+__SYSCALL(__NR_eventfd, sys_eventfd)
+#define __NR_signalfd 1045
+__SYSCALL(__NR_signalfd, sys_signalfd)
+
+#undef __NR_syscalls
+#define __NR_syscalls (__NR_signalfd+1)
+#endif /* __ARCH_WANT_SYSCALL_NO_FLAGS */
+
+#if __BITS_PER_LONG == 32 && defined(__ARCH_WANT_SYSCALL_OFF_T)
+#define __NR_sendfile 1046
+__SYSCALL(__NR_sendfile, sys_sendfile)
+#define __NR_ftruncate 1047
+__SYSCALL(__NR_ftruncate, sys_ftruncate)
+#define __NR_truncate 1048
+__SYSCALL(__NR_truncate, sys_truncate)
+#define __NR_stat 1049
+__SYSCALL(__NR_stat, sys_newstat)
+#define __NR_lstat 1050
+__SYSCALL(__NR_lstat, sys_newlstat)
+#define __NR_fstat 1051
+__SYSCALL(__NR_fstat, sys_newfstat)
+#define __NR_fcntl 1052
+__SYSCALL(__NR_fcntl, sys_fcntl)
+#define __NR_fadvise64 1053
+#define __ARCH_WANT_SYS_FADVISE64
+__SYSCALL(__NR_fadvise64, sys_fadvise64)
+#define __NR_newfstatat 1054
+#define __ARCH_WANT_SYS_NEWFSTATAT
+__SYSCALL(__NR_newfstatat, sys_newfstatat)
+#define __NR_fstatfs 1055
+__SYSCALL(__NR_fstatfs, sys_fstatfs)
+#define __NR_statfs 1056
+__SYSCALL(__NR_statfs, sys_statfs)
+#define __NR_lseek 1057
+__SYSCALL(__NR_lseek, sys_lseek)
+#define __NR_mmap 1058
+__SYSCALL(__NR_mmap, sys_mmap)
+
+#undef __NR_syscalls
+#define __NR_syscalls (__NR_mmap+1)
+#endif /* 32 bit off_t syscalls */
+
+#ifdef __ARCH_WANT_SYSCALL_DEPRECATED
+#define __NR_alarm 1059
+#define __ARCH_WANT_SYS_ALARM
+__SYSCALL(__NR_alarm, sys_alarm)
+#define __NR_getpgrp 1060
+#define __ARCH_WANT_SYS_GETPGRP
+__SYSCALL(__NR_getpgrp, sys_getpgrp)
+#define __NR_pause 1061
+#define __ARCH_WANT_SYS_PAUSE
+__SYSCALL(__NR_pause, sys_pause)
+#define __NR_time 1062
+#define __ARCH_WANT_SYS_TIME
+__SYSCALL(__NR_time, sys_time)
+#define __NR_utime 1063
+#define __ARCH_WANT_SYS_UTIME
+__SYSCALL(__NR_utime, sys_utime)
+
+#define __NR_creat 1064
+__SYSCALL(__NR_creat, sys_creat)
+#define __NR_getdents 1065
+#define __ARCH_WANT_SYS_GETDENTS
+__SYSCALL(__NR_getdents, sys_getdents)
+#define __NR_futimesat 1066
+__SYSCALL(__NR_futimesat, sys_futimesat)
+#define __NR_select 1067
+#define __ARCH_WANT_SYS_SELECT
+__SYSCALL(__NR_select, sys_select)
+#define __NR_poll 1068
+__SYSCALL(__NR_poll, sys_poll)
+#define __NR_epoll_wait 1069
+__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_ustat 1070
+__SYSCALL(__NR_ustat, sys_ustat)
+#define __NR_vfork 1071
+__SYSCALL(__NR_vfork, sys_vfork)
+#define __NR_wait4 1072
+__SYSCALL(__NR_wait4, sys_wait4)
+#define __NR_recv 1073
+__SYSCALL(__NR_recv, sys_recv)
+#define __NR_send 1074
+__SYSCALL(__NR_send, sys_send)
+#define __NR_bdflush 1075
+__SYSCALL(__NR_bdflush, sys_bdflush)
+#define __NR_umount 1076
+__SYSCALL(__NR_umount, sys_oldumount)
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __NR_uselib 1077
+__SYSCALL(__NR_uselib, sys_uselib)
+#define __NR__sysctl 1078
+__SYSCALL(__NR__sysctl, sys_sysctl)
+
+#define __NR_fork 1079
+#ifdef CONFIG_MMU
+__SYSCALL(__NR_fork, sys_fork)
+#else
+__SYSCALL(__NR_fork, sys_ni_syscall)
+#endif /* CONFIG_MMU */
+
+#undef __NR_syscalls
+#define __NR_syscalls (__NR_fork+1)
+
+#endif /* __ARCH_WANT_SYSCALL_DEPRECATED */
+
+/*
+ * 32 bit systems traditionally used different
+ * syscalls for off_t and loff_t arguments, while
+ * 64 bit systems only need the off_t version.
+ * For new 32 bit platforms, there is no need to
+ * implement the old 32 bit off_t syscalls, so
+ * they take different names.
+ * Here we map the numbers so that both versions
+ * use the same syscall table layout.
+ */
+#if __BITS_PER_LONG == 64
+#define __NR_fcntl __NR3264_fcntl
+#define __NR_statfs __NR3264_statfs
+#define __NR_fstatfs __NR3264_fstatfs
+#define __NR_truncate __NR3264_truncate
+#define __NR_ftruncate __NR3264_truncate
+#define __NR_lseek __NR3264_lseek
+#define __NR_sendfile __NR3264_sendfile
+#define __NR_newfstatat __NR3264_fstatat
+#define __NR_fstat __NR3264_fstat
+#define __NR_mmap __NR3264_mmap
+#define __NR_fadvise64 __NR3264_fadvise64
+#ifdef __NR3264_stat
+#define __NR_stat __NR3264_stat
+#define __NR_lstat __NR3264_lstat
+#endif
+#else
+#define __NR_fcntl64 __NR3264_fcntl
+#define __NR_statfs64 __NR3264_statfs
+#define __NR_fstatfs64 __NR3264_fstatfs
+#define __NR_truncate64 __NR3264_truncate
+#define __NR_ftruncate64 __NR3264_truncate
+#define __NR_llseek __NR3264_lseek
+#define __NR_sendfile64 __NR3264_sendfile
+#define __NR_fstatat64 __NR3264_fstatat
+#define __NR_fstat64 __NR3264_fstat
+#define __NR_mmap2 __NR3264_mmap
+#define __NR_fadvise64_64 __NR3264_fadvise64
+#ifdef __NR3264_stat
+#define __NR_stat64 __NR3264_stat
+#define __NR_lstat64 __NR3264_lstat
+#endif
+#endif
+
+#endif /* _ASM_GENERIC_UNISTD_H */
diff -uNr linux-2.6.32/usr/include/drm/drm.h clean_modified/linux-2.6.32/usr/include/drm/drm.h
--- linux-2.6.32/usr/include/drm/drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/drm.h	2019-04-14 13:24:02.886652997 -0500
@@ -0,0 +1,744 @@
+/**
+ * \file drm.h
+ * Header for the Direct Rendering Manager
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ * \par Acknowledgments:
+ * Dec 1999, Richard Henderson <rth@twiddle.net>, move to generic \c cmpxchg.
+ */
+
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_H_
+#define _DRM_H_
+
+#include <linux/types.h>
+#include <asm/ioctl.h>		/* For _IO* macros */
+#define DRM_IOCTL_NR(n)		_IOC_NR(n)
+#define DRM_IOC_VOID		_IOC_NONE
+#define DRM_IOC_READ		_IOC_READ
+#define DRM_IOC_WRITE		_IOC_WRITE
+#define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+
+#define DRM_MAJOR       226
+#define DRM_MAX_MINOR   15
+
+#define DRM_NAME	"drm"	  /**< Name in kernel, /dev, and /proc */
+#define DRM_MIN_ORDER	5	  /**< At least 2^5 bytes = 32 bytes */
+#define DRM_MAX_ORDER	22	  /**< Up to 2^22 bytes = 4MB */
+#define DRM_RAM_PERCENT 10	  /**< How much system ram can we lock? */
+
+#define _DRM_LOCK_HELD	0x80000000U /**< Hardware lock is held */
+#define _DRM_LOCK_CONT	0x40000000U /**< Hardware lock is contended */
+#define _DRM_LOCK_IS_HELD(lock)	   ((lock) & _DRM_LOCK_HELD)
+#define _DRM_LOCK_IS_CONT(lock)	   ((lock) & _DRM_LOCK_CONT)
+#define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
+
+typedef unsigned int drm_handle_t;
+typedef unsigned int drm_context_t;
+typedef unsigned int drm_drawable_t;
+typedef unsigned int drm_magic_t;
+
+/**
+ * Cliprect.
+ *
+ * \warning: If you change this structure, make sure you change
+ * XF86DRIClipRectRec in the server as well
+ *
+ * \note KW: Actually it's illegal to change either for
+ * backwards-compatibility reasons.
+ */
+struct drm_clip_rect {
+	unsigned short x1;
+	unsigned short y1;
+	unsigned short x2;
+	unsigned short y2;
+};
+
+/**
+ * Drawable information.
+ */
+struct drm_drawable_info {
+	unsigned int num_rects;
+	struct drm_clip_rect *rects;
+};
+
+/**
+ * Texture region,
+ */
+struct drm_tex_region {
+	unsigned char next;
+	unsigned char prev;
+	unsigned char in_use;
+	unsigned char padding;
+	unsigned int age;
+};
+
+/**
+ * Hardware lock.
+ *
+ * The lock structure is a simple cache-line aligned integer.  To avoid
+ * processor bus contention on a multiprocessor system, there should not be any
+ * other data stored in the same cache line.
+ */
+struct drm_hw_lock {
+	__volatile__ unsigned int lock;		/**< lock variable */
+	char padding[60];			/**< Pad to cache line */
+};
+
+/**
+ * DRM_IOCTL_VERSION ioctl argument type.
+ *
+ * \sa drmGetVersion().
+ */
+struct drm_version {
+	int version_major;	  /**< Major version */
+	int version_minor;	  /**< Minor version */
+	int version_patchlevel;	  /**< Patch level */
+	size_t name_len;	  /**< Length of name buffer */
+	char *name;	  /**< Name of driver */
+	size_t date_len;	  /**< Length of date buffer */
+	char *date;	  /**< User-space buffer to hold date */
+	size_t desc_len;	  /**< Length of desc buffer */
+	char *desc;	  /**< User-space buffer to hold desc */
+};
+
+/**
+ * DRM_IOCTL_GET_UNIQUE ioctl argument type.
+ *
+ * \sa drmGetBusid() and drmSetBusId().
+ */
+struct drm_unique {
+	size_t unique_len;	  /**< Length of unique */
+	char *unique;	  /**< Unique name for driver instantiation */
+};
+
+struct drm_list {
+	int count;		  /**< Length of user-space structures */
+	struct drm_version *version;
+};
+
+struct drm_block {
+	int unused;
+};
+
+/**
+ * DRM_IOCTL_CONTROL ioctl argument type.
+ *
+ * \sa drmCtlInstHandler() and drmCtlUninstHandler().
+ */
+struct drm_control {
+	enum {
+		DRM_ADD_COMMAND,
+		DRM_RM_COMMAND,
+		DRM_INST_HANDLER,
+		DRM_UNINST_HANDLER
+	} func;
+	int irq;
+};
+
+/**
+ * Type of memory to map.
+ */
+enum drm_map_type {
+	_DRM_FRAME_BUFFER = 0,	  /**< WC (no caching), no core dump */
+	_DRM_REGISTERS = 1,	  /**< no caching, no core dump */
+	_DRM_SHM = 2,		  /**< shared, cached */
+	_DRM_AGP = 3,		  /**< AGP/GART */
+	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
+	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
+	_DRM_GEM = 6,		  /**< GEM object */
+};
+
+/**
+ * Memory mapping flags.
+ */
+enum drm_map_flags {
+	_DRM_RESTRICTED = 0x01,	     /**< Cannot be mapped to user-virtual */
+	_DRM_READ_ONLY = 0x02,
+	_DRM_LOCKED = 0x04,	     /**< shared, cached, locked */
+	_DRM_KERNEL = 0x08,	     /**< kernel requires access */
+	_DRM_WRITE_COMBINING = 0x10, /**< use write-combining if available */
+	_DRM_CONTAINS_LOCK = 0x20,   /**< SHM page that contains lock */
+	_DRM_REMOVABLE = 0x40,	     /**< Removable mapping */
+	_DRM_DRIVER = 0x80	     /**< Managed by driver */
+};
+
+struct drm_ctx_priv_map {
+	unsigned int ctx_id;	 /**< Context requesting private mapping */
+	void *handle;		 /**< Handle of map */
+};
+
+/**
+ * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
+ * argument type.
+ *
+ * \sa drmAddMap().
+ */
+struct drm_map {
+	unsigned long offset;	 /**< Requested physical address (0 for SAREA)*/
+	unsigned long size;	 /**< Requested physical size (bytes) */
+	enum drm_map_type type;	 /**< Type of memory to map */
+	enum drm_map_flags flags;	 /**< Flags */
+	void *handle;		 /**< User-space: "Handle" to pass to mmap() */
+				 /**< Kernel-space: kernel-virtual address */
+	int mtrr;		 /**< MTRR slot used */
+	/*   Private data */
+};
+
+/**
+ * DRM_IOCTL_GET_CLIENT ioctl argument type.
+ */
+struct drm_client {
+	int idx;		/**< Which client desired? */
+	int auth;		/**< Is client authenticated? */
+	unsigned long pid;	/**< Process ID */
+	unsigned long uid;	/**< User ID */
+	unsigned long magic;	/**< Magic */
+	unsigned long iocs;	/**< Ioctl count */
+};
+
+enum drm_stat_type {
+	_DRM_STAT_LOCK,
+	_DRM_STAT_OPENS,
+	_DRM_STAT_CLOSES,
+	_DRM_STAT_IOCTLS,
+	_DRM_STAT_LOCKS,
+	_DRM_STAT_UNLOCKS,
+	_DRM_STAT_VALUE,	/**< Generic value */
+	_DRM_STAT_BYTE,		/**< Generic byte counter (1024bytes/K) */
+	_DRM_STAT_COUNT,	/**< Generic non-byte counter (1000/k) */
+
+	_DRM_STAT_IRQ,		/**< IRQ */
+	_DRM_STAT_PRIMARY,	/**< Primary DMA bytes */
+	_DRM_STAT_SECONDARY,	/**< Secondary DMA bytes */
+	_DRM_STAT_DMA,		/**< DMA */
+	_DRM_STAT_SPECIAL,	/**< Special DMA (e.g., priority or polled) */
+	_DRM_STAT_MISSED	/**< Missed DMA opportunity */
+	    /* Add to the *END* of the list */
+};
+
+/**
+ * DRM_IOCTL_GET_STATS ioctl argument type.
+ */
+struct drm_stats {
+	unsigned long count;
+	struct {
+		unsigned long value;
+		enum drm_stat_type type;
+	} data[15];
+};
+
+/**
+ * Hardware locking flags.
+ */
+enum drm_lock_flags {
+	_DRM_LOCK_READY = 0x01,	     /**< Wait until hardware is ready for DMA */
+	_DRM_LOCK_QUIESCENT = 0x02,  /**< Wait until hardware quiescent */
+	_DRM_LOCK_FLUSH = 0x04,	     /**< Flush this context's DMA queue first */
+	_DRM_LOCK_FLUSH_ALL = 0x08,  /**< Flush all DMA queues first */
+	/* These *HALT* flags aren't supported yet
+	   -- they will be used to support the
+	   full-screen DGA-like mode. */
+	_DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
+	_DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
+};
+
+/**
+ * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
+ *
+ * \sa drmGetLock() and drmUnlock().
+ */
+struct drm_lock {
+	int context;
+	enum drm_lock_flags flags;
+};
+
+/**
+ * DMA flags
+ *
+ * \warning
+ * These values \e must match xf86drm.h.
+ *
+ * \sa drm_dma.
+ */
+enum drm_dma_flags {
+	/* Flags for DMA buffer dispatch */
+	_DRM_DMA_BLOCK = 0x01,	      /**<
+				       * Block until buffer dispatched.
+				       *
+				       * \note The buffer may not yet have
+				       * been processed by the hardware --
+				       * getting a hardware lock with the
+				       * hardware quiescent will ensure
+				       * that the buffer has been
+				       * processed.
+				       */
+	_DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
+	_DRM_DMA_PRIORITY = 0x04,     /**< High priority dispatch */
+
+	/* Flags for DMA buffer request */
+	_DRM_DMA_WAIT = 0x10,	      /**< Wait for free buffers */
+	_DRM_DMA_SMALLER_OK = 0x20,   /**< Smaller-than-requested buffers OK */
+	_DRM_DMA_LARGER_OK = 0x40     /**< Larger-than-requested buffers OK */
+};
+
+/**
+ * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
+ *
+ * \sa drmAddBufs().
+ */
+struct drm_buf_desc {
+	int count;		 /**< Number of buffers of this size */
+	int size;		 /**< Size in bytes */
+	int low_mark;		 /**< Low water mark */
+	int high_mark;		 /**< High water mark */
+	enum {
+		_DRM_PAGE_ALIGN = 0x01,	/**< Align on page boundaries for DMA */
+		_DRM_AGP_BUFFER = 0x02,	/**< Buffer is in AGP space */
+		_DRM_SG_BUFFER = 0x04,	/**< Scatter/gather memory buffer */
+		_DRM_FB_BUFFER = 0x08,	/**< Buffer is in frame buffer */
+		_DRM_PCI_BUFFER_RO = 0x10 /**< Map PCI DMA buffer read-only */
+	} flags;
+	unsigned long agp_start; /**<
+				  * Start address of where the AGP buffers are
+				  * in the AGP aperture
+				  */
+};
+
+/**
+ * DRM_IOCTL_INFO_BUFS ioctl argument type.
+ */
+struct drm_buf_info {
+	int count;		/**< Entries in list */
+	struct drm_buf_desc *list;
+};
+
+/**
+ * DRM_IOCTL_FREE_BUFS ioctl argument type.
+ */
+struct drm_buf_free {
+	int count;
+	int *list;
+};
+
+/**
+ * Buffer information
+ *
+ * \sa drm_buf_map.
+ */
+struct drm_buf_pub {
+	int idx;		       /**< Index into the master buffer list */
+	int total;		       /**< Buffer size */
+	int used;		       /**< Amount of buffer in use (for DMA) */
+	void *address;	       /**< Address of buffer */
+};
+
+/**
+ * DRM_IOCTL_MAP_BUFS ioctl argument type.
+ */
+struct drm_buf_map {
+	int count;		/**< Length of the buffer list */
+	void *virtual;		/**< Mmap'd area in user-virtual */
+	struct drm_buf_pub *list;	/**< Buffer information */
+};
+
+/**
+ * DRM_IOCTL_DMA ioctl argument type.
+ *
+ * Indices here refer to the offset into the buffer list in drm_buf_get.
+ *
+ * \sa drmDMA().
+ */
+struct drm_dma {
+	int context;			  /**< Context handle */
+	int send_count;			  /**< Number of buffers to send */
+	int *send_indices;	  /**< List of handles to buffers */
+	int *send_sizes;		  /**< Lengths of data to send */
+	enum drm_dma_flags flags;	  /**< Flags */
+	int request_count;		  /**< Number of buffers requested */
+	int request_size;		  /**< Desired size for buffers */
+	int *request_indices;	  /**< Buffer information */
+	int *request_sizes;
+	int granted_count;		  /**< Number of buffers granted */
+};
+
+enum drm_ctx_flags {
+	_DRM_CONTEXT_PRESERVED = 0x01,
+	_DRM_CONTEXT_2DONLY = 0x02
+};
+
+/**
+ * DRM_IOCTL_ADD_CTX ioctl argument type.
+ *
+ * \sa drmCreateContext() and drmDestroyContext().
+ */
+struct drm_ctx {
+	drm_context_t handle;
+	enum drm_ctx_flags flags;
+};
+
+/**
+ * DRM_IOCTL_RES_CTX ioctl argument type.
+ */
+struct drm_ctx_res {
+	int count;
+	struct drm_ctx *contexts;
+};
+
+/**
+ * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
+ */
+struct drm_draw {
+	drm_drawable_t handle;
+};
+
+/**
+ * DRM_IOCTL_UPDATE_DRAW ioctl argument type.
+ */
+typedef enum {
+	DRM_DRAWABLE_CLIPRECTS,
+} drm_drawable_info_type_t;
+
+struct drm_update_draw {
+	drm_drawable_t handle;
+	unsigned int type;
+	unsigned int num;
+	unsigned long long data;
+};
+
+/**
+ * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
+ */
+struct drm_auth {
+	drm_magic_t magic;
+};
+
+/**
+ * DRM_IOCTL_IRQ_BUSID ioctl argument type.
+ *
+ * \sa drmGetInterruptFromBusID().
+ */
+struct drm_irq_busid {
+	int irq;	/**< IRQ number */
+	int busnum;	/**< bus number */
+	int devnum;	/**< device number */
+	int funcnum;	/**< function number */
+};
+
+enum drm_vblank_seq_type {
+	_DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+	_DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+	_DRM_VBLANK_FLIP = 0x8000000,   /**< Scheduled buffer swap should flip */
+	_DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
+	_DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
+	_DRM_VBLANK_SIGNAL = 0x40000000	/**< Send signal instead of blocking, unsupported */
+};
+
+#define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)
+#define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_SIGNAL | _DRM_VBLANK_SECONDARY | \
+				_DRM_VBLANK_NEXTONMISS)
+
+struct drm_wait_vblank_request {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	unsigned long signal;
+};
+
+struct drm_wait_vblank_reply {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+};
+
+/**
+ * DRM_IOCTL_WAIT_VBLANK ioctl argument type.
+ *
+ * \sa drmWaitVBlank().
+ */
+union drm_wait_vblank {
+	struct drm_wait_vblank_request request;
+	struct drm_wait_vblank_reply reply;
+};
+
+#define _DRM_PRE_MODESET 1
+#define _DRM_POST_MODESET 2
+
+/**
+ * DRM_IOCTL_MODESET_CTL ioctl argument type
+ *
+ * \sa drmModesetCtl().
+ */
+struct drm_modeset_ctl {
+	__u32 crtc;
+	__u32 cmd;
+};
+
+/**
+ * DRM_IOCTL_AGP_ENABLE ioctl argument type.
+ *
+ * \sa drmAgpEnable().
+ */
+struct drm_agp_mode {
+	unsigned long mode;	/**< AGP mode */
+};
+
+/**
+ * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
+ *
+ * \sa drmAgpAlloc() and drmAgpFree().
+ */
+struct drm_agp_buffer {
+	unsigned long size;	/**< In bytes -- will round to page boundary */
+	unsigned long handle;	/**< Used for binding / unbinding */
+	unsigned long type;	/**< Type of memory to allocate */
+	unsigned long physical;	/**< Physical used by i810 */
+};
+
+/**
+ * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
+ *
+ * \sa drmAgpBind() and drmAgpUnbind().
+ */
+struct drm_agp_binding {
+	unsigned long handle;	/**< From drm_agp_buffer */
+	unsigned long offset;	/**< In bytes -- will round to page boundary */
+};
+
+/**
+ * DRM_IOCTL_AGP_INFO ioctl argument type.
+ *
+ * \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),
+ * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
+ * drmAgpVendorId() and drmAgpDeviceId().
+ */
+struct drm_agp_info {
+	int agp_version_major;
+	int agp_version_minor;
+	unsigned long mode;
+	unsigned long aperture_base;	/* physical address */
+	unsigned long aperture_size;	/* bytes */
+	unsigned long memory_allowed;	/* bytes */
+	unsigned long memory_used;
+
+	/* PCI information */
+	unsigned short id_vendor;
+	unsigned short id_device;
+};
+
+/**
+ * DRM_IOCTL_SG_ALLOC ioctl argument type.
+ */
+struct drm_scatter_gather {
+	unsigned long size;	/**< In bytes -- will round to page boundary */
+	unsigned long handle;	/**< Used for mapping / unmapping */
+};
+
+/**
+ * DRM_IOCTL_SET_VERSION ioctl argument type.
+ */
+struct drm_set_version {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+};
+
+/** DRM_IOCTL_GEM_CLOSE ioctl argument type */
+struct drm_gem_close {
+	/** Handle of the object to be closed. */
+	__u32 handle;
+	__u32 pad;
+};
+
+/** DRM_IOCTL_GEM_FLINK ioctl argument type */
+struct drm_gem_flink {
+	/** Handle for the object being named */
+	__u32 handle;
+
+	/** Returned global name */
+	__u32 name;
+};
+
+/** DRM_IOCTL_GEM_OPEN ioctl argument type */
+struct drm_gem_open {
+	/** Name of object being opened */
+	__u32 name;
+
+	/** Returned handle for the object */
+	__u32 handle;
+
+	/** Returned size of the object */
+	__u64 size;
+};
+
+#include "drm_mode.h"
+
+#define DRM_IOCTL_BASE			'd'
+#define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
+#define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)
+
+#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)
+#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)
+#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)
+#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)
+#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)
+#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)
+#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)
+#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)
+#define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)
+#define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)
+#define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)
+#define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)
+
+#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)
+#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)
+#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)
+#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)
+#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)
+#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)
+#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)
+#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)
+#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)
+#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)
+#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)
+
+#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)
+
+#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)
+#define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, struct drm_ctx_priv_map)
+
+#define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)
+#define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)
+
+#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)
+#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)
+#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)
+#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)
+#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)
+#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)
+#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)
+#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)
+#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)
+#define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)
+#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)
+#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)
+#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)
+
+#define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
+#define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
+#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)
+#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)
+#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)
+
+#define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)
+#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)
+
+#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)
+
+#define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)
+
+#define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)
+#define DRM_IOCTL_MODE_GETCRTC		DRM_IOWR(0xA1, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)
+#define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)
+#define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)
+#define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)
+#define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)
+#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)
+
+#define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)
+#define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)
+#define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)
+#define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, unsigned int)
+
+/**
+ * Device specific ioctls should only be in their respective headers
+ * The device specific ioctl range is from 0x40 to 0x99.
+ * Generic IOCTLS restart at 0xA0.
+ *
+ * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and
+ * drmCommandReadWrite().
+ */
+#define DRM_COMMAND_BASE                0x40
+#define DRM_COMMAND_END			0xA0
+
+/* typedef area */
+typedef struct drm_clip_rect drm_clip_rect_t;
+typedef struct drm_drawable_info drm_drawable_info_t;
+typedef struct drm_tex_region drm_tex_region_t;
+typedef struct drm_hw_lock drm_hw_lock_t;
+typedef struct drm_version drm_version_t;
+typedef struct drm_unique drm_unique_t;
+typedef struct drm_list drm_list_t;
+typedef struct drm_block drm_block_t;
+typedef struct drm_control drm_control_t;
+typedef enum drm_map_type drm_map_type_t;
+typedef enum drm_map_flags drm_map_flags_t;
+typedef struct drm_ctx_priv_map drm_ctx_priv_map_t;
+typedef struct drm_map drm_map_t;
+typedef struct drm_client drm_client_t;
+typedef enum drm_stat_type drm_stat_type_t;
+typedef struct drm_stats drm_stats_t;
+typedef enum drm_lock_flags drm_lock_flags_t;
+typedef struct drm_lock drm_lock_t;
+typedef enum drm_dma_flags drm_dma_flags_t;
+typedef struct drm_buf_desc drm_buf_desc_t;
+typedef struct drm_buf_info drm_buf_info_t;
+typedef struct drm_buf_free drm_buf_free_t;
+typedef struct drm_buf_pub drm_buf_pub_t;
+typedef struct drm_buf_map drm_buf_map_t;
+typedef struct drm_dma drm_dma_t;
+typedef union drm_wait_vblank drm_wait_vblank_t;
+typedef struct drm_agp_mode drm_agp_mode_t;
+typedef enum drm_ctx_flags drm_ctx_flags_t;
+typedef struct drm_ctx drm_ctx_t;
+typedef struct drm_ctx_res drm_ctx_res_t;
+typedef struct drm_draw drm_draw_t;
+typedef struct drm_update_draw drm_update_draw_t;
+typedef struct drm_auth drm_auth_t;
+typedef struct drm_irq_busid drm_irq_busid_t;
+typedef enum drm_vblank_seq_type drm_vblank_seq_type_t;
+
+typedef struct drm_agp_buffer drm_agp_buffer_t;
+typedef struct drm_agp_binding drm_agp_binding_t;
+typedef struct drm_agp_info drm_agp_info_t;
+typedef struct drm_scatter_gather drm_scatter_gather_t;
+typedef struct drm_set_version drm_set_version_t;
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/drm_mode.h clean_modified/linux-2.6.32/usr/include/drm/drm_mode.h
--- linux-2.6.32/usr/include/drm/drm_mode.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/drm_mode.h	2019-04-14 13:24:02.892473657 -0500
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (c) 2007 Jakob Bornecrantz <wallbraker@gmail.com>
+ * Copyright (c) 2008 Red Hat Inc.
+ * Copyright (c) 2007-2008 Tungsten Graphics, Inc., Cedar Park, TX., USA
+ * Copyright (c) 2007-2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_MODE_H
+#define _DRM_MODE_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#define DRM_DISPLAY_INFO_LEN	32
+#define DRM_CONNECTOR_NAME_LEN	32
+#define DRM_DISPLAY_MODE_LEN	32
+#define DRM_PROP_NAME_LEN	32
+
+#define DRM_MODE_TYPE_BUILTIN	(1<<0)
+#define DRM_MODE_TYPE_CLOCK_C	((1<<1) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_CRTC_C	((1<<2) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_PREFERRED	(1<<3)
+#define DRM_MODE_TYPE_DEFAULT	(1<<4)
+#define DRM_MODE_TYPE_USERDEF	(1<<5)
+#define DRM_MODE_TYPE_DRIVER	(1<<6)
+
+/* Video mode flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_FLAG_PHSYNC	(1<<0)
+#define DRM_MODE_FLAG_NHSYNC	(1<<1)
+#define DRM_MODE_FLAG_PVSYNC	(1<<2)
+#define DRM_MODE_FLAG_NVSYNC	(1<<3)
+#define DRM_MODE_FLAG_INTERLACE	(1<<4)
+#define DRM_MODE_FLAG_DBLSCAN	(1<<5)
+#define DRM_MODE_FLAG_CSYNC	(1<<6)
+#define DRM_MODE_FLAG_PCSYNC	(1<<7)
+#define DRM_MODE_FLAG_NCSYNC	(1<<8)
+#define DRM_MODE_FLAG_HSKEW	(1<<9) /* hskew provided */
+#define DRM_MODE_FLAG_BCAST	(1<<10)
+#define DRM_MODE_FLAG_PIXMUX	(1<<11)
+#define DRM_MODE_FLAG_DBLCLK	(1<<12)
+#define DRM_MODE_FLAG_CLKDIV2	(1<<13)
+
+/* DPMS flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_DPMS_ON	0
+#define DRM_MODE_DPMS_STANDBY	1
+#define DRM_MODE_DPMS_SUSPEND	2
+#define DRM_MODE_DPMS_OFF	3
+
+/* Scaling mode options */
+#define DRM_MODE_SCALE_NONE		0 /* Unmodified timing (display or
+					     software can still scale) */
+#define DRM_MODE_SCALE_FULLSCREEN	1 /* Full screen, ignore aspect */
+#define DRM_MODE_SCALE_CENTER		2 /* Centered, no scaling */
+#define DRM_MODE_SCALE_ASPECT		3 /* Full screen, preserve aspect */
+
+/* Dithering mode options */
+#define DRM_MODE_DITHERING_OFF	0
+#define DRM_MODE_DITHERING_ON	1
+
+struct drm_mode_modeinfo {
+	__u32 clock;
+	__u16 hdisplay, hsync_start, hsync_end, htotal, hskew;
+	__u16 vdisplay, vsync_start, vsync_end, vtotal, vscan;
+
+	__u32 vrefresh; /* vertical refresh * 1000 */
+
+	__u32 flags;
+	__u32 type;
+	char name[DRM_DISPLAY_MODE_LEN];
+};
+
+struct drm_mode_card_res {
+	__u64 fb_id_ptr;
+	__u64 crtc_id_ptr;
+	__u64 connector_id_ptr;
+	__u64 encoder_id_ptr;
+	__u32 count_fbs;
+	__u32 count_crtcs;
+	__u32 count_connectors;
+	__u32 count_encoders;
+	__u32 min_width, max_width;
+	__u32 min_height, max_height;
+};
+
+struct drm_mode_crtc {
+	__u64 set_connectors_ptr;
+	__u32 count_connectors;
+
+	__u32 crtc_id; /**< Id */
+	__u32 fb_id; /**< Id of framebuffer */
+
+	__u32 x, y; /**< Position on the frameuffer */
+
+	__u32 gamma_size;
+	__u32 mode_valid;
+	struct drm_mode_modeinfo mode;
+};
+
+#define DRM_MODE_ENCODER_NONE	0
+#define DRM_MODE_ENCODER_DAC	1
+#define DRM_MODE_ENCODER_TMDS	2
+#define DRM_MODE_ENCODER_LVDS	3
+#define DRM_MODE_ENCODER_TVDAC	4
+
+struct drm_mode_get_encoder {
+	__u32 encoder_id;
+	__u32 encoder_type;
+
+	__u32 crtc_id; /**< Id of crtc */
+
+	__u32 possible_crtcs;
+	__u32 possible_clones;
+};
+
+/* This is for connectors with multiple signal types. */
+/* Try to match DRM_MODE_CONNECTOR_X as closely as possible. */
+#define DRM_MODE_SUBCONNECTOR_Automatic	0
+#define DRM_MODE_SUBCONNECTOR_Unknown	0
+#define DRM_MODE_SUBCONNECTOR_DVID	3
+#define DRM_MODE_SUBCONNECTOR_DVIA	4
+#define DRM_MODE_SUBCONNECTOR_Composite	5
+#define DRM_MODE_SUBCONNECTOR_SVIDEO	6
+#define DRM_MODE_SUBCONNECTOR_Component	8
+#define DRM_MODE_SUBCONNECTOR_SCART	9
+
+#define DRM_MODE_CONNECTOR_Unknown	0
+#define DRM_MODE_CONNECTOR_VGA		1
+#define DRM_MODE_CONNECTOR_DVII		2
+#define DRM_MODE_CONNECTOR_DVID		3
+#define DRM_MODE_CONNECTOR_DVIA		4
+#define DRM_MODE_CONNECTOR_Composite	5
+#define DRM_MODE_CONNECTOR_SVIDEO	6
+#define DRM_MODE_CONNECTOR_LVDS		7
+#define DRM_MODE_CONNECTOR_Component	8
+#define DRM_MODE_CONNECTOR_9PinDIN	9
+#define DRM_MODE_CONNECTOR_DisplayPort	10
+#define DRM_MODE_CONNECTOR_HDMIA	11
+#define DRM_MODE_CONNECTOR_HDMIB	12
+#define DRM_MODE_CONNECTOR_TV		13
+
+struct drm_mode_get_connector {
+
+	__u64 encoders_ptr;
+	__u64 modes_ptr;
+	__u64 props_ptr;
+	__u64 prop_values_ptr;
+
+	__u32 count_modes;
+	__u32 count_props;
+	__u32 count_encoders;
+
+	__u32 encoder_id; /**< Current Encoder */
+	__u32 connector_id; /**< Id */
+	__u32 connector_type;
+	__u32 connector_type_id;
+
+	__u32 connection;
+	__u32 mm_width, mm_height; /**< HxW in millimeters */
+	__u32 subpixel;
+};
+
+#define DRM_MODE_PROP_PENDING	(1<<0)
+#define DRM_MODE_PROP_RANGE	(1<<1)
+#define DRM_MODE_PROP_IMMUTABLE	(1<<2)
+#define DRM_MODE_PROP_ENUM	(1<<3) /* enumerated type with text strings */
+#define DRM_MODE_PROP_BLOB	(1<<4)
+
+struct drm_mode_property_enum {
+	__u64 value;
+	char name[DRM_PROP_NAME_LEN];
+};
+
+struct drm_mode_get_property {
+	__u64 values_ptr; /* values and blob lengths */
+	__u64 enum_blob_ptr; /* enum and blob id ptrs */
+
+	__u32 prop_id;
+	__u32 flags;
+	char name[DRM_PROP_NAME_LEN];
+
+	__u32 count_values;
+	__u32 count_enum_blobs;
+};
+
+struct drm_mode_connector_set_property {
+	__u64 value;
+	__u32 prop_id;
+	__u32 connector_id;
+};
+
+struct drm_mode_get_blob {
+	__u32 blob_id;
+	__u32 length;
+	__u64 data;
+};
+
+struct drm_mode_fb_cmd {
+	__u32 fb_id;
+	__u32 width, height;
+	__u32 pitch;
+	__u32 bpp;
+	__u32 depth;
+	/* driver specific handle */
+	__u32 handle;
+};
+
+struct drm_mode_mode_cmd {
+	__u32 connector_id;
+	struct drm_mode_modeinfo mode;
+};
+
+#define DRM_MODE_CURSOR_BO	(1<<0)
+#define DRM_MODE_CURSOR_MOVE	(1<<1)
+
+/*
+ * depending on the value in flags diffrent members are used.
+ *
+ * CURSOR_BO uses
+ *    crtc
+ *    width
+ *    height
+ *    handle - if 0 turns the cursor of
+ *
+ * CURSOR_MOVE uses
+ *    crtc
+ *    x
+ *    y
+ */
+struct drm_mode_cursor {
+	__u32 flags;
+	__u32 crtc_id;
+	__s32 x;
+	__s32 y;
+	__u32 width;
+	__u32 height;
+	/* driver specific handle */
+	__u32 handle;
+};
+
+struct drm_mode_crtc_lut {
+	__u32 crtc_id;
+	__u32 gamma_size;
+
+	/* pointers to arrays */
+	__u64 red;
+	__u64 green;
+	__u64 blue;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/drm_sarea.h clean_modified/linux-2.6.32/usr/include/drm/drm_sarea.h
--- linux-2.6.32/usr/include/drm/drm_sarea.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/drm_sarea.h	2019-04-14 13:24:02.892473657 -0500
@@ -0,0 +1,82 @@
+/**
+ * \file drm_sarea.h
+ * \brief SAREA definitions
+ *
+ * \author Michel Dänzer <michel@daenzer.net>
+ */
+
+/*
+ * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_SAREA_H_
+#define _DRM_SAREA_H_
+
+#include "drm.h"
+
+/* SAREA area needs to be at least a page */
+#if defined(__alpha__)
+#define SAREA_MAX                       0x2000U
+#elif defined(__ia64__)
+#define SAREA_MAX                       0x10000U	/* 64kB */
+#else
+/* Intel 830M driver needs at least 8k SAREA */
+#define SAREA_MAX                       0x2000U
+#endif
+
+/** Maximum number of drawables in the SAREA */
+#define SAREA_MAX_DRAWABLES		256
+
+#define SAREA_DRAWABLE_CLAIMED_ENTRY    0x80000000
+
+/** SAREA drawable */
+struct drm_sarea_drawable {
+	unsigned int stamp;
+	unsigned int flags;
+};
+
+/** SAREA frame */
+struct drm_sarea_frame {
+	unsigned int x;
+	unsigned int y;
+	unsigned int width;
+	unsigned int height;
+	unsigned int fullscreen;
+};
+
+/** SAREA */
+struct drm_sarea {
+    /** first thing is always the DRM locking structure */
+	struct drm_hw_lock lock;
+    /** \todo Use readers/writer lock for drm_sarea::drawable_lock */
+	struct drm_hw_lock drawable_lock;
+	struct drm_sarea_drawable drawableTable[SAREA_MAX_DRAWABLES];	/**< drawables */
+	struct drm_sarea_frame frame;	/**< frame */
+	drm_context_t dummy_context;
+};
+
+typedef struct drm_sarea_drawable drm_sarea_drawable_t;
+typedef struct drm_sarea_frame drm_sarea_frame_t;
+typedef struct drm_sarea drm_sarea_t;
+
+#endif				/* _DRM_SAREA_H_ */
diff -uNr linux-2.6.32/usr/include/drm/i810_drm.h clean_modified/linux-2.6.32/usr/include/drm/i810_drm.h
--- linux-2.6.32/usr/include/drm/i810_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/i810_drm.h	2019-04-14 13:24:02.893419339 -0500
@@ -0,0 +1,281 @@
+#ifndef _I810_DRM_H_
+#define _I810_DRM_H_
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.
+ */
+
+#ifndef _I810_DEFINES_
+#define _I810_DEFINES_
+
+#define I810_DMA_BUF_ORDER		12
+#define I810_DMA_BUF_SZ 		(1<<I810_DMA_BUF_ORDER)
+#define I810_DMA_BUF_NR 		256
+#define I810_NR_SAREA_CLIPRECTS 	8
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.
+ */
+#define I810_NR_TEX_REGIONS 64
+#define I810_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+#define I810_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
+#define I810_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
+#define I810_UPLOAD_CTX        0x4
+#define I810_UPLOAD_BUFFERS    0x8
+#define I810_UPLOAD_TEX0       0x10
+#define I810_UPLOAD_TEX1       0x20
+#define I810_UPLOAD_CLIPRECTS  0x40
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+/* Destbuffer state
+ *    - backbuffer linear offset and pitch -- invarient in the current dri
+ *    - zbuffer linear offset and pitch -- also invarient
+ *    - drawing origin in back and depth buffers.
+ *
+ * Keep the depth/back buffer state here to accommodate private buffers
+ * in the future.
+ */
+#define I810_DESTREG_DI0  0	/* CMD_OP_DESTBUFFER_INFO (2 dwords) */
+#define I810_DESTREG_DI1  1
+#define I810_DESTREG_DV0  2	/* GFX_OP_DESTBUFFER_VARS (2 dwords) */
+#define I810_DESTREG_DV1  3
+#define I810_DESTREG_DR0  4	/* GFX_OP_DRAWRECT_INFO (4 dwords) */
+#define I810_DESTREG_DR1  5
+#define I810_DESTREG_DR2  6
+#define I810_DESTREG_DR3  7
+#define I810_DESTREG_DR4  8
+#define I810_DEST_SETUP_SIZE 10
+
+/* Context state
+ */
+#define I810_CTXREG_CF0   0	/* GFX_OP_COLOR_FACTOR */
+#define I810_CTXREG_CF1   1
+#define I810_CTXREG_ST0   2	/* GFX_OP_STIPPLE */
+#define I810_CTXREG_ST1   3
+#define I810_CTXREG_VF    4	/* GFX_OP_VERTEX_FMT */
+#define I810_CTXREG_MT    5	/* GFX_OP_MAP_TEXELS */
+#define I810_CTXREG_MC0   6	/* GFX_OP_MAP_COLOR_STAGES - stage 0 */
+#define I810_CTXREG_MC1   7	/* GFX_OP_MAP_COLOR_STAGES - stage 1 */
+#define I810_CTXREG_MC2   8	/* GFX_OP_MAP_COLOR_STAGES - stage 2 */
+#define I810_CTXREG_MA0   9	/* GFX_OP_MAP_ALPHA_STAGES - stage 0 */
+#define I810_CTXREG_MA1   10	/* GFX_OP_MAP_ALPHA_STAGES - stage 1 */
+#define I810_CTXREG_MA2   11	/* GFX_OP_MAP_ALPHA_STAGES - stage 2 */
+#define I810_CTXREG_SDM   12	/* GFX_OP_SRC_DEST_MONO */
+#define I810_CTXREG_FOG   13	/* GFX_OP_FOG_COLOR */
+#define I810_CTXREG_B1    14	/* GFX_OP_BOOL_1 */
+#define I810_CTXREG_B2    15	/* GFX_OP_BOOL_2 */
+#define I810_CTXREG_LCS   16	/* GFX_OP_LINEWIDTH_CULL_SHADE_MODE */
+#define I810_CTXREG_PV    17	/* GFX_OP_PV_RULE -- Invarient! */
+#define I810_CTXREG_ZA    18	/* GFX_OP_ZBIAS_ALPHAFUNC */
+#define I810_CTXREG_AA    19	/* GFX_OP_ANTIALIAS */
+#define I810_CTX_SETUP_SIZE 20
+
+/* Texture state (per tex unit)
+ */
+#define I810_TEXREG_MI0  0	/* GFX_OP_MAP_INFO (4 dwords) */
+#define I810_TEXREG_MI1  1
+#define I810_TEXREG_MI2  2
+#define I810_TEXREG_MI3  3
+#define I810_TEXREG_MF   4	/* GFX_OP_MAP_FILTER */
+#define I810_TEXREG_MLC  5	/* GFX_OP_MAP_LOD_CTL */
+#define I810_TEXREG_MLL  6	/* GFX_OP_MAP_LOD_LIMITS */
+#define I810_TEXREG_MCS  7	/* GFX_OP_MAP_COORD_SETS ??? */
+#define I810_TEX_SETUP_SIZE 8
+
+/* Flags for clear ioctl
+ */
+#define I810_FRONT   0x1
+#define I810_BACK    0x2
+#define I810_DEPTH   0x4
+
+typedef enum _drm_i810_init_func {
+	I810_INIT_DMA = 0x01,
+	I810_CLEANUP_DMA = 0x02,
+	I810_INIT_DMA_1_4 = 0x03
+} drm_i810_init_func_t;
+
+/* This is the init structure after v1.2 */
+typedef struct _drm_i810_init {
+	drm_i810_init_func_t func;
+	unsigned int mmio_offset;
+	unsigned int buffers_offset;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int overlay_offset;
+	unsigned int overlay_physical;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits;
+} drm_i810_init_t;
+
+/* This is the init structure prior to v1.2 */
+typedef struct _drm_i810_pre12_init {
+	drm_i810_init_func_t func;
+	unsigned int mmio_offset;
+	unsigned int buffers_offset;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits;
+} drm_i810_pre12_init_t;
+
+/* Warning: If you change the SAREA structure you must change the Xserver
+ * structure as well */
+
+typedef struct _drm_i810_tex_region {
+	unsigned char next, prev;	/* indices to form a circular LRU  */
+	unsigned char in_use;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+} drm_i810_tex_region_t;
+
+typedef struct _drm_i810_sarea {
+	unsigned int ContextState[I810_CTX_SETUP_SIZE];
+	unsigned int BufferState[I810_DEST_SETUP_SIZE];
+	unsigned int TexState[2][I810_TEX_SETUP_SIZE];
+	unsigned int dirty;
+
+	unsigned int nbox;
+	struct drm_clip_rect boxes[I810_NR_SAREA_CLIPRECTS];
+
+	/* Maintain an LRU of contiguous regions of texture space.  If
+	 * you think you own a region of texture memory, and it has an
+	 * age different to the one you set, then you are mistaken and
+	 * it has been stolen by another client.  If global texAge
+	 * hasn't changed, there is no need to walk the list.
+	 *
+	 * These regions can be used as a proxy for the fine-grained
+	 * texture information of other clients - by maintaining them
+	 * in the same lru which is used to age their own textures,
+	 * clients have an approximate lru for the whole of global
+	 * texture space, and can make informed decisions as to which
+	 * areas to kick out.  There is no need to choose whether to
+	 * kick out your own texture or someone else's - simply eject
+	 * them all in LRU order.
+	 */
+
+	drm_i810_tex_region_t texList[I810_NR_TEX_REGIONS + 1];
+	/* Last elt is sentinal */
+	int texAge;		/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
+	int last_dispatch;	/* age of the most recently dispatched buffer */
+	int last_quiescent;	/*  */
+	int ctxOwner;		/* last context to upload state */
+
+	int vertex_prim;
+
+	int pf_enabled;		/* is pageflipping allowed? */
+	int pf_active;
+	int pf_current_page;	/* which buffer is being displayed? */
+} drm_i810_sarea_t;
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmMga.h)
+ */
+
+/* i810 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_I810_INIT		0x00
+#define DRM_I810_VERTEX		0x01
+#define DRM_I810_CLEAR		0x02
+#define DRM_I810_FLUSH		0x03
+#define DRM_I810_GETAGE		0x04
+#define DRM_I810_GETBUF		0x05
+#define DRM_I810_SWAP		0x06
+#define DRM_I810_COPY		0x07
+#define DRM_I810_DOCOPY		0x08
+#define DRM_I810_OV0INFO	0x09
+#define DRM_I810_FSTATUS	0x0a
+#define DRM_I810_OV0FLIP	0x0b
+#define DRM_I810_MC		0x0c
+#define DRM_I810_RSTATUS	0x0d
+#define DRM_I810_FLIP		0x0e
+
+#define DRM_IOCTL_I810_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_INIT, drm_i810_init_t)
+#define DRM_IOCTL_I810_VERTEX		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_VERTEX, drm_i810_vertex_t)
+#define DRM_IOCTL_I810_CLEAR		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_CLEAR, drm_i810_clear_t)
+#define DRM_IOCTL_I810_FLUSH		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_FLUSH)
+#define DRM_IOCTL_I810_GETAGE		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_GETAGE)
+#define DRM_IOCTL_I810_GETBUF		DRM_IOWR(DRM_COMMAND_BASE + DRM_I810_GETBUF, drm_i810_dma_t)
+#define DRM_IOCTL_I810_SWAP		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_SWAP)
+#define DRM_IOCTL_I810_COPY		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_COPY, drm_i810_copy_t)
+#define DRM_IOCTL_I810_DOCOPY		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_DOCOPY)
+#define DRM_IOCTL_I810_OV0INFO		DRM_IOR( DRM_COMMAND_BASE + DRM_I810_OV0INFO, drm_i810_overlay_t)
+#define DRM_IOCTL_I810_FSTATUS		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_FSTATUS)
+#define DRM_IOCTL_I810_OV0FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_OV0FLIP)
+#define DRM_IOCTL_I810_MC		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_MC, drm_i810_mc_t)
+#define DRM_IOCTL_I810_RSTATUS		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_RSTATUS)
+#define DRM_IOCTL_I810_FLIP             DRM_IO ( DRM_COMMAND_BASE + DRM_I810_FLIP)
+
+typedef struct _drm_i810_clear {
+	int clear_color;
+	int clear_depth;
+	int flags;
+} drm_i810_clear_t;
+
+/* These may be placeholders if we have more cliprects than
+ * I810_NR_SAREA_CLIPRECTS.  In that case, the client sets discard to
+ * false, indicating that the buffer will be dispatched again with a
+ * new set of cliprects.
+ */
+typedef struct _drm_i810_vertex {
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	int discard;		/* client is finished with the buffer? */
+} drm_i810_vertex_t;
+
+typedef struct _drm_i810_copy_t {
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	void *address;		/* Address to copy from */
+} drm_i810_copy_t;
+
+#define PR_TRIANGLES         (0x0<<18)
+#define PR_TRISTRIP_0        (0x1<<18)
+#define PR_TRISTRIP_1        (0x2<<18)
+#define PR_TRIFAN            (0x3<<18)
+#define PR_POLYGON           (0x4<<18)
+#define PR_LINES             (0x5<<18)
+#define PR_LINESTRIP         (0x6<<18)
+#define PR_RECTS             (0x7<<18)
+#define PR_MASK              (0x7<<18)
+
+typedef struct drm_i810_dma {
+	void *virtual;
+	int request_idx;
+	int request_size;
+	int granted;
+} drm_i810_dma_t;
+
+typedef struct _drm_i810_overlay_t {
+	unsigned int offset;	/* Address of the Overlay Regs */
+	unsigned int physical;
+} drm_i810_overlay_t;
+
+typedef struct _drm_i810_mc {
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	int num_blocks;		/* number of GFXBlocks */
+	int *length;		/* List of lengths for GFXBlocks (FUTURE) */
+	unsigned int last_render;	/* Last Render Request */
+} drm_i810_mc_t;
+
+#endif				/* _I810_DRM_H_ */
diff -uNr linux-2.6.32/usr/include/drm/i830_drm.h clean_modified/linux-2.6.32/usr/include/drm/i830_drm.h
--- linux-2.6.32/usr/include/drm/i830_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/i830_drm.h	2019-04-14 13:24:02.894388680 -0500
@@ -0,0 +1,342 @@
+#ifndef _I830_DRM_H_
+#define _I830_DRM_H_
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.
+ *
+ * KW: Actually, you can't ever change them because doing so would
+ * break backwards compatibility.
+ */
+
+#ifndef _I830_DEFINES_
+#define _I830_DEFINES_
+
+#define I830_DMA_BUF_ORDER		12
+#define I830_DMA_BUF_SZ			(1<<I830_DMA_BUF_ORDER)
+#define I830_DMA_BUF_NR			256
+#define I830_NR_SAREA_CLIPRECTS		8
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.
+ */
+#define I830_NR_TEX_REGIONS 64
+#define I830_LOG_MIN_TEX_REGION_SIZE 16
+
+/* KW: These aren't correct but someone set them to two and then
+ * released the module.  Now we can't change them as doing so would
+ * break backwards compatibility.
+ */
+#define I830_TEXTURE_COUNT	2
+#define I830_TEXBLEND_COUNT	I830_TEXTURE_COUNT
+
+#define I830_TEXBLEND_SIZE	12	/* (4 args + op) * 2 + COLOR_FACTOR */
+
+#define I830_UPLOAD_CTX			0x1
+#define I830_UPLOAD_BUFFERS		0x2
+#define I830_UPLOAD_CLIPRECTS		0x4
+#define I830_UPLOAD_TEX0_IMAGE		0x100	/* handled clientside */
+#define I830_UPLOAD_TEX0_CUBE		0x200	/* handled clientside */
+#define I830_UPLOAD_TEX1_IMAGE		0x400	/* handled clientside */
+#define I830_UPLOAD_TEX1_CUBE		0x800	/* handled clientside */
+#define I830_UPLOAD_TEX2_IMAGE		0x1000	/* handled clientside */
+#define I830_UPLOAD_TEX2_CUBE		0x2000	/* handled clientside */
+#define I830_UPLOAD_TEX3_IMAGE		0x4000	/* handled clientside */
+#define I830_UPLOAD_TEX3_CUBE		0x8000	/* handled clientside */
+#define I830_UPLOAD_TEX_N_IMAGE(n)	(0x100 << (n * 2))
+#define I830_UPLOAD_TEX_N_CUBE(n)	(0x200 << (n * 2))
+#define I830_UPLOAD_TEXIMAGE_MASK	0xff00
+#define I830_UPLOAD_TEX0			0x10000
+#define I830_UPLOAD_TEX1			0x20000
+#define I830_UPLOAD_TEX2			0x40000
+#define I830_UPLOAD_TEX3			0x80000
+#define I830_UPLOAD_TEX_N(n)		(0x10000 << (n))
+#define I830_UPLOAD_TEX_MASK		0xf0000
+#define I830_UPLOAD_TEXBLEND0		0x100000
+#define I830_UPLOAD_TEXBLEND1		0x200000
+#define I830_UPLOAD_TEXBLEND2		0x400000
+#define I830_UPLOAD_TEXBLEND3		0x800000
+#define I830_UPLOAD_TEXBLEND_N(n)	(0x100000 << (n))
+#define I830_UPLOAD_TEXBLEND_MASK	0xf00000
+#define I830_UPLOAD_TEX_PALETTE_N(n)    (0x1000000 << (n))
+#define I830_UPLOAD_TEX_PALETTE_SHARED	0x4000000
+#define I830_UPLOAD_STIPPLE		0x8000000
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+/* Destbuffer state
+ *    - backbuffer linear offset and pitch -- invarient in the current dri
+ *    - zbuffer linear offset and pitch -- also invarient
+ *    - drawing origin in back and depth buffers.
+ *
+ * Keep the depth/back buffer state here to accommodate private buffers
+ * in the future.
+ */
+
+#define I830_DESTREG_CBUFADDR 0
+#define I830_DESTREG_DBUFADDR 1
+#define I830_DESTREG_DV0 2
+#define I830_DESTREG_DV1 3
+#define I830_DESTREG_SENABLE 4
+#define I830_DESTREG_SR0 5
+#define I830_DESTREG_SR1 6
+#define I830_DESTREG_SR2 7
+#define I830_DESTREG_DR0 8
+#define I830_DESTREG_DR1 9
+#define I830_DESTREG_DR2 10
+#define I830_DESTREG_DR3 11
+#define I830_DESTREG_DR4 12
+#define I830_DEST_SETUP_SIZE 13
+
+/* Context state
+ */
+#define I830_CTXREG_STATE1		0
+#define I830_CTXREG_STATE2		1
+#define I830_CTXREG_STATE3		2
+#define I830_CTXREG_STATE4		3
+#define I830_CTXREG_STATE5		4
+#define I830_CTXREG_IALPHAB		5
+#define I830_CTXREG_STENCILTST		6
+#define I830_CTXREG_ENABLES_1		7
+#define I830_CTXREG_ENABLES_2		8
+#define I830_CTXREG_AA			9
+#define I830_CTXREG_FOGCOLOR		10
+#define I830_CTXREG_BLENDCOLR0		11
+#define I830_CTXREG_BLENDCOLR		12	/* Dword 1 of 2 dword command */
+#define I830_CTXREG_VF			13
+#define I830_CTXREG_VF2			14
+#define I830_CTXREG_MCSB0		15
+#define I830_CTXREG_MCSB1		16
+#define I830_CTX_SETUP_SIZE		17
+
+/* 1.3: Stipple state
+ */
+#define I830_STPREG_ST0 0
+#define I830_STPREG_ST1 1
+#define I830_STP_SETUP_SIZE 2
+
+/* Texture state (per tex unit)
+ */
+
+#define I830_TEXREG_MI0	0	/* GFX_OP_MAP_INFO (6 dwords) */
+#define I830_TEXREG_MI1	1
+#define I830_TEXREG_MI2	2
+#define I830_TEXREG_MI3	3
+#define I830_TEXREG_MI4	4
+#define I830_TEXREG_MI5	5
+#define I830_TEXREG_MF	6	/* GFX_OP_MAP_FILTER */
+#define I830_TEXREG_MLC	7	/* GFX_OP_MAP_LOD_CTL */
+#define I830_TEXREG_MLL	8	/* GFX_OP_MAP_LOD_LIMITS */
+#define I830_TEXREG_MCS	9	/* GFX_OP_MAP_COORD_SETS */
+#define I830_TEX_SETUP_SIZE 10
+
+#define I830_TEXREG_TM0LI      0	/* load immediate 2 texture map n */
+#define I830_TEXREG_TM0S0      1
+#define I830_TEXREG_TM0S1      2
+#define I830_TEXREG_TM0S2      3
+#define I830_TEXREG_TM0S3      4
+#define I830_TEXREG_TM0S4      5
+#define I830_TEXREG_NOP0       6	/* noop */
+#define I830_TEXREG_NOP1       7	/* noop */
+#define I830_TEXREG_NOP2       8	/* noop */
+#define __I830_TEXREG_MCS      9	/* GFX_OP_MAP_COORD_SETS -- shared */
+#define __I830_TEX_SETUP_SIZE   10
+
+#define I830_FRONT   0x1
+#define I830_BACK    0x2
+#define I830_DEPTH   0x4
+
+#endif				/* _I830_DEFINES_ */
+
+typedef struct _drm_i830_init {
+	enum {
+		I830_INIT_DMA = 0x01,
+		I830_CLEANUP_DMA = 0x02
+	} func;
+	unsigned int mmio_offset;
+	unsigned int buffers_offset;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits;
+	unsigned int back_pitch;
+	unsigned int depth_pitch;
+	unsigned int cpp;
+} drm_i830_init_t;
+
+/* Warning: If you change the SAREA structure you must change the Xserver
+ * structure as well */
+
+typedef struct _drm_i830_tex_region {
+	unsigned char next, prev;	/* indices to form a circular LRU  */
+	unsigned char in_use;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+} drm_i830_tex_region_t;
+
+typedef struct _drm_i830_sarea {
+	unsigned int ContextState[I830_CTX_SETUP_SIZE];
+	unsigned int BufferState[I830_DEST_SETUP_SIZE];
+	unsigned int TexState[I830_TEXTURE_COUNT][I830_TEX_SETUP_SIZE];
+	unsigned int TexBlendState[I830_TEXBLEND_COUNT][I830_TEXBLEND_SIZE];
+	unsigned int TexBlendStateWordsUsed[I830_TEXBLEND_COUNT];
+	unsigned int Palette[2][256];
+	unsigned int dirty;
+
+	unsigned int nbox;
+	struct drm_clip_rect boxes[I830_NR_SAREA_CLIPRECTS];
+
+	/* Maintain an LRU of contiguous regions of texture space.  If
+	 * you think you own a region of texture memory, and it has an
+	 * age different to the one you set, then you are mistaken and
+	 * it has been stolen by another client.  If global texAge
+	 * hasn't changed, there is no need to walk the list.
+	 *
+	 * These regions can be used as a proxy for the fine-grained
+	 * texture information of other clients - by maintaining them
+	 * in the same lru which is used to age their own textures,
+	 * clients have an approximate lru for the whole of global
+	 * texture space, and can make informed decisions as to which
+	 * areas to kick out.  There is no need to choose whether to
+	 * kick out your own texture or someone else's - simply eject
+	 * them all in LRU order.
+	 */
+
+	drm_i830_tex_region_t texList[I830_NR_TEX_REGIONS + 1];
+	/* Last elt is sentinal */
+	int texAge;		/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
+	int last_dispatch;	/* age of the most recently dispatched buffer */
+	int last_quiescent;	/*  */
+	int ctxOwner;		/* last context to upload state */
+
+	int vertex_prim;
+
+	int pf_enabled;		/* is pageflipping allowed? */
+	int pf_active;
+	int pf_current_page;	/* which buffer is being displayed? */
+
+	int perf_boxes;		/* performance boxes to be displayed */
+
+	/* Here's the state for texunits 2,3:
+	 */
+	unsigned int TexState2[I830_TEX_SETUP_SIZE];
+	unsigned int TexBlendState2[I830_TEXBLEND_SIZE];
+	unsigned int TexBlendStateWordsUsed2;
+
+	unsigned int TexState3[I830_TEX_SETUP_SIZE];
+	unsigned int TexBlendState3[I830_TEXBLEND_SIZE];
+	unsigned int TexBlendStateWordsUsed3;
+
+	unsigned int StippleState[I830_STP_SETUP_SIZE];
+} drm_i830_sarea_t;
+
+/* Flags for perf_boxes
+ */
+#define I830_BOX_RING_EMPTY    0x1	/* populated by kernel */
+#define I830_BOX_FLIP          0x2	/* populated by kernel */
+#define I830_BOX_WAIT          0x4	/* populated by kernel & client */
+#define I830_BOX_TEXTURE_LOAD  0x8	/* populated by kernel */
+#define I830_BOX_LOST_CONTEXT  0x10	/* populated by client */
+
+/* I830 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_I830_INIT	0x00
+#define DRM_I830_VERTEX	0x01
+#define DRM_I830_CLEAR	0x02
+#define DRM_I830_FLUSH	0x03
+#define DRM_I830_GETAGE	0x04
+#define DRM_I830_GETBUF	0x05
+#define DRM_I830_SWAP	0x06
+#define DRM_I830_COPY	0x07
+#define DRM_I830_DOCOPY	0x08
+#define DRM_I830_FLIP	0x09
+#define DRM_I830_IRQ_EMIT	0x0a
+#define DRM_I830_IRQ_WAIT	0x0b
+#define DRM_I830_GETPARAM	0x0c
+#define DRM_I830_SETPARAM	0x0d
+
+#define DRM_IOCTL_I830_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_IOCTL_I830_INIT, drm_i830_init_t)
+#define DRM_IOCTL_I830_VERTEX		DRM_IOW( DRM_COMMAND_BASE + DRM_IOCTL_I830_VERTEX, drm_i830_vertex_t)
+#define DRM_IOCTL_I830_CLEAR		DRM_IOW( DRM_COMMAND_BASE + DRM_IOCTL_I830_CLEAR, drm_i830_clear_t)
+#define DRM_IOCTL_I830_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_IOCTL_I830_FLUSH)
+#define DRM_IOCTL_I830_GETAGE		DRM_IO ( DRM_COMMAND_BASE + DRM_IOCTL_I830_GETAGE)
+#define DRM_IOCTL_I830_GETBUF		DRM_IOWR(DRM_COMMAND_BASE + DRM_IOCTL_I830_GETBUF, drm_i830_dma_t)
+#define DRM_IOCTL_I830_SWAP		DRM_IO ( DRM_COMMAND_BASE + DRM_IOCTL_I830_SWAP)
+#define DRM_IOCTL_I830_COPY		DRM_IOW( DRM_COMMAND_BASE + DRM_IOCTL_I830_COPY, drm_i830_copy_t)
+#define DRM_IOCTL_I830_DOCOPY		DRM_IO ( DRM_COMMAND_BASE + DRM_IOCTL_I830_DOCOPY)
+#define DRM_IOCTL_I830_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_IOCTL_I830_FLIP)
+#define DRM_IOCTL_I830_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_IOCTL_I830_IRQ_EMIT, drm_i830_irq_emit_t)
+#define DRM_IOCTL_I830_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_IOCTL_I830_IRQ_WAIT, drm_i830_irq_wait_t)
+#define DRM_IOCTL_I830_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_IOCTL_I830_GETPARAM, drm_i830_getparam_t)
+#define DRM_IOCTL_I830_SETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_IOCTL_I830_SETPARAM, drm_i830_setparam_t)
+
+typedef struct _drm_i830_clear {
+	int clear_color;
+	int clear_depth;
+	int flags;
+	unsigned int clear_colormask;
+	unsigned int clear_depthmask;
+} drm_i830_clear_t;
+
+/* These may be placeholders if we have more cliprects than
+ * I830_NR_SAREA_CLIPRECTS.  In that case, the client sets discard to
+ * false, indicating that the buffer will be dispatched again with a
+ * new set of cliprects.
+ */
+typedef struct _drm_i830_vertex {
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	int discard;		/* client is finished with the buffer? */
+} drm_i830_vertex_t;
+
+typedef struct _drm_i830_copy_t {
+	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	void *address;	/* Address to copy from */
+} drm_i830_copy_t;
+
+typedef struct drm_i830_dma {
+	void *virtual;
+	int request_idx;
+	int request_size;
+	int granted;
+} drm_i830_dma_t;
+
+/* 1.3: Userspace can request & wait on irq's:
+ */
+typedef struct drm_i830_irq_emit {
+	int *irq_seq;
+} drm_i830_irq_emit_t;
+
+typedef struct drm_i830_irq_wait {
+	int irq_seq;
+} drm_i830_irq_wait_t;
+
+/* 1.3: New ioctl to query kernel params:
+ */
+#define I830_PARAM_IRQ_ACTIVE            1
+
+typedef struct drm_i830_getparam {
+	int param;
+	int *value;
+} drm_i830_getparam_t;
+
+/* 1.3: New ioctl to set kernel params:
+ */
+#define I830_SETPARAM_USE_MI_BATCHBUFFER_START            1
+
+typedef struct drm_i830_setparam {
+	int param;
+	int value;
+} drm_i830_setparam_t;
+
+#endif				/* _I830_DRM_H_ */
diff -uNr linux-2.6.32/usr/include/drm/i915_drm.h clean_modified/linux-2.6.32/usr/include/drm/i915_drm.h
--- linux-2.6.32/usr/include/drm/i915_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/i915_drm.h	2019-04-14 13:24:02.895905773 -0500
@@ -0,0 +1,689 @@
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _I915_DRM_H_
+#define _I915_DRM_H_
+
+/* Please note that modifications to all structs defined here are
+ * subject to backwards-compatibility constraints.
+ */
+#include <linux/types.h>
+#include "drm.h"
+
+/* Each region is a minimum of 16k, and there are at most 255 of them.
+ */
+#define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use
+				 * of chars for next/prev indices */
+#define I915_LOG_MIN_TEX_REGION_SIZE 14
+
+typedef struct _drm_i915_init {
+	enum {
+		I915_INIT_DMA = 0x01,
+		I915_CLEANUP_DMA = 0x02,
+		I915_RESUME_DMA = 0x03
+	} func;
+	unsigned int mmio_offset;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits;
+	unsigned int back_pitch;
+	unsigned int depth_pitch;
+	unsigned int cpp;
+	unsigned int chipset;
+} drm_i915_init_t;
+
+typedef struct _drm_i915_sarea {
+	struct drm_tex_region texList[I915_NR_TEX_REGIONS + 1];
+	int last_upload;	/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
+	int last_dispatch;	/* age of the most recently dispatched buffer */
+	int ctxOwner;		/* last context to upload state */
+	int texAge;
+	int pf_enabled;		/* is pageflipping allowed? */
+	int pf_active;
+	int pf_current_page;	/* which buffer is being displayed? */
+	int perf_boxes;		/* performance boxes to be displayed */
+	int width, height;      /* screen size in pixels */
+
+	drm_handle_t front_handle;
+	int front_offset;
+	int front_size;
+
+	drm_handle_t back_handle;
+	int back_offset;
+	int back_size;
+
+	drm_handle_t depth_handle;
+	int depth_offset;
+	int depth_size;
+
+	drm_handle_t tex_handle;
+	int tex_offset;
+	int tex_size;
+	int log_tex_granularity;
+	int pitch;
+	int rotation;           /* 0, 90, 180 or 270 */
+	int rotated_offset;
+	int rotated_size;
+	int rotated_pitch;
+	int virtualX, virtualY;
+
+	unsigned int front_tiled;
+	unsigned int back_tiled;
+	unsigned int depth_tiled;
+	unsigned int rotated_tiled;
+	unsigned int rotated2_tiled;
+
+	int pipeA_x;
+	int pipeA_y;
+	int pipeA_w;
+	int pipeA_h;
+	int pipeB_x;
+	int pipeB_y;
+	int pipeB_w;
+	int pipeB_h;
+
+	/* fill out some space for old userspace triple buffer */
+	drm_handle_t unused_handle;
+	__u32 unused1, unused2, unused3;
+
+	/* buffer object handles for static buffers. May change
+	 * over the lifetime of the client.
+	 */
+	__u32 front_bo_handle;
+	__u32 back_bo_handle;
+	__u32 unused_bo_handle;
+	__u32 depth_bo_handle;
+
+} drm_i915_sarea_t;
+
+/* due to userspace building against these headers we need some compat here */
+#define planeA_x pipeA_x
+#define planeA_y pipeA_y
+#define planeA_w pipeA_w
+#define planeA_h pipeA_h
+#define planeB_x pipeB_x
+#define planeB_y pipeB_y
+#define planeB_w pipeB_w
+#define planeB_h pipeB_h
+
+/* Flags for perf_boxes
+ */
+#define I915_BOX_RING_EMPTY    0x1
+#define I915_BOX_FLIP          0x2
+#define I915_BOX_WAIT          0x4
+#define I915_BOX_TEXTURE_LOAD  0x8
+#define I915_BOX_LOST_CONTEXT  0x10
+
+/* I915 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_I915_INIT		0x00
+#define DRM_I915_FLUSH		0x01
+#define DRM_I915_FLIP		0x02
+#define DRM_I915_BATCHBUFFER	0x03
+#define DRM_I915_IRQ_EMIT	0x04
+#define DRM_I915_IRQ_WAIT	0x05
+#define DRM_I915_GETPARAM	0x06
+#define DRM_I915_SETPARAM	0x07
+#define DRM_I915_ALLOC		0x08
+#define DRM_I915_FREE		0x09
+#define DRM_I915_INIT_HEAP	0x0a
+#define DRM_I915_CMDBUFFER	0x0b
+#define DRM_I915_DESTROY_HEAP	0x0c
+#define DRM_I915_SET_VBLANK_PIPE	0x0d
+#define DRM_I915_GET_VBLANK_PIPE	0x0e
+#define DRM_I915_VBLANK_SWAP	0x0f
+#define DRM_I915_HWS_ADDR	0x11
+#define DRM_I915_GEM_INIT	0x13
+#define DRM_I915_GEM_EXECBUFFER	0x14
+#define DRM_I915_GEM_PIN	0x15
+#define DRM_I915_GEM_UNPIN	0x16
+#define DRM_I915_GEM_BUSY	0x17
+#define DRM_I915_GEM_THROTTLE	0x18
+#define DRM_I915_GEM_ENTERVT	0x19
+#define DRM_I915_GEM_LEAVEVT	0x1a
+#define DRM_I915_GEM_CREATE	0x1b
+#define DRM_I915_GEM_PREAD	0x1c
+#define DRM_I915_GEM_PWRITE	0x1d
+#define DRM_I915_GEM_MMAP	0x1e
+#define DRM_I915_GEM_SET_DOMAIN	0x1f
+#define DRM_I915_GEM_SW_FINISH	0x20
+#define DRM_I915_GEM_SET_TILING	0x21
+#define DRM_I915_GEM_GET_TILING	0x22
+#define DRM_I915_GEM_GET_APERTURE 0x23
+#define DRM_I915_GEM_MMAP_GTT	0x24
+#define DRM_I915_GET_PIPE_FROM_CRTC_ID	0x25
+#define DRM_I915_GEM_MADVISE	0x26
+
+#define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
+#define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
+#define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
+#define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)
+#define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)
+#define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)
+#define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)
+#define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)
+#define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)
+#define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)
+#define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)
+#define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)
+#define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)
+#define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
+#define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
+#define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
+#define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)
+#define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)
+#define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)
+#define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)
+#define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)
+#define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)
+#define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)
+#define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)
+#define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)
+#define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)
+#define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)
+#define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)
+#define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)
+#define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)
+#define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)
+#define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)
+#define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)
+#define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)
+#define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_intel_get_pipe_from_crtc_id)
+#define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)
+
+/* Allow drivers to submit batchbuffers directly to hardware, relying
+ * on the security mechanisms provided by hardware.
+ */
+typedef struct drm_i915_batchbuffer {
+	int start;		/* agp offset */
+	int used;		/* nr bytes in use */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	struct drm_clip_rect *cliprects;	/* pointer to userspace cliprects */
+} drm_i915_batchbuffer_t;
+
+/* As above, but pass a pointer to userspace buffer which can be
+ * validated by the kernel prior to sending to hardware.
+ */
+typedef struct _drm_i915_cmdbuffer {
+	char *buf;	/* pointer to userspace command buffer */
+	int sz;			/* nr bytes in buf */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	struct drm_clip_rect *cliprects;	/* pointer to userspace cliprects */
+} drm_i915_cmdbuffer_t;
+
+/* Userspace can request & wait on irq's:
+ */
+typedef struct drm_i915_irq_emit {
+	int *irq_seq;
+} drm_i915_irq_emit_t;
+
+typedef struct drm_i915_irq_wait {
+	int irq_seq;
+} drm_i915_irq_wait_t;
+
+/* Ioctl to query kernel params:
+ */
+#define I915_PARAM_IRQ_ACTIVE            1
+#define I915_PARAM_ALLOW_BATCHBUFFER     2
+#define I915_PARAM_LAST_DISPATCH         3
+#define I915_PARAM_CHIPSET_ID            4
+#define I915_PARAM_HAS_GEM               5
+#define I915_PARAM_NUM_FENCES_AVAIL      6
+
+typedef struct drm_i915_getparam {
+	int param;
+	int *value;
+} drm_i915_getparam_t;
+
+/* Ioctl to set kernel params:
+ */
+#define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1
+#define I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2
+#define I915_SETPARAM_ALLOW_BATCHBUFFER                   3
+#define I915_SETPARAM_NUM_USED_FENCES                     4
+
+typedef struct drm_i915_setparam {
+	int param;
+	int value;
+} drm_i915_setparam_t;
+
+/* A memory manager for regions of shared memory:
+ */
+#define I915_MEM_REGION_AGP 1
+
+typedef struct drm_i915_mem_alloc {
+	int region;
+	int alignment;
+	int size;
+	int *region_offset;	/* offset from start of fb or agp */
+} drm_i915_mem_alloc_t;
+
+typedef struct drm_i915_mem_free {
+	int region;
+	int region_offset;
+} drm_i915_mem_free_t;
+
+typedef struct drm_i915_mem_init_heap {
+	int region;
+	int size;
+	int start;
+} drm_i915_mem_init_heap_t;
+
+/* Allow memory manager to be torn down and re-initialized (eg on
+ * rotate):
+ */
+typedef struct drm_i915_mem_destroy_heap {
+	int region;
+} drm_i915_mem_destroy_heap_t;
+
+/* Allow X server to configure which pipes to monitor for vblank signals
+ */
+#define	DRM_I915_VBLANK_PIPE_A	1
+#define	DRM_I915_VBLANK_PIPE_B	2
+
+typedef struct drm_i915_vblank_pipe {
+	int pipe;
+} drm_i915_vblank_pipe_t;
+
+/* Schedule buffer swap at given vertical blank:
+ */
+typedef struct drm_i915_vblank_swap {
+	drm_drawable_t drawable;
+	enum drm_vblank_seq_type seqtype;
+	unsigned int sequence;
+} drm_i915_vblank_swap_t;
+
+typedef struct drm_i915_hws_addr {
+	__u64 addr;
+} drm_i915_hws_addr_t;
+
+struct drm_i915_gem_init {
+	/**
+	 * Beginning offset in the GTT to be managed by the DRM memory
+	 * manager.
+	 */
+	__u64 gtt_start;
+	/**
+	 * Ending offset in the GTT to be managed by the DRM memory
+	 * manager.
+	 */
+	__u64 gtt_end;
+};
+
+struct drm_i915_gem_create {
+	/**
+	 * Requested size for the object.
+	 *
+	 * The (page-aligned) allocated size for the object will be returned.
+	 */
+	__u64 size;
+	/**
+	 * Returned handle for the object.
+	 *
+	 * Object handles are nonzero.
+	 */
+	__u32 handle;
+	__u32 pad;
+};
+
+struct drm_i915_gem_pread {
+	/** Handle for the object being read. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset into the object to read from */
+	__u64 offset;
+	/** Length of data to read */
+	__u64 size;
+	/**
+	 * Pointer to write the data into.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 data_ptr;
+};
+
+struct drm_i915_gem_pwrite {
+	/** Handle for the object being written to. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset into the object to write to */
+	__u64 offset;
+	/** Length of data to write */
+	__u64 size;
+	/**
+	 * Pointer to read the data from.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 data_ptr;
+};
+
+struct drm_i915_gem_mmap {
+	/** Handle for the object being mapped. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset in the object to map. */
+	__u64 offset;
+	/**
+	 * Length of data to map.
+	 *
+	 * The value will be page-aligned.
+	 */
+	__u64 size;
+	/**
+	 * Returned pointer the data was mapped at.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 addr_ptr;
+};
+
+struct drm_i915_gem_mmap_gtt {
+	/** Handle for the object being mapped. */
+	__u32 handle;
+	__u32 pad;
+	/**
+	 * Fake offset to use for subsequent mmap call
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 offset;
+};
+
+struct drm_i915_gem_set_domain {
+	/** Handle for the object */
+	__u32 handle;
+
+	/** New read domains */
+	__u32 read_domains;
+
+	/** New write domain */
+	__u32 write_domain;
+};
+
+struct drm_i915_gem_sw_finish {
+	/** Handle for the object */
+	__u32 handle;
+};
+
+struct drm_i915_gem_relocation_entry {
+	/**
+	 * Handle of the buffer being pointed to by this relocation entry.
+	 *
+	 * It's appealing to make this be an index into the mm_validate_entry
+	 * list to refer to the buffer, but this allows the driver to create
+	 * a relocation list for state buffers and not re-write it per
+	 * exec using the buffer.
+	 */
+	__u32 target_handle;
+
+	/**
+	 * Value to be added to the offset of the target buffer to make up
+	 * the relocation entry.
+	 */
+	__u32 delta;
+
+	/** Offset in the buffer the relocation entry will be written into */
+	__u64 offset;
+
+	/**
+	 * Offset value of the target buffer that the relocation entry was last
+	 * written as.
+	 *
+	 * If the buffer has the same offset as last time, we can skip syncing
+	 * and writing the relocation.  This value is written back out by
+	 * the execbuffer ioctl when the relocation is written.
+	 */
+	__u64 presumed_offset;
+
+	/**
+	 * Target memory domains read by this operation.
+	 */
+	__u32 read_domains;
+
+	/**
+	 * Target memory domains written by this operation.
+	 *
+	 * Note that only one domain may be written by the whole
+	 * execbuffer operation, so that where there are conflicts,
+	 * the application will get -EINVAL back.
+	 */
+	__u32 write_domain;
+};
+
+/** @{
+ * Intel memory domains
+ *
+ * Most of these just align with the various caches in
+ * the system and are used to flush and invalidate as
+ * objects end up cached in different domains.
+ */
+/** CPU cache */
+#define I915_GEM_DOMAIN_CPU		0x00000001
+/** Render cache, used by 2D and 3D drawing */
+#define I915_GEM_DOMAIN_RENDER		0x00000002
+/** Sampler cache, used by texture engine */
+#define I915_GEM_DOMAIN_SAMPLER		0x00000004
+/** Command queue, used to load batch buffers */
+#define I915_GEM_DOMAIN_COMMAND		0x00000008
+/** Instruction cache, used by shader programs */
+#define I915_GEM_DOMAIN_INSTRUCTION	0x00000010
+/** Vertex address cache */
+#define I915_GEM_DOMAIN_VERTEX		0x00000020
+/** GTT domain - aperture and scanout */
+#define I915_GEM_DOMAIN_GTT		0x00000040
+/** @} */
+
+struct drm_i915_gem_exec_object {
+	/**
+	 * User's handle for a buffer to be bound into the GTT for this
+	 * operation.
+	 */
+	__u32 handle;
+
+	/** Number of relocations to be performed on this buffer */
+	__u32 relocation_count;
+	/**
+	 * Pointer to array of struct drm_i915_gem_relocation_entry containing
+	 * the relocations to be performed in this buffer.
+	 */
+	__u64 relocs_ptr;
+
+	/** Required alignment in graphics aperture */
+	__u64 alignment;
+
+	/**
+	 * Returned value of the updated offset of the object, for future
+	 * presumed_offset writes.
+	 */
+	__u64 offset;
+};
+
+struct drm_i915_gem_execbuffer {
+	/**
+	 * List of buffers to be validated with their relocations to be
+	 * performend on them.
+	 *
+	 * This is a pointer to an array of struct drm_i915_gem_validate_entry.
+	 *
+	 * These buffers must be listed in an order such that all relocations
+	 * a buffer is performing refer to buffers that have already appeared
+	 * in the validate list.
+	 */
+	__u64 buffers_ptr;
+	__u32 buffer_count;
+
+	/** Offset in the batchbuffer to start execution from. */
+	__u32 batch_start_offset;
+	/** Bytes used in batchbuffer from batch_start_offset */
+	__u32 batch_len;
+	__u32 DR1;
+	__u32 DR4;
+	__u32 num_cliprects;
+	/** This is a struct drm_clip_rect *cliprects */
+	__u64 cliprects_ptr;
+};
+
+struct drm_i915_gem_pin {
+	/** Handle of the buffer to be pinned. */
+	__u32 handle;
+	__u32 pad;
+
+	/** alignment required within the aperture */
+	__u64 alignment;
+
+	/** Returned GTT offset of the buffer. */
+	__u64 offset;
+};
+
+struct drm_i915_gem_unpin {
+	/** Handle of the buffer to be unpinned. */
+	__u32 handle;
+	__u32 pad;
+};
+
+struct drm_i915_gem_busy {
+	/** Handle of the buffer to check for busy */
+	__u32 handle;
+
+	/** Return busy status (1 if busy, 0 if idle) */
+	__u32 busy;
+};
+
+#define I915_TILING_NONE	0
+#define I915_TILING_X		1
+#define I915_TILING_Y		2
+
+#define I915_BIT_6_SWIZZLE_NONE		0
+#define I915_BIT_6_SWIZZLE_9		1
+#define I915_BIT_6_SWIZZLE_9_10		2
+#define I915_BIT_6_SWIZZLE_9_11		3
+#define I915_BIT_6_SWIZZLE_9_10_11	4
+/* Not seen by userland */
+#define I915_BIT_6_SWIZZLE_UNKNOWN	5
+/* Seen by userland. */
+#define I915_BIT_6_SWIZZLE_9_17		6
+#define I915_BIT_6_SWIZZLE_9_10_17	7
+
+struct drm_i915_gem_set_tiling {
+	/** Handle of the buffer to have its tiling state updated */
+	__u32 handle;
+
+	/**
+	 * Tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
+	 * I915_TILING_Y).
+	 *
+	 * This value is to be set on request, and will be updated by the
+	 * kernel on successful return with the actual chosen tiling layout.
+	 *
+	 * The tiling mode may be demoted to I915_TILING_NONE when the system
+	 * has bit 6 swizzling that can't be managed correctly by GEM.
+	 *
+	 * Buffer contents become undefined when changing tiling_mode.
+	 */
+	__u32 tiling_mode;
+
+	/**
+	 * Stride in bytes for the object when in I915_TILING_X or
+	 * I915_TILING_Y.
+	 */
+	__u32 stride;
+
+	/**
+	 * Returned address bit 6 swizzling required for CPU access through
+	 * mmap mapping.
+	 */
+	__u32 swizzle_mode;
+};
+
+struct drm_i915_gem_get_tiling {
+	/** Handle of the buffer to get tiling state for. */
+	__u32 handle;
+
+	/**
+	 * Current tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
+	 * I915_TILING_Y).
+	 */
+	__u32 tiling_mode;
+
+	/**
+	 * Returned address bit 6 swizzling required for CPU access through
+	 * mmap mapping.
+	 */
+	__u32 swizzle_mode;
+};
+
+struct drm_i915_gem_get_aperture {
+	/** Total size of the aperture used by i915_gem_execbuffer, in bytes */
+	__u64 aper_size;
+
+	/**
+	 * Available space in the aperture used by i915_gem_execbuffer, in
+	 * bytes
+	 */
+	__u64 aper_available_size;
+};
+
+struct drm_i915_get_pipe_from_crtc_id {
+	/** ID of CRTC being requested **/
+	__u32 crtc_id;
+
+	/** pipe of requested CRTC **/
+	__u32 pipe;
+};
+
+#define I915_MADV_WILLNEED 0
+#define I915_MADV_DONTNEED 1
+#define __I915_MADV_PURGED 2 /* internal state */
+
+struct drm_i915_gem_madvise {
+	/** Handle of the buffer to change the backing store advice */
+	__u32 handle;
+
+	/* Advice: either the buffer will be needed again in the near future,
+	 *         or wont be and could be discarded under memory pressure.
+	 */
+	__u32 madv;
+
+	/** Whether the backing store still exists. */
+	__u32 retained;
+};
+
+#endif				/* _I915_DRM_H_ */
diff -uNr linux-2.6.32/usr/include/drm/mga_drm.h clean_modified/linux-2.6.32/usr/include/drm/mga_drm.h
--- linux-2.6.32/usr/include/drm/mga_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/mga_drm.h	2019-04-14 13:24:02.896942514 -0500
@@ -0,0 +1,419 @@
+/* mga_drm.h -- Public header for the Matrox g200/g400 driver -*- linux-c -*-
+ * Created: Tue Jan 25 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jeff Hartmann <jhartmann@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ *
+ * Rewritten by:
+ *    Gareth Hughes <gareth@valinux.com>
+ */
+
+#ifndef __MGA_DRM_H__
+#define __MGA_DRM_H__
+
+#include <linux/types.h>
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (mga_sarea.h)
+ */
+
+#ifndef __MGA_SAREA_DEFINES__
+#define __MGA_SAREA_DEFINES__
+
+/* WARP pipe flags
+ */
+#define MGA_F			0x1	/* fog */
+#define MGA_A			0x2	/* alpha */
+#define MGA_S			0x4	/* specular */
+#define MGA_T2			0x8	/* multitexture */
+
+#define MGA_WARP_TGZ		0
+#define MGA_WARP_TGZF		(MGA_F)
+#define MGA_WARP_TGZA		(MGA_A)
+#define MGA_WARP_TGZAF		(MGA_F|MGA_A)
+#define MGA_WARP_TGZS		(MGA_S)
+#define MGA_WARP_TGZSF		(MGA_S|MGA_F)
+#define MGA_WARP_TGZSA		(MGA_S|MGA_A)
+#define MGA_WARP_TGZSAF		(MGA_S|MGA_F|MGA_A)
+#define MGA_WARP_T2GZ		(MGA_T2)
+#define MGA_WARP_T2GZF		(MGA_T2|MGA_F)
+#define MGA_WARP_T2GZA		(MGA_T2|MGA_A)
+#define MGA_WARP_T2GZAF		(MGA_T2|MGA_A|MGA_F)
+#define MGA_WARP_T2GZS		(MGA_T2|MGA_S)
+#define MGA_WARP_T2GZSF		(MGA_T2|MGA_S|MGA_F)
+#define MGA_WARP_T2GZSA		(MGA_T2|MGA_S|MGA_A)
+#define MGA_WARP_T2GZSAF	(MGA_T2|MGA_S|MGA_F|MGA_A)
+
+#define MGA_MAX_G200_PIPES	8	/* no multitex */
+#define MGA_MAX_G400_PIPES	16
+#define MGA_MAX_WARP_PIPES	MGA_MAX_G400_PIPES
+#define MGA_WARP_UCODE_SIZE	32768	/* in bytes */
+
+#define MGA_CARD_TYPE_G200	1
+#define MGA_CARD_TYPE_G400	2
+#define MGA_CARD_TYPE_G450	3	/* not currently used */
+#define MGA_CARD_TYPE_G550	4
+
+#define MGA_FRONT		0x1
+#define MGA_BACK		0x2
+#define MGA_DEPTH		0x4
+
+/* What needs to be changed for the current vertex dma buffer?
+ */
+#define MGA_UPLOAD_CONTEXT	0x1
+#define MGA_UPLOAD_TEX0		0x2
+#define MGA_UPLOAD_TEX1		0x4
+#define MGA_UPLOAD_PIPE		0x8
+#define MGA_UPLOAD_TEX0IMAGE	0x10	/* handled client-side */
+#define MGA_UPLOAD_TEX1IMAGE	0x20	/* handled client-side */
+#define MGA_UPLOAD_2D		0x40
+#define MGA_WAIT_AGE		0x80	/* handled client-side */
+#define MGA_UPLOAD_CLIPRECTS	0x100	/* handled client-side */
+#if 0
+#define MGA_DMA_FLUSH		0x200	/* set when someone gets the lock
+					   quiescent */
+#endif
+
+/* 32 buffers of 64k each, total 2 meg.
+ */
+#define MGA_BUFFER_SIZE		(1 << 16)
+#define MGA_NUM_BUFFERS		128
+
+/* Keep these small for testing.
+ */
+#define MGA_NR_SAREA_CLIPRECTS	8
+
+/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+ * regions, subject to a minimum region size of (1<<16) == 64k.
+ *
+ * Clients may subdivide regions internally, but when sharing between
+ * clients, the region size is the minimum granularity.
+ */
+
+#define MGA_CARD_HEAP			0
+#define MGA_AGP_HEAP			1
+#define MGA_NR_TEX_HEAPS		2
+#define MGA_NR_TEX_REGIONS		16
+#define MGA_LOG_MIN_TEX_REGION_SIZE	16
+
+#define  DRM_MGA_IDLE_RETRY          2048
+
+#endif				/* __MGA_SAREA_DEFINES__ */
+
+/* Setup registers for 3D context
+ */
+typedef struct {
+	unsigned int dstorg;
+	unsigned int maccess;
+	unsigned int plnwt;
+	unsigned int dwgctl;
+	unsigned int alphactrl;
+	unsigned int fogcolor;
+	unsigned int wflag;
+	unsigned int tdualstage0;
+	unsigned int tdualstage1;
+	unsigned int fcol;
+	unsigned int stencil;
+	unsigned int stencilctl;
+} drm_mga_context_regs_t;
+
+/* Setup registers for 2D, X server
+ */
+typedef struct {
+	unsigned int pitch;
+} drm_mga_server_regs_t;
+
+/* Setup registers for each texture unit
+ */
+typedef struct {
+	unsigned int texctl;
+	unsigned int texctl2;
+	unsigned int texfilter;
+	unsigned int texbordercol;
+	unsigned int texorg;
+	unsigned int texwidth;
+	unsigned int texheight;
+	unsigned int texorg1;
+	unsigned int texorg2;
+	unsigned int texorg3;
+	unsigned int texorg4;
+} drm_mga_texture_regs_t;
+
+/* General aging mechanism
+ */
+typedef struct {
+	unsigned int head;	/* Position of head pointer          */
+	unsigned int wrap;	/* Primary DMA wrap count            */
+} drm_mga_age_t;
+
+typedef struct _drm_mga_sarea {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex dma buffer.
+	 */
+	drm_mga_context_regs_t context_state;
+	drm_mga_server_regs_t server_state;
+	drm_mga_texture_regs_t tex_state[2];
+	unsigned int warp_pipe;
+	unsigned int dirty;
+	unsigned int vertsize;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	struct drm_clip_rect boxes[MGA_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Information about the most recently used 3d drawable.  The
+	 * client fills in the req_* fields, the server fills in the
+	 * exported_ fields and puts the cliprects into boxes, above.
+	 *
+	 * The client clears the exported_drawable field before
+	 * clobbering the boxes data.
+	 */
+	unsigned int req_drawable;	/* the X drawable id */
+	unsigned int req_draw_buffer;	/* MGA_FRONT or MGA_BACK */
+
+	unsigned int exported_drawable;
+	unsigned int exported_index;
+	unsigned int exported_stamp;
+	unsigned int exported_buffers;
+	unsigned int exported_nfront;
+	unsigned int exported_nback;
+	int exported_back_x, exported_front_x, exported_w;
+	int exported_back_y, exported_front_y, exported_h;
+	struct drm_clip_rect exported_boxes[MGA_NR_SAREA_CLIPRECTS];
+
+	/* Counters for aging textures and for client-side throttling.
+	 */
+	unsigned int status[4];
+	unsigned int last_wrap;
+
+	drm_mga_age_t last_frame;
+	unsigned int last_enqueue;	/* last time a buffer was enqueued */
+	unsigned int last_dispatch;	/* age of the most recently dispatched buffer */
+	unsigned int last_quiescent;	/*  */
+
+	/* LRU lists for texture memory in agp space and on the card.
+	 */
+	struct drm_tex_region texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS + 1];
+	unsigned int texAge[MGA_NR_TEX_HEAPS];
+
+	/* Mechanism to validate card state.
+	 */
+	int ctxOwner;
+} drm_mga_sarea_t;
+
+/* MGA specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_MGA_INIT     0x00
+#define DRM_MGA_FLUSH    0x01
+#define DRM_MGA_RESET    0x02
+#define DRM_MGA_SWAP     0x03
+#define DRM_MGA_CLEAR    0x04
+#define DRM_MGA_VERTEX   0x05
+#define DRM_MGA_INDICES  0x06
+#define DRM_MGA_ILOAD    0x07
+#define DRM_MGA_BLIT     0x08
+#define DRM_MGA_GETPARAM 0x09
+
+/* 3.2:
+ * ioctls for operating on fences.
+ */
+#define DRM_MGA_SET_FENCE      0x0a
+#define DRM_MGA_WAIT_FENCE     0x0b
+#define DRM_MGA_DMA_BOOTSTRAP  0x0c
+
+#define DRM_IOCTL_MGA_INIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INIT, drm_mga_init_t)
+#define DRM_IOCTL_MGA_FLUSH    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_FLUSH, drm_lock_t)
+#define DRM_IOCTL_MGA_RESET    DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_RESET)
+#define DRM_IOCTL_MGA_SWAP     DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_SWAP)
+#define DRM_IOCTL_MGA_CLEAR    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_CLEAR, drm_mga_clear_t)
+#define DRM_IOCTL_MGA_VERTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_VERTEX, drm_mga_vertex_t)
+#define DRM_IOCTL_MGA_INDICES  DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INDICES, drm_mga_indices_t)
+#define DRM_IOCTL_MGA_ILOAD    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_ILOAD, drm_mga_iload_t)
+#define DRM_IOCTL_MGA_BLIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_BLIT, drm_mga_blit_t)
+#define DRM_IOCTL_MGA_GETPARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_GETPARAM, drm_mga_getparam_t)
+#define DRM_IOCTL_MGA_SET_FENCE     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_SET_FENCE, __u32)
+#define DRM_IOCTL_MGA_WAIT_FENCE    DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_WAIT_FENCE, __u32)
+#define DRM_IOCTL_MGA_DMA_BOOTSTRAP DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_DMA_BOOTSTRAP, drm_mga_dma_bootstrap_t)
+
+typedef struct _drm_mga_warp_index {
+	int installed;
+	unsigned long phys_addr;
+	int size;
+} drm_mga_warp_index_t;
+
+typedef struct drm_mga_init {
+	enum {
+		MGA_INIT_DMA = 0x01,
+		MGA_CLEANUP_DMA = 0x02
+	} func;
+
+	unsigned long sarea_priv_offset;
+
+	int chipset;
+	int sgram;
+
+	unsigned int maccess;
+
+	unsigned int fb_cpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+
+	unsigned int depth_cpp;
+	unsigned int depth_offset, depth_pitch;
+
+	unsigned int texture_offset[MGA_NR_TEX_HEAPS];
+	unsigned int texture_size[MGA_NR_TEX_HEAPS];
+
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long status_offset;
+	unsigned long warp_offset;
+	unsigned long primary_offset;
+	unsigned long buffers_offset;
+} drm_mga_init_t;
+
+typedef struct drm_mga_dma_bootstrap {
+	/**
+	 * \name AGP texture region
+	 *
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will
+	 * be filled in with the actual AGP texture settings.
+	 *
+	 * \warning
+	 * If these fields are non-zero, but dma_mga_dma_bootstrap::agp_mode
+	 * is zero, it means that PCI memory (most likely through the use of
+	 * an IOMMU) is being used for "AGP" textures.
+	 */
+	/*@{ */
+	unsigned long texture_handle; /**< Handle used to map AGP textures. */
+	__u32 texture_size;	      /**< Size of the AGP texture region. */
+	/*@} */
+
+	/**
+	 * Requested size of the primary DMA region.
+	 *
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual AGP mode.  If AGP was not available
+	 */
+	__u32 primary_size;
+
+	/**
+	 * Requested number of secondary DMA buffers.
+	 *
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual number of secondary DMA buffers
+	 * allocated.  Particularly when PCI DMA is used, this may be
+	 * (subtantially) less than the number requested.
+	 */
+	__u32 secondary_bin_count;
+
+	/**
+	 * Requested size of each secondary DMA buffer.
+	 *
+	 * While the kernel \b is free to reduce
+	 * dma_mga_dma_bootstrap::secondary_bin_count, it is \b not allowed
+	 * to reduce dma_mga_dma_bootstrap::secondary_bin_size.
+	 */
+	__u32 secondary_bin_size;
+
+	/**
+	 * Bit-wise mask of AGPSTAT2_* values.  Currently only \c AGPSTAT2_1X,
+	 * \c AGPSTAT2_2X, and \c AGPSTAT2_4X are supported.  If this value is
+	 * zero, it means that PCI DMA should be used, even if AGP is
+	 * possible.
+	 *
+	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be
+	 * filled in with the actual AGP mode.  If AGP was not available
+	 * (i.e., PCI DMA was used), this value will be zero.
+	 */
+	__u32 agp_mode;
+
+	/**
+	 * Desired AGP GART size, measured in megabytes.
+	 */
+	__u8 agp_size;
+} drm_mga_dma_bootstrap_t;
+
+typedef struct drm_mga_clear {
+	unsigned int flags;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int color_mask;
+	unsigned int depth_mask;
+} drm_mga_clear_t;
+
+typedef struct drm_mga_vertex {
+	int idx;		/* buffer to queue */
+	int used;		/* bytes in use */
+	int discard;		/* client finished with buffer?  */
+} drm_mga_vertex_t;
+
+typedef struct drm_mga_indices {
+	int idx;		/* buffer to queue */
+	unsigned int start;
+	unsigned int end;
+	int discard;		/* client finished with buffer?  */
+} drm_mga_indices_t;
+
+typedef struct drm_mga_iload {
+	int idx;
+	unsigned int dstorg;
+	unsigned int length;
+} drm_mga_iload_t;
+
+typedef struct _drm_mga_blit {
+	unsigned int planemask;
+	unsigned int srcorg;
+	unsigned int dstorg;
+	int src_pitch, dst_pitch;
+	int delta_sx, delta_sy;
+	int delta_dx, delta_dy;
+	int height, ydir;	/* flip image vertically */
+	int source_pitch, dest_pitch;
+} drm_mga_blit_t;
+
+/* 3.1: An ioctl to get parameters that aren't available to the 3d
+ * client any other way.
+ */
+#define MGA_PARAM_IRQ_NR            1
+
+/* 3.2: Query the actual card type.  The DDX only distinguishes between
+ * G200 chips and non-G200 chips, which it calls G400.  It turns out that
+ * there are some very sublte differences between the G4x0 chips and the G550
+ * chips.  Using this parameter query, a client-side driver can detect the
+ * difference between a G4x0 and a G550.
+ */
+#define MGA_PARAM_CARD_TYPE         2
+
+typedef struct drm_mga_getparam {
+	int param;
+	void *value;
+} drm_mga_getparam_t;
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/r128_drm.h clean_modified/linux-2.6.32/usr/include/drm/r128_drm.h
--- linux-2.6.32/usr/include/drm/r128_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/r128_drm.h	2019-04-14 13:24:02.898172970 -0500
@@ -0,0 +1,326 @@
+/* r128_drm.h -- Public header for the r128 driver -*- linux-c -*-
+ * Created: Wed Apr  5 19:24:19 2000 by kevin@precisioninsight.com
+ */
+/*
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Kevin E. Martin <martin@valinux.com>
+ */
+
+#ifndef __R128_DRM_H__
+#define __R128_DRM_H__
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the X server file (r128_sarea.h)
+ */
+#ifndef __R128_SAREA_DEFINES__
+#define __R128_SAREA_DEFINES__
+
+/* What needs to be changed for the current vertex buffer?
+ */
+#define R128_UPLOAD_CONTEXT		0x001
+#define R128_UPLOAD_SETUP		0x002
+#define R128_UPLOAD_TEX0		0x004
+#define R128_UPLOAD_TEX1		0x008
+#define R128_UPLOAD_TEX0IMAGES		0x010
+#define R128_UPLOAD_TEX1IMAGES		0x020
+#define R128_UPLOAD_CORE		0x040
+#define R128_UPLOAD_MASKS		0x080
+#define R128_UPLOAD_WINDOW		0x100
+#define R128_UPLOAD_CLIPRECTS		0x200	/* handled client-side */
+#define R128_REQUIRE_QUIESCENCE		0x400
+#define R128_UPLOAD_ALL			0x7ff
+
+#define R128_FRONT			0x1
+#define R128_BACK			0x2
+#define R128_DEPTH			0x4
+
+/* Primitive types
+ */
+#define R128_POINTS			0x1
+#define R128_LINES			0x2
+#define R128_LINE_STRIP			0x3
+#define R128_TRIANGLES			0x4
+#define R128_TRIANGLE_FAN		0x5
+#define R128_TRIANGLE_STRIP		0x6
+
+/* Vertex/indirect buffer size
+ */
+#define R128_BUFFER_SIZE		16384
+
+/* Byte offsets for indirect buffer data
+ */
+#define R128_INDEX_PRIM_OFFSET		20
+#define R128_HOSTDATA_BLIT_OFFSET	32
+
+/* Keep these small for testing.
+ */
+#define R128_NR_SAREA_CLIPRECTS		12
+
+/* There are 2 heaps (local/AGP).  Each region within a heap is a
+ *  minimum of 64k, and there are at most 64 of them per heap.
+ */
+#define R128_LOCAL_TEX_HEAP		0
+#define R128_AGP_TEX_HEAP		1
+#define R128_NR_TEX_HEAPS		2
+#define R128_NR_TEX_REGIONS		64
+#define R128_LOG_TEX_GRANULARITY	16
+
+#define R128_NR_CONTEXT_REGS		12
+
+#define R128_MAX_TEXTURE_LEVELS		11
+#define R128_MAX_TEXTURE_UNITS		2
+
+#endif				/* __R128_SAREA_DEFINES__ */
+
+typedef struct {
+	/* Context state - can be written in one large chunk */
+	unsigned int dst_pitch_offset_c;
+	unsigned int dp_gui_master_cntl_c;
+	unsigned int sc_top_left_c;
+	unsigned int sc_bottom_right_c;
+	unsigned int z_offset_c;
+	unsigned int z_pitch_c;
+	unsigned int z_sten_cntl_c;
+	unsigned int tex_cntl_c;
+	unsigned int misc_3d_state_cntl_reg;
+	unsigned int texture_clr_cmp_clr_c;
+	unsigned int texture_clr_cmp_msk_c;
+	unsigned int fog_color_c;
+
+	/* Texture state */
+	unsigned int tex_size_pitch_c;
+	unsigned int constant_color_c;
+
+	/* Setup state */
+	unsigned int pm4_vc_fpu_setup;
+	unsigned int setup_cntl;
+
+	/* Mask state */
+	unsigned int dp_write_mask;
+	unsigned int sten_ref_mask_c;
+	unsigned int plane_3d_mask_c;
+
+	/* Window state */
+	unsigned int window_xy_offset;
+
+	/* Core state */
+	unsigned int scale_3d_cntl;
+} drm_r128_context_regs_t;
+
+/* Setup registers for each texture unit
+ */
+typedef struct {
+	unsigned int tex_cntl;
+	unsigned int tex_combine_cntl;
+	unsigned int tex_size_pitch;
+	unsigned int tex_offset[R128_MAX_TEXTURE_LEVELS];
+	unsigned int tex_border_color;
+} drm_r128_texture_regs_t;
+
+typedef struct drm_r128_sarea {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex buffer.
+	 */
+	drm_r128_context_regs_t context_state;
+	drm_r128_texture_regs_t tex_state[R128_MAX_TEXTURE_UNITS];
+	unsigned int dirty;
+	unsigned int vertsize;
+	unsigned int vc_format;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	struct drm_clip_rect boxes[R128_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int last_frame;
+	unsigned int last_dispatch;
+
+	struct drm_tex_region tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS + 1];
+	unsigned int tex_age[R128_NR_TEX_HEAPS];
+	int ctx_owner;
+	int pfAllowPageFlip;	/* number of 3d windows (0,1,2 or more) */
+	int pfCurrentPage;	/* which buffer is being displayed? */
+} drm_r128_sarea_t;
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmR128.h)
+ */
+
+/* Rage 128 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_R128_INIT       0x00
+#define DRM_R128_CCE_START  0x01
+#define DRM_R128_CCE_STOP   0x02
+#define DRM_R128_CCE_RESET  0x03
+#define DRM_R128_CCE_IDLE   0x04
+/* 0x05 not used */
+#define DRM_R128_RESET      0x06
+#define DRM_R128_SWAP       0x07
+#define DRM_R128_CLEAR      0x08
+#define DRM_R128_VERTEX     0x09
+#define DRM_R128_INDICES    0x0a
+#define DRM_R128_BLIT       0x0b
+#define DRM_R128_DEPTH      0x0c
+#define DRM_R128_STIPPLE    0x0d
+/* 0x0e not used */
+#define DRM_R128_INDIRECT   0x0f
+#define DRM_R128_FULLSCREEN 0x10
+#define DRM_R128_CLEAR2     0x11
+#define DRM_R128_GETPARAM   0x12
+#define DRM_R128_FLIP       0x13
+
+#define DRM_IOCTL_R128_INIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INIT, drm_r128_init_t)
+#define DRM_IOCTL_R128_CCE_START  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_START)
+#define DRM_IOCTL_R128_CCE_STOP   DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CCE_STOP, drm_r128_cce_stop_t)
+#define DRM_IOCTL_R128_CCE_RESET  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_RESET)
+#define DRM_IOCTL_R128_CCE_IDLE   DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_IDLE)
+/* 0x05 not used */
+#define DRM_IOCTL_R128_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_R128_RESET)
+#define DRM_IOCTL_R128_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_SWAP)
+#define DRM_IOCTL_R128_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR, drm_r128_clear_t)
+#define DRM_IOCTL_R128_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_VERTEX, drm_r128_vertex_t)
+#define DRM_IOCTL_R128_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INDICES, drm_r128_indices_t)
+#define DRM_IOCTL_R128_BLIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_BLIT, drm_r128_blit_t)
+#define DRM_IOCTL_R128_DEPTH      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_DEPTH, drm_r128_depth_t)
+#define DRM_IOCTL_R128_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_STIPPLE, drm_r128_stipple_t)
+/* 0x0e not used */
+#define DRM_IOCTL_R128_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_R128_INDIRECT, drm_r128_indirect_t)
+#define DRM_IOCTL_R128_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_R128_FULLSCREEN, drm_r128_fullscreen_t)
+#define DRM_IOCTL_R128_CLEAR2     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR2, drm_r128_clear2_t)
+#define DRM_IOCTL_R128_GETPARAM   DRM_IOWR( DRM_COMMAND_BASE + DRM_R128_GETPARAM, drm_r128_getparam_t)
+#define DRM_IOCTL_R128_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_FLIP)
+
+typedef struct drm_r128_init {
+	enum {
+		R128_INIT_CCE = 0x01,
+		R128_CLEANUP_CCE = 0x02
+	} func;
+	unsigned long sarea_priv_offset;
+	int is_pci;
+	int cce_mode;
+	int cce_secure;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+	unsigned int span_offset;
+
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long ring_offset;
+	unsigned long ring_rptr_offset;
+	unsigned long buffers_offset;
+	unsigned long agp_textures_offset;
+} drm_r128_init_t;
+
+typedef struct drm_r128_cce_stop {
+	int flush;
+	int idle;
+} drm_r128_cce_stop_t;
+
+typedef struct drm_r128_clear {
+	unsigned int flags;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int color_mask;
+	unsigned int depth_mask;
+} drm_r128_clear_t;
+
+typedef struct drm_r128_vertex {
+	int prim;
+	int idx;		/* Index of vertex buffer */
+	int count;		/* Number of vertices in buffer */
+	int discard;		/* Client finished with buffer? */
+} drm_r128_vertex_t;
+
+typedef struct drm_r128_indices {
+	int prim;
+	int idx;
+	int start;
+	int end;
+	int discard;		/* Client finished with buffer? */
+} drm_r128_indices_t;
+
+typedef struct drm_r128_blit {
+	int idx;
+	int pitch;
+	int offset;
+	int format;
+	unsigned short x, y;
+	unsigned short width, height;
+} drm_r128_blit_t;
+
+typedef struct drm_r128_depth {
+	enum {
+		R128_WRITE_SPAN = 0x01,
+		R128_WRITE_PIXELS = 0x02,
+		R128_READ_SPAN = 0x03,
+		R128_READ_PIXELS = 0x04
+	} func;
+	int n;
+	int *x;
+	int *y;
+	unsigned int *buffer;
+	unsigned char *mask;
+} drm_r128_depth_t;
+
+typedef struct drm_r128_stipple {
+	unsigned int *mask;
+} drm_r128_stipple_t;
+
+typedef struct drm_r128_indirect {
+	int idx;
+	int start;
+	int end;
+	int discard;
+} drm_r128_indirect_t;
+
+typedef struct drm_r128_fullscreen {
+	enum {
+		R128_INIT_FULLSCREEN = 0x01,
+		R128_CLEANUP_FULLSCREEN = 0x02
+	} func;
+} drm_r128_fullscreen_t;
+
+/* 2.3: An ioctl to get parameters that aren't available to the 3d
+ * client any other way.
+ */
+#define R128_PARAM_IRQ_NR            1
+
+typedef struct drm_r128_getparam {
+	int param;
+	void *value;
+} drm_r128_getparam_t;
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/radeon_drm.h clean_modified/linux-2.6.32/usr/include/drm/radeon_drm.h
--- linux-2.6.32/usr/include/drm/radeon_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/radeon_drm.h	2019-04-14 13:24:02.899902041 -0500
@@ -0,0 +1,911 @@
+/* radeon_drm.h -- Public header for the radeon driver -*- linux-c -*-
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+#ifndef __RADEON_DRM_H__
+#define __RADEON_DRM_H__
+
+#include <linux/types.h>
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the X server file (radeon_sarea.h)
+ */
+#ifndef __RADEON_SAREA_DEFINES__
+#define __RADEON_SAREA_DEFINES__
+
+/* Old style state flags, required for sarea interface (1.1 and 1.2
+ * clears) and 1.2 drm_vertex2 ioctl.
+ */
+#define RADEON_UPLOAD_CONTEXT		0x00000001
+#define RADEON_UPLOAD_VERTFMT		0x00000002
+#define RADEON_UPLOAD_LINE		0x00000004
+#define RADEON_UPLOAD_BUMPMAP		0x00000008
+#define RADEON_UPLOAD_MASKS		0x00000010
+#define RADEON_UPLOAD_VIEWPORT		0x00000020
+#define RADEON_UPLOAD_SETUP		0x00000040
+#define RADEON_UPLOAD_TCL		0x00000080
+#define RADEON_UPLOAD_MISC		0x00000100
+#define RADEON_UPLOAD_TEX0		0x00000200
+#define RADEON_UPLOAD_TEX1		0x00000400
+#define RADEON_UPLOAD_TEX2		0x00000800
+#define RADEON_UPLOAD_TEX0IMAGES	0x00001000
+#define RADEON_UPLOAD_TEX1IMAGES	0x00002000
+#define RADEON_UPLOAD_TEX2IMAGES	0x00004000
+#define RADEON_UPLOAD_CLIPRECTS		0x00008000	/* handled client-side */
+#define RADEON_REQUIRE_QUIESCENCE	0x00010000
+#define RADEON_UPLOAD_ZBIAS		0x00020000	/* version 1.2 and newer */
+#define RADEON_UPLOAD_ALL		0x003effff
+#define RADEON_UPLOAD_CONTEXT_ALL       0x003e01ff
+
+/* New style per-packet identifiers for use in cmd_buffer ioctl with
+ * the RADEON_EMIT_PACKET command.  Comments relate new packets to old
+ * state bits and the packet size:
+ */
+#define RADEON_EMIT_PP_MISC                         0	/* context/7 */
+#define RADEON_EMIT_PP_CNTL                         1	/* context/3 */
+#define RADEON_EMIT_RB3D_COLORPITCH                 2	/* context/1 */
+#define RADEON_EMIT_RE_LINE_PATTERN                 3	/* line/2 */
+#define RADEON_EMIT_SE_LINE_WIDTH                   4	/* line/1 */
+#define RADEON_EMIT_PP_LUM_MATRIX                   5	/* bumpmap/1 */
+#define RADEON_EMIT_PP_ROT_MATRIX_0                 6	/* bumpmap/2 */
+#define RADEON_EMIT_RB3D_STENCILREFMASK             7	/* masks/3 */
+#define RADEON_EMIT_SE_VPORT_XSCALE                 8	/* viewport/6 */
+#define RADEON_EMIT_SE_CNTL                         9	/* setup/2 */
+#define RADEON_EMIT_SE_CNTL_STATUS                  10	/* setup/1 */
+#define RADEON_EMIT_RE_MISC                         11	/* misc/1 */
+#define RADEON_EMIT_PP_TXFILTER_0                   12	/* tex0/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_0               13	/* tex0/1 */
+#define RADEON_EMIT_PP_TXFILTER_1                   14	/* tex1/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_1               15	/* tex1/1 */
+#define RADEON_EMIT_PP_TXFILTER_2                   16	/* tex2/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_2               17	/* tex2/1 */
+#define RADEON_EMIT_SE_ZBIAS_FACTOR                 18	/* zbias/2 */
+#define RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT           19	/* tcl/11 */
+#define RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED   20	/* material/17 */
+#define R200_EMIT_PP_TXCBLEND_0                     21	/* tex0/4 */
+#define R200_EMIT_PP_TXCBLEND_1                     22	/* tex1/4 */
+#define R200_EMIT_PP_TXCBLEND_2                     23	/* tex2/4 */
+#define R200_EMIT_PP_TXCBLEND_3                     24	/* tex3/4 */
+#define R200_EMIT_PP_TXCBLEND_4                     25	/* tex4/4 */
+#define R200_EMIT_PP_TXCBLEND_5                     26	/* tex5/4 */
+#define R200_EMIT_PP_TXCBLEND_6                     27	/* /4 */
+#define R200_EMIT_PP_TXCBLEND_7                     28	/* /4 */
+#define R200_EMIT_TCL_LIGHT_MODEL_CTL_0             29	/* tcl/7 */
+#define R200_EMIT_TFACTOR_0                         30	/* tf/7 */
+#define R200_EMIT_VTX_FMT_0                         31	/* vtx/5 */
+#define R200_EMIT_VAP_CTL                           32	/* vap/1 */
+#define R200_EMIT_MATRIX_SELECT_0                   33	/* msl/5 */
+#define R200_EMIT_TEX_PROC_CTL_2                    34	/* tcg/5 */
+#define R200_EMIT_TCL_UCP_VERT_BLEND_CTL            35	/* tcl/1 */
+#define R200_EMIT_PP_TXFILTER_0                     36	/* tex0/6 */
+#define R200_EMIT_PP_TXFILTER_1                     37	/* tex1/6 */
+#define R200_EMIT_PP_TXFILTER_2                     38	/* tex2/6 */
+#define R200_EMIT_PP_TXFILTER_3                     39	/* tex3/6 */
+#define R200_EMIT_PP_TXFILTER_4                     40	/* tex4/6 */
+#define R200_EMIT_PP_TXFILTER_5                     41	/* tex5/6 */
+#define R200_EMIT_PP_TXOFFSET_0                     42	/* tex0/1 */
+#define R200_EMIT_PP_TXOFFSET_1                     43	/* tex1/1 */
+#define R200_EMIT_PP_TXOFFSET_2                     44	/* tex2/1 */
+#define R200_EMIT_PP_TXOFFSET_3                     45	/* tex3/1 */
+#define R200_EMIT_PP_TXOFFSET_4                     46	/* tex4/1 */
+#define R200_EMIT_PP_TXOFFSET_5                     47	/* tex5/1 */
+#define R200_EMIT_VTE_CNTL                          48	/* vte/1 */
+#define R200_EMIT_OUTPUT_VTX_COMP_SEL               49	/* vtx/1 */
+#define R200_EMIT_PP_TAM_DEBUG3                     50	/* tam/1 */
+#define R200_EMIT_PP_CNTL_X                         51	/* cst/1 */
+#define R200_EMIT_RB3D_DEPTHXY_OFFSET               52	/* cst/1 */
+#define R200_EMIT_RE_AUX_SCISSOR_CNTL               53	/* cst/1 */
+#define R200_EMIT_RE_SCISSOR_TL_0                   54	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_1                   55	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_2                   56	/* cst/2 */
+#define R200_EMIT_SE_VAP_CNTL_STATUS                57	/* cst/1 */
+#define R200_EMIT_SE_VTX_STATE_CNTL                 58	/* cst/1 */
+#define R200_EMIT_RE_POINTSIZE                      59	/* cst/1 */
+#define R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0       60	/* cst/4 */
+#define R200_EMIT_PP_CUBIC_FACES_0                  61
+#define R200_EMIT_PP_CUBIC_OFFSETS_0                62
+#define R200_EMIT_PP_CUBIC_FACES_1                  63
+#define R200_EMIT_PP_CUBIC_OFFSETS_1                64
+#define R200_EMIT_PP_CUBIC_FACES_2                  65
+#define R200_EMIT_PP_CUBIC_OFFSETS_2                66
+#define R200_EMIT_PP_CUBIC_FACES_3                  67
+#define R200_EMIT_PP_CUBIC_OFFSETS_3                68
+#define R200_EMIT_PP_CUBIC_FACES_4                  69
+#define R200_EMIT_PP_CUBIC_OFFSETS_4                70
+#define R200_EMIT_PP_CUBIC_FACES_5                  71
+#define R200_EMIT_PP_CUBIC_OFFSETS_5                72
+#define RADEON_EMIT_PP_TEX_SIZE_0                   73
+#define RADEON_EMIT_PP_TEX_SIZE_1                   74
+#define RADEON_EMIT_PP_TEX_SIZE_2                   75
+#define R200_EMIT_RB3D_BLENDCOLOR                   76
+#define R200_EMIT_TCL_POINT_SPRITE_CNTL             77
+#define RADEON_EMIT_PP_CUBIC_FACES_0                78
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T0             79
+#define RADEON_EMIT_PP_CUBIC_FACES_1                80
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T1             81
+#define RADEON_EMIT_PP_CUBIC_FACES_2                82
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T2             83
+#define R200_EMIT_PP_TRI_PERF_CNTL                  84
+#define R200_EMIT_PP_AFS_0                          85
+#define R200_EMIT_PP_AFS_1                          86
+#define R200_EMIT_ATF_TFACTOR                       87
+#define R200_EMIT_PP_TXCTLALL_0                     88
+#define R200_EMIT_PP_TXCTLALL_1                     89
+#define R200_EMIT_PP_TXCTLALL_2                     90
+#define R200_EMIT_PP_TXCTLALL_3                     91
+#define R200_EMIT_PP_TXCTLALL_4                     92
+#define R200_EMIT_PP_TXCTLALL_5                     93
+#define R200_EMIT_VAP_PVS_CNTL                      94
+#define RADEON_MAX_STATE_PACKETS                    95
+
+/* Commands understood by cmd_buffer ioctl.  More can be added but
+ * obviously these can't be removed or changed:
+ */
+#define RADEON_CMD_PACKET      1	/* emit one of the register packets above */
+#define RADEON_CMD_SCALARS     2	/* emit scalar data */
+#define RADEON_CMD_VECTORS     3	/* emit vector data */
+#define RADEON_CMD_DMA_DISCARD 4	/* discard current dma buf */
+#define RADEON_CMD_PACKET3     5	/* emit hw packet */
+#define RADEON_CMD_PACKET3_CLIP 6	/* emit hw packet wrapped in cliprects */
+#define RADEON_CMD_SCALARS2     7	/* r200 stopgap */
+#define RADEON_CMD_WAIT         8	/* emit hw wait commands -- note:
+					 *  doesn't make the cpu wait, just
+					 *  the graphics hardware */
+#define RADEON_CMD_VECLINEAR	9       /* another r200 stopgap */
+
+typedef union {
+	int i;
+	struct {
+		unsigned char cmd_type, pad0, pad1, pad2;
+	} header;
+	struct {
+		unsigned char cmd_type, packet_id, pad0, pad1;
+	} packet;
+	struct {
+		unsigned char cmd_type, offset, stride, count;
+	} scalars;
+	struct {
+		unsigned char cmd_type, offset, stride, count;
+	} vectors;
+	struct {
+		unsigned char cmd_type, addr_lo, addr_hi, count;
+	} veclinear;
+	struct {
+		unsigned char cmd_type, buf_idx, pad0, pad1;
+	} dma;
+	struct {
+		unsigned char cmd_type, flags, pad0, pad1;
+	} wait;
+} drm_radeon_cmd_header_t;
+
+#define RADEON_WAIT_2D  0x1
+#define RADEON_WAIT_3D  0x2
+
+/* Allowed parameters for R300_CMD_PACKET3
+ */
+#define R300_CMD_PACKET3_CLEAR		0
+#define R300_CMD_PACKET3_RAW		1
+
+/* Commands understood by cmd_buffer ioctl for R300.
+ * The interface has not been stabilized, so some of these may be removed
+ * and eventually reordered before stabilization.
+ */
+#define R300_CMD_PACKET0		1
+#define R300_CMD_VPU			2	/* emit vertex program upload */
+#define R300_CMD_PACKET3		3	/* emit a packet3 */
+#define R300_CMD_END3D			4	/* emit sequence ending 3d rendering */
+#define R300_CMD_CP_DELAY		5
+#define R300_CMD_DMA_DISCARD		6
+#define R300_CMD_WAIT			7
+#	define R300_WAIT_2D		0x1
+#	define R300_WAIT_3D		0x2
+/* these two defines are DOING IT WRONG - however
+ * we have userspace which relies on using these.
+ * The wait interface is backwards compat new 
+ * code should use the NEW_WAIT defines below
+ * THESE ARE NOT BIT FIELDS
+ */
+#	define R300_WAIT_2D_CLEAN	0x3
+#	define R300_WAIT_3D_CLEAN	0x4
+
+#	define R300_NEW_WAIT_2D_3D	0x3
+#	define R300_NEW_WAIT_2D_2D_CLEAN	0x4
+#	define R300_NEW_WAIT_3D_3D_CLEAN	0x6
+#	define R300_NEW_WAIT_2D_2D_CLEAN_3D_3D_CLEAN	0x8
+
+#define R300_CMD_SCRATCH		8
+#define R300_CMD_R500FP                 9
+
+typedef union {
+	unsigned int u;
+	struct {
+		unsigned char cmd_type, pad0, pad1, pad2;
+	} header;
+	struct {
+		unsigned char cmd_type, count, reglo, reghi;
+	} packet0;
+	struct {
+		unsigned char cmd_type, count, adrlo, adrhi;
+	} vpu;
+	struct {
+		unsigned char cmd_type, packet, pad0, pad1;
+	} packet3;
+	struct {
+		unsigned char cmd_type, packet;
+		unsigned short count;	/* amount of packet2 to emit */
+	} delay;
+	struct {
+		unsigned char cmd_type, buf_idx, pad0, pad1;
+	} dma;
+	struct {
+		unsigned char cmd_type, flags, pad0, pad1;
+	} wait;
+	struct {
+		unsigned char cmd_type, reg, n_bufs, flags;
+	} scratch;
+	struct {
+		unsigned char cmd_type, count, adrlo, adrhi_flags;
+	} r500fp;
+} drm_r300_cmd_header_t;
+
+#define RADEON_FRONT			0x1
+#define RADEON_BACK			0x2
+#define RADEON_DEPTH			0x4
+#define RADEON_STENCIL			0x8
+#define RADEON_CLEAR_FASTZ		0x80000000
+#define RADEON_USE_HIERZ		0x40000000
+#define RADEON_USE_COMP_ZBUF		0x20000000
+
+#define R500FP_CONSTANT_TYPE  (1 << 1)
+#define R500FP_CONSTANT_CLAMP (1 << 2)
+
+/* Primitive types
+ */
+#define RADEON_POINTS			0x1
+#define RADEON_LINES			0x2
+#define RADEON_LINE_STRIP		0x3
+#define RADEON_TRIANGLES		0x4
+#define RADEON_TRIANGLE_FAN		0x5
+#define RADEON_TRIANGLE_STRIP		0x6
+
+/* Vertex/indirect buffer size
+ */
+#define RADEON_BUFFER_SIZE		65536
+
+/* Byte offsets for indirect buffer data
+ */
+#define RADEON_INDEX_PRIM_OFFSET	20
+
+#define RADEON_SCRATCH_REG_OFFSET	32
+
+#define R600_SCRATCH_REG_OFFSET         256
+
+#define RADEON_NR_SAREA_CLIPRECTS	12
+
+/* There are 2 heaps (local/GART).  Each region within a heap is a
+ * minimum of 64k, and there are at most 64 of them per heap.
+ */
+#define RADEON_LOCAL_TEX_HEAP		0
+#define RADEON_GART_TEX_HEAP		1
+#define RADEON_NR_TEX_HEAPS		2
+#define RADEON_NR_TEX_REGIONS		64
+#define RADEON_LOG_TEX_GRANULARITY	16
+
+#define RADEON_MAX_TEXTURE_LEVELS	12
+#define RADEON_MAX_TEXTURE_UNITS	3
+
+#define RADEON_MAX_SURFACES		8
+
+/* Blits have strict offset rules.  All blit offset must be aligned on
+ * a 1K-byte boundary.
+ */
+#define RADEON_OFFSET_SHIFT             10
+#define RADEON_OFFSET_ALIGN             (1 << RADEON_OFFSET_SHIFT)
+#define RADEON_OFFSET_MASK              (RADEON_OFFSET_ALIGN - 1)
+
+#endif				/* __RADEON_SAREA_DEFINES__ */
+
+typedef struct {
+	unsigned int red;
+	unsigned int green;
+	unsigned int blue;
+	unsigned int alpha;
+} radeon_color_regs_t;
+
+typedef struct {
+	/* Context state */
+	unsigned int pp_misc;	/* 0x1c14 */
+	unsigned int pp_fog_color;
+	unsigned int re_solid_color;
+	unsigned int rb3d_blendcntl;
+	unsigned int rb3d_depthoffset;
+	unsigned int rb3d_depthpitch;
+	unsigned int rb3d_zstencilcntl;
+
+	unsigned int pp_cntl;	/* 0x1c38 */
+	unsigned int rb3d_cntl;
+	unsigned int rb3d_coloroffset;
+	unsigned int re_width_height;
+	unsigned int rb3d_colorpitch;
+	unsigned int se_cntl;
+
+	/* Vertex format state */
+	unsigned int se_coord_fmt;	/* 0x1c50 */
+
+	/* Line state */
+	unsigned int re_line_pattern;	/* 0x1cd0 */
+	unsigned int re_line_state;
+
+	unsigned int se_line_width;	/* 0x1db8 */
+
+	/* Bumpmap state */
+	unsigned int pp_lum_matrix;	/* 0x1d00 */
+
+	unsigned int pp_rot_matrix_0;	/* 0x1d58 */
+	unsigned int pp_rot_matrix_1;
+
+	/* Mask state */
+	unsigned int rb3d_stencilrefmask;	/* 0x1d7c */
+	unsigned int rb3d_ropcntl;
+	unsigned int rb3d_planemask;
+
+	/* Viewport state */
+	unsigned int se_vport_xscale;	/* 0x1d98 */
+	unsigned int se_vport_xoffset;
+	unsigned int se_vport_yscale;
+	unsigned int se_vport_yoffset;
+	unsigned int se_vport_zscale;
+	unsigned int se_vport_zoffset;
+
+	/* Setup state */
+	unsigned int se_cntl_status;	/* 0x2140 */
+
+	/* Misc state */
+	unsigned int re_top_left;	/* 0x26c0 */
+	unsigned int re_misc;
+} drm_radeon_context_regs_t;
+
+typedef struct {
+	/* Zbias state */
+	unsigned int se_zbias_factor;	/* 0x1dac */
+	unsigned int se_zbias_constant;
+} drm_radeon_context2_regs_t;
+
+/* Setup registers for each texture unit
+ */
+typedef struct {
+	unsigned int pp_txfilter;
+	unsigned int pp_txformat;
+	unsigned int pp_txoffset;
+	unsigned int pp_txcblend;
+	unsigned int pp_txablend;
+	unsigned int pp_tfactor;
+	unsigned int pp_border_color;
+} drm_radeon_texture_regs_t;
+
+typedef struct {
+	unsigned int start;
+	unsigned int finish;
+	unsigned int prim:8;
+	unsigned int stateidx:8;
+	unsigned int numverts:16;	/* overloaded as offset/64 for elt prims */
+	unsigned int vc_format;	/* vertex format */
+} drm_radeon_prim_t;
+
+typedef struct {
+	drm_radeon_context_regs_t context;
+	drm_radeon_texture_regs_t tex[RADEON_MAX_TEXTURE_UNITS];
+	drm_radeon_context2_regs_t context2;
+	unsigned int dirty;
+} drm_radeon_state_t;
+
+typedef struct {
+	/* The channel for communication of state information to the
+	 * kernel on firing a vertex buffer with either of the
+	 * obsoleted vertex/index ioctls.
+	 */
+	drm_radeon_context_regs_t context_state;
+	drm_radeon_texture_regs_t tex_state[RADEON_MAX_TEXTURE_UNITS];
+	unsigned int dirty;
+	unsigned int vertsize;
+	unsigned int vc_format;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	struct drm_clip_rect boxes[RADEON_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int last_frame;
+	unsigned int last_dispatch;
+	unsigned int last_clear;
+
+	struct drm_tex_region tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS +
+						       1];
+	unsigned int tex_age[RADEON_NR_TEX_HEAPS];
+	int ctx_owner;
+	int pfState;		/* number of 3d windows (0,1,2ormore) */
+	int pfCurrentPage;	/* which buffer is being displayed? */
+	int crtc2_base;		/* CRTC2 frame offset */
+	int tiling_enabled;	/* set by drm, read by 2d + 3d clients */
+} drm_radeon_sarea_t;
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmRadeon.h)
+ *
+ * KW: actually it's illegal to change any of this (backwards compatibility).
+ */
+
+/* Radeon specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_RADEON_CP_INIT    0x00
+#define DRM_RADEON_CP_START   0x01
+#define DRM_RADEON_CP_STOP    0x02
+#define DRM_RADEON_CP_RESET   0x03
+#define DRM_RADEON_CP_IDLE    0x04
+#define DRM_RADEON_RESET      0x05
+#define DRM_RADEON_FULLSCREEN 0x06
+#define DRM_RADEON_SWAP       0x07
+#define DRM_RADEON_CLEAR      0x08
+#define DRM_RADEON_VERTEX     0x09
+#define DRM_RADEON_INDICES    0x0A
+#define DRM_RADEON_NOT_USED
+#define DRM_RADEON_STIPPLE    0x0C
+#define DRM_RADEON_INDIRECT   0x0D
+#define DRM_RADEON_TEXTURE    0x0E
+#define DRM_RADEON_VERTEX2    0x0F
+#define DRM_RADEON_CMDBUF     0x10
+#define DRM_RADEON_GETPARAM   0x11
+#define DRM_RADEON_FLIP       0x12
+#define DRM_RADEON_ALLOC      0x13
+#define DRM_RADEON_FREE       0x14
+#define DRM_RADEON_INIT_HEAP  0x15
+#define DRM_RADEON_IRQ_EMIT   0x16
+#define DRM_RADEON_IRQ_WAIT   0x17
+#define DRM_RADEON_CP_RESUME  0x18
+#define DRM_RADEON_SETPARAM   0x19
+#define DRM_RADEON_SURF_ALLOC 0x1a
+#define DRM_RADEON_SURF_FREE  0x1b
+/* KMS ioctl */
+#define DRM_RADEON_GEM_INFO		0x1c
+#define DRM_RADEON_GEM_CREATE		0x1d
+#define DRM_RADEON_GEM_MMAP		0x1e
+#define DRM_RADEON_GEM_PREAD		0x21
+#define DRM_RADEON_GEM_PWRITE		0x22
+#define DRM_RADEON_GEM_SET_DOMAIN	0x23
+#define DRM_RADEON_GEM_WAIT_IDLE	0x24
+#define DRM_RADEON_CS			0x26
+#define DRM_RADEON_INFO			0x27
+#define DRM_RADEON_GEM_SET_TILING	0x28
+#define DRM_RADEON_GEM_GET_TILING	0x29
+#define DRM_RADEON_GEM_BUSY		0x2a
+
+#define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)
+#define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)
+#define DRM_IOCTL_RADEON_CP_STOP    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_STOP, drm_radeon_cp_stop_t)
+#define DRM_IOCTL_RADEON_CP_RESET   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESET)
+#define DRM_IOCTL_RADEON_CP_IDLE    DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_IDLE)
+#define DRM_IOCTL_RADEON_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_RESET)
+#define DRM_IOCTL_RADEON_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FULLSCREEN, drm_radeon_fullscreen_t)
+#define DRM_IOCTL_RADEON_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_SWAP)
+#define DRM_IOCTL_RADEON_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CLEAR, drm_radeon_clear_t)
+#define DRM_IOCTL_RADEON_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX, drm_radeon_vertex_t)
+#define DRM_IOCTL_RADEON_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INDICES, drm_radeon_indices_t)
+#define DRM_IOCTL_RADEON_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_STIPPLE, drm_radeon_stipple_t)
+#define DRM_IOCTL_RADEON_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INDIRECT, drm_radeon_indirect_t)
+#define DRM_IOCTL_RADEON_TEXTURE    DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_TEXTURE, drm_radeon_texture_t)
+#define DRM_IOCTL_RADEON_VERTEX2    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX2, drm_radeon_vertex2_t)
+#define DRM_IOCTL_RADEON_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CMDBUF, drm_radeon_cmd_buffer_t)
+#define DRM_IOCTL_RADEON_GETPARAM   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GETPARAM, drm_radeon_getparam_t)
+#define DRM_IOCTL_RADEON_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_FLIP)
+#define DRM_IOCTL_RADEON_ALLOC      DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_ALLOC, drm_radeon_mem_alloc_t)
+#define DRM_IOCTL_RADEON_FREE       DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FREE, drm_radeon_mem_free_t)
+#define DRM_IOCTL_RADEON_INIT_HEAP  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INIT_HEAP, drm_radeon_mem_init_heap_t)
+#define DRM_IOCTL_RADEON_IRQ_EMIT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_IRQ_EMIT, drm_radeon_irq_emit_t)
+#define DRM_IOCTL_RADEON_IRQ_WAIT   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_IRQ_WAIT, drm_radeon_irq_wait_t)
+#define DRM_IOCTL_RADEON_CP_RESUME  DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESUME)
+#define DRM_IOCTL_RADEON_SETPARAM   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SETPARAM, drm_radeon_setparam_t)
+#define DRM_IOCTL_RADEON_SURF_ALLOC DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_ALLOC, drm_radeon_surface_alloc_t)
+#define DRM_IOCTL_RADEON_SURF_FREE  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_FREE, drm_radeon_surface_free_t)
+/* KMS */
+#define DRM_IOCTL_RADEON_GEM_INFO	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_INFO, struct drm_radeon_gem_info)
+#define DRM_IOCTL_RADEON_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_CREATE, struct drm_radeon_gem_create)
+#define DRM_IOCTL_RADEON_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_MMAP, struct drm_radeon_gem_mmap)
+#define DRM_IOCTL_RADEON_GEM_PREAD	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PREAD, struct drm_radeon_gem_pread)
+#define DRM_IOCTL_RADEON_GEM_PWRITE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PWRITE, struct drm_radeon_gem_pwrite)
+#define DRM_IOCTL_RADEON_GEM_SET_DOMAIN	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_DOMAIN, struct drm_radeon_gem_set_domain)
+#define DRM_IOCTL_RADEON_GEM_WAIT_IDLE	DRM_IOW(DRM_COMMAND_BASE + DRM_RADEON_GEM_WAIT_IDLE, struct drm_radeon_gem_wait_idle)
+#define DRM_IOCTL_RADEON_CS		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_CS, struct drm_radeon_cs)
+#define DRM_IOCTL_RADEON_INFO		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INFO, struct drm_radeon_info)
+#define DRM_IOCTL_RADEON_SET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_TILING, struct drm_radeon_gem_set_tiling)
+#define DRM_IOCTL_RADEON_GET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_GET_TILING, struct drm_radeon_gem_get_tiling)
+#define DRM_IOCTL_RADEON_GEM_BUSY	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_BUSY, struct drm_radeon_gem_busy)
+
+typedef struct drm_radeon_init {
+	enum {
+		RADEON_INIT_CP = 0x01,
+		RADEON_CLEANUP_CP = 0x02,
+		RADEON_INIT_R200_CP = 0x03,
+		RADEON_INIT_R300_CP = 0x04,
+		RADEON_INIT_R600_CP = 0x05
+	} func;
+	unsigned long sarea_priv_offset;
+	int is_pci;
+	int cp_mode;
+	int gart_size;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long ring_offset;
+	unsigned long ring_rptr_offset;
+	unsigned long buffers_offset;
+	unsigned long gart_textures_offset;
+} drm_radeon_init_t;
+
+typedef struct drm_radeon_cp_stop {
+	int flush;
+	int idle;
+} drm_radeon_cp_stop_t;
+
+typedef struct drm_radeon_fullscreen {
+	enum {
+		RADEON_INIT_FULLSCREEN = 0x01,
+		RADEON_CLEANUP_FULLSCREEN = 0x02
+	} func;
+} drm_radeon_fullscreen_t;
+
+#define CLEAR_X1	0
+#define CLEAR_Y1	1
+#define CLEAR_X2	2
+#define CLEAR_Y2	3
+#define CLEAR_DEPTH	4
+
+typedef union drm_radeon_clear_rect {
+	float f[5];
+	unsigned int ui[5];
+} drm_radeon_clear_rect_t;
+
+typedef struct drm_radeon_clear {
+	unsigned int flags;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int color_mask;
+	unsigned int depth_mask;	/* misnamed field:  should be stencil */
+	drm_radeon_clear_rect_t *depth_boxes;
+} drm_radeon_clear_t;
+
+typedef struct drm_radeon_vertex {
+	int prim;
+	int idx;		/* Index of vertex buffer */
+	int count;		/* Number of vertices in buffer */
+	int discard;		/* Client finished with buffer? */
+} drm_radeon_vertex_t;
+
+typedef struct drm_radeon_indices {
+	int prim;
+	int idx;
+	int start;
+	int end;
+	int discard;		/* Client finished with buffer? */
+} drm_radeon_indices_t;
+
+/* v1.2 - obsoletes drm_radeon_vertex and drm_radeon_indices
+ *      - allows multiple primitives and state changes in a single ioctl
+ *      - supports driver change to emit native primitives
+ */
+typedef struct drm_radeon_vertex2 {
+	int idx;		/* Index of vertex buffer */
+	int discard;		/* Client finished with buffer? */
+	int nr_states;
+	drm_radeon_state_t *state;
+	int nr_prims;
+	drm_radeon_prim_t *prim;
+} drm_radeon_vertex2_t;
+
+/* v1.3 - obsoletes drm_radeon_vertex2
+ *      - allows arbitarily large cliprect list
+ *      - allows updating of tcl packet, vector and scalar state
+ *      - allows memory-efficient description of state updates
+ *      - allows state to be emitted without a primitive
+ *           (for clears, ctx switches)
+ *      - allows more than one dma buffer to be referenced per ioctl
+ *      - supports tcl driver
+ *      - may be extended in future versions with new cmd types, packets
+ */
+typedef struct drm_radeon_cmd_buffer {
+	int bufsz;
+	char *buf;
+	int nbox;
+	struct drm_clip_rect *boxes;
+} drm_radeon_cmd_buffer_t;
+
+typedef struct drm_radeon_tex_image {
+	unsigned int x, y;	/* Blit coordinates */
+	unsigned int width, height;
+	const void *data;
+} drm_radeon_tex_image_t;
+
+typedef struct drm_radeon_texture {
+	unsigned int offset;
+	int pitch;
+	int format;
+	int width;		/* Texture image coordinates */
+	int height;
+	drm_radeon_tex_image_t *image;
+} drm_radeon_texture_t;
+
+typedef struct drm_radeon_stipple {
+	unsigned int *mask;
+} drm_radeon_stipple_t;
+
+typedef struct drm_radeon_indirect {
+	int idx;
+	int start;
+	int end;
+	int discard;
+} drm_radeon_indirect_t;
+
+/* enum for card type parameters */
+#define RADEON_CARD_PCI 0
+#define RADEON_CARD_AGP 1
+#define RADEON_CARD_PCIE 2
+
+/* 1.3: An ioctl to get parameters that aren't available to the 3d
+ * client any other way.
+ */
+#define RADEON_PARAM_GART_BUFFER_OFFSET    1	/* card offset of 1st GART buffer */
+#define RADEON_PARAM_LAST_FRAME            2
+#define RADEON_PARAM_LAST_DISPATCH         3
+#define RADEON_PARAM_LAST_CLEAR            4
+/* Added with DRM version 1.6. */
+#define RADEON_PARAM_IRQ_NR                5
+#define RADEON_PARAM_GART_BASE             6	/* card offset of GART base */
+/* Added with DRM version 1.8. */
+#define RADEON_PARAM_REGISTER_HANDLE       7	/* for drmMap() */
+#define RADEON_PARAM_STATUS_HANDLE         8
+#define RADEON_PARAM_SAREA_HANDLE          9
+#define RADEON_PARAM_GART_TEX_HANDLE       10
+#define RADEON_PARAM_SCRATCH_OFFSET        11
+#define RADEON_PARAM_CARD_TYPE             12
+#define RADEON_PARAM_VBLANK_CRTC           13   /* VBLANK CRTC */
+#define RADEON_PARAM_FB_LOCATION           14   /* FB location */
+#define RADEON_PARAM_NUM_GB_PIPES          15   /* num GB pipes */
+#define RADEON_PARAM_DEVICE_ID             16
+#define RADEON_PARAM_NUM_Z_PIPES           17   /* num Z pipes */
+
+typedef struct drm_radeon_getparam {
+	int param;
+	void *value;
+} drm_radeon_getparam_t;
+
+/* 1.6: Set up a memory manager for regions of shared memory:
+ */
+#define RADEON_MEM_REGION_GART 1
+#define RADEON_MEM_REGION_FB   2
+
+typedef struct drm_radeon_mem_alloc {
+	int region;
+	int alignment;
+	int size;
+	int *region_offset;	/* offset from start of fb or GART */
+} drm_radeon_mem_alloc_t;
+
+typedef struct drm_radeon_mem_free {
+	int region;
+	int region_offset;
+} drm_radeon_mem_free_t;
+
+typedef struct drm_radeon_mem_init_heap {
+	int region;
+	int size;
+	int start;
+} drm_radeon_mem_init_heap_t;
+
+/* 1.6: Userspace can request & wait on irq's:
+ */
+typedef struct drm_radeon_irq_emit {
+	int *irq_seq;
+} drm_radeon_irq_emit_t;
+
+typedef struct drm_radeon_irq_wait {
+	int irq_seq;
+} drm_radeon_irq_wait_t;
+
+/* 1.10: Clients tell the DRM where they think the framebuffer is located in
+ * the card's address space, via a new generic ioctl to set parameters
+ */
+
+typedef struct drm_radeon_setparam {
+	unsigned int param;
+	__s64 value;
+} drm_radeon_setparam_t;
+
+#define RADEON_SETPARAM_FB_LOCATION    1	/* determined framebuffer location */
+#define RADEON_SETPARAM_SWITCH_TILING  2	/* enable/disable color tiling */
+#define RADEON_SETPARAM_PCIGART_LOCATION 3	/* PCI Gart Location */
+#define RADEON_SETPARAM_NEW_MEMMAP 4		/* Use new memory map */
+#define RADEON_SETPARAM_PCIGART_TABLE_SIZE 5    /* PCI GART Table Size */
+#define RADEON_SETPARAM_VBLANK_CRTC 6           /* VBLANK CRTC */
+/* 1.14: Clients can allocate/free a surface
+ */
+typedef struct drm_radeon_surface_alloc {
+	unsigned int address;
+	unsigned int size;
+	unsigned int flags;
+} drm_radeon_surface_alloc_t;
+
+typedef struct drm_radeon_surface_free {
+	unsigned int address;
+} drm_radeon_surface_free_t;
+
+#define	DRM_RADEON_VBLANK_CRTC1		1
+#define	DRM_RADEON_VBLANK_CRTC2		2
+
+/*
+ * Kernel modesetting world below.
+ */
+#define RADEON_GEM_DOMAIN_CPU		0x1
+#define RADEON_GEM_DOMAIN_GTT		0x2
+#define RADEON_GEM_DOMAIN_VRAM		0x4
+
+struct drm_radeon_gem_info {
+	uint64_t	gart_size;
+	uint64_t	vram_size;
+	uint64_t	vram_visible;
+};
+
+#define RADEON_GEM_NO_BACKING_STORE 1
+
+struct drm_radeon_gem_create {
+	uint64_t	size;
+	uint64_t	alignment;
+	uint32_t	handle;
+	uint32_t	initial_domain;
+	uint32_t	flags;
+};
+
+#define RADEON_TILING_MACRO       0x1
+#define RADEON_TILING_MICRO       0x2
+#define RADEON_TILING_SWAP_16BIT  0x4
+#define RADEON_TILING_SWAP_32BIT  0x8
+#define RADEON_TILING_SURFACE     0x10 /* this object requires a surface
+					* when mapped - i.e. front buffer */
+
+struct drm_radeon_gem_set_tiling {
+	uint32_t	handle;
+	uint32_t	tiling_flags;
+	uint32_t	pitch;
+};
+
+struct drm_radeon_gem_get_tiling {
+	uint32_t	handle;
+	uint32_t	tiling_flags;
+	uint32_t	pitch;
+};
+
+struct drm_radeon_gem_mmap {
+	uint32_t	handle;
+	uint32_t	pad;
+	uint64_t	offset;
+	uint64_t	size;
+	uint64_t	addr_ptr;
+};
+
+struct drm_radeon_gem_set_domain {
+	uint32_t	handle;
+	uint32_t	read_domains;
+	uint32_t	write_domain;
+};
+
+struct drm_radeon_gem_wait_idle {
+	uint32_t	handle;
+	uint32_t	pad;
+};
+
+struct drm_radeon_gem_busy {
+	uint32_t	handle;
+	uint32_t        domain;
+};
+
+struct drm_radeon_gem_pread {
+	/** Handle for the object being read. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to read from */
+	uint64_t offset;
+	/** Length of data to read */
+	uint64_t size;
+	/** Pointer to write the data into. */
+	/* void *, but pointers are not 32/64 compatible */
+	uint64_t data_ptr;
+};
+
+struct drm_radeon_gem_pwrite {
+	/** Handle for the object being written to. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to write to */
+	uint64_t offset;
+	/** Length of data to write */
+	uint64_t size;
+	/** Pointer to read the data from. */
+	/* void *, but pointers are not 32/64 compatible */
+	uint64_t data_ptr;
+};
+
+#define RADEON_CHUNK_ID_RELOCS	0x01
+#define RADEON_CHUNK_ID_IB	0x02
+
+struct drm_radeon_cs_chunk {
+	uint32_t		chunk_id;
+	uint32_t		length_dw;
+	uint64_t		chunk_data;
+};
+
+struct drm_radeon_cs_reloc {
+	uint32_t		handle;
+	uint32_t		read_domains;
+	uint32_t		write_domain;
+	uint32_t		flags;
+};
+
+struct drm_radeon_cs {
+	uint32_t		num_chunks;
+	uint32_t		cs_id;
+	/* this points to uint64_t * which point to cs chunks */
+	uint64_t		chunks;
+	/* updates to the limits after this CS ioctl */
+	uint64_t		gart_limit;
+	uint64_t		vram_limit;
+};
+
+#define RADEON_INFO_DEVICE_ID		0x00
+#define RADEON_INFO_NUM_GB_PIPES	0x01
+#define RADEON_INFO_NUM_Z_PIPES 	0x02
+#define RADEON_INFO_ACCEL_WORKING	0x03
+
+struct drm_radeon_info {
+	uint32_t		request;
+	uint32_t		pad;
+	uint64_t		value;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/savage_drm.h clean_modified/linux-2.6.32/usr/include/drm/savage_drm.h
--- linux-2.6.32/usr/include/drm/savage_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/savage_drm.h	2019-04-14 13:24:02.900780166 -0500
@@ -0,0 +1,210 @@
+/* savage_drm.h -- Public header for the savage driver
+ *
+ * Copyright 2004  Felix Kuehling
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL FELIX KUEHLING BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __SAVAGE_DRM_H__
+#define __SAVAGE_DRM_H__
+
+#ifndef __SAVAGE_SAREA_DEFINES__
+#define __SAVAGE_SAREA_DEFINES__
+
+/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+ * regions, subject to a minimum region size of (1<<16) == 64k.
+ *
+ * Clients may subdivide regions internally, but when sharing between
+ * clients, the region size is the minimum granularity.
+ */
+
+#define SAVAGE_CARD_HEAP		0
+#define SAVAGE_AGP_HEAP			1
+#define SAVAGE_NR_TEX_HEAPS		2
+#define SAVAGE_NR_TEX_REGIONS		16
+#define SAVAGE_LOG_MIN_TEX_REGION_SIZE	16
+
+#endif				/* __SAVAGE_SAREA_DEFINES__ */
+
+typedef struct _drm_savage_sarea {
+	/* LRU lists for texture memory in agp space and on the card.
+	 */
+	struct drm_tex_region texList[SAVAGE_NR_TEX_HEAPS][SAVAGE_NR_TEX_REGIONS +
+						      1];
+	unsigned int texAge[SAVAGE_NR_TEX_HEAPS];
+
+	/* Mechanism to validate card state.
+	 */
+	int ctxOwner;
+} drm_savage_sarea_t, *drm_savage_sarea_ptr;
+
+/* Savage-specific ioctls
+ */
+#define DRM_SAVAGE_BCI_INIT		0x00
+#define DRM_SAVAGE_BCI_CMDBUF           0x01
+#define DRM_SAVAGE_BCI_EVENT_EMIT	0x02
+#define DRM_SAVAGE_BCI_EVENT_WAIT	0x03
+
+#define DRM_IOCTL_SAVAGE_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_INIT, drm_savage_init_t)
+#define DRM_IOCTL_SAVAGE_CMDBUF		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_CMDBUF, drm_savage_cmdbuf_t)
+#define DRM_IOCTL_SAVAGE_EVENT_EMIT	DRM_IOWR(DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_EMIT, drm_savage_event_emit_t)
+#define DRM_IOCTL_SAVAGE_EVENT_WAIT	DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_WAIT, drm_savage_event_wait_t)
+
+#define SAVAGE_DMA_PCI	1
+#define SAVAGE_DMA_AGP	3
+typedef struct drm_savage_init {
+	enum {
+		SAVAGE_INIT_BCI = 1,
+		SAVAGE_CLEANUP_BCI = 2
+	} func;
+	unsigned int sarea_priv_offset;
+
+	/* some parameters */
+	unsigned int cob_size;
+	unsigned int bci_threshold_lo, bci_threshold_hi;
+	unsigned int dma_type;
+
+	/* frame buffer layout */
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	/* local textures */
+	unsigned int texture_offset;
+	unsigned int texture_size;
+
+	/* physical locations of non-permanent maps */
+	unsigned long status_offset;
+	unsigned long buffers_offset;
+	unsigned long agp_textures_offset;
+	unsigned long cmd_dma_offset;
+} drm_savage_init_t;
+
+typedef union drm_savage_cmd_header drm_savage_cmd_header_t;
+typedef struct drm_savage_cmdbuf {
+	/* command buffer in client's address space */
+	drm_savage_cmd_header_t *cmd_addr;
+	unsigned int size;	/* size of the command buffer in 64bit units */
+
+	unsigned int dma_idx;	/* DMA buffer index to use */
+	int discard;		/* discard DMA buffer when done */
+	/* vertex buffer in client's address space */
+	unsigned int *vb_addr;
+	unsigned int vb_size;	/* size of client vertex buffer in bytes */
+	unsigned int vb_stride;	/* stride of vertices in 32bit words */
+	/* boxes in client's address space */
+	struct drm_clip_rect *box_addr;
+	unsigned int nbox;	/* number of clipping boxes */
+} drm_savage_cmdbuf_t;
+
+#define SAVAGE_WAIT_2D  0x1	/* wait for 2D idle before updating event tag */
+#define SAVAGE_WAIT_3D  0x2	/* wait for 3D idle before updating event tag */
+#define SAVAGE_WAIT_IRQ 0x4	/* emit or wait for IRQ, not implemented yet */
+typedef struct drm_savage_event {
+	unsigned int count;
+	unsigned int flags;
+} drm_savage_event_emit_t, drm_savage_event_wait_t;
+
+/* Commands for the cmdbuf ioctl
+ */
+#define SAVAGE_CMD_STATE	0	/* a range of state registers */
+#define SAVAGE_CMD_DMA_PRIM	1	/* vertices from DMA buffer */
+#define SAVAGE_CMD_VB_PRIM	2	/* vertices from client vertex buffer */
+#define SAVAGE_CMD_DMA_IDX	3	/* indexed vertices from DMA buffer */
+#define SAVAGE_CMD_VB_IDX	4	/* indexed vertices client vertex buffer */
+#define SAVAGE_CMD_CLEAR	5	/* clear buffers */
+#define SAVAGE_CMD_SWAP		6	/* swap buffers */
+
+/* Primitive types
+*/
+#define SAVAGE_PRIM_TRILIST	0	/* triangle list */
+#define SAVAGE_PRIM_TRISTRIP	1	/* triangle strip */
+#define SAVAGE_PRIM_TRIFAN	2	/* triangle fan */
+#define SAVAGE_PRIM_TRILIST_201	3	/* reorder verts for correct flat
+					 * shading on s3d */
+
+/* Skip flags (vertex format)
+ */
+#define SAVAGE_SKIP_Z		0x01
+#define SAVAGE_SKIP_W		0x02
+#define SAVAGE_SKIP_C0		0x04
+#define SAVAGE_SKIP_C1		0x08
+#define SAVAGE_SKIP_S0		0x10
+#define SAVAGE_SKIP_T0		0x20
+#define SAVAGE_SKIP_ST0		0x30
+#define SAVAGE_SKIP_S1		0x40
+#define SAVAGE_SKIP_T1		0x80
+#define SAVAGE_SKIP_ST1		0xc0
+#define SAVAGE_SKIP_ALL_S3D	0x3f
+#define SAVAGE_SKIP_ALL_S4	0xff
+
+/* Buffer names for clear command
+ */
+#define SAVAGE_FRONT		0x1
+#define SAVAGE_BACK		0x2
+#define SAVAGE_DEPTH		0x4
+
+/* 64-bit command header
+ */
+union drm_savage_cmd_header {
+	struct {
+		unsigned char cmd;	/* command */
+		unsigned char pad0;
+		unsigned short pad1;
+		unsigned short pad2;
+		unsigned short pad3;
+	} cmd;			/* generic */
+	struct {
+		unsigned char cmd;
+		unsigned char global;	/* need idle engine? */
+		unsigned short count;	/* number of consecutive registers */
+		unsigned short start;	/* first register */
+		unsigned short pad3;
+	} state;		/* SAVAGE_CMD_STATE */
+	struct {
+		unsigned char cmd;
+		unsigned char prim;	/* primitive type */
+		unsigned short skip;	/* vertex format (skip flags) */
+		unsigned short count;	/* number of vertices */
+		unsigned short start;	/* first vertex in DMA/vertex buffer */
+	} prim;			/* SAVAGE_CMD_DMA_PRIM, SAVAGE_CMD_VB_PRIM */
+	struct {
+		unsigned char cmd;
+		unsigned char prim;
+		unsigned short skip;
+		unsigned short count;	/* number of indices that follow */
+		unsigned short pad3;
+	} idx;			/* SAVAGE_CMD_DMA_IDX, SAVAGE_CMD_VB_IDX */
+	struct {
+		unsigned char cmd;
+		unsigned char pad0;
+		unsigned short pad1;
+		unsigned int flags;
+	} clear0;		/* SAVAGE_CMD_CLEAR */
+	struct {
+		unsigned int mask;
+		unsigned int value;
+	} clear1;		/* SAVAGE_CMD_CLEAR data */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/drm/sis_drm.h clean_modified/linux-2.6.32/usr/include/drm/sis_drm.h
--- linux-2.6.32/usr/include/drm/sis_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/sis_drm.h	2019-04-14 13:24:02.900780166 -0500
@@ -0,0 +1,67 @@
+/* sis_drv.h -- Private header for sis driver -*- linux-c -*- */
+/*
+ * Copyright 2005 Eric Anholt
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef __SIS_DRM_H__
+#define __SIS_DRM_H__
+
+/* SiS specific ioctls */
+#define NOT_USED_0_3
+#define DRM_SIS_FB_ALLOC	0x04
+#define DRM_SIS_FB_FREE	        0x05
+#define NOT_USED_6_12
+#define DRM_SIS_AGP_INIT	0x13
+#define DRM_SIS_AGP_ALLOC	0x14
+#define DRM_SIS_AGP_FREE	0x15
+#define DRM_SIS_FB_INIT	        0x16
+
+#define DRM_IOCTL_SIS_FB_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_FB_ALLOC, drm_sis_mem_t)
+#define DRM_IOCTL_SIS_FB_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_FREE, drm_sis_mem_t)
+#define DRM_IOCTL_SIS_AGP_INIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_INIT, drm_sis_agp_t)
+#define DRM_IOCTL_SIS_AGP_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_ALLOC, drm_sis_mem_t)
+#define DRM_IOCTL_SIS_AGP_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_AGP_FREE, drm_sis_mem_t)
+#define DRM_IOCTL_SIS_FB_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_INIT, drm_sis_fb_t)
+/*
+#define DRM_IOCTL_SIS_FLIP		DRM_IOW( 0x48, drm_sis_flip_t)
+#define DRM_IOCTL_SIS_FLIP_INIT		DRM_IO(  0x49)
+#define DRM_IOCTL_SIS_FLIP_FINAL	DRM_IO(  0x50)
+*/
+
+typedef struct {
+	int context;
+	unsigned int offset;
+	unsigned int size;
+	unsigned long free;
+} drm_sis_mem_t;
+
+typedef struct {
+	unsigned int offset, size;
+} drm_sis_agp_t;
+
+typedef struct {
+	unsigned int offset, size;
+} drm_sis_fb_t;
+
+#endif				/* __SIS_DRM_H__ */
diff -uNr linux-2.6.32/usr/include/drm/via_drm.h clean_modified/linux-2.6.32/usr/include/drm/via_drm.h
--- linux-2.6.32/usr/include/drm/via_drm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/drm/via_drm.h	2019-04-14 13:24:02.900780166 -0500
@@ -0,0 +1,275 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_DRM_H_
+#define _VIA_DRM_H_
+
+#include <linux/types.h>
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.
+ */
+
+#ifndef _VIA_DEFINES_
+#define _VIA_DEFINES_
+
+#include "via_drmclient.h"
+
+#define VIA_NR_SAREA_CLIPRECTS		8
+#define VIA_NR_XVMC_PORTS               10
+#define VIA_NR_XVMC_LOCKS               5
+#define VIA_MAX_CACHELINE_SIZE          64
+#define XVMCLOCKPTR(saPriv,lockNo)					\
+	((__volatile__ struct drm_hw_lock *)(((((unsigned long) (saPriv)->XvMCLockArea) + \
+				      (VIA_MAX_CACHELINE_SIZE - 1)) &	\
+				     ~(VIA_MAX_CACHELINE_SIZE - 1)) +	\
+				    VIA_MAX_CACHELINE_SIZE*(lockNo)))
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.
+ */
+#define VIA_NR_TEX_REGIONS 64
+#define VIA_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+#define VIA_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
+#define VIA_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
+#define VIA_UPLOAD_CTX        0x4
+#define VIA_UPLOAD_BUFFERS    0x8
+#define VIA_UPLOAD_TEX0       0x10
+#define VIA_UPLOAD_TEX1       0x20
+#define VIA_UPLOAD_CLIPRECTS  0x40
+#define VIA_UPLOAD_ALL        0xff
+
+/* VIA specific ioctls */
+#define DRM_VIA_ALLOCMEM	0x00
+#define DRM_VIA_FREEMEM	        0x01
+#define DRM_VIA_AGP_INIT	0x02
+#define DRM_VIA_FB_INIT	        0x03
+#define DRM_VIA_MAP_INIT	0x04
+#define DRM_VIA_DEC_FUTEX       0x05
+#define NOT_USED
+#define DRM_VIA_DMA_INIT	0x07
+#define DRM_VIA_CMDBUFFER	0x08
+#define DRM_VIA_FLUSH	        0x09
+#define DRM_VIA_PCICMD	        0x0a
+#define DRM_VIA_CMDBUF_SIZE	0x0b
+#define NOT_USED
+#define DRM_VIA_WAIT_IRQ        0x0d
+#define DRM_VIA_DMA_BLIT        0x0e
+#define DRM_VIA_BLIT_SYNC       0x0f
+
+#define DRM_IOCTL_VIA_ALLOCMEM	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_ALLOCMEM, drm_via_mem_t)
+#define DRM_IOCTL_VIA_FREEMEM	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_FREEMEM, drm_via_mem_t)
+#define DRM_IOCTL_VIA_AGP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_AGP_INIT, drm_via_agp_t)
+#define DRM_IOCTL_VIA_FB_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_FB_INIT, drm_via_fb_t)
+#define DRM_IOCTL_VIA_MAP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_MAP_INIT, drm_via_init_t)
+#define DRM_IOCTL_VIA_DEC_FUTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_DEC_FUTEX, drm_via_futex_t)
+#define DRM_IOCTL_VIA_DMA_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_DMA_INIT, drm_via_dma_init_t)
+#define DRM_IOCTL_VIA_CMDBUFFER	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_CMDBUFFER, drm_via_cmdbuffer_t)
+#define DRM_IOCTL_VIA_FLUSH	  DRM_IO(  DRM_COMMAND_BASE + DRM_VIA_FLUSH)
+#define DRM_IOCTL_VIA_PCICMD	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_PCICMD, drm_via_cmdbuffer_t)
+#define DRM_IOCTL_VIA_CMDBUF_SIZE DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_CMDBUF_SIZE, \
+					    drm_via_cmdbuf_size_t)
+#define DRM_IOCTL_VIA_WAIT_IRQ    DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_WAIT_IRQ, drm_via_irqwait_t)
+#define DRM_IOCTL_VIA_DMA_BLIT    DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_DMA_BLIT, drm_via_dmablit_t)
+#define DRM_IOCTL_VIA_BLIT_SYNC   DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_BLIT_SYNC, drm_via_blitsync_t)
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+#define VIA_TEX_SETUP_SIZE 8
+
+/* Flags for clear ioctl
+ */
+#define VIA_FRONT   0x1
+#define VIA_BACK    0x2
+#define VIA_DEPTH   0x4
+#define VIA_STENCIL 0x8
+#define VIA_MEM_VIDEO   0	/* matches drm constant */
+#define VIA_MEM_AGP     1	/* matches drm constant */
+#define VIA_MEM_SYSTEM  2
+#define VIA_MEM_MIXED   3
+#define VIA_MEM_UNKNOWN 4
+
+typedef struct {
+	__u32 offset;
+	__u32 size;
+} drm_via_agp_t;
+
+typedef struct {
+	__u32 offset;
+	__u32 size;
+} drm_via_fb_t;
+
+typedef struct {
+	__u32 context;
+	__u32 type;
+	__u32 size;
+	unsigned long index;
+	unsigned long offset;
+} drm_via_mem_t;
+
+typedef struct _drm_via_init {
+	enum {
+		VIA_INIT_MAP = 0x01,
+		VIA_CLEANUP_MAP = 0x02
+	} func;
+
+	unsigned long sarea_priv_offset;
+	unsigned long fb_offset;
+	unsigned long mmio_offset;
+	unsigned long agpAddr;
+} drm_via_init_t;
+
+typedef struct _drm_via_futex {
+	enum {
+		VIA_FUTEX_WAIT = 0x00,
+		VIA_FUTEX_WAKE = 0X01
+	} func;
+	__u32 ms;
+	__u32 lock;
+	__u32 val;
+} drm_via_futex_t;
+
+typedef struct _drm_via_dma_init {
+	enum {
+		VIA_INIT_DMA = 0x01,
+		VIA_CLEANUP_DMA = 0x02,
+		VIA_DMA_INITIALIZED = 0x03
+	} func;
+
+	unsigned long offset;
+	unsigned long size;
+	unsigned long reg_pause_addr;
+} drm_via_dma_init_t;
+
+typedef struct _drm_via_cmdbuffer {
+	char *buf;
+	unsigned long size;
+} drm_via_cmdbuffer_t;
+
+/* Warning: If you change the SAREA structure you must change the Xserver
+ * structure as well */
+
+typedef struct _drm_via_tex_region {
+	unsigned char next, prev;	/* indices to form a circular LRU  */
+	unsigned char inUse;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+} drm_via_tex_region_t;
+
+typedef struct _drm_via_sarea {
+	unsigned int dirty;
+	unsigned int nbox;
+	struct drm_clip_rect boxes[VIA_NR_SAREA_CLIPRECTS];
+	drm_via_tex_region_t texList[VIA_NR_TEX_REGIONS + 1];
+	int texAge;		/* last time texture was uploaded */
+	int ctxOwner;		/* last context to upload state */
+	int vertexPrim;
+
+	/*
+	 * Below is for XvMC.
+	 * We want the lock integers alone on, and aligned to, a cache line.
+	 * Therefore this somewhat strange construct.
+	 */
+
+	char XvMCLockArea[VIA_MAX_CACHELINE_SIZE * (VIA_NR_XVMC_LOCKS + 1)];
+
+	unsigned int XvMCDisplaying[VIA_NR_XVMC_PORTS];
+	unsigned int XvMCSubPicOn[VIA_NR_XVMC_PORTS];
+	unsigned int XvMCCtxNoGrabbed;	/* Last context to hold decoder */
+
+	/* Used by the 3d driver only at this point, for pageflipping:
+	 */
+	unsigned int pfCurrentOffset;
+} drm_via_sarea_t;
+
+typedef struct _drm_via_cmdbuf_size {
+	enum {
+		VIA_CMDBUF_SPACE = 0x01,
+		VIA_CMDBUF_LAG = 0x02
+	} func;
+	int wait;
+	__u32 size;
+} drm_via_cmdbuf_size_t;
+
+typedef enum {
+	VIA_IRQ_ABSOLUTE = 0x0,
+	VIA_IRQ_RELATIVE = 0x1,
+	VIA_IRQ_SIGNAL = 0x10000000,
+	VIA_IRQ_FORCE_SEQUENCE = 0x20000000
+} via_irq_seq_type_t;
+
+#define VIA_IRQ_FLAGS_MASK 0xF0000000
+
+enum drm_via_irqs {
+	drm_via_irq_hqv0 = 0,
+	drm_via_irq_hqv1,
+	drm_via_irq_dma0_dd,
+	drm_via_irq_dma0_td,
+	drm_via_irq_dma1_dd,
+	drm_via_irq_dma1_td,
+	drm_via_irq_num
+};
+
+struct drm_via_wait_irq_request {
+	unsigned irq;
+	via_irq_seq_type_t type;
+	__u32 sequence;
+	__u32 signal;
+};
+
+typedef union drm_via_irqwait {
+	struct drm_via_wait_irq_request request;
+	struct drm_wait_vblank_reply reply;
+} drm_via_irqwait_t;
+
+typedef struct drm_via_blitsync {
+	__u32 sync_handle;
+	unsigned engine;
+} drm_via_blitsync_t;
+
+/* - * Below,"flags" is currently unused but will be used for possible future
+ * extensions like kernel space bounce buffers for bad alignments and
+ * blit engine busy-wait polling for better latency in the absence of
+ * interrupts.
+ */
+
+typedef struct drm_via_dmablit {
+	__u32 num_lines;
+	__u32 line_length;
+
+	__u32 fb_addr;
+	__u32 fb_stride;
+
+	unsigned char *mem_addr;
+	__u32 mem_stride;
+
+	__u32 flags;
+	int to_fb;
+
+	drm_via_blitsync_t sync;
+} drm_via_dmablit_t;
+
+#endif				/* _VIA_DRM_H_ */
diff -uNr linux-2.6.32/usr/include/linux/acct.h clean_modified/linux-2.6.32/usr/include/linux/acct.h
--- linux-2.6.32/usr/include/linux/acct.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/acct.h	2019-04-14 13:24:02.902223656 -0500
@@ -0,0 +1,114 @@
+/*
+ *  BSD Process Accounting for Linux - Definitions
+ *
+ *  Author: Marco van Wieringen (mvw@planets.elm.net)
+ *
+ *  This header file contains the definitions needed to implement
+ *  BSD-style process accounting. The kernel accounting code and all
+ *  user-level programs that try to do something useful with the
+ *  process accounting log must include this file.
+ *
+ *  Copyright (C) 1995 - 1997 Marco van Wieringen - ELM Consultancy B.V.
+ *
+ */
+
+#ifndef _LINUX_ACCT_H
+#define _LINUX_ACCT_H
+
+#include <linux/types.h>
+
+#include <asm/param.h>
+#include <asm/byteorder.h>
+
+/* 
+ *  comp_t is a 16-bit "floating" point number with a 3-bit base 8
+ *  exponent and a 13-bit fraction.
+ *  comp2_t is 24-bit with 5-bit base 2 exponent and 20 bit fraction
+ *  (leading 1 not stored).
+ *  See linux/kernel/acct.c for the specific encoding systems used.
+ */
+
+typedef __u16	comp_t;
+typedef __u32	comp2_t;
+
+/*
+ *   accounting file record
+ *
+ *   This structure contains all of the information written out to the
+ *   process accounting file whenever a process exits.
+ */
+
+#define ACCT_COMM	16
+
+struct acct
+{
+	char		ac_flag;		/* Flags */
+	char		ac_version;		/* Always set to ACCT_VERSION */
+	/* for binary compatibility back until 2.0 */
+	__u16		ac_uid16;		/* LSB of Real User ID */
+	__u16		ac_gid16;		/* LSB of Real Group ID */
+	__u16		ac_tty;			/* Control Terminal */
+	__u32		ac_btime;		/* Process Creation Time */
+	comp_t		ac_utime;		/* User Time */
+	comp_t		ac_stime;		/* System Time */
+	comp_t		ac_etime;		/* Elapsed Time */
+	comp_t		ac_mem;			/* Average Memory Usage */
+	comp_t		ac_io;			/* Chars Transferred */
+	comp_t		ac_rw;			/* Blocks Read or Written */
+	comp_t		ac_minflt;		/* Minor Pagefaults */
+	comp_t		ac_majflt;		/* Major Pagefaults */
+	comp_t		ac_swaps;		/* Number of Swaps */
+/* m68k had no padding here. */
+	__u16		ac_ahz;			/* AHZ */
+	__u32		ac_exitcode;		/* Exitcode */
+	char		ac_comm[ACCT_COMM + 1];	/* Command Name */
+	__u8		ac_etime_hi;		/* Elapsed Time MSB */
+	__u16		ac_etime_lo;		/* Elapsed Time LSB */
+	__u32		ac_uid;			/* Real User ID */
+	__u32		ac_gid;			/* Real Group ID */
+};
+
+struct acct_v3
+{
+	char		ac_flag;		/* Flags */
+	char		ac_version;		/* Always set to ACCT_VERSION */
+	__u16		ac_tty;			/* Control Terminal */
+	__u32		ac_exitcode;		/* Exitcode */
+	__u32		ac_uid;			/* Real User ID */
+	__u32		ac_gid;			/* Real Group ID */
+	__u32		ac_pid;			/* Process ID */
+	__u32		ac_ppid;		/* Parent Process ID */
+	__u32		ac_btime;		/* Process Creation Time */
+	float		ac_etime;		/* Elapsed Time */
+	comp_t		ac_utime;		/* User Time */
+	comp_t		ac_stime;		/* System Time */
+	comp_t		ac_mem;			/* Average Memory Usage */
+	comp_t		ac_io;			/* Chars Transferred */
+	comp_t		ac_rw;			/* Blocks Read or Written */
+	comp_t		ac_minflt;		/* Minor Pagefaults */
+	comp_t		ac_majflt;		/* Major Pagefaults */
+	comp_t		ac_swaps;		/* Number of Swaps */
+	char		ac_comm[ACCT_COMM];	/* Command Name */
+};
+
+/*
+ *  accounting flags
+ */
+				/* bit set when the process ... */
+#define AFORK		0x01	/* ... executed fork, but did not exec */
+#define ASU		0x02	/* ... used super-user privileges */
+#define ACOMPAT		0x04	/* ... used compatibility mode (VAX only not used) */
+#define ACORE		0x08	/* ... dumped core */
+#define AXSIG		0x10	/* ... was killed by a signal */
+
+#ifdef __BIG_ENDIAN
+#define ACCT_BYTEORDER	0x80	/* accounting file is big endian */
+#else
+#define ACCT_BYTEORDER	0x00	/* accounting file is little endian */
+#endif
+
+#define ACCT_VERSION	2
+#define AHZ		(HZ)
+
+
+#endif	/* _LINUX_ACCT_H */
diff -uNr linux-2.6.32/usr/include/linux/adb.h clean_modified/linux-2.6.32/usr/include/linux/adb.h
--- linux-2.6.32/usr/include/linux/adb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/adb.h	2019-04-14 13:24:02.903210168 -0500
@@ -0,0 +1,44 @@
+/*
+ * Definitions for ADB (Apple Desktop Bus) support.
+ */
+#ifndef __ADB_H
+#define __ADB_H
+
+/* ADB commands */
+#define ADB_BUSRESET		0
+#define ADB_FLUSH(id)		(0x01 | ((id) << 4))
+#define ADB_WRITEREG(id, reg)	(0x08 | (reg) | ((id) << 4))
+#define ADB_READREG(id, reg)	(0x0C | (reg) | ((id) << 4))
+
+/* ADB default device IDs (upper 4 bits of ADB command byte) */
+#define ADB_DONGLE	1	/* "software execution control" devices */
+#define ADB_KEYBOARD	2
+#define ADB_MOUSE	3
+#define ADB_TABLET	4
+#define ADB_MODEM	5
+#define ADB_MISC	7	/* maybe a monitor */
+
+#define ADB_RET_OK	0
+#define ADB_RET_TIMEOUT	3
+
+/* The kind of ADB request. The controller may emulate some
+   or all of those CUDA/PMU packet kinds */
+#define ADB_PACKET	0
+#define CUDA_PACKET	1
+#define ERROR_PACKET	2
+#define TIMER_PACKET	3
+#define POWER_PACKET	4
+#define MACIIC_PACKET	5
+#define PMU_PACKET	6
+#define ADB_QUERY	7
+
+/* ADB queries */
+
+/* ADB_QUERY_GETDEVINFO
+ * Query ADB slot for device presence
+ * data[2] = id, rep[0] = orig addr, rep[1] = handler_id
+ */
+#define ADB_QUERY_GETDEVINFO	1
+
+
+#endif /* __ADB_H */
diff -uNr linux-2.6.32/usr/include/linux/adfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/adfs_fs.h
--- linux-2.6.32/usr/include/linux/adfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/adfs_fs.h	2019-04-14 13:24:02.904181429 -0500
@@ -0,0 +1,44 @@
+#ifndef _ADFS_FS_H
+#define _ADFS_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/*
+ * Disc Record at disc address 0xc00
+ */
+struct adfs_discrecord {
+    __u8  log2secsize;
+    __u8  secspertrack;
+    __u8  heads;
+    __u8  density;
+    __u8  idlen;
+    __u8  log2bpmb;
+    __u8  skew;
+    __u8  bootoption;
+    __u8  lowsector;
+    __u8  nzones;
+    __le16 zone_spare;
+    __le32 root;
+    __le32 disc_size;
+    __le16 disc_id;
+    __u8  disc_name[10];
+    __le32 disc_type;
+    __le32 disc_size_high;
+    __u8  log2sharesize:4;
+    __u8  unused40:4;
+    __u8  big_flag:1;
+    __u8  unused41:1;
+    __u8  nzones_high;
+    __le32 format_version;
+    __le32 root_size;
+    __u8  unused52[60 - 52];
+};
+
+#define ADFS_DISCRECORD		(0xc00)
+#define ADFS_DR_OFFSET		(0x1c0)
+#define ADFS_DR_SIZE		 60
+#define ADFS_DR_SIZE_BITS	(ADFS_DR_SIZE << 3)
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/affs_hardblocks.h clean_modified/linux-2.6.32/usr/include/linux/affs_hardblocks.h
--- linux-2.6.32/usr/include/linux/affs_hardblocks.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/affs_hardblocks.h	2019-04-14 13:24:02.904849489 -0500
@@ -0,0 +1,68 @@
+#ifndef	AFFS_HARDBLOCKS_H
+#define	AFFS_HARDBLOCKS_H
+
+#include <linux/types.h>
+
+/* Just the needed definitions for the RDB of an Amiga HD. */
+
+struct RigidDiskBlock {
+	__u32	rdb_ID;
+	__be32	rdb_SummedLongs;
+	__s32	rdb_ChkSum;
+	__u32	rdb_HostID;
+	__be32	rdb_BlockBytes;
+	__u32	rdb_Flags;
+	__u32	rdb_BadBlockList;
+	__be32	rdb_PartitionList;
+	__u32	rdb_FileSysHeaderList;
+	__u32	rdb_DriveInit;
+	__u32	rdb_Reserved1[6];
+	__u32	rdb_Cylinders;
+	__u32	rdb_Sectors;
+	__u32	rdb_Heads;
+	__u32	rdb_Interleave;
+	__u32	rdb_Park;
+	__u32	rdb_Reserved2[3];
+	__u32	rdb_WritePreComp;
+	__u32	rdb_ReducedWrite;
+	__u32	rdb_StepRate;
+	__u32	rdb_Reserved3[5];
+	__u32	rdb_RDBBlocksLo;
+	__u32	rdb_RDBBlocksHi;
+	__u32	rdb_LoCylinder;
+	__u32	rdb_HiCylinder;
+	__u32	rdb_CylBlocks;
+	__u32	rdb_AutoParkSeconds;
+	__u32	rdb_HighRDSKBlock;
+	__u32	rdb_Reserved4;
+	char	rdb_DiskVendor[8];
+	char	rdb_DiskProduct[16];
+	char	rdb_DiskRevision[4];
+	char	rdb_ControllerVendor[8];
+	char	rdb_ControllerProduct[16];
+	char	rdb_ControllerRevision[4];
+	__u32	rdb_Reserved5[10];
+};
+
+#define	IDNAME_RIGIDDISK	0x5244534B	/* "RDSK" */
+
+struct PartitionBlock {
+	__be32	pb_ID;
+	__be32	pb_SummedLongs;
+	__s32	pb_ChkSum;
+	__u32	pb_HostID;
+	__be32	pb_Next;
+	__u32	pb_Flags;
+	__u32	pb_Reserved1[2];
+	__u32	pb_DevFlags;
+	__u8	pb_DriveName[32];
+	__u32	pb_Reserved2[15];
+	__be32	pb_Environment[17];
+	__u32	pb_EReserved[15];
+};
+
+#define	IDNAME_PARTITION	0x50415254	/* "PART" */
+
+#define RDB_ALLOCATION_LIMIT	16
+
+#endif	/* AFFS_HARDBLOCKS_H */
diff -uNr linux-2.6.32/usr/include/linux/agpgart.h clean_modified/linux-2.6.32/usr/include/linux/agpgart.h
--- linux-2.6.32/usr/include/linux/agpgart.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/agpgart.h	2019-04-14 13:24:02.904849489 -0500
@@ -0,0 +1,111 @@
+/*
+ * AGPGART module version 0.99
+ * Copyright (C) 1999 Jeff Hartmann
+ * Copyright (C) 1999 Precision Insight, Inc.
+ * Copyright (C) 1999 Xi Graphics, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * JEFF HARTMANN, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _AGP_H
+#define _AGP_H 1
+
+#define AGPIOC_BASE       'A'
+#define AGPIOC_INFO       _IOR (AGPIOC_BASE, 0, struct agp_info*)
+#define AGPIOC_ACQUIRE    _IO  (AGPIOC_BASE, 1)
+#define AGPIOC_RELEASE    _IO  (AGPIOC_BASE, 2)
+#define AGPIOC_SETUP      _IOW (AGPIOC_BASE, 3, struct agp_setup*)
+#define AGPIOC_RESERVE    _IOW (AGPIOC_BASE, 4, struct agp_region*)
+#define AGPIOC_PROTECT    _IOW (AGPIOC_BASE, 5, struct agp_region*)
+#define AGPIOC_ALLOCATE   _IOWR(AGPIOC_BASE, 6, struct agp_allocate*)
+#define AGPIOC_DEALLOCATE _IOW (AGPIOC_BASE, 7, int)
+#define AGPIOC_BIND       _IOW (AGPIOC_BASE, 8, struct agp_bind*)
+#define AGPIOC_UNBIND     _IOW (AGPIOC_BASE, 9, struct agp_unbind*)
+#define AGPIOC_CHIPSET_FLUSH _IO (AGPIOC_BASE, 10)
+
+#define AGP_DEVICE      "/dev/agpgart"
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#include <linux/types.h>
+
+struct agp_version {
+	__u16 major;
+	__u16 minor;
+};
+
+typedef struct _agp_info {
+	struct agp_version version;	/* version of the driver        */
+	__u32 bridge_id;	/* bridge vendor/device         */
+	__u32 agp_mode;		/* mode info of bridge          */
+	unsigned long aper_base;/* base of aperture             */
+	size_t aper_size;	/* size of aperture             */
+	size_t pg_total;	/* max pages (swap + system)    */
+	size_t pg_system;	/* max pages (system)           */
+	size_t pg_used;		/* current pages used           */
+} agp_info;
+
+typedef struct _agp_setup {
+	__u32 agp_mode;		/* mode info of bridge          */
+} agp_setup;
+
+/*
+ * The "prot" down below needs still a "sleep" flag somehow ...
+ */
+typedef struct _agp_segment {
+	__kernel_off_t pg_start;	/* starting page to populate    */
+	__kernel_size_t pg_count;	/* number of pages              */
+	int prot;			/* prot flags for mmap          */
+} agp_segment;
+
+typedef struct _agp_region {
+	__kernel_pid_t pid;		/* pid of process       */
+	__kernel_size_t seg_count;	/* number of segments   */
+	struct _agp_segment *seg_list;
+} agp_region;
+
+typedef struct _agp_allocate {
+	int key;		/* tag of allocation            */
+	__kernel_size_t pg_count;/* number of pages             */
+	__u32 type;		/* 0 == normal, other devspec   */
+   	__u32 physical;         /* device specific (some devices  
+				 * need a phys address of the     
+				 * actual page behind the gatt    
+				 * table)                        */
+} agp_allocate;
+
+typedef struct _agp_bind {
+	int key;		/* tag of allocation            */
+	__kernel_off_t pg_start;/* starting page to populate    */
+} agp_bind;
+
+typedef struct _agp_unbind {
+	int key;		/* tag of allocation            */
+	__u32 priority;		/* priority for paging out      */
+} agp_unbind;
+
+
+#endif				/* _AGP_H */
diff -uNr linux-2.6.32/usr/include/linux/aio_abi.h clean_modified/linux-2.6.32/usr/include/linux/aio_abi.h
--- linux-2.6.32/usr/include/linux/aio_abi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/aio_abi.h	2019-04-14 13:24:02.906102255 -0500
@@ -0,0 +1,111 @@
+/* include/linux/aio_abi.h
+ *
+ * Copyright 2000,2001,2002 Red Hat.
+ *
+ * Written by Benjamin LaHaise <bcrl@kvack.org>
+ *
+ * Distribute under the terms of the GPLv2 (see ../../COPYING) or under 
+ * the following terms.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, provided that the above copyright
+ * notice appears in all copies.  This software is provided without any
+ * warranty, express or implied.  Red Hat makes no representations about
+ * the suitability of this software for any purpose.
+ *
+ * IN NO EVENT SHALL RED HAT BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+ * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
+ * THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF RED HAT HAS BEEN ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * RED HAT DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND
+ * RED HAT HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
+ * ENHANCEMENTS, OR MODIFICATIONS.
+ */
+#ifndef __LINUX__AIO_ABI_H
+#define __LINUX__AIO_ABI_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef unsigned long	aio_context_t;
+
+enum {
+	IOCB_CMD_PREAD = 0,
+	IOCB_CMD_PWRITE = 1,
+	IOCB_CMD_FSYNC = 2,
+	IOCB_CMD_FDSYNC = 3,
+	/* These two are experimental.
+	 * IOCB_CMD_PREADX = 4,
+	 * IOCB_CMD_POLL = 5,
+	 */
+	IOCB_CMD_NOOP = 6,
+	IOCB_CMD_PREADV = 7,
+	IOCB_CMD_PWRITEV = 8,
+};
+
+/*
+ * Valid flags for the "aio_flags" member of the "struct iocb".
+ *
+ * IOCB_FLAG_RESFD - Set if the "aio_resfd" member of the "struct iocb"
+ *                   is valid.
+ */
+#define IOCB_FLAG_RESFD		(1 << 0)
+
+/* read() from /dev/aio returns these structures. */
+struct io_event {
+	__u64		data;		/* the data field from the iocb */
+	__u64		obj;		/* what iocb this event came from */
+	__s64		res;		/* result code for this event */
+	__s64		res2;		/* secondary result */
+};
+
+#if defined(__LITTLE_ENDIAN)
+#define PADDED(x,y)	x, y
+#elif defined(__BIG_ENDIAN)
+#define PADDED(x,y)	y, x
+#else
+#error edit for your odd byteorder.
+#endif
+
+/*
+ * we always use a 64bit off_t when communicating
+ * with userland.  its up to libraries to do the
+ * proper padding and aio_error abstraction
+ */
+
+struct iocb {
+	/* these are internal to the kernel/libc. */
+	__u64	aio_data;	/* data to be returned in event's data */
+	__u32	PADDED(aio_key, aio_reserved1);
+				/* the kernel sets aio_key to the req # */
+
+	/* common fields */
+	__u16	aio_lio_opcode;	/* see IOCB_CMD_ above */
+	__s16	aio_reqprio;
+	__u32	aio_fildes;
+
+	__u64	aio_buf;
+	__u64	aio_nbytes;
+	__s64	aio_offset;
+
+	/* extra parameters */
+	__u64	aio_reserved2;	/* TODO: use this for a (struct sigevent *) */
+
+	/* flags for the "struct iocb" */
+	__u32	aio_flags;
+
+	/*
+	 * if the IOCB_FLAG_RESFD flag of "aio_flags" is set, this is an
+	 * eventfd to signal AIO readiness to
+	 */
+	__u32	aio_resfd;
+}; /* 64 bytes */
+
+#undef IFBIG
+#undef IFLITTLE
+
+#endif /* __LINUX__AIO_ABI_H */
+
diff -uNr linux-2.6.32/usr/include/linux/a.out.h clean_modified/linux-2.6.32/usr/include/linux/a.out.h
--- linux-2.6.32/usr/include/linux/a.out.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/a.out.h	2019-04-14 13:24:02.906102255 -0500
@@ -0,0 +1,270 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#define __GNU_EXEC_MACROS__
+
+#ifndef __STRUCT_EXEC_OVERRIDE__
+
+#include <asm/a.out.h>
+
+#endif /* __STRUCT_EXEC_OVERRIDE__ */
+
+#ifndef __ASSEMBLY__
+
+/* these go in the N_MACHTYPE field */
+enum machine_type {
+#if defined (M_OLDSUN2)
+  M__OLDSUN2 = M_OLDSUN2,
+#else
+  M_OLDSUN2 = 0,
+#endif
+#if defined (M_68010)
+  M__68010 = M_68010,
+#else
+  M_68010 = 1,
+#endif
+#if defined (M_68020)
+  M__68020 = M_68020,
+#else
+  M_68020 = 2,
+#endif
+#if defined (M_SPARC)
+  M__SPARC = M_SPARC,
+#else
+  M_SPARC = 3,
+#endif
+  /* skip a bunch so we don't run into any of sun's numbers */
+  M_386 = 100,
+  M_MIPS1 = 151,	/* MIPS R3000/R3000 binary */
+  M_MIPS2 = 152		/* MIPS R6000/R4000 binary */
+};
+
+#if !defined (N_MAGIC)
+#define N_MAGIC(exec) ((exec).a_info & 0xffff)
+#endif
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec) (((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+	((exec).a_info = ((magic) & 0xffff) \
+	 | (((int)(type) & 0xff) << 16) \
+	 | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+	((exec).a_info = (((exec).a_info & 0xffff0000) | ((magic) & 0xffff)))
+
+#define N_SET_MACHTYPE(exec, machtype) \
+	((exec).a_info = \
+	 ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+
+#define N_SET_FLAGS(exec, flags) \
+	((exec).a_info = \
+	 ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+/* This indicates a demand-paged executable with the header in the text. 
+   The first page is unmapped to help trap NULL pointer references */
+#define QMAGIC 0314
+
+/* Code indicating core file.  */
+#define CMAGIC 0421
+
+#if !defined (N_BADMAG)
+#define N_BADMAG(x)	  (N_MAGIC(x) != OMAGIC		\
+			&& N_MAGIC(x) != NMAGIC		\
+  			&& N_MAGIC(x) != ZMAGIC \
+		        && N_MAGIC(x) != QMAGIC)
+#endif
+
+#define _N_HDROFF(x) (1024 - sizeof (struct exec))
+
+#if !defined (N_TXTOFF)
+#define N_TXTOFF(x) \
+ (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : \
+  (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))
+#endif
+
+#if !defined (N_DATOFF)
+#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)
+#endif
+
+#if !defined (N_TRELOFF)
+#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)
+#endif
+
+#if !defined (N_DRELOFF)
+#define N_DRELOFF(x) (N_TRELOFF(x) + N_TRSIZE(x))
+#endif
+
+#if !defined (N_SYMOFF)
+#define N_SYMOFF(x) (N_DRELOFF(x) + N_DRSIZE(x))
+#endif
+
+#if !defined (N_STROFF)
+#define N_STROFF(x) (N_SYMOFF(x) + N_SYMSIZE(x))
+#endif
+
+/* Address of text segment in memory after it is loaded.  */
+#if !defined (N_TXTADDR)
+#define N_TXTADDR(x) (N_MAGIC(x) == QMAGIC ? PAGE_SIZE : 0)
+#endif
+
+/* Address of data segment in memory after it is loaded.
+   Note that it is up to you to define SEGMENT_SIZE
+   on machines not listed here.  */
+#if defined(vax) || defined(hp300) || defined(pyr)
+#define SEGMENT_SIZE page_size
+#endif
+#ifdef	sony
+#define	SEGMENT_SIZE	0x2000
+#endif	/* Sony.  */
+#ifdef is68k
+#define SEGMENT_SIZE 0x20000
+#endif
+#if defined(m68k) && defined(PORTAR)
+#define PAGE_SIZE 0x400
+#define SEGMENT_SIZE PAGE_SIZE
+#endif
+
+#ifdef linux
+#include <unistd.h>
+#if defined(__i386__) || defined(__mc68000__)
+#define SEGMENT_SIZE	1024
+#else
+#ifndef SEGMENT_SIZE
+#define SEGMENT_SIZE   getpagesize()
+#endif
+#endif
+#endif
+
+#define _N_SEGMENT_ROUND(x) ALIGN(x, SEGMENT_SIZE)
+
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#ifndef N_DATADDR
+#define N_DATADDR(x) \
+    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) \
+     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
+#endif
+
+/* Address of bss segment in memory after it is loaded.  */
+#if !defined (N_BSSADDR)
+#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
+#endif
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist {
+  union {
+    char *n_name;
+    struct nlist *n_next;
+    long n_strx;
+  } n_un;
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#if !defined (N_UNDF)
+#define N_UNDF 0
+#endif
+#if !defined (N_ABS)
+#define N_ABS 2
+#endif
+#if !defined (N_TEXT)
+#define N_TEXT 4
+#endif
+#if !defined (N_DATA)
+#define N_DATA 6
+#endif
+#if !defined (N_BSS)
+#define N_BSS 8
+#endif
+#if !defined (N_FN)
+#define N_FN 15
+#endif
+
+#if !defined (N_EXT)
+#define N_EXT 1
+#endif
+#if !defined (N_TYPE)
+#define N_TYPE 036
+#endif
+#if !defined (N_STAB)
+#define N_STAB 0340
+#endif
+
+/* The following type indicates the definition of a symbol as being
+   an indirect reference to another symbol.  The other symbol
+   appears as an undefined reference, immediately following this symbol.
+
+   Indirection is asymmetrical.  The other symbol's value will be used
+   to satisfy requests for the indirect symbol, but not vice versa.
+   If the other symbol does not have a definition, libraries will
+   be searched to find a definition.  */
+#define N_INDR 0xa
+
+/* The following symbols refer to set elements.
+   All the N_SET[ATDB] symbols with the same name form one set.
+   Space is allocated for the set in the text section, and each set
+   element's value is stored into one word of the space.
+   The first word of the space is the length of the set (number of elements).
+
+   The address of the set is made into an N_SETV symbol
+   whose name is the same as the name of the set.
+   This symbol acts like a N_DATA global symbol
+   in that it can satisfy undefined external references.  */
+
+/* These appear as input to LD, in a .o file.  */
+#define	N_SETA	0x14		/* Absolute set element symbol */
+#define	N_SETT	0x16		/* Text set element symbol */
+#define	N_SETD	0x18		/* Data set element symbol */
+#define	N_SETB	0x1A		/* Bss set element symbol */
+
+/* This is output from LD.  */
+#define N_SETV	0x1C		/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  /* Address (within segment) to be relocated.  */
+  int r_address;
+  /* The meaning of r_symbolnum depends on r_extern.  */
+  unsigned int r_symbolnum:24;
+  /* Nonzero means value is a pc-relative offset
+     and it should be relocated for changes in its own address
+     as well as for changes in the symbol or section specified.  */
+  unsigned int r_pcrel:1;
+  /* Length (as exponent of 2) of the field to be relocated.
+     Thus, a value of 2 indicates 1<<2 bytes.  */
+  unsigned int r_length:2;
+  /* 1 => relocate with value of symbol.
+          r_symbolnum is the index of the symbol
+	  in file's the symbol table.
+     0 => relocate with the address of a segment.
+          r_symbolnum is N_TEXT, N_DATA, N_BSS or N_ABS
+	  (the N_EXT bit may be set also, but signifies nothing).  */
+  unsigned int r_extern:1;
+  /* Four bits that aren't used, but when writing an object file
+     it is desirable to clear them.  */
+#ifdef NS32K
+  unsigned r_bsr:1;
+  unsigned r_disp:1;
+  unsigned r_pad:2;
+#else
+  unsigned int r_pad:4;
+#endif
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#endif /*__ASSEMBLY__ */
+#endif /* __A_OUT_GNU_H__ */
diff -uNr linux-2.6.32/usr/include/linux/apm_bios.h clean_modified/linux-2.6.32/usr/include/linux/apm_bios.h
--- linux-2.6.32/usr/include/linux/apm_bios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/apm_bios.h	2019-04-14 13:24:02.906102255 -0500
@@ -0,0 +1,135 @@
+#ifndef _LINUX_APM_H
+#define _LINUX_APM_H
+
+/*
+ * Include file for the interface to an APM BIOS
+ * Copyright 1994-2001 Stephen Rothwell (sfr@canb.auug.org.au)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/types.h>
+
+typedef unsigned short	apm_event_t;
+typedef unsigned short	apm_eventinfo_t;
+
+struct apm_bios_info {
+	__u16	version;
+	__u16	cseg;
+	__u32	offset;
+	__u16	cseg_16;
+	__u16	dseg;
+	__u16	flags;
+	__u16	cseg_len;
+	__u16	cseg_16_len;
+	__u16	dseg_len;
+};
+
+
+/*
+ * Power states
+ */
+#define APM_STATE_READY		0x0000
+#define APM_STATE_STANDBY	0x0001
+#define APM_STATE_SUSPEND	0x0002
+#define APM_STATE_OFF		0x0003
+#define APM_STATE_BUSY		0x0004
+#define APM_STATE_REJECT	0x0005
+#define APM_STATE_OEM_SYS	0x0020
+#define APM_STATE_OEM_DEV	0x0040
+
+#define APM_STATE_DISABLE	0x0000
+#define APM_STATE_ENABLE	0x0001
+
+#define APM_STATE_DISENGAGE	0x0000
+#define APM_STATE_ENGAGE	0x0001
+
+/*
+ * Events (results of Get PM Event)
+ */
+#define APM_SYS_STANDBY		0x0001
+#define APM_SYS_SUSPEND		0x0002
+#define APM_NORMAL_RESUME	0x0003
+#define APM_CRITICAL_RESUME	0x0004
+#define APM_LOW_BATTERY		0x0005
+#define APM_POWER_STATUS_CHANGE	0x0006
+#define APM_UPDATE_TIME		0x0007
+#define APM_CRITICAL_SUSPEND	0x0008
+#define APM_USER_STANDBY	0x0009
+#define APM_USER_SUSPEND	0x000a
+#define APM_STANDBY_RESUME	0x000b
+#define APM_CAPABILITY_CHANGE	0x000c
+
+/*
+ * Error codes
+ */
+#define APM_SUCCESS		0x00
+#define APM_DISABLED		0x01
+#define APM_CONNECTED		0x02
+#define APM_NOT_CONNECTED	0x03
+#define APM_16_CONNECTED	0x05
+#define APM_16_UNSUPPORTED	0x06
+#define APM_32_CONNECTED	0x07
+#define APM_32_UNSUPPORTED	0x08
+#define APM_BAD_DEVICE		0x09
+#define APM_BAD_PARAM		0x0a
+#define APM_NOT_ENGAGED		0x0b
+#define APM_BAD_FUNCTION	0x0c
+#define APM_RESUME_DISABLED	0x0d
+#define APM_NO_ERROR		0x53
+#define APM_BAD_STATE		0x60
+#define APM_NO_EVENTS		0x80
+#define APM_NOT_PRESENT		0x86
+
+/*
+ * APM Device IDs
+ */
+#define APM_DEVICE_BIOS		0x0000
+#define APM_DEVICE_ALL		0x0001
+#define APM_DEVICE_DISPLAY	0x0100
+#define APM_DEVICE_STORAGE	0x0200
+#define APM_DEVICE_PARALLEL	0x0300
+#define APM_DEVICE_SERIAL	0x0400
+#define APM_DEVICE_NETWORK	0x0500
+#define APM_DEVICE_PCMCIA	0x0600
+#define APM_DEVICE_BATTERY	0x8000
+#define APM_DEVICE_OEM		0xe000
+#define APM_DEVICE_OLD_ALL	0xffff
+#define APM_DEVICE_CLASS	0x00ff
+#define APM_DEVICE_MASK		0xff00
+
+
+/*
+ * Battery status
+ */
+#define APM_MAX_BATTERIES	2
+
+/*
+ * APM defined capability bit flags
+ */
+#define APM_CAP_GLOBAL_STANDBY		0x0001
+#define APM_CAP_GLOBAL_SUSPEND		0x0002
+#define APM_CAP_RESUME_STANDBY_TIMER	0x0004 /* Timer resume from standby */
+#define APM_CAP_RESUME_SUSPEND_TIMER	0x0008 /* Timer resume from suspend */
+#define APM_CAP_RESUME_STANDBY_RING	0x0010 /* Resume on Ring fr standby */
+#define APM_CAP_RESUME_SUSPEND_RING	0x0020 /* Resume on Ring fr suspend */
+#define APM_CAP_RESUME_STANDBY_PCMCIA	0x0040 /* Resume on PCMCIA Ring	*/
+#define APM_CAP_RESUME_SUSPEND_PCMCIA	0x0080 /* Resume on PCMCIA Ring	*/
+
+/*
+ * ioctl operations
+ */
+#include <linux/ioctl.h>
+
+#define APM_IOC_STANDBY		_IO('A', 1)
+#define APM_IOC_SUSPEND		_IO('A', 2)
+
+#endif	/* LINUX_APM_H */
diff -uNr linux-2.6.32/usr/include/linux/arcfb.h clean_modified/linux-2.6.32/usr/include/linux/arcfb.h
--- linux-2.6.32/usr/include/linux/arcfb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/arcfb.h	2019-04-14 13:24:02.907098712 -0500
@@ -0,0 +1,8 @@
+#ifndef __LINUX_ARCFB_H__
+#define __LINUX_ARCFB_H__
+
+#define FBIO_WAITEVENT		_IO('F', 0x88)
+#define FBIO_GETCONTROL2	_IOR('F', 0x89, size_t)
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/atalk.h clean_modified/linux-2.6.32/usr/include/linux/atalk.h
--- linux-2.6.32/usr/include/linux/atalk.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atalk.h	2019-04-14 13:24:02.907098712 -0500
@@ -0,0 +1,43 @@
+#ifndef __LINUX_ATALK_H__
+#define __LINUX_ATALK_H__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/*
+ * AppleTalk networking structures
+ *
+ * The following are directly referenced from the University Of Michigan
+ * netatalk for compatibility reasons.
+ */
+#define ATPORT_FIRST	1
+#define ATPORT_RESERVED	128
+#define ATPORT_LAST	254		/* 254 is only legal on localtalk */ 
+#define ATADDR_ANYNET	(__u16)0
+#define ATADDR_ANYNODE	(__u8)0
+#define ATADDR_ANYPORT  (__u8)0
+#define ATADDR_BCAST	(__u8)255
+#define DDP_MAXSZ	587
+#define DDP_MAXHOPS     15		/* 4 bits of hop counter */
+
+#define SIOCATALKDIFADDR       (SIOCPROTOPRIVATE + 0)
+
+struct atalk_addr {
+	__be16	s_net;
+	__u8	s_node;
+};
+
+struct sockaddr_at {
+	sa_family_t	  sat_family;
+	__u8		  sat_port;
+	struct atalk_addr sat_addr;
+	char		  sat_zero[8];
+};
+
+struct atalk_netrange {
+	__u8	nr_phase;
+	__be16	nr_firstnet;
+	__be16	nr_lastnet;
+};
+
+#endif /* __LINUX_ATALK_H__ */
diff -uNr linux-2.6.32/usr/include/linux/atmapi.h clean_modified/linux-2.6.32/usr/include/linux/atmapi.h
--- linux-2.6.32/usr/include/linux/atmapi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmapi.h	2019-04-14 13:24:02.907098712 -0500
@@ -0,0 +1,29 @@
+/* atmapi.h - ATM API user space/kernel compatibility */
+ 
+/* Written 1999,2000 by Werner Almesberger, EPFL ICA */
+ 
+
+#ifndef _LINUX_ATMAPI_H
+#define _LINUX_ATMAPI_H
+
+#if defined(__sparc__) || defined(__ia64__)
+/* such alignment is not required on 32 bit sparcs, but we can't
+   figure that we are on a sparc64 while compiling user-space programs. */
+#define __ATM_API_ALIGN	__attribute__((aligned(8)))
+#else
+#define __ATM_API_ALIGN
+#endif
+
+
+/*
+ * Opaque type for kernel pointers. Note that _ is never accessed. We need
+ * the struct in order hide the array, so that we can make simple assignments
+ * instead of being forced to use memcpy. It also improves error reporting for
+ * code that still assumes that we're passing unsigned longs.
+ *
+ * Convention: NULL pointers are passed as a field of all zeroes.
+ */
+ 
+typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmarp.h clean_modified/linux-2.6.32/usr/include/linux/atmarp.h
--- linux-2.6.32/usr/include/linux/atmarp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmarp.h	2019-04-14 13:24:02.907098712 -0500
@@ -0,0 +1,41 @@
+/* atmarp.h - ATM ARP protocol and kernel-demon interface definitions */
+ 
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef _LINUX_ATMARP_H
+#define _LINUX_ATMARP_H
+
+#include <linux/types.h>
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+
+
+#define ATMARP_RETRY_DELAY 30		/* request next resolution or forget
+					   NAK after 30 sec - should go into
+					   atmclip.h */
+#define ATMARP_MAX_UNRES_PACKETS 5	/* queue that many packets while
+					   waiting for the resolver */
+
+
+#define ATMARPD_CTRL	_IO('a',ATMIOC_CLIP+1)	/* become atmarpd ctrl sock */
+#define ATMARP_MKIP	_IO('a',ATMIOC_CLIP+2)	/* attach socket to IP */
+#define ATMARP_SETENTRY	_IO('a',ATMIOC_CLIP+3)	/* fill or hide ARP entry */
+#define ATMARP_ENCAP	_IO('a',ATMIOC_CLIP+5)	/* change encapsulation */
+
+
+enum atmarp_ctrl_type {
+	act_invalid,		/* catch uninitialized structures */
+	act_need,		/* need address resolution */
+	act_up,			/* interface is coming up */
+	act_down,		/* interface is going down */
+	act_change		/* interface configuration has changed */
+};
+
+struct atmarp_ctrl {
+	enum atmarp_ctrl_type	type;	/* message type */
+	int			itf_num;/* interface number (if present) */
+	__be32			ip;	/* IP address (act_need only) */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmbr2684.h clean_modified/linux-2.6.32/usr/include/linux/atmbr2684.h
--- linux-2.6.32/usr/include/linux/atmbr2684.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmbr2684.h	2019-04-14 13:24:02.908047634 -0500
@@ -0,0 +1,117 @@
+#ifndef _LINUX_ATMBR2684_H
+#define _LINUX_ATMBR2684_H
+
+#include <linux/types.h>
+#include <linux/atm.h>
+#include <linux/if.h>		/* For IFNAMSIZ */
+
+/*
+ * Type of media we're bridging (ethernet, token ring, etc)  Currently only
+ * ethernet is supported
+ */
+#define BR2684_MEDIA_ETHERNET	(0)	/* 802.3 */
+#define BR2684_MEDIA_802_4	(1)	/* 802.4 */
+#define BR2684_MEDIA_TR		(2)	/* 802.5 - token ring */
+#define BR2684_MEDIA_FDDI	(3)
+#define BR2684_MEDIA_802_6	(4)	/* 802.6 */
+
+					/* used only at device creation:  */
+#define BR2684_FLAG_ROUTED	(1<<16)	/* payload is routed, not bridged */
+
+/*
+ * Is there FCS inbound on this VC?  This currently isn't supported.
+ */
+#define BR2684_FCSIN_NO		(0)
+#define BR2684_FCSIN_IGNORE	(1)
+#define BR2684_FCSIN_VERIFY	(2)
+
+/*
+ * Is there FCS outbound on this VC?  This currently isn't supported.
+ */
+#define BR2684_FCSOUT_NO	(0)
+#define BR2684_FCSOUT_SENDZERO	(1)
+#define BR2684_FCSOUT_GENERATE	(2)
+
+/*
+ * Does this VC include LLC encapsulation?
+ */
+#define BR2684_ENCAPS_VC	(0)	/* VC-mux */
+#define BR2684_ENCAPS_LLC	(1)
+#define BR2684_ENCAPS_AUTODETECT (2)	/* Unsuported */
+
+/*
+ * Is this VC bridged or routed?
+ */
+
+#define BR2684_PAYLOAD_ROUTED   (0)
+#define BR2684_PAYLOAD_BRIDGED  (1)
+
+/*
+ * This is for the ATM_NEWBACKENDIF call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_newif_br2684 {
+	atm_backend_t backend_num;	/* ATM_BACKEND_BR2684 */
+	int media;		/* BR2684_MEDIA_*, flags in upper bits */
+	char ifname[IFNAMSIZ];
+	int mtu;
+};
+
+/*
+ * This structure is used to specify a br2684 interface - either by a
+ * positive integer (returned by ATM_NEWBACKENDIF) or the interfaces name
+ */
+#define BR2684_FIND_BYNOTHING	(0)
+#define BR2684_FIND_BYNUM	(1)
+#define BR2684_FIND_BYIFNAME	(2)
+struct br2684_if_spec {
+	int method;		/* BR2684_FIND_* */
+	union {
+		char ifname[IFNAMSIZ];
+		int devnum;
+	} spec;
+};
+
+/*
+ * This is for the ATM_SETBACKEND call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_backend_br2684 {
+	atm_backend_t backend_num;	/* ATM_BACKEND_BR2684 */
+	struct br2684_if_spec ifspec;
+	int fcs_in;		/* BR2684_FCSIN_* */
+	int fcs_out;		/* BR2684_FCSOUT_* */
+	int fcs_auto;		/* 1: fcs_{in,out} disabled if no FCS rx'ed */
+	int encaps;		/* BR2684_ENCAPS_* */
+	int has_vpiid;		/* 1: use vpn_id - Unsupported */
+	__u8 vpn_id[7];
+	int send_padding;	/* unsupported */
+	int min_size;		/* we will pad smaller packets than this */
+};
+
+/*
+ * The BR2684_SETFILT ioctl is an experimental mechanism for folks
+ * terminating a large number of IP-only vcc's.  When netfilter allows
+ * efficient per-if in/out filters, this support will be removed
+ */
+struct br2684_filter {
+	__be32 prefix;		/* network byte order */
+	__be32 netmask;		/* 0 = disable filter */
+};
+
+struct br2684_filter_set {
+	struct br2684_if_spec ifspec;
+	struct br2684_filter filter;
+};
+
+enum br2684_payload {
+	p_routed = BR2684_PAYLOAD_ROUTED,
+	p_bridged = BR2684_PAYLOAD_BRIDGED,
+};
+
+#define BR2684_SETFILT	_IOW( 'a', ATMIOC_BACKEND + 0, \
+				struct br2684_filter_set)
+
+#endif /* _LINUX_ATMBR2684_H */
diff -uNr linux-2.6.32/usr/include/linux/atmclip.h clean_modified/linux-2.6.32/usr/include/linux/atmclip.h
--- linux-2.6.32/usr/include/linux/atmclip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmclip.h	2019-04-14 13:24:02.908047634 -0500
@@ -0,0 +1,21 @@
+/* atmclip.h - Classical IP over ATM */
+ 
+/* Written 1995-1998 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_ATMCLIP_H
+#define LINUX_ATMCLIP_H
+
+#include <linux/sockios.h>
+#include <linux/atmioc.h>
+
+
+#define RFC1483LLC_LEN	8		/* LLC+OUI+PID = 8 */
+#define RFC1626_MTU	9180		/* RFC1626 default MTU */
+
+#define CLIP_DEFAULT_IDLETIMER 1200	/* 20 minutes, see RFC1755 */
+#define CLIP_CHECK_INTERVAL	 10	/* check every ten seconds */
+
+#define	SIOCMKCLIP	_IO('a',ATMIOC_CLIP)	/* create IP interface */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmdev.h clean_modified/linux-2.6.32/usr/include/linux/atmdev.h
--- linux-2.6.32/usr/include/linux/atmdev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmdev.h	2019-04-14 13:24:02.908047634 -0500
@@ -0,0 +1,215 @@
+/* atmdev.h - ATM device driver declarations and various related items */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_ATMDEV_H
+#define LINUX_ATMDEV_H
+
+
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+
+
+#define ESI_LEN		6
+
+#define ATM_OC3_PCR	(155520000/270*260/8/53)
+			/* OC3 link rate:  155520000 bps
+			   SONET overhead: /270*260 (9 section, 1 path)
+			   bits per cell:  /8/53
+			   max cell rate:  353207.547 cells/sec */
+#define ATM_25_PCR	((25600000/8-8000)/54)
+			/* 25 Mbps ATM cell rate (59111) */
+#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
+			/* OC12 link rate: 622080000 bps
+			   SONET overhead: /1080*1040
+			   bits per cell:  /8/53
+			   max cell rate:  1412830.188 cells/sec */
+#define ATM_DS3_PCR	(8000*12)
+			/* DS3: 12 cells in a 125 usec time slot */
+
+
+#define __AAL_STAT_ITEMS \
+    __HANDLE_ITEM(tx);			/* TX okay */ \
+    __HANDLE_ITEM(tx_err);		/* TX errors */ \
+    __HANDLE_ITEM(rx);			/* RX okay */ \
+    __HANDLE_ITEM(rx_err);		/* RX errors */ \
+    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
+
+struct atm_aal_stats {
+#define __HANDLE_ITEM(i) int i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+
+struct atm_dev_stats {
+	struct atm_aal_stats aal0;
+	struct atm_aal_stats aal34;
+	struct atm_aal_stats aal5;
+} __ATM_API_ALIGN;
+
+
+#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
+					/* get link rate */
+#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
+					/* get interface names (numbers) */
+#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
+					/* get interface type name */
+#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
+					/* get interface ESI */
+#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
+					/* get itf's local ATM addr. list */
+#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
+					/* reset itf's ATM address list */
+#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
+					/* add a local ATM address */
+#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
+					/* remove a local ATM address */
+#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
+					/* get connection identifier range */
+#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
+					/* set connection identifier range */
+#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
+					/* set interface ESI */
+#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
+					/* force interface ESI */
+#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
+					/* register a LECS address */
+#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
+					/* unregister a LECS address */
+#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
+					/* retrieve LECS address(es) */
+
+#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
+					/* get AAL layer statistics */
+#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
+					/* get AAL layer statistics and zero */
+#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
+					/* get loopback mode */
+#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
+					/* set loopback mode */
+#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
+					/* query supported loopback modes */
+#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
+					/* enable or disable single-copy */
+#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
+					/* set backend handler */
+#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
+					/* use backend to make new if */
+#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
+ 					/* add party to p2mp call */
+#ifdef CONFIG_COMPAT
+/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
+#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
+#endif
+#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
+					/* drop party from p2mp call */
+
+/*
+ * These are backend handkers that can be set via the ATM_SETBACKEND call
+ * above.  In the future we may support dynamic loading of these - for now,
+ * they're just being used to share the ATMIOC_BACKEND ioctls
+ */
+#define ATM_BACKEND_RAW		0	
+#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
+#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
+
+/* for ATM_GETTYPE */
+#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
+
+/*
+ * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
+ */
+
+/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
+#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
+#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
+#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
+/* RESERVED		4	loop back on PHY side  ---'		      */
+#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
+#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
+
+/* Direction of loopback */
+#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
+#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
+
+#define __ATM_LM_XTLOC(n)	((n) & 0xff)
+#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
+
+#define ATM_LM_NONE	0	/* no loopback */
+
+#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
+#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
+#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
+#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
+
+#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
+#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
+#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
+#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
+
+/*
+ * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
+ * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
+ */
+
+
+struct atm_iobuf {
+	int length;
+	void *buffer;
+};
+
+/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
+
+#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
+ 
+struct atm_cirange {
+	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
+	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
+};
+
+/* for ATM_SETSC; actually taken from the ATM_VF number space */
+
+#define ATM_SC_RX	1024		/* enable RX single-copy */
+#define ATM_SC_TX	2048		/* enable TX single-copy */
+
+#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
+				  anyway */
+
+/* MF: change_qos (Modify) flags */
+
+#define ATM_MF_IMMED	 1	/* Block until change is effective */
+#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
+#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
+#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
+#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
+#define ATM_MF_BWD	32	/* Set the backward direction parameters */
+
+#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
+			  ATM_MF_DEC_SHP | ATM_MF_BWD)
+
+/*
+ * ATM_VS_* are used to express VC state in a human-friendly way.
+ */
+
+#define ATM_VS_IDLE	0	/* VC is not used */
+#define ATM_VS_CONNECTED 1	/* VC is connected */
+#define ATM_VS_CLOSING	2	/* VC is closing */
+#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
+#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
+#define ATM_VS_BOUND	5	/* VC is bound */
+
+#define ATM_VS2TXT_MAP \
+    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
+
+#define ATM_VF2TXT_MAP \
+    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
+    "RELEASED", "HASQOS",	"LISTEN",	"META", \
+    "256",	"512",		"1024",		"2048", \
+    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atm_eni.h clean_modified/linux-2.6.32/usr/include/linux/atm_eni.h
--- linux-2.6.32/usr/include/linux/atm_eni.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_eni.h	2019-04-14 13:24:02.908047634 -0500
@@ -0,0 +1,23 @@
+/* atm_eni.h - Driver-specific declarations of the ENI driver (for use by
+	       driver-specific utilities) */
+
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#ifndef LINUX_ATM_ENI_H
+#define LINUX_ATM_ENI_H
+
+#include <linux/atmioc.h>
+
+
+struct eni_multipliers {
+	int tx,rx;	/* values are in percent and must be > 100 */
+};
+
+
+#define ENI_MEMDUMP     _IOW('a',ATMIOC_SARPRV,struct atmif_sioc)
+                                                /* printk memory map */
+#define ENI_SETMULT	_IOW('a',ATMIOC_SARPRV+7,struct atmif_sioc)
+						/* set buffer multipliers */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atm.h clean_modified/linux-2.6.32/usr/include/linux/atm.h
--- linux-2.6.32/usr/include/linux/atm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm.h	2019-04-14 13:24:02.909022893 -0500
@@ -0,0 +1,241 @@
+/* atm.h - general ATM declarations */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+/*
+ * WARNING: User-space programs should not #include <linux/atm.h> directly.
+ *          Instead, #include <atm.h>
+ */
+
+#ifndef _LINUX_ATM_H
+#define _LINUX_ATM_H
+
+/*
+ * BEGIN_xx and END_xx markers are used for automatic generation of
+ * documentation. Do not change them.
+ */
+
+
+#include <linux/atmapi.h>
+#include <linux/atmsap.h>
+#include <linux/atmioc.h>
+#include <linux/types.h>
+
+
+/* general ATM constants */
+#define ATM_CELL_SIZE		    53	/* ATM cell size incl. header */
+#define ATM_CELL_PAYLOAD	    48	/* ATM payload size */
+#define ATM_AAL0_SDU		    52	/* AAL0 SDU size */
+#define ATM_MAX_AAL34_PDU	 65535	/* maximum AAL3/4 PDU payload */
+#define ATM_AAL5_TRAILER	     8	/* AAL5 trailer size */
+#define ATM_MAX_AAL5_PDU	 65535	/* maximum AAL5 PDU payload */
+#define ATM_MAX_CDV		  9999	/* maximum (default) CDV */
+#define ATM_NOT_RSV_VCI		    32	/* first non-reserved VCI value */
+
+#define ATM_MAX_VPI		   255	/* maximum VPI at the UNI */
+#define ATM_MAX_VPI_NNI		  4096	/* maximum VPI at the NNI */
+#define ATM_MAX_VCI		 65535	/* maximum VCI */
+
+
+/* "protcol" values for the socket system call */
+#define ATM_NO_AAL	0		/* AAL not specified */
+#define ATM_AAL0	13		/* "raw" ATM cells */
+#define ATM_AAL1	1		/* AAL1 (CBR) */
+#define ATM_AAL2	2		/* AAL2 (VBR) */
+#define ATM_AAL34	3		/* AAL3/4 (data) */
+#define ATM_AAL5	5		/* AAL5 (data) */
+
+/*
+ * socket option name coding functions
+ *
+ * Note that __SO_ENCODE and __SO_LEVEL are somewhat a hack since the
+ * << 22 only reserves 9 bits for the level.  On some architectures
+ * SOL_SOCKET is 0xFFFF, so that's a bit of a problem
+ */
+
+#define __SO_ENCODE(l,n,t)	((((l) & 0x1FF) << 22) | ((n) << 16) | \
+				sizeof(t))
+#define __SO_LEVEL_MATCH(c,m)	(((c) >> 22) == ((m) & 0x1FF))
+#define __SO_NUMBER(c)		(((c) >> 16) & 0x3f)
+#define __SO_SIZE(c)		((c) & 0x3fff)
+
+/*
+ * ATM layer
+ */
+
+#define SO_SETCLP	__SO_ENCODE(SOL_ATM,0,int)
+			    /* set CLP bit value - TODO */
+#define SO_CIRANGE	__SO_ENCODE(SOL_ATM,1,struct atm_cirange)
+			    /* connection identifier range; socket must be
+			       bound or connected */
+#define SO_ATMQOS	__SO_ENCODE(SOL_ATM,2,struct atm_qos)
+			    /* Quality of Service setting */
+#define SO_ATMSAP	__SO_ENCODE(SOL_ATM,3,struct atm_sap)
+			    /* Service Access Point */
+#define SO_ATMPVC	__SO_ENCODE(SOL_ATM,4,struct sockaddr_atmpvc)
+			    /* "PVC" address (also for SVCs); get only */
+#define SO_MULTIPOINT	__SO_ENCODE(SOL_ATM, 5, int)
+			    /* make this vc a p2mp */
+
+
+/*
+ * Note @@@: since the socket layers don't really distinguish the control and
+ * the data plane but generally seems to be data plane-centric, any layer is
+ * about equally wrong for the SAP. If you have a better idea about this,
+ * please speak up ...
+ */
+
+
+/* ATM cell header (for AAL0) */
+
+/* BEGIN_CH */
+#define ATM_HDR_GFC_MASK	0xf0000000
+#define ATM_HDR_GFC_SHIFT	28
+#define ATM_HDR_VPI_MASK	0x0ff00000
+#define ATM_HDR_VPI_SHIFT	20
+#define ATM_HDR_VCI_MASK	0x000ffff0
+#define ATM_HDR_VCI_SHIFT	4
+#define ATM_HDR_PTI_MASK	0x0000000e
+#define ATM_HDR_PTI_SHIFT	1
+#define ATM_HDR_CLP		0x00000001
+/* END_CH */
+
+
+/* PTI codings */
+
+/* BEGIN_PTI */
+#define ATM_PTI_US0	0  /* user data cell, congestion not exp, SDU-type 0 */
+#define ATM_PTI_US1	1  /* user data cell, congestion not exp, SDU-type 1 */
+#define ATM_PTI_UCES0	2  /* user data cell, cong. experienced, SDU-type 0 */
+#define ATM_PTI_UCES1	3  /* user data cell, cong. experienced, SDU-type 1 */
+#define ATM_PTI_SEGF5	4  /* segment OAM F5 flow related cell */
+#define ATM_PTI_E2EF5	5  /* end-to-end OAM F5 flow related cell */
+#define ATM_PTI_RSV_RM	6  /* reserved for traffic control/resource mgmt */
+#define ATM_PTI_RSV	7  /* reserved */
+/* END_PTI */
+
+
+/*
+ * The following items should stay in linux/atm.h, which should be linked to
+ * netatm/atm.h
+ */
+
+/* Traffic description */
+
+#define ATM_NONE	0		/* no traffic */
+#define ATM_UBR		1
+#define ATM_CBR		2
+#define ATM_VBR		3
+#define ATM_ABR		4
+#define ATM_ANYCLASS	5		/* compatible with everything */
+
+#define ATM_MAX_PCR	-1		/* maximum available PCR */
+
+struct atm_trafprm {
+	unsigned char	traffic_class;	/* traffic class (ATM_UBR, ...) */
+	int		max_pcr;	/* maximum PCR in cells per second */
+	int		pcr;		/* desired PCR in cells per second */
+	int		min_pcr;	/* minimum PCR in cells per second */
+	int		max_cdv;	/* maximum CDV in microseconds */
+	int		max_sdu;	/* maximum SDU in bytes */
+        /* extra params for ABR */
+        unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
+        unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
+        unsigned int 	frtt : 24;	/* Fixed Round Trip Time (24-bit) */
+        unsigned int 	rif  : 4;       /* Rate Increment Factor (4-bit) */
+        unsigned int 	rdf  : 4;       /* Rate Decrease Factor (4-bit) */
+        unsigned int nrm_pres  :1;      /* nrm present bit */
+        unsigned int trm_pres  :1;     	/* rm present bit */
+        unsigned int adtf_pres :1;     	/* adtf present bit */
+        unsigned int cdf_pres  :1;    	/* cdf present bit*/
+        unsigned int nrm       :3;     	/* Max # of Cells for each forward RM cell (3-bit) */
+        unsigned int trm       :3;    	/* Time between forward RM cells (3-bit) */    
+	unsigned int adtf      :10;     /* ACR Decrease Time Factor (10-bit) */
+	unsigned int cdf       :3;      /* Cutoff Decrease Factor (3-bit) */
+        unsigned int spare     :9;      /* spare bits */ 
+};
+
+struct atm_qos {
+	struct atm_trafprm txtp;	/* parameters in TX direction */
+	struct atm_trafprm rxtp __ATM_API_ALIGN;
+					/* parameters in RX direction */
+	unsigned char aal __ATM_API_ALIGN;
+};
+
+/* PVC addressing */
+
+#define ATM_ITF_ANY	-1		/* "magic" PVC address values */
+#define ATM_VPI_ANY	-1
+#define ATM_VCI_ANY	-1
+#define ATM_VPI_UNSPEC	-2
+#define ATM_VCI_UNSPEC	-2
+
+
+struct sockaddr_atmpvc {
+	unsigned short 	sap_family;	/* address family, AF_ATMPVC  */
+	struct {			/* PVC address */
+		short	itf;		/* ATM interface */
+		short	vpi;		/* VPI (only 8 bits at UNI) */
+		int	vci;		/* VCI (only 16 bits at UNI) */
+	} sap_addr __ATM_API_ALIGN;	/* PVC address */
+};
+
+/* SVC addressing */
+
+#define	ATM_ESA_LEN	20		/* ATM End System Address length */
+#define ATM_E164_LEN	12		/* maximum E.164 number length */
+
+#define ATM_AFI_DCC	0x39		/* DCC ATM Format */
+#define ATM_AFI_ICD	0x47		/* ICD ATM Format */
+#define ATM_AFI_E164	0x45		/* E.164 ATM Format */
+#define ATM_AFI_LOCAL	0x49		/* Local ATM Format */ 
+
+#define ATM_AFI_DCC_GROUP	0xBD	/* DCC ATM Group Format */
+#define ATM_AFI_ICD_GROUP	0xC5	/* ICD ATM Group Format */
+#define ATM_AFI_E164_GROUP	0xC3	/* E.164 ATM Group Format */
+#define ATM_AFI_LOCAL_GROUP	0xC7	/* Local ATM Group Format */
+
+#define ATM_LIJ_NONE	0		/* no leaf-initiated join */
+#define ATM_LIJ		1		/* request joining */
+#define ATM_LIJ_RPJ	2		/* set to root-prompted join */
+#define ATM_LIJ_NJ	3		/* set to network join */
+
+
+struct sockaddr_atmsvc {
+    unsigned short 	sas_family;	/* address family, AF_ATMSVC */
+    struct {				/* SVC address */
+        unsigned char	prv[ATM_ESA_LEN];/* private ATM address */
+        char		pub[ATM_E164_LEN+1]; /* public address (E.164) */
+    					/* unused addresses must be bzero'ed */
+	char		lij_type;	/* role in LIJ call; one of ATM_LIJ* */
+	__u32	lij_id;		/* LIJ call identifier */
+    } sas_addr __ATM_API_ALIGN;		/* SVC address */
+};
+
+
+static __inline__ int atmsvc_addr_in_use(struct sockaddr_atmsvc addr)
+{
+	return *addr.sas_addr.prv || *addr.sas_addr.pub;
+}
+
+
+static __inline__ int atmpvc_addr_in_use(struct sockaddr_atmpvc addr)
+{
+	return addr.sap_addr.itf || addr.sap_addr.vpi || addr.sap_addr.vci;
+}
+
+
+/*
+ * Some stuff for linux/sockios.h
+ */
+
+struct atmif_sioc {
+	int number;
+	int length;
+	void *arg;
+};
+
+
+typedef unsigned short atm_backend_t;
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atm_he.h clean_modified/linux-2.6.32/usr/include/linux/atm_he.h
--- linux-2.6.32/usr/include/linux/atm_he.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_he.h	2019-04-14 13:24:02.909022893 -0500
@@ -0,0 +1,20 @@
+/* atm_he.h */
+
+#ifndef LINUX_ATM_HE_H
+#define LINUX_ATM_HE_H
+
+#include <linux/atmioc.h>
+
+#define HE_GET_REG	_IOW('a', ATMIOC_SARPRV, struct atmif_sioc)
+
+#define HE_REGTYPE_PCI	1
+#define HE_REGTYPE_RCM	2
+#define HE_REGTYPE_TCM	3
+#define HE_REGTYPE_MBOX	4
+
+struct he_ioctl_reg {
+	unsigned addr, val;
+	char type;
+};
+
+#endif /* LINUX_ATM_HE_H */
diff -uNr linux-2.6.32/usr/include/linux/atm_idt77105.h clean_modified/linux-2.6.32/usr/include/linux/atm_idt77105.h
--- linux-2.6.32/usr/include/linux/atm_idt77105.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_idt77105.h	2019-04-14 13:24:02.909022893 -0500
@@ -0,0 +1,28 @@
+/* atm_idt77105.h - Driver-specific declarations of the IDT77105 driver (for
+ * use by driver-specific utilities) */
+
+/* Written 1999 by Greg Banks <gnb@linuxfan.com>. Copied from atm_suni.h. */
+
+
+#ifndef LINUX_ATM_IDT77105_H
+#define LINUX_ATM_IDT77105_H
+
+#include <linux/types.h>
+#include <linux/atmioc.h>
+#include <linux/atmdev.h>
+
+/*
+ * Structure for IDT77105_GETSTAT and IDT77105_GETSTATZ ioctls.
+ * Pointed to by `arg' in atmif_sioc.
+ */
+struct idt77105_stats {
+        __u32 symbol_errors;  /* wire symbol errors */
+        __u32 tx_cells;       /* cells transmitted */
+        __u32 rx_cells;       /* cells received */
+        __u32 rx_hec_errors;  /* Header Error Check errors on receive */
+};
+
+#define IDT77105_GETSTAT	_IOW('a',ATMIOC_PHYPRV+2,struct atmif_sioc)	/* get stats */
+#define IDT77105_GETSTATZ	_IOW('a',ATMIOC_PHYPRV+3,struct atmif_sioc)	/* get stats and zero */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmioc.h clean_modified/linux-2.6.32/usr/include/linux/atmioc.h
--- linux-2.6.32/usr/include/linux/atmioc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmioc.h	2019-04-14 13:24:02.910021008 -0500
@@ -0,0 +1,41 @@
+/* atmioc.h - ranges for ATM-related ioctl numbers */
+ 
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+
+
+/*
+ * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of
+ * "magic" ioctl numbers.
+ */
+
+
+#ifndef _LINUX_ATMIOC_H
+#define _LINUX_ATMIOC_H
+
+#include <asm/ioctl.h>
+		/* everybody including atmioc.h will also need _IO{,R,W,WR} */
+
+#define ATMIOC_PHYCOM	  0x00 /* PHY device common ioctls, globally unique */
+#define ATMIOC_PHYCOM_END 0x0f
+#define ATMIOC_PHYTYP	  0x10 /* PHY dev type ioctls, unique per PHY type */
+#define ATMIOC_PHYTYP_END 0x2f
+#define ATMIOC_PHYPRV	  0x30 /* PHY dev private ioctls, unique per driver */
+#define ATMIOC_PHYPRV_END 0x4f
+#define ATMIOC_SARCOM	  0x50 /* SAR device common ioctls, globally unique */
+#define ATMIOC_SARCOM_END 0x50
+#define ATMIOC_SARPRV	  0x60 /* SAR dev private ioctls, unique per driver */
+#define ATMIOC_SARPRV_END 0x7f
+#define ATMIOC_ITF	  0x80 /* Interface ioctls, globally unique */
+#define ATMIOC_ITF_END	  0x8f
+#define ATMIOC_BACKEND	  0x90 /* ATM generic backend ioctls, u. per backend */
+#define ATMIOC_BACKEND_END 0xaf
+/* 0xb0-0xbf: Reserved for future use */
+#define ATMIOC_AREQUIPA	  0xc0 /* Application requested IP over ATM, glob. u. */
+#define ATMIOC_LANE	  0xd0 /* LAN Emulation, globally unique */
+#define ATMIOC_MPOA       0xd8 /* MPOA, globally unique */
+#define	ATMIOC_CLIP	  0xe0 /* Classical IP over ATM control, globally u. */
+#define	ATMIOC_CLIP_END	  0xef
+#define	ATMIOC_SPECIAL	  0xf0 /* Special-purpose controls, globally unique */
+#define	ATMIOC_SPECIAL_END 0xff
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmlec.h clean_modified/linux-2.6.32/usr/include/linux/atmlec.h
--- linux-2.6.32/usr/include/linux/atmlec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmlec.h	2019-04-14 13:24:02.910021008 -0500
@@ -0,0 +1,98 @@
+/*
+ * ATM Lan Emulation Daemon driver interface
+ *
+ * Marko Kiiskila <mkiiskila@yahoo.com>
+ */
+
+#ifndef _ATMLEC_H_
+#define _ATMLEC_H_
+
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+#include <linux/atm.h>
+#include <linux/if_ether.h>
+#include <linux/types.h>
+
+/* ATM lec daemon control socket */
+#define ATMLEC_CTRL	_IO('a', ATMIOC_LANE)
+#define ATMLEC_DATA	_IO('a', ATMIOC_LANE+1)
+#define ATMLEC_MCAST	_IO('a', ATMIOC_LANE+2)
+
+/* Maximum number of LEC interfaces (tweakable) */
+#define MAX_LEC_ITF 48
+
+/*
+ * From the total of MAX_LEC_ITF, last NUM_TR_DEVS are reserved for Token Ring.
+ * E.g. if MAX_LEC_ITF = 48 and NUM_TR_DEVS = 8, then lec0-lec39 are for
+ * Ethernet ELANs and lec40-lec47 are for Token Ring ELANS.
+ */
+#define NUM_TR_DEVS 8
+
+typedef enum {
+	l_set_mac_addr,
+	l_del_mac_addr,
+	l_svc_setup,
+	l_addr_delete,
+	l_topology_change,
+	l_flush_complete,
+	l_arp_update,
+	l_narp_req,		/* LANE2 mandates the use of this */
+	l_config,
+	l_flush_tran_id,
+	l_set_lecid,
+	l_arp_xmt,
+	l_rdesc_arp_xmt,
+	l_associate_req,
+	l_should_bridge		/* should we bridge this MAC? */
+} atmlec_msg_type;
+
+#define ATMLEC_MSG_TYPE_MAX l_should_bridge
+
+struct atmlec_config_msg {
+	unsigned int maximum_unknown_frame_count;
+	unsigned int max_unknown_frame_time;
+	unsigned short max_retry_count;
+	unsigned int aging_time;
+	unsigned int forward_delay_time;
+	unsigned int arp_response_time;
+	unsigned int flush_timeout;
+	unsigned int path_switching_delay;
+	unsigned int lane_version;	/* LANE2: 1 for LANEv1, 2 for LANEv2 */
+	int mtu;
+	int is_proxy;
+};
+
+struct atmlec_msg {
+	atmlec_msg_type type;
+	int sizeoftlvs;		/* LANE2: if != 0, tlvs follow */
+	union {
+		struct {
+			unsigned char mac_addr[ETH_ALEN];
+			unsigned char atm_addr[ATM_ESA_LEN];
+			unsigned int flag;	/*
+						 * Topology_change flag,
+						 * remoteflag, permanent flag,
+						 * lecid, transaction id
+						 */
+			unsigned int targetless_le_arp;	/* LANE2 */
+			unsigned int no_source_le_narp;	/* LANE2 */
+		} normal;
+		struct atmlec_config_msg config;
+		struct {
+			__u16 lec_id;				/* requestor lec_id  */
+			__u32 tran_id;				/* transaction id    */
+			unsigned char mac_addr[ETH_ALEN];	/* dst mac addr      */
+			unsigned char atm_addr[ATM_ESA_LEN];	/* reqestor ATM addr */
+		} proxy;	/*
+				 * For mapping LE_ARP requests to responses. Filled by
+				 * zeppelin, returned by kernel. Used only when proxying
+				 */
+	} content;
+} __ATM_API_ALIGN;
+
+struct atmlec_ioc {
+	int dev_num;
+	unsigned char atm_addr[ATM_ESA_LEN];
+	unsigned char receive;	/* 1= receive vcc, 0 = send vcc */
+};
+#endif /* _ATMLEC_H_ */
diff -uNr linux-2.6.32/usr/include/linux/atmmpc.h clean_modified/linux-2.6.32/usr/include/linux/atmmpc.h
--- linux-2.6.32/usr/include/linux/atmmpc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmmpc.h	2019-04-14 13:24:02.910021008 -0500
@@ -0,0 +1,126 @@
+#ifndef _ATMMPC_H_
+#define _ATMMPC_H_
+
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+#include <linux/atm.h>
+#include <linux/types.h>
+
+#define ATMMPC_CTRL _IO('a', ATMIOC_MPOA)
+#define ATMMPC_DATA _IO('a', ATMIOC_MPOA+1)
+
+#define MPC_SOCKET_INGRESS 1
+#define MPC_SOCKET_EGRESS  2
+
+struct atmmpc_ioc {
+        int dev_num;
+        __be32 ipaddr;              /* the IP address of the shortcut    */
+        int type;                     /* ingress or egress                 */
+};
+
+typedef struct in_ctrl_info {
+        __u8   Last_NHRP_CIE_code;
+        __u8   Last_Q2931_cause_value;
+        __u8   eg_MPC_ATM_addr[ATM_ESA_LEN];
+        __be32  tag;
+        __be32  in_dst_ip;      /* IP address this ingress MPC sends packets to */
+        __u16  holding_time;
+        __u32  request_id;
+} in_ctrl_info;
+
+typedef struct eg_ctrl_info {
+        __u8   DLL_header[256];
+        __u8   DH_length;
+        __be32  cache_id;
+        __be32  tag;
+        __be32  mps_ip;
+        __be32  eg_dst_ip;      /* IP address to which ingress MPC sends packets */
+        __u8   in_MPC_data_ATM_addr[ATM_ESA_LEN];
+        __u16  holding_time;
+} eg_ctrl_info;
+
+struct mpc_parameters {
+        __u16 mpc_p1;   /* Shortcut-Setup Frame Count    */
+        __u16 mpc_p2;   /* Shortcut-Setup Frame Time     */
+        __u8 mpc_p3[8]; /* Flow-detection Protocols      */
+        __u16 mpc_p4;   /* MPC Initial Retry Time        */
+        __u16 mpc_p5;   /* MPC Retry Time Maximum        */
+        __u16 mpc_p6;   /* Hold Down Time                */
+} ;
+
+struct k_message {
+        __u16 type;
+        __be32 ip_mask;
+        __u8  MPS_ctrl[ATM_ESA_LEN];
+        union {
+                in_ctrl_info in_info;
+                eg_ctrl_info eg_info;
+                struct mpc_parameters params;
+        } content;
+        struct atm_qos qos;       
+} __ATM_API_ALIGN;
+
+struct llc_snap_hdr {
+	/* RFC 1483 LLC/SNAP encapsulation for routed IP PDUs */
+        __u8  dsap;    /* Destination Service Access Point (0xAA)     */
+        __u8  ssap;    /* Source Service Access Point      (0xAA)     */
+        __u8  ui;      /* Unnumbered Information           (0x03)     */
+        __u8  org[3];  /* Organizational identification    (0x000000) */
+        __u8  type[2]; /* Ether type (for IP)              (0x0800)   */
+};
+
+/* TLVs this MPC recognizes */
+#define TLV_MPOA_DEVICE_TYPE         0x00a03e2a  
+
+/* MPOA device types in MPOA Device Type TLV */
+#define NON_MPOA    0
+#define MPS         1
+#define MPC         2
+#define MPS_AND_MPC 3
+
+
+/* MPC parameter defaults */
+
+#define MPC_P1 10  /* Shortcut-Setup Frame Count  */ 
+#define MPC_P2 1   /* Shortcut-Setup Frame Time   */
+#define MPC_P3 0   /* Flow-detection Protocols    */
+#define MPC_P4 5   /* MPC Initial Retry Time      */
+#define MPC_P5 40  /* MPC Retry Time Maximum      */
+#define MPC_P6 160 /* Hold Down Time              */
+#define HOLDING_TIME_DEFAULT 1200 /* same as MPS-p7 */
+
+/* MPC constants */
+
+#define MPC_C1 2   /* Retry Time Multiplier       */
+#define MPC_C2 60  /* Initial Keep-Alive Lifetime */
+
+/* Message types - to MPOA daemon */
+
+#define SND_MPOA_RES_RQST    201
+#define SET_MPS_CTRL_ADDR    202
+#define SND_MPOA_RES_RTRY    203 /* Different type in a retry due to req id         */
+#define STOP_KEEP_ALIVE_SM   204
+#define EGRESS_ENTRY_REMOVED 205
+#define SND_EGRESS_PURGE     206
+#define DIE                  207 /* tell the daemon to exit()                       */
+#define DATA_PLANE_PURGE     208 /* Data plane purge because of egress cache hit miss or dead MPS */
+#define OPEN_INGRESS_SVC     209
+
+/* Message types - from MPOA daemon */
+
+#define MPOA_TRIGGER_RCVD     101
+#define MPOA_RES_REPLY_RCVD   102
+#define INGRESS_PURGE_RCVD    103
+#define EGRESS_PURGE_RCVD     104
+#define MPS_DEATH             105
+#define CACHE_IMPOS_RCVD      106
+#define SET_MPC_CTRL_ADDR     107 /* Our MPC's control ATM address   */
+#define SET_MPS_MAC_ADDR      108
+#define CLEAN_UP_AND_EXIT     109
+#define SET_MPC_PARAMS        110 /* MPC configuration parameters    */
+
+/* Message types - bidirectional */       
+
+#define RELOAD                301 /* kill -HUP the daemon for reload */
+
+#endif /* _ATMMPC_H_ */
diff -uNr linux-2.6.32/usr/include/linux/atm_nicstar.h clean_modified/linux-2.6.32/usr/include/linux/atm_nicstar.h
--- linux-2.6.32/usr/include/linux/atm_nicstar.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_nicstar.h	2019-04-14 13:24:02.910021008 -0500
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * atm_nicstar.h
+ *
+ * Driver-specific declarations for use by NICSTAR driver specific utils.
+ *
+ * Author: Rui Prior
+ *
+ * (C) INESC 1998
+ *
+ ******************************************************************************/
+
+
+#ifndef LINUX_ATM_NICSTAR_H
+#define LINUX_ATM_NICSTAR_H
+
+/* Note: non-kernel programs including this file must also include
+ * sys/types.h for struct timeval
+ */
+
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+
+#define NS_GETPSTAT	_IOWR('a',ATMIOC_SARPRV+1,struct atmif_sioc)
+						/* get pool statistics */
+#define NS_SETBUFLEV	_IOW('a',ATMIOC_SARPRV+2,struct atmif_sioc)
+						/* set buffer level markers */
+#define NS_ADJBUFLEV	_IO('a',ATMIOC_SARPRV+3)
+						/* adjust buffer level */
+
+typedef struct buf_nr
+{
+   unsigned min;
+   unsigned init;
+   unsigned max;
+}buf_nr;
+
+
+typedef struct pool_levels
+{
+   int buftype;
+   int count;		/* (At least for now) only used in NS_GETPSTAT */
+   buf_nr level;
+} pool_levels;
+
+/* type must be one of the following: */
+#define NS_BUFTYPE_SMALL 1
+#define NS_BUFTYPE_LARGE 2
+#define NS_BUFTYPE_HUGE 3
+#define NS_BUFTYPE_IOVEC 4
+
+
+#endif /* LINUX_ATM_NICSTAR_H */
diff -uNr linux-2.6.32/usr/include/linux/atmppp.h clean_modified/linux-2.6.32/usr/include/linux/atmppp.h
--- linux-2.6.32/usr/include/linux/atmppp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmppp.h	2019-04-14 13:24:02.910978940 -0500
@@ -0,0 +1,24 @@
+/* atmppp.h - RFC2364 PPPoATM */
+
+/* Written 2000 by Mitchell Blank Jr */
+
+#ifndef _LINUX_ATMPPP_H
+#define _LINUX_ATMPPP_H
+
+#include <linux/atm.h>
+
+#define PPPOATM_ENCAPS_AUTODETECT	(0)
+#define PPPOATM_ENCAPS_VC		(1)
+#define PPPOATM_ENCAPS_LLC		(2)
+
+/*
+ * This is for the ATM_SETBACKEND call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_backend_ppp {
+	atm_backend_t	backend_num;	/* ATM_BACKEND_PPP */
+	int		encaps;		/* PPPOATM_ENCAPS_* */
+};
+
+#endif	/* _LINUX_ATMPPP_H */
diff -uNr linux-2.6.32/usr/include/linux/atmsap.h clean_modified/linux-2.6.32/usr/include/linux/atmsap.h
--- linux-2.6.32/usr/include/linux/atmsap.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmsap.h	2019-04-14 13:24:02.910978940 -0500
@@ -0,0 +1,162 @@
+/* atmsap.h - ATM Service Access Point addressing definitions */
+
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#ifndef _LINUX_ATMSAP_H
+#define _LINUX_ATMSAP_H
+
+#include <linux/atmapi.h>
+
+/*
+ * BEGIN_xx and END_xx markers are used for automatic generation of
+ * documentation. Do not change them.
+ */
+
+
+/*
+ * Layer 2 protocol identifiers
+ */
+
+/* BEGIN_L2 */
+#define ATM_L2_NONE	0	/* L2 not specified */
+#define ATM_L2_ISO1745  0x01	/* Basic mode ISO 1745 */
+#define ATM_L2_Q291	0x02	/* ITU-T Q.291 (Rec. I.441) */
+#define ATM_L2_X25_LL	0x06	/* ITU-T X.25, link layer */
+#define ATM_L2_X25_ML	0x07	/* ITU-T X.25, multilink */
+#define ATM_L2_LAPB	0x08	/* Extended LAPB, half-duplex (Rec. T.71) */
+#define ATM_L2_HDLC_ARM	0x09	/* HDLC ARM (ISO/IEC 4335) */
+#define ATM_L2_HDLC_NRM	0x0a	/* HDLC NRM (ISO/IEC 4335) */
+#define ATM_L2_HDLC_ABM	0x0b	/* HDLC ABM (ISO/IEC 4335) */
+#define ATM_L2_ISO8802	0x0c	/* LAN LLC (ISO/IEC 8802/2) */
+#define ATM_L2_X75	0x0d	/* ITU-T X.75, SLP */
+#define ATM_L2_Q922	0x0e	/* ITU-T Q.922 */
+#define ATM_L2_USER	0x10	/* user-specified */
+#define ATM_L2_ISO7776	0x11	/* ISO 7776 DTE-DTE */
+/* END_L2 */
+
+
+/*
+ * Layer 3 protocol identifiers
+ */
+
+/* BEGIN_L3 */
+#define ATM_L3_NONE	0	/* L3 not specified */
+#define ATM_L3_X25	0x06	/* ITU-T X.25, packet layer */
+#define ATM_L3_ISO8208	0x07	/* ISO/IEC 8208 */
+#define ATM_L3_X223	0x08	/* ITU-T X.223 | ISO/IEC 8878 */
+#define ATM_L3_ISO8473	0x09	/* ITU-T X.233 | ISO/IEC 8473 */
+#define ATM_L3_T70	0x0a	/* ITU-T T.70 minimum network layer */
+#define ATM_L3_TR9577	0x0b	/* ISO/IEC TR 9577 */
+#define ATM_L3_H310	0x0c	/* ITU-T Recommendation H.310 */
+#define ATM_L3_H321	0x0d	/* ITU-T Recommendation H.321 */
+#define ATM_L3_USER	0x10	/* user-specified */
+/* END_L3 */
+
+
+/*
+ * High layer identifiers
+ */
+
+/* BEGIN_HL */
+#define ATM_HL_NONE	0	/* HL not specified */
+#define ATM_HL_ISO	0x01	/* ISO */
+#define ATM_HL_USER	0x02	/* user-specific */
+#define ATM_HL_HLP	0x03	/* high layer profile - UNI 3.0 only */
+#define ATM_HL_VENDOR	0x04	/* vendor-specific application identifier */
+/* END_HL */
+
+
+/*
+ * ITU-T coded mode of operation
+ */
+
+/* BEGIN_IMD */
+#define ATM_IMD_NONE	 0	/* mode not specified */
+#define ATM_IMD_NORMAL	 1	/* normal mode of operation */
+#define ATM_IMD_EXTENDED 2	/* extended mode of operation */
+/* END_IMD */
+
+/*
+ * H.310 code points
+ */
+
+#define ATM_TT_NONE	0	/* terminal type not specified */
+#define ATM_TT_RX	1	/* receive only */
+#define ATM_TT_TX	2	/* send only */
+#define ATM_TT_RXTX	3	/* receive and send */
+
+#define ATM_MC_NONE	0	/* no multiplexing */
+#define ATM_MC_TS	1	/* transport stream (TS) */
+#define ATM_MC_TS_FEC	2	/* transport stream with forward error corr. */
+#define ATM_MC_PS	3	/* program stream (PS) */
+#define ATM_MC_PS_FEC	4	/* program stream with forward error corr. */
+#define ATM_MC_H221	5	/* ITU-T Rec. H.221 */
+
+/*
+ * SAP structures
+ */
+
+#define ATM_MAX_HLI	8	/* maximum high-layer information length */
+
+
+struct atm_blli {
+    unsigned char l2_proto;	/* layer 2 protocol */
+    union {
+	struct {
+	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
+				/* absent */
+	    unsigned char window; /* window size (k), 1-127 (0 to omit) */
+	} itu;			/* ITU-T encoding */
+	unsigned char user;	/* user-specified l2 information */
+    } l2;
+    unsigned char l3_proto;	/* layer 3 protocol */
+    union {
+	struct {
+	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
+				/* absent */
+	    unsigned char def_size; /* default packet size (log2), 4-12 (0 to */
+				    /* omit) */
+	    unsigned char window;/* packet window size, 1-127 (0 to omit) */
+	} itu;			/* ITU-T encoding */
+	unsigned char user;	/* user specified l3 information */
+	struct {		      /* if l3_proto = ATM_L3_H310 */
+	    unsigned char term_type;  /* terminal type */
+	    unsigned char fw_mpx_cap; /* forward multiplexing capability */
+				      /* only if term_type != ATM_TT_NONE */
+	    unsigned char bw_mpx_cap; /* backward multiplexing capability */
+				      /* only if term_type != ATM_TT_NONE */
+	} h310;
+	struct {		  /* if l3_proto = ATM_L3_TR9577 */
+	    unsigned char ipi;	  /* initial protocol id */
+	    unsigned char snap[5];/* IEEE 802.1 SNAP identifier */
+				  /* (only if ipi == NLPID_IEEE802_1_SNAP) */
+	} tr9577;
+    } l3;
+} __ATM_API_ALIGN;
+
+
+struct atm_bhli {
+    unsigned char hl_type;	/* high layer information type */
+    unsigned char hl_length;	/* length (only if hl_type == ATM_HL_USER || */
+				/* hl_type == ATM_HL_ISO) */
+    unsigned char hl_info[ATM_MAX_HLI];/* high layer information */
+};
+
+
+#define ATM_MAX_BLLI	3		/* maximum number of BLLI elements */
+
+
+struct atm_sap {
+	struct atm_bhli bhli;		/* local SAP, high-layer information */
+	struct atm_blli blli[ATM_MAX_BLLI] __ATM_API_ALIGN;
+					/* local SAP, low-layer info */
+};
+
+
+static __inline__ int blli_in_use(struct atm_blli blli)
+{
+	return blli.l2_proto || blli.l3_proto;
+}
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atmsvc.h clean_modified/linux-2.6.32/usr/include/linux/atmsvc.h
--- linux-2.6.32/usr/include/linux/atmsvc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atmsvc.h	2019-04-14 13:24:02.911873296 -0500
@@ -0,0 +1,55 @@
+/* atmsvc.h - ATM signaling kernel-demon interface definitions */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef _LINUX_ATMSVC_H
+#define _LINUX_ATMSVC_H
+
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+
+
+#define ATMSIGD_CTRL _IO('a',ATMIOC_SPECIAL)
+				/* become ATM signaling demon control socket */
+
+enum atmsvc_msg_type { as_catch_null, as_bind, as_connect, as_accept, as_reject,
+		       as_listen, as_okay, as_error, as_indicate, as_close,
+		       as_itf_notify, as_modify, as_identify, as_terminate,
+		       as_addparty, as_dropparty };
+
+struct atmsvc_msg {
+	enum atmsvc_msg_type type;
+	atm_kptr_t vcc;
+	atm_kptr_t listen_vcc;		/* indicate */
+	int reply;			/* for okay and close:		   */
+					/*   < 0: error before active	   */
+					/*        (sigd has discarded ctx) */
+					/*   ==0: success		   */
+				        /*   > 0: error when active (still */
+					/*        need to close)	   */
+	struct sockaddr_atmpvc pvc;	/* indicate, okay (connect) */
+	struct sockaddr_atmsvc local;	/* local SVC address */
+	struct atm_qos qos;		/* QOS parameters */
+	struct atm_sap sap;		/* SAP */
+	unsigned int session;		/* for p2pm */
+	struct sockaddr_atmsvc svc;	/* SVC address */
+} __ATM_API_ALIGN;
+
+/*
+ * Message contents: see ftp://icaftp.epfl.ch/pub/linux/atm/docs/isp-*.tar.gz
+ */
+
+/*
+ * Some policy stuff for atmsigd and for net/atm/svc.c. Both have to agree on
+ * what PCR is used to request bandwidth from the device driver. net/atm/svc.c
+ * tries to do better than that, but only if there's no routing decision (i.e.
+ * if signaling only uses one ATM interface).
+ */
+
+#define SELECT_TOP_PCR(tp) ((tp).pcr ? (tp).pcr : \
+  (tp).max_pcr && (tp).max_pcr != ATM_MAX_PCR ? (tp).max_pcr : \
+  (tp).min_pcr ? (tp).min_pcr : ATM_MAX_PCR)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atm_tcp.h clean_modified/linux-2.6.32/usr/include/linux/atm_tcp.h
--- linux-2.6.32/usr/include/linux/atm_tcp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_tcp.h	2019-04-14 13:24:02.911873296 -0500
@@ -0,0 +1,61 @@
+/* atm_tcp.h - Driver-specific declarations of the ATMTCP driver (for use by
+	       driver-specific utilities) */
+
+/* Written 1997-2000 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#ifndef LINUX_ATM_TCP_H
+#define LINUX_ATM_TCP_H
+
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+#include <linux/types.h>
+
+
+/*
+ * All values in struct atmtcp_hdr are in network byte order
+ */
+
+struct atmtcp_hdr {
+	__u16	vpi;
+	__u16	vci;
+	__u32	length;		/* ... of data part */
+};
+
+/*
+ * All values in struct atmtcp_command are in host byte order
+ */
+
+#define ATMTCP_HDR_MAGIC	(~0)	/* this length indicates a command */
+#define ATMTCP_CTRL_OPEN	1	/* request/reply */
+#define ATMTCP_CTRL_CLOSE	2	/* request/reply */
+
+struct atmtcp_control {
+	struct atmtcp_hdr hdr;	/* must be first */
+	int type;		/* message type; both directions */
+	atm_kptr_t vcc;		/* both directions */
+	struct sockaddr_atmpvc addr; /* suggested value from kernel */
+	struct atm_qos	qos;	/* both directions */
+	int result;		/* to kernel only */
+} __ATM_API_ALIGN;
+
+/*
+ * Field usage:
+ * Messge type	dir.	hdr.v?i	type	addr	qos	vcc	result
+ * -----------  ----	------- ----	----	---	---	------
+ * OPEN		K->D	Y	Y	Y	Y	Y	0
+ * OPEN		D->K	-	Y	Y	Y	Y	Y
+ * CLOSE	K->D	-	-	Y	-	Y	0
+ * CLOSE	D->K	-	-	-	-	Y	Y
+ */
+
+#define SIOCSIFATMTCP	_IO('a',ATMIOC_ITF)	/* set ATMTCP mode */
+#define ATMTCP_CREATE	_IO('a',ATMIOC_ITF+14)	/* create persistent ATMTCP
+						   interface */
+#define ATMTCP_REMOVE	_IO('a',ATMIOC_ITF+15)	/* destroy persistent ATMTCP
+						   interface */
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/atm_zatm.h clean_modified/linux-2.6.32/usr/include/linux/atm_zatm.h
--- linux-2.6.32/usr/include/linux/atm_zatm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/atm_zatm.h	2019-04-14 13:24:02.911873296 -0500
@@ -0,0 +1,52 @@
+/* atm_zatm.h - Driver-specific declarations of the ZATM driver (for use by
+		driver-specific utilities) */
+
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#ifndef LINUX_ATM_ZATM_H
+#define LINUX_ATM_ZATM_H
+
+/*
+ * Note: non-kernel programs including this file must also include
+ * sys/types.h for struct timeval
+ */
+
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+
+#define ZATM_GETPOOL	_IOW('a',ATMIOC_SARPRV+1,struct atmif_sioc)
+						/* get pool statistics */
+#define ZATM_GETPOOLZ	_IOW('a',ATMIOC_SARPRV+2,struct atmif_sioc)
+						/* get statistics and zero */
+#define ZATM_SETPOOL	_IOW('a',ATMIOC_SARPRV+3,struct atmif_sioc)
+						/* set pool parameters */
+
+struct zatm_pool_info {
+	int ref_count;			/* free buffer pool usage counters */
+	int low_water,high_water;	/* refill parameters */
+	int rqa_count,rqu_count;	/* queue condition counters */
+	int offset,next_off;		/* alignment optimizations: offset */
+	int next_cnt,next_thres;	/* repetition counter and threshold */
+};
+
+struct zatm_pool_req {
+	int pool_num;			/* pool number */
+	struct zatm_pool_info info;	/* actual information */
+};
+
+struct zatm_t_hist {
+	struct timeval real;		/* real (wall-clock) time */
+	struct timeval expected;	/* expected real time */
+};
+
+
+#define ZATM_OAM_POOL		0	/* free buffer pool for OAM cells */
+#define ZATM_AAL0_POOL		1	/* free buffer pool for AAL0 cells */
+#define ZATM_AAL5_POOL_BASE	2	/* first AAL5 free buffer pool */
+#define ZATM_LAST_POOL	ZATM_AAL5_POOL_BASE+10 /* max. 64 kB */
+
+#define ZATM_TIMER_HISTORY_SIZE	16	/* number of timer adjustments to
+					   record; must be 2^n */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/audit.h clean_modified/linux-2.6.32/usr/include/linux/audit.h
--- linux-2.6.32/usr/include/linux/audit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/audit.h	2019-04-14 13:24:02.912960551 -0500
@@ -0,0 +1,361 @@
+/* audit.h -- Auditing support
+ *
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Written by Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+#ifndef _LINUX_AUDIT_H_
+#define _LINUX_AUDIT_H_
+
+#include <linux/types.h>
+#include <linux/elf-em.h>
+
+/* The netlink messages for the audit system is divided into blocks:
+ * 1000 - 1099 are for commanding the audit system
+ * 1100 - 1199 user space trusted application messages
+ * 1200 - 1299 messages internal to the audit daemon
+ * 1300 - 1399 audit event messages
+ * 1400 - 1499 SE Linux use
+ * 1500 - 1599 kernel LSPP events
+ * 1600 - 1699 kernel crypto events
+ * 1700 - 1799 kernel anomaly records
+ * 1800 - 1899 kernel integrity events
+ * 1900 - 1999 future kernel use
+ * 2000 is for otherwise unclassified kernel audit messages (legacy)
+ * 2001 - 2099 unused (kernel)
+ * 2100 - 2199 user space anomaly records
+ * 2200 - 2299 user space actions taken in response to anomalies
+ * 2300 - 2399 user space generated LSPP events
+ * 2400 - 2499 user space crypto events
+ * 2500 - 2999 future user space (maybe integrity labels and related events)
+ *
+ * Messages from 1000-1199 are bi-directional. 1200-1299 & 2100 - 2999 are
+ * exclusively user space. 1300-2099 is kernel --> user space 
+ * communication.
+ */
+#define AUDIT_GET		1000	/* Get status */
+#define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
+#define AUDIT_LIST		1002	/* List syscall rules -- deprecated */
+#define AUDIT_ADD		1003	/* Add syscall rule -- deprecated */
+#define AUDIT_DEL		1004	/* Delete syscall rule -- deprecated */
+#define AUDIT_USER		1005	/* Message from userspace -- deprecated */
+#define AUDIT_LOGIN		1006	/* Define the login id and information */
+#define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
+#define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
+#define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
+#define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
+#define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
+#define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
+#define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
+#define AUDIT_TRIM		1014	/* Trim junk from watched tree */
+#define AUDIT_MAKE_EQUIV	1015	/* Append to watched tree */
+#define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
+#define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
+
+#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
+#define AUDIT_USER_AVC		1107	/* We filter this differently */
+#define AUDIT_USER_TTY		1124	/* Non-ICANON TTY input meaning */
+#define AUDIT_LAST_USER_MSG	1199
+#define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
+#define AUDIT_LAST_USER_MSG2	2999
+ 
+#define AUDIT_DAEMON_START      1200    /* Daemon startup record */
+#define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
+#define AUDIT_DAEMON_ABORT      1202    /* Daemon error stop record */
+#define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */
+
+#define AUDIT_SYSCALL		1300	/* Syscall event */
+/* #define AUDIT_FS_WATCH	1301	 * Deprecated */
+#define AUDIT_PATH		1302	/* Filename path information */
+#define AUDIT_IPC		1303	/* IPC record */
+#define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
+#define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
+#define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
+#define AUDIT_CWD		1307	/* Current working directory */
+#define AUDIT_EXECVE		1309	/* execve arguments */
+#define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
+#define AUDIT_MQ_OPEN		1312	/* POSIX MQ open record type */
+#define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
+#define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
+#define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
+#define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
+#define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
+#define AUDIT_OBJ_PID		1318	/* ptrace target */
+#define AUDIT_TTY		1319	/* Input on an administrative TTY */
+#define AUDIT_EOE		1320	/* End of multi-record event */
+#define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
+#define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
+
+#define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
+#define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
+#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
+#define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
+#define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
+#define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
+#define AUDIT_MAC_UNLBL_ALLOW	1406	/* NetLabel: allow unlabeled traffic */
+#define AUDIT_MAC_CIPSOV4_ADD	1407	/* NetLabel: add CIPSOv4 DOI entry */
+#define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
+#define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
+#define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
+#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSA	1412	/* Not used  */
+#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
+#define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
+#define AUDIT_MAC_UNLBL_STCADD	1416	/* NetLabel: add a static label */
+#define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */
+
+#define AUDIT_FIRST_KERN_ANOM_MSG   1700
+#define AUDIT_LAST_KERN_ANOM_MSG    1799
+#define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
+#define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
+#define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
+#define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
+#define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
+#define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
+#define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
+#define AUDIT_INTEGRITY_RULE	    1805 /* policy rule */
+
+#define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
+
+/* Rule flags */
+#define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
+#define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
+#define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
+#define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
+#define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
+#define AUDIT_FILTER_TYPE	0x05	/* Apply rule at audit_log_start */
+
+#define AUDIT_NR_FILTERS	6
+
+#define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */
+
+/* Rule actions */
+#define AUDIT_NEVER    0	/* Do not build context if rule matches */
+#define AUDIT_POSSIBLE 1	/* Build context if rule matches  */
+#define AUDIT_ALWAYS   2	/* Generate audit record if rule matches */
+
+/* Rule structure sizes -- if these change, different AUDIT_ADD and
+ * AUDIT_LIST commands must be implemented. */
+#define AUDIT_MAX_FIELDS   64
+#define AUDIT_MAX_KEY_LEN  256
+#define AUDIT_BITMASK_SIZE 64
+#define AUDIT_WORD(nr) ((__u32)((nr)/32))
+#define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
+
+#define AUDIT_SYSCALL_CLASSES 16
+#define AUDIT_CLASS_DIR_WRITE 0
+#define AUDIT_CLASS_DIR_WRITE_32 1
+#define AUDIT_CLASS_CHATTR 2
+#define AUDIT_CLASS_CHATTR_32 3
+#define AUDIT_CLASS_READ 4
+#define AUDIT_CLASS_READ_32 5
+#define AUDIT_CLASS_WRITE 6
+#define AUDIT_CLASS_WRITE_32 7
+#define AUDIT_CLASS_SIGNAL 8
+#define AUDIT_CLASS_SIGNAL_32 9
+
+/* This bitmask is used to validate user input.  It represents all bits that
+ * are currently used in an audit field constant understood by the kernel.
+ * If you are adding a new #define AUDIT_<whatever>, please ensure that
+ * AUDIT_UNUSED_BITS is updated if need be. */
+#define AUDIT_UNUSED_BITS	0x07FFFC00
+
+
+/* Rule fields */
+				/* These are useful when checking the
+				 * task structure at task creation time
+				 * (AUDIT_PER_TASK).  */
+#define AUDIT_PID	0
+#define AUDIT_UID	1
+#define AUDIT_EUID	2
+#define AUDIT_SUID	3
+#define AUDIT_FSUID	4
+#define AUDIT_GID	5
+#define AUDIT_EGID	6
+#define AUDIT_SGID	7
+#define AUDIT_FSGID	8
+#define AUDIT_LOGINUID	9
+#define AUDIT_PERS	10
+#define AUDIT_ARCH	11
+#define AUDIT_MSGTYPE	12
+#define AUDIT_SUBJ_USER	13	/* security label user */
+#define AUDIT_SUBJ_ROLE	14	/* security label role */
+#define AUDIT_SUBJ_TYPE	15	/* security label type */
+#define AUDIT_SUBJ_SEN	16	/* security label sensitivity label */
+#define AUDIT_SUBJ_CLR	17	/* security label clearance label */
+#define AUDIT_PPID	18
+#define AUDIT_OBJ_USER	19
+#define AUDIT_OBJ_ROLE	20
+#define AUDIT_OBJ_TYPE	21
+#define AUDIT_OBJ_LEV_LOW	22
+#define AUDIT_OBJ_LEV_HIGH	23
+
+				/* These are ONLY useful when checking
+				 * at syscall exit time (AUDIT_AT_EXIT). */
+#define AUDIT_DEVMAJOR	100
+#define AUDIT_DEVMINOR	101
+#define AUDIT_INODE	102
+#define AUDIT_EXIT	103
+#define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
+#define AUDIT_WATCH	105
+#define AUDIT_PERM	106
+#define AUDIT_DIR	107
+#define AUDIT_FILETYPE	108
+
+#define AUDIT_ARG0      200
+#define AUDIT_ARG1      (AUDIT_ARG0+1)
+#define AUDIT_ARG2      (AUDIT_ARG0+2)
+#define AUDIT_ARG3      (AUDIT_ARG0+3)
+
+#define AUDIT_FILTERKEY	210
+
+#define AUDIT_NEGATE			0x80000000
+
+/* These are the supported operators.
+ *	4  2  1  8
+ *	=  >  <  ?
+ *	----------
+ *	0  0  0	 0	00	nonsense
+ *	0  0  0	 1	08	&  bit mask
+ *	0  0  1	 0	10	<
+ *	0  1  0	 0	20	>
+ *	0  1  1	 0	30	!=
+ *	1  0  0	 0	40	=
+ *	1  0  0	 1	48	&=  bit test
+ *	1  0  1	 0	50	<=
+ *	1  1  0	 0	60	>=
+ *	1  1  1	 1	78	all operators
+ */
+#define AUDIT_BIT_MASK			0x08000000
+#define AUDIT_LESS_THAN			0x10000000
+#define AUDIT_GREATER_THAN		0x20000000
+#define AUDIT_NOT_EQUAL			0x30000000
+#define AUDIT_EQUAL			0x40000000
+#define AUDIT_BIT_TEST			(AUDIT_BIT_MASK|AUDIT_EQUAL)
+#define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
+#define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
+#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)
+
+enum {
+	Audit_equal,
+	Audit_not_equal,
+	Audit_bitmask,
+	Audit_bittest,
+	Audit_lt,
+	Audit_gt,
+	Audit_le,
+	Audit_ge,
+	Audit_bad
+};
+
+/* Status symbols */
+				/* Mask values */
+#define AUDIT_STATUS_ENABLED		0x0001
+#define AUDIT_STATUS_FAILURE		0x0002
+#define AUDIT_STATUS_PID		0x0004
+#define AUDIT_STATUS_RATE_LIMIT		0x0008
+#define AUDIT_STATUS_BACKLOG_LIMIT	0x0010
+				/* Failure-to-log actions */
+#define AUDIT_FAIL_SILENT	0
+#define AUDIT_FAIL_PRINTK	1
+#define AUDIT_FAIL_PANIC	2
+
+/* distinguish syscall tables */
+#define __AUDIT_ARCH_64BIT 0x80000000
+#define __AUDIT_ARCH_LE	   0x40000000
+#define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARMEB	(EM_ARM)
+#define AUDIT_ARCH_CRIS		(EM_CRIS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_FRV		(EM_FRV)
+#define AUDIT_ARCH_H8300	(EM_H8_300)
+#define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_M32R		(EM_M32R)
+#define AUDIT_ARCH_M68K		(EM_68K)
+#define AUDIT_ARCH_MIPS		(EM_MIPS)
+#define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_PARISC	(EM_PARISC)
+#define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_PPC		(EM_PPC)
+#define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_S390		(EM_S390)
+#define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SH		(EM_SH)
+#define AUDIT_ARCH_SHEL		(EM_SH|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SPARC	(EM_SPARC)
+#define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+
+#define AUDIT_PERM_EXEC		1
+#define AUDIT_PERM_WRITE	2
+#define AUDIT_PERM_READ		4
+#define AUDIT_PERM_ATTR		8
+
+struct audit_status {
+	__u32		mask;		/* Bit mask for valid entries */
+	__u32		enabled;	/* 1 = enabled, 0 = disabled */
+	__u32		failure;	/* Failure-to-log action */
+	__u32		pid;		/* pid of auditd process */
+	__u32		rate_limit;	/* messages rate limit (per second) */
+	__u32		backlog_limit;	/* waiting messages limit */
+	__u32		lost;		/* messages lost */
+	__u32		backlog;	/* messages waiting in queue */
+};
+
+struct audit_tty_status {
+	__u32		enabled; /* 1 = enabled, 0 = disabled */
+};
+
+/* audit_rule_data supports filter rules with both integer and string
+ * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
+ * AUDIT_LIST_RULES requests.
+ */
+struct audit_rule_data {
+	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	__u32		field_count;
+	__u32		mask[AUDIT_BITMASK_SIZE]; /* syscall(s) affected */
+	__u32		fields[AUDIT_MAX_FIELDS];
+	__u32		values[AUDIT_MAX_FIELDS];
+	__u32		fieldflags[AUDIT_MAX_FIELDS];
+	__u32		buflen;	/* total length of string fields */
+	char		buf[0];	/* string fields buffer */
+};
+
+/* audit_rule is supported to maintain backward compatibility with
+ * userspace.  It supports integer fields only and corresponds to
+ * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
+ */
+struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
+	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	__u32		field_count;
+	__u32		mask[AUDIT_BITMASK_SIZE];
+	__u32		fields[AUDIT_MAX_FIELDS];
+	__u32		values[AUDIT_MAX_FIELDS];
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/auto_fs4.h clean_modified/linux-2.6.32/usr/include/linux/auto_fs4.h
--- linux-2.6.32/usr/include/linux/auto_fs4.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/auto_fs4.h	2019-04-14 13:24:02.912960551 -0500
@@ -0,0 +1,164 @@
+/* -*- c -*-
+ * linux/include/linux/auto_fs4.h
+ *
+ * Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ */
+
+#ifndef _LINUX_AUTO_FS4_H
+#define _LINUX_AUTO_FS4_H
+
+/* Include common v3 definitions */
+#include <linux/types.h>
+#include <linux/auto_fs.h>
+
+/* autofs v4 definitions */
+#undef AUTOFS_PROTO_VERSION
+#undef AUTOFS_MIN_PROTO_VERSION
+#undef AUTOFS_MAX_PROTO_VERSION
+
+#define AUTOFS_PROTO_VERSION		5
+#define AUTOFS_MIN_PROTO_VERSION	3
+#define AUTOFS_MAX_PROTO_VERSION	5
+
+#define AUTOFS_PROTO_SUBVERSION		1
+
+/* Mask for expire behaviour */
+#define AUTOFS_EXP_IMMEDIATE		1
+#define AUTOFS_EXP_LEAVES		2
+
+#define AUTOFS_TYPE_ANY			0U
+#define AUTOFS_TYPE_INDIRECT		1U
+#define AUTOFS_TYPE_DIRECT		2U
+#define AUTOFS_TYPE_OFFSET		4U
+
+static __inline__ void set_autofs_type_indirect(unsigned int *type)
+{
+	*type = AUTOFS_TYPE_INDIRECT;
+	return;
+}
+
+static __inline__ unsigned int autofs_type_indirect(unsigned int type)
+{
+	return (type == AUTOFS_TYPE_INDIRECT);
+}
+
+static __inline__ void set_autofs_type_direct(unsigned int *type)
+{
+	*type = AUTOFS_TYPE_DIRECT;
+	return;
+}
+
+static __inline__ unsigned int autofs_type_direct(unsigned int type)
+{
+	return (type == AUTOFS_TYPE_DIRECT);
+}
+
+static __inline__ void set_autofs_type_offset(unsigned int *type)
+{
+	*type = AUTOFS_TYPE_OFFSET;
+	return;
+}
+
+static __inline__ unsigned int autofs_type_offset(unsigned int type)
+{
+	return (type == AUTOFS_TYPE_OFFSET);
+}
+
+static __inline__ unsigned int autofs_type_trigger(unsigned int type)
+{
+	return (type == AUTOFS_TYPE_DIRECT || type == AUTOFS_TYPE_OFFSET);
+}
+
+/*
+ * This isn't really a type as we use it to say "no type set" to
+ * indicate we want to search for "any" mount in the
+ * autofs_dev_ioctl_ismountpoint() device ioctl function.
+ */
+static __inline__ void set_autofs_type_any(unsigned int *type)
+{
+	*type = AUTOFS_TYPE_ANY;
+	return;
+}
+
+static __inline__ unsigned int autofs_type_any(unsigned int type)
+{
+	return (type == AUTOFS_TYPE_ANY);
+}
+
+/* Daemon notification packet types */
+enum autofs_notify {
+	NFY_NONE,
+	NFY_MOUNT,
+	NFY_EXPIRE
+};
+
+/* Kernel protocol version 4 packet types */
+
+/* Expire entry (umount request) */
+#define autofs_ptype_expire_multi	2
+
+/* Kernel protocol version 5 packet types */
+
+/* Indirect mount missing and expire requests. */
+#define autofs_ptype_missing_indirect	3
+#define autofs_ptype_expire_indirect	4
+
+/* Direct mount missing and expire requests */
+#define autofs_ptype_missing_direct	5
+#define autofs_ptype_expire_direct	6
+
+/* v4 multi expire (via pipe) */
+struct autofs_packet_expire_multi {
+	struct autofs_packet_hdr hdr;
+        autofs_wqt_t wait_queue_token;
+	int len;
+	char name[NAME_MAX+1];
+};
+
+union autofs_packet_union {
+	struct autofs_packet_hdr hdr;
+	struct autofs_packet_missing missing;
+	struct autofs_packet_expire expire;
+	struct autofs_packet_expire_multi expire_multi;
+};
+
+/* autofs v5 common packet struct */
+struct autofs_v5_packet {
+	struct autofs_packet_hdr hdr;
+	autofs_wqt_t wait_queue_token;
+	__u32 dev;
+	__u64 ino;
+	__u32 uid;
+	__u32 gid;
+	__u32 pid;
+	__u32 tgid;
+	__u32 len;
+	char name[NAME_MAX+1];
+};
+
+typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;
+typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;
+typedef struct autofs_v5_packet autofs_packet_missing_direct_t;
+typedef struct autofs_v5_packet autofs_packet_expire_direct_t;
+
+union autofs_v5_packet_union {
+	struct autofs_packet_hdr hdr;
+	struct autofs_v5_packet v5_packet;
+	autofs_packet_missing_indirect_t missing_indirect;
+	autofs_packet_expire_indirect_t expire_indirect;
+	autofs_packet_missing_direct_t missing_direct;
+	autofs_packet_expire_direct_t expire_direct;
+};
+
+#define AUTOFS_IOC_EXPIRE_MULTI		_IOW(0x93,0x66,int)
+#define AUTOFS_IOC_EXPIRE_INDIRECT	AUTOFS_IOC_EXPIRE_MULTI
+#define AUTOFS_IOC_EXPIRE_DIRECT	AUTOFS_IOC_EXPIRE_MULTI
+#define AUTOFS_IOC_PROTOSUBVER		_IOR(0x93,0x67,int)
+#define AUTOFS_IOC_ASKUMOUNT		_IOR(0x93,0x70,int)
+
+
+#endif /* _LINUX_AUTO_FS4_H */
diff -uNr linux-2.6.32/usr/include/linux/auto_fs.h clean_modified/linux-2.6.32/usr/include/linux/auto_fs.h
--- linux-2.6.32/usr/include/linux/auto_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/auto_fs.h	2019-04-14 13:24:02.913923314 -0500
@@ -0,0 +1,79 @@
+/* -*- linux-c -*- ------------------------------------------------------- *
+ *   
+ * linux/include/linux/auto_fs.h
+ *
+ *   Copyright 1997 Transmeta Corporation - All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * ----------------------------------------------------------------------- */
+
+
+#ifndef _LINUX_AUTO_FS_H
+#define _LINUX_AUTO_FS_H
+
+#include <linux/types.h>
+#include <sys/ioctl.h>
+
+/* This file describes autofs v3 */
+#define AUTOFS_PROTO_VERSION	3
+
+/* Range of protocol versions defined */
+#define AUTOFS_MAX_PROTO_VERSION	AUTOFS_PROTO_VERSION
+#define AUTOFS_MIN_PROTO_VERSION	AUTOFS_PROTO_VERSION
+
+/*
+ * Architectures where both 32- and 64-bit binaries can be executed
+ * on 64-bit kernels need this.  This keeps the structure format
+ * uniform, and makes sure the wait_queue_token isn't too big to be
+ * passed back down to the kernel.
+ *
+ * This assumes that on these architectures:
+ * mode     32 bit    64 bit
+ * -------------------------
+ * int      32 bit    32 bit
+ * long     32 bit    64 bit
+ *
+ * If so, 32-bit user-space code should be backwards compatible.
+ */
+
+#if defined(__sparc__) || defined(__mips__) || defined(__x86_64__) \
+ || defined(__powerpc__) || defined(__s390__)
+typedef unsigned int autofs_wqt_t;
+#else
+typedef unsigned long autofs_wqt_t;
+#endif
+
+/* Packet types */
+#define autofs_ptype_missing	0	/* Missing entry (mount request) */
+#define autofs_ptype_expire	1	/* Expire entry (umount request) */
+
+struct autofs_packet_hdr {
+	int proto_version;		/* Protocol version */
+	int type;			/* Type of packet */
+};
+
+struct autofs_packet_missing {
+	struct autofs_packet_hdr hdr;
+        autofs_wqt_t wait_queue_token;
+	int len;
+	char name[NAME_MAX+1];
+};	
+
+/* v3 expire (via ioctl) */
+struct autofs_packet_expire {
+	struct autofs_packet_hdr hdr;
+	int len;
+	char name[NAME_MAX+1];
+};
+
+#define AUTOFS_IOC_READY      _IO(0x93,0x60)
+#define AUTOFS_IOC_FAIL       _IO(0x93,0x61)
+#define AUTOFS_IOC_CATATONIC  _IO(0x93,0x62)
+#define AUTOFS_IOC_PROTOVER   _IOR(0x93,0x63,int)
+#define AUTOFS_IOC_SETTIMEOUT _IOWR(0x93,0x64,unsigned long)
+#define AUTOFS_IOC_EXPIRE     _IOR(0x93,0x65,struct autofs_packet_expire)
+
+#endif /* _LINUX_AUTO_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/auxvec.h clean_modified/linux-2.6.32/usr/include/linux/auxvec.h
--- linux-2.6.32/usr/include/linux/auxvec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/auxvec.h	2019-04-14 13:24:02.913923314 -0500
@@ -0,0 +1,35 @@
+#ifndef _LINUX_AUXVEC_H
+#define _LINUX_AUXVEC_H
+
+#include <asm/auxvec.h>
+
+/* Symbolic values for the entries in the auxiliary table
+   put on the initial stack */
+#define AT_NULL   0	/* end of vector */
+#define AT_IGNORE 1	/* entry should be ignored */
+#define AT_EXECFD 2	/* file descriptor of program */
+#define AT_PHDR   3	/* program headers for program */
+#define AT_PHENT  4	/* size of program header entry */
+#define AT_PHNUM  5	/* number of program headers */
+#define AT_PAGESZ 6	/* system page size */
+#define AT_BASE   7	/* base address of interpreter */
+#define AT_FLAGS  8	/* flags */
+#define AT_ENTRY  9	/* entry point of program */
+#define AT_NOTELF 10	/* program is not ELF */
+#define AT_UID    11	/* real uid */
+#define AT_EUID   12	/* effective uid */
+#define AT_GID    13	/* real gid */
+#define AT_EGID   14	/* effective gid */
+#define AT_PLATFORM 15  /* string identifying CPU for optimizations */
+#define AT_HWCAP  16    /* arch dependent hints at CPU capabilities */
+#define AT_CLKTCK 17	/* frequency at which times() increments */
+/* AT_* values 18 through 22 are reserved */
+#define AT_SECURE 23   /* secure mode boolean */
+#define AT_BASE_PLATFORM 24	/* string identifying real platform, may
+				 * differ from AT_PLATFORM. */
+#define AT_RANDOM 25	/* address of 16 random bytes */
+
+#define AT_EXECFN  31	/* filename of program */
+
+
+#endif /* _LINUX_AUXVEC_H */
diff -uNr linux-2.6.32/usr/include/linux/ax25.h clean_modified/linux-2.6.32/usr/include/linux/ax25.h
--- linux-2.6.32/usr/include/linux/ax25.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ax25.h	2019-04-14 13:24:02.913923314 -0500
@@ -0,0 +1,116 @@
+/*
+ * These are the public elements of the Linux kernel AX.25 code. A similar
+ * file netrom.h exists for the NET/ROM protocol.
+ */
+
+#ifndef	AX25_KERNEL_H
+#define	AX25_KERNEL_H
+
+#include <linux/socket.h>
+
+#define AX25_MTU	256
+#define AX25_MAX_DIGIS  8
+
+#define AX25_WINDOW	1
+#define AX25_T1		2
+#define AX25_N2		3
+#define AX25_T3		4
+#define AX25_T2		5
+#define	AX25_BACKOFF	6
+#define	AX25_EXTSEQ	7
+#define	AX25_PIDINCL	8
+#define AX25_IDLE	9
+#define AX25_PACLEN	10
+#define AX25_IAMDIGI	12
+
+#define AX25_KILL	99
+
+#define SIOCAX25GETUID		(SIOCPROTOPRIVATE+0)
+#define SIOCAX25ADDUID		(SIOCPROTOPRIVATE+1)
+#define SIOCAX25DELUID		(SIOCPROTOPRIVATE+2)
+#define SIOCAX25NOUID		(SIOCPROTOPRIVATE+3)
+#define SIOCAX25OPTRT		(SIOCPROTOPRIVATE+7)
+#define SIOCAX25CTLCON		(SIOCPROTOPRIVATE+8)
+#define SIOCAX25GETINFOOLD	(SIOCPROTOPRIVATE+9)
+#define SIOCAX25ADDFWD		(SIOCPROTOPRIVATE+10)
+#define SIOCAX25DELFWD		(SIOCPROTOPRIVATE+11)
+#define SIOCAX25DEVCTL          (SIOCPROTOPRIVATE+12)
+#define SIOCAX25GETINFO         (SIOCPROTOPRIVATE+13)
+
+#define AX25_SET_RT_IPMODE	2
+
+#define AX25_NOUID_DEFAULT	0
+#define AX25_NOUID_BLOCK	1
+
+typedef struct {
+	char		ax25_call[7];	/* 6 call + SSID (shifted ascii!) */
+} ax25_address;
+
+struct sockaddr_ax25 {
+	sa_family_t	sax25_family;
+	ax25_address	sax25_call;
+	int		sax25_ndigis;
+	/* Digipeater ax25_address sets follow */
+};
+
+#define sax25_uid	sax25_ndigis
+
+struct full_sockaddr_ax25 {
+	struct sockaddr_ax25 fsa_ax25;
+	ax25_address	fsa_digipeater[AX25_MAX_DIGIS];
+};
+
+struct ax25_routes_struct {
+	ax25_address	port_addr;
+	ax25_address	dest_addr;
+	unsigned char	digi_count;
+	ax25_address	digi_addr[AX25_MAX_DIGIS];
+};
+
+struct ax25_route_opt_struct {
+	ax25_address	port_addr;
+	ax25_address	dest_addr;
+	int		cmd;
+	int		arg;
+};
+
+struct ax25_ctl_struct {
+        ax25_address            port_addr;
+        ax25_address            source_addr;
+        ax25_address            dest_addr;
+        unsigned int            cmd;
+        unsigned long           arg;
+        unsigned char           digi_count;
+        ax25_address            digi_addr[AX25_MAX_DIGIS];
+};
+
+/* this will go away. Please do not export to user land */
+struct ax25_info_struct_deprecated {
+	unsigned int	n2, n2count;
+	unsigned int	t1, t1timer;
+	unsigned int	t2, t2timer;
+	unsigned int	t3, t3timer;
+	unsigned int	idle, idletimer;
+	unsigned int	state;
+	unsigned int	rcv_q, snd_q;
+};
+
+struct ax25_info_struct {
+	unsigned int	n2, n2count;
+	unsigned int	t1, t1timer;
+	unsigned int	t2, t2timer;
+	unsigned int	t3, t3timer;
+	unsigned int	idle, idletimer;
+	unsigned int	state;
+	unsigned int	rcv_q, snd_q;
+	unsigned int	vs, vr, va, vs_max;
+	unsigned int	paclen;
+	unsigned int	window;
+};
+
+struct ax25_fwd_struct {
+	ax25_address	port_from;
+	ax25_address	port_to;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/b1lli.h clean_modified/linux-2.6.32/usr/include/linux/b1lli.h
--- linux-2.6.32/usr/include/linux/b1lli.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/b1lli.h	2019-04-14 13:24:02.914882147 -0500
@@ -0,0 +1,73 @@
+/* $Id: b1lli.h,v 1.8.8.3 2001/09/23 22:25:05 kai Exp $
+ *
+ * ISDN lowlevel-module for AVM B1-card.
+ *
+ * Copyright 1996 by Carsten Paeth (calle@calle.in-berlin.de)
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef _B1LLI_H_
+#define _B1LLI_H_
+/*
+ * struct for loading t4 file 
+ */
+typedef struct avmb1_t4file {
+	int len;
+	unsigned char *data;
+} avmb1_t4file;
+
+typedef struct avmb1_loaddef {
+	int contr;
+	avmb1_t4file t4file;
+} avmb1_loaddef;
+
+typedef struct avmb1_loadandconfigdef {
+	int contr;
+	avmb1_t4file t4file;
+        avmb1_t4file t4config; 
+} avmb1_loadandconfigdef;
+
+typedef struct avmb1_resetdef {
+	int contr;
+} avmb1_resetdef;
+
+typedef struct avmb1_getdef {
+	int contr;
+	int cardtype;
+	int cardstate;
+} avmb1_getdef;
+
+/*
+ * struct for adding new cards 
+ */
+typedef struct avmb1_carddef {
+	int port;
+	int irq;
+} avmb1_carddef;
+
+#define AVM_CARDTYPE_B1		0
+#define AVM_CARDTYPE_T1		1
+#define AVM_CARDTYPE_M1		2
+#define AVM_CARDTYPE_M2		3
+
+typedef struct avmb1_extcarddef {
+	int port;
+	int irq;
+        int cardtype;
+        int cardnr;  /* for HEMA/T1 */
+} avmb1_extcarddef;
+
+#define	AVMB1_LOAD		0	/* load image to card */
+#define AVMB1_ADDCARD		1	/* add a new card - OBSOLETE */
+#define AVMB1_RESETCARD		2	/* reset a card */
+#define	AVMB1_LOAD_AND_CONFIG	3	/* load image and config to card */
+#define	AVMB1_ADDCARD_WITH_TYPE	4	/* add a new card, with cardtype */
+#define AVMB1_GET_CARDINFO	5	/* get cardtype */
+#define AVMB1_REMOVECARD	6	/* remove a card - OBSOLETE */
+
+#define	AVMB1_REGISTERCARD_IS_OBSOLETE
+
+#endif				/* _B1LLI_H_ */
diff -uNr linux-2.6.32/usr/include/linux/baycom.h clean_modified/linux-2.6.32/usr/include/linux/baycom.h
--- linux-2.6.32/usr/include/linux/baycom.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/baycom.h	2019-04-14 13:24:02.914882147 -0500
@@ -0,0 +1,39 @@
+/*
+ * The Linux BAYCOM driver for the Baycom serial 1200 baud modem
+ * and the parallel 9600 baud modem
+ * (C) 1997-1998 by Thomas Sailer, HB9JNX/AE4WA
+ */
+
+#ifndef _BAYCOM_H
+#define _BAYCOM_H
+
+/* -------------------------------------------------------------------- */
+/*
+ * structs for the IOCTL commands
+ */
+
+struct baycom_debug_data {
+	unsigned long debug1;
+	unsigned long debug2;
+	long debug3;
+};
+
+struct baycom_ioctl {
+	int cmd;
+	union {
+		struct baycom_debug_data dbg;
+	} data;
+};
+
+/* -------------------------------------------------------------------- */
+
+/*
+ * ioctl values change for baycom
+ */
+#define BAYCOMCTL_GETDEBUG       0x92
+
+/* -------------------------------------------------------------------- */
+
+#endif /* _BAYCOM_H */
+
+/* --------------------------------------------------------------------- */
diff -uNr linux-2.6.32/usr/include/linux/bfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/bfs_fs.h
--- linux-2.6.32/usr/include/linux/bfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/bfs_fs.h	2019-04-14 13:24:02.914882147 -0500
@@ -0,0 +1,81 @@
+/*
+ *	include/linux/bfs_fs.h - BFS data structures on disk.
+ *	Copyright (C) 1999 Tigran Aivazian <tigran@veritas.com>
+ */
+
+#ifndef _LINUX_BFS_FS_H
+#define _LINUX_BFS_FS_H
+
+#include <linux/types.h>
+
+#define BFS_BSIZE_BITS		9
+#define BFS_BSIZE		(1<<BFS_BSIZE_BITS)
+
+#define BFS_MAGIC		0x1BADFACE
+#define BFS_ROOT_INO		2
+#define BFS_INODES_PER_BLOCK	8
+
+/* SVR4 vnode type values (bfs_inode->i_vtype) */
+#define BFS_VDIR 2L
+#define BFS_VREG 1L
+
+/* BFS inode layout on disk */
+struct bfs_inode {
+	__le16 i_ino;
+	__u16 i_unused;
+	__le32 i_sblock;
+	__le32 i_eblock;
+	__le32 i_eoffset;
+	__le32 i_vtype;
+	__le32 i_mode;
+	__le32 i_uid;
+	__le32 i_gid;
+	__le32 i_nlink;
+	__le32 i_atime;
+	__le32 i_mtime;
+	__le32 i_ctime;
+	__u32 i_padding[4];
+};
+
+#define BFS_NAMELEN		14	
+#define BFS_DIRENT_SIZE		16
+#define BFS_DIRS_PER_BLOCK	32
+
+struct bfs_dirent {
+	__le16 ino;
+	char name[BFS_NAMELEN];
+};
+
+/* BFS superblock layout on disk */
+struct bfs_super_block {
+	__le32 s_magic;
+	__le32 s_start;
+	__le32 s_end;
+	__le32 s_from;
+	__le32 s_to;
+	__s32 s_bfrom;
+	__s32 s_bto;
+	char  s_fsname[6];
+	char  s_volume[6];
+	__u32 s_padding[118];
+};
+
+
+#define BFS_OFF2INO(offset) \
+        ((((offset) - BFS_BSIZE) / sizeof(struct bfs_inode)) + BFS_ROOT_INO)
+
+#define BFS_INO2OFF(ino) \
+	((__u32)(((ino) - BFS_ROOT_INO) * sizeof(struct bfs_inode)) + BFS_BSIZE)
+#define BFS_NZFILESIZE(ip) \
+        ((le32_to_cpu((ip)->i_eoffset) + 1) -  le32_to_cpu((ip)->i_sblock) * BFS_BSIZE)
+
+#define BFS_FILESIZE(ip) \
+        ((ip)->i_sblock == 0 ? 0 : BFS_NZFILESIZE(ip))
+
+#define BFS_FILEBLOCKS(ip) \
+        ((ip)->i_sblock == 0 ? 0 : (le32_to_cpu((ip)->i_eblock) + 1) -  le32_to_cpu((ip)->i_sblock))
+#define BFS_UNCLEAN(bfs_sb, sb)	\
+	((le32_to_cpu(bfs_sb->s_from) != -1) && (le32_to_cpu(bfs_sb->s_to) != -1) && !(sb->s_flags & MS_RDONLY))
+
+
+#endif	/* _LINUX_BFS_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/binfmts.h clean_modified/linux-2.6.32/usr/include/linux/binfmts.h
--- linux-2.6.32/usr/include/linux/binfmts.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/binfmts.h	2019-04-14 13:24:02.914882147 -0500
@@ -0,0 +1,20 @@
+#ifndef _LINUX_BINFMTS_H
+#define _LINUX_BINFMTS_H
+
+#include <linux/capability.h>
+
+struct pt_regs;
+
+/*
+ * These are the maximum length and maximum number of strings passed to the
+ * execve() system call.  MAX_ARG_STRLEN is essentially random but serves to
+ * prevent the kernel from being unduly impacted by misaddressed pointers.
+ * MAX_ARG_STRINGS is chosen to fit in a signed 32-bit integer.
+ */
+#define MAX_ARG_STRLEN (PAGE_SIZE * 32)
+#define MAX_ARG_STRINGS 0x7FFFFFFF
+
+/* sizeof(linux_binprm->buf) */
+#define BINPRM_BUF_SIZE 128
+
+#endif /* _LINUX_BINFMTS_H */
diff -uNr linux-2.6.32/usr/include/linux/blkpg.h clean_modified/linux-2.6.32/usr/include/linux/blkpg.h
--- linux-2.6.32/usr/include/linux/blkpg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/blkpg.h	2019-04-14 13:24:02.914882147 -0500
@@ -0,0 +1,58 @@
+#ifndef _LINUX_BLKPG_H
+#define _LINUX_BLKPG_H
+
+/*
+ * Partition table and disk geometry handling
+ *
+ * A single ioctl with lots of subfunctions:
+ *
+ * Device number stuff:
+ *    get_whole_disk()		(given the device number of a partition,
+ *                               find the device number of the encompassing disk)
+ *    get_all_partitions()	(given the device number of a disk, return the
+ *				 device numbers of all its known partitions)
+ *
+ * Partition stuff:
+ *    add_partition()
+ *    delete_partition()
+ *    test_partition_in_use()	(also for test_disk_in_use)
+ *
+ * Geometry stuff:
+ *    get_geometry()
+ *    set_geometry()
+ *    get_bios_drivedata()
+ *
+ * For today, only the partition stuff - aeb, 990515
+ */
+
+#include <linux/ioctl.h>
+
+#define BLKPG      _IO(0x12,105)
+
+/* The argument structure */
+struct blkpg_ioctl_arg {
+        int op;
+        int flags;
+        int datalen;
+        void *data;
+};
+
+/* The subfunctions (for the op field) */
+#define BLKPG_ADD_PARTITION	1
+#define BLKPG_DEL_PARTITION	2
+
+/* Sizes of name fields. Unused at present. */
+#define BLKPG_DEVNAMELTH	64
+#define BLKPG_VOLNAMELTH	64
+
+/* The data structure for ADD_PARTITION and DEL_PARTITION */
+struct blkpg_partition {
+	long long start;		/* starting offset in bytes */
+	long long length;		/* length in bytes */
+	int pno;			/* partition number */
+	char devname[BLKPG_DEVNAMELTH];	/* partition name, like sda5 or c0d1p2,
+					   to be used in kernel messages */
+	char volname[BLKPG_VOLNAMELTH];	/* volume label */
+};
+
+#endif /* _LINUX_BLKPG_H */
diff -uNr linux-2.6.32/usr/include/linux/blktrace_api.h clean_modified/linux-2.6.32/usr/include/linux/blktrace_api.h
--- linux-2.6.32/usr/include/linux/blktrace_api.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/blktrace_api.h	2019-04-14 13:24:02.915871386 -0500
@@ -0,0 +1,141 @@
+#ifndef BLKTRACE_H
+#define BLKTRACE_H
+
+#include <linux/types.h>
+
+/*
+ * Trace categories
+ */
+enum blktrace_cat {
+	BLK_TC_READ	= 1 << 0,	/* reads */
+	BLK_TC_WRITE	= 1 << 1,	/* writes */
+	BLK_TC_BARRIER	= 1 << 2,	/* barrier */
+	BLK_TC_SYNC	= 1 << 3,	/* sync IO */
+	BLK_TC_SYNCIO	= BLK_TC_SYNC,
+	BLK_TC_QUEUE	= 1 << 4,	/* queueing/merging */
+	BLK_TC_REQUEUE	= 1 << 5,	/* requeueing */
+	BLK_TC_ISSUE	= 1 << 6,	/* issue */
+	BLK_TC_COMPLETE	= 1 << 7,	/* completions */
+	BLK_TC_FS	= 1 << 8,	/* fs requests */
+	BLK_TC_PC	= 1 << 9,	/* pc requests */
+	BLK_TC_NOTIFY	= 1 << 10,	/* special message */
+	BLK_TC_AHEAD	= 1 << 11,	/* readahead */
+	BLK_TC_META	= 1 << 12,	/* metadata */
+	BLK_TC_DISCARD	= 1 << 13,	/* discard requests */
+	BLK_TC_DRV_DATA	= 1 << 14,	/* binary per-driver data */
+
+	BLK_TC_END	= 1 << 15,	/* only 16-bits, reminder */
+};
+
+#define BLK_TC_SHIFT		(16)
+#define BLK_TC_ACT(act)		((act) << BLK_TC_SHIFT)
+
+/*
+ * Basic trace actions
+ */
+enum blktrace_act {
+	__BLK_TA_QUEUE = 1,		/* queued */
+	__BLK_TA_BACKMERGE,		/* back merged to existing rq */
+	__BLK_TA_FRONTMERGE,		/* front merge to existing rq */
+	__BLK_TA_GETRQ,			/* allocated new request */
+	__BLK_TA_SLEEPRQ,		/* sleeping on rq allocation */
+	__BLK_TA_REQUEUE,		/* request requeued */
+	__BLK_TA_ISSUE,			/* sent to driver */
+	__BLK_TA_COMPLETE,		/* completed by driver */
+	__BLK_TA_PLUG,			/* queue was plugged */
+	__BLK_TA_UNPLUG_IO,		/* queue was unplugged by io */
+	__BLK_TA_UNPLUG_TIMER,		/* queue was unplugged by timer */
+	__BLK_TA_INSERT,		/* insert request */
+	__BLK_TA_SPLIT,			/* bio was split */
+	__BLK_TA_BOUNCE,		/* bio was bounced */
+	__BLK_TA_REMAP,			/* bio was remapped */
+	__BLK_TA_ABORT,			/* request aborted */
+	__BLK_TA_DRV_DATA,		/* driver-specific binary data */
+};
+
+/*
+ * Notify events.
+ */
+enum blktrace_notify {
+	__BLK_TN_PROCESS = 0,		/* establish pid/name mapping */
+	__BLK_TN_TIMESTAMP,		/* include system clock */
+	__BLK_TN_MESSAGE,		/* Character string message */
+};
+
+
+/*
+ * Trace actions in full. Additionally, read or write is masked
+ */
+#define BLK_TA_QUEUE		(__BLK_TA_QUEUE | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_BACKMERGE	(__BLK_TA_BACKMERGE | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_FRONTMERGE	(__BLK_TA_FRONTMERGE | BLK_TC_ACT(BLK_TC_QUEUE))
+#define	BLK_TA_GETRQ		(__BLK_TA_GETRQ | BLK_TC_ACT(BLK_TC_QUEUE))
+#define	BLK_TA_SLEEPRQ		(__BLK_TA_SLEEPRQ | BLK_TC_ACT(BLK_TC_QUEUE))
+#define	BLK_TA_REQUEUE		(__BLK_TA_REQUEUE | BLK_TC_ACT(BLK_TC_REQUEUE))
+#define BLK_TA_ISSUE		(__BLK_TA_ISSUE | BLK_TC_ACT(BLK_TC_ISSUE))
+#define BLK_TA_COMPLETE		(__BLK_TA_COMPLETE| BLK_TC_ACT(BLK_TC_COMPLETE))
+#define BLK_TA_PLUG		(__BLK_TA_PLUG | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_UNPLUG_IO	(__BLK_TA_UNPLUG_IO | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_UNPLUG_TIMER	(__BLK_TA_UNPLUG_TIMER | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_INSERT		(__BLK_TA_INSERT | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_SPLIT		(__BLK_TA_SPLIT)
+#define BLK_TA_BOUNCE		(__BLK_TA_BOUNCE)
+#define BLK_TA_REMAP		(__BLK_TA_REMAP | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_ABORT		(__BLK_TA_ABORT | BLK_TC_ACT(BLK_TC_QUEUE))
+#define BLK_TA_DRV_DATA	(__BLK_TA_DRV_DATA | BLK_TC_ACT(BLK_TC_DRV_DATA))
+
+#define BLK_TN_PROCESS		(__BLK_TN_PROCESS | BLK_TC_ACT(BLK_TC_NOTIFY))
+#define BLK_TN_TIMESTAMP	(__BLK_TN_TIMESTAMP | BLK_TC_ACT(BLK_TC_NOTIFY))
+#define BLK_TN_MESSAGE		(__BLK_TN_MESSAGE | BLK_TC_ACT(BLK_TC_NOTIFY))
+
+#define BLK_IO_TRACE_MAGIC	0x65617400
+#define BLK_IO_TRACE_VERSION	0x07
+
+/*
+ * The trace itself
+ */
+struct blk_io_trace {
+	__u32 magic;		/* MAGIC << 8 | version */
+	__u32 sequence;		/* event number */
+	__u64 time;		/* in microseconds */
+	__u64 sector;		/* disk offset */
+	__u32 bytes;		/* transfer length */
+	__u32 action;		/* what happened */
+	__u32 pid;		/* who did it */
+	__u32 device;		/* device number */
+	__u32 cpu;		/* on what cpu did it happen */
+	__u16 error;		/* completion error */
+	__u16 pdu_len;		/* length of data after this trace */
+};
+
+/*
+ * The remap event
+ */
+struct blk_io_trace_remap {
+	__be32 device_from;
+	__be32 device_to;
+	__be64 sector_from;
+};
+
+enum {
+	Blktrace_setup = 1,
+	Blktrace_running,
+	Blktrace_stopped,
+};
+
+#define BLKTRACE_BDEV_SIZE	32
+
+/*
+ * User setup structure passed with BLKTRACESTART
+ */
+struct blk_user_trace_setup {
+	char name[BLKTRACE_BDEV_SIZE];	/* output */
+	__u16 act_mask;			/* input */
+	__u32 buf_size;			/* input */
+	__u32 buf_nr;			/* input */
+	__u64 start_lba;
+	__u64 end_lba;
+	__u32 pid;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/bpqether.h clean_modified/linux-2.6.32/usr/include/linux/bpqether.h
--- linux-2.6.32/usr/include/linux/bpqether.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/bpqether.h	2019-04-14 13:24:02.915871386 -0500
@@ -0,0 +1,41 @@
+#ifndef	__BPQETHER_H
+#define	__BPQETHER_H
+
+/*
+ * 	Defines for the BPQETHER pseudo device driver
+ */
+
+#ifndef __LINUX_IF_ETHER_H
+#include <linux/if_ether.h>
+#endif
+
+#define SIOCSBPQETHOPT		(SIOCDEVPRIVATE+0)	/* reserved */
+#define SIOCSBPQETHADDR		(SIOCDEVPRIVATE+1)
+ 
+struct bpq_ethaddr {
+	unsigned char destination[ETH_ALEN];
+	unsigned char accept[ETH_ALEN];
+};
+
+/* 
+ * For SIOCSBPQETHOPT - this is compatible with PI2/PacketTwin card drivers,
+ * currently not implemented, though. If someone wants to hook a radio
+ * to his Ethernet card he may find this useful. ;-)
+ */
+
+#define SIOCGBPQETHPARAM	0x5000  /* get Level 1 parameters */
+#define SIOCSBPQETHPARAM	0x5001  /* set */
+
+struct bpq_req  {
+    int cmd;
+    int speed;			/* unused */
+    int clockmode;		/* unused */
+    int txdelay;
+    unsigned char persist;	/* unused */
+    int slotime;		/* unused */
+    int squeldelay;
+    int dmachan;		/* unused */
+    int irq;			/* unused */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/bsg.h clean_modified/linux-2.6.32/usr/include/linux/bsg.h
--- linux-2.6.32/usr/include/linux/bsg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/bsg.h	2019-04-14 13:24:02.915871386 -0500
@@ -0,0 +1,65 @@
+#ifndef BSG_H
+#define BSG_H
+
+#include <linux/types.h>
+
+#define BSG_PROTOCOL_SCSI		0
+
+#define BSG_SUB_PROTOCOL_SCSI_CMD	0
+#define BSG_SUB_PROTOCOL_SCSI_TMF	1
+#define BSG_SUB_PROTOCOL_SCSI_TRANSPORT	2
+
+/*
+ * For flags member below
+ * sg.h sg_io_hdr also has bits defined for it's flags member. However
+ * none of these bits are implemented/used by bsg. The bits below are
+ * allocated to not conflict with sg.h ones anyway.
+ */
+#define BSG_FLAG_Q_AT_TAIL 0x10 /* default, == 0 at this bit, is Q_AT_HEAD */
+
+struct sg_io_v4 {
+	__s32 guard;		/* [i] 'Q' to differentiate from v3 */
+	__u32 protocol;		/* [i] 0 -> SCSI , .... */
+	__u32 subprotocol;	/* [i] 0 -> SCSI command, 1 -> SCSI task
+				   management function, .... */
+
+	__u32 request_len;	/* [i] in bytes */
+	__u64 request;		/* [i], [*i] {SCSI: cdb} */
+	__u64 request_tag;	/* [i] {SCSI: task tag (only if flagged)} */
+	__u32 request_attr;	/* [i] {SCSI: task attribute} */
+	__u32 request_priority;	/* [i] {SCSI: task priority} */
+	__u32 request_extra;	/* [i] {spare, for padding} */
+	__u32 max_response_len;	/* [i] in bytes */
+	__u64 response;		/* [i], [*o] {SCSI: (auto)sense data} */
+
+        /* "dout_": data out (to device); "din_": data in (from device) */
+	__u32 dout_iovec_count;	/* [i] 0 -> "flat" dout transfer else
+				   dout_xfer points to array of iovec */
+	__u32 dout_xfer_len;	/* [i] bytes to be transferred to device */
+	__u32 din_iovec_count;	/* [i] 0 -> "flat" din transfer */
+	__u32 din_xfer_len;	/* [i] bytes to be transferred from device */
+	__u64 dout_xferp;	/* [i], [*i] */
+	__u64 din_xferp;	/* [i], [*o] */
+
+	__u32 timeout;		/* [i] units: millisecond */
+	__u32 flags;		/* [i] bit mask */
+	__u64 usr_ptr;		/* [i->o] unused internally */
+	__u32 spare_in;		/* [i] */
+
+	__u32 driver_status;	/* [o] 0 -> ok */
+	__u32 transport_status;	/* [o] 0 -> ok */
+	__u32 device_status;	/* [o] {SCSI: command completion status} */
+	__u32 retry_delay;	/* [o] {SCSI: status auxiliary information} */
+	__u32 info;		/* [o] additional information */
+	__u32 duration;		/* [o] time to complete, in milliseconds */
+	__u32 response_len;	/* [o] bytes of response actually written */
+	__s32 din_resid;	/* [o] din_xfer_len - actual_din_xfer_len */
+	__s32 dout_resid;	/* [o] dout_xfer_len - actual_dout_xfer_len */
+	__u64 generated_tag;	/* [o] {SCSI: transport generated task tag} */
+	__u32 spare_out;	/* [o] */
+
+	__u32 padding;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/byteorder/big_endian.h clean_modified/linux-2.6.32/usr/include/linux/byteorder/big_endian.h
--- linux-2.6.32/usr/include/linux/byteorder/big_endian.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/byteorder/big_endian.h	2019-04-14 13:24:02.916836686 -0500
@@ -0,0 +1,105 @@
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include <linux/types.h>
+#include <linux/swab.h>
+
+#define __constant_htonl(x) ((__be32)(__u32)(x))
+#define __constant_ntohl(x) ((__u32)(__be32)(x))
+#define __constant_htons(x) ((__be16)(__u16)(x))
+#define __constant_ntohs(x) ((__u16)(__be16)(x))
+#define __constant_cpu_to_le64(x) ((__le64)___constant_swab64((x)))
+#define __constant_le64_to_cpu(x) ___constant_swab64((__u64)(__le64)(x))
+#define __constant_cpu_to_le32(x) ((__le32)___constant_swab32((x)))
+#define __constant_le32_to_cpu(x) ___constant_swab32((__u32)(__le32)(x))
+#define __constant_cpu_to_le16(x) ((__le16)___constant_swab16((x)))
+#define __constant_le16_to_cpu(x) ___constant_swab16((__u16)(__le16)(x))
+#define __constant_cpu_to_be64(x) ((__be64)(__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(__be64)(x))
+#define __constant_cpu_to_be32(x) ((__be32)(__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(__be32)(x))
+#define __constant_cpu_to_be16(x) ((__be16)(__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(__be16)(x))
+#define __cpu_to_le64(x) ((__le64)__swab64((x)))
+#define __le64_to_cpu(x) __swab64((__u64)(__le64)(x))
+#define __cpu_to_le32(x) ((__le32)__swab32((x)))
+#define __le32_to_cpu(x) __swab32((__u32)(__le32)(x))
+#define __cpu_to_le16(x) ((__le16)__swab16((x)))
+#define __le16_to_cpu(x) __swab16((__u16)(__le16)(x))
+#define __cpu_to_be64(x) ((__be64)(__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(__be64)(x))
+#define __cpu_to_be32(x) ((__be32)(__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(__be32)(x))
+#define __cpu_to_be16(x) ((__be16)(__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(__be16)(x))
+
+static __inline__ __le64 __cpu_to_le64p(const __u64 *p)
+{
+	return (__le64)__swab64p(p);
+}
+static __inline__ __u64 __le64_to_cpup(const __le64 *p)
+{
+	return __swab64p((__u64 *)p);
+}
+static __inline__ __le32 __cpu_to_le32p(const __u32 *p)
+{
+	return (__le32)__swab32p(p);
+}
+static __inline__ __u32 __le32_to_cpup(const __le32 *p)
+{
+	return __swab32p((__u32 *)p);
+}
+static __inline__ __le16 __cpu_to_le16p(const __u16 *p)
+{
+	return (__le16)__swab16p(p);
+}
+static __inline__ __u16 __le16_to_cpup(const __le16 *p)
+{
+	return __swab16p((__u16 *)p);
+}
+static __inline__ __be64 __cpu_to_be64p(const __u64 *p)
+{
+	return (__be64)*p;
+}
+static __inline__ __u64 __be64_to_cpup(const __be64 *p)
+{
+	return (__u64)*p;
+}
+static __inline__ __be32 __cpu_to_be32p(const __u32 *p)
+{
+	return (__be32)*p;
+}
+static __inline__ __u32 __be32_to_cpup(const __be32 *p)
+{
+	return (__u32)*p;
+}
+static __inline__ __be16 __cpu_to_be16p(const __u16 *p)
+{
+	return (__be16)*p;
+}
+static __inline__ __u16 __be16_to_cpup(const __be16 *p)
+{
+	return (__u16)*p;
+}
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do { (void)(x); } while (0)
+#define __be64_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_be32s(x) do { (void)(x); } while (0)
+#define __be32_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_be16s(x) do { (void)(x); } while (0)
+#define __be16_to_cpus(x) do { (void)(x); } while (0)
+
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
diff -uNr linux-2.6.32/usr/include/linux/byteorder/little_endian.h clean_modified/linux-2.6.32/usr/include/linux/byteorder/little_endian.h
--- linux-2.6.32/usr/include/linux/byteorder/little_endian.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/byteorder/little_endian.h	2019-04-14 13:24:02.923904620 -0500
@@ -0,0 +1,105 @@
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include <linux/types.h>
+#include <linux/swab.h>
+
+#define __constant_htonl(x) ((__be32)___constant_swab32((x)))
+#define __constant_ntohl(x) ___constant_swab32((__be32)(x))
+#define __constant_htons(x) ((__be16)___constant_swab16((x)))
+#define __constant_ntohs(x) ___constant_swab16((__be16)(x))
+#define __constant_cpu_to_le64(x) ((__le64)(__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(__le64)(x))
+#define __constant_cpu_to_le32(x) ((__le32)(__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(__le32)(x))
+#define __constant_cpu_to_le16(x) ((__le16)(__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(__le16)(x))
+#define __constant_cpu_to_be64(x) ((__be64)___constant_swab64((x)))
+#define __constant_be64_to_cpu(x) ___constant_swab64((__u64)(__be64)(x))
+#define __constant_cpu_to_be32(x) ((__be32)___constant_swab32((x)))
+#define __constant_be32_to_cpu(x) ___constant_swab32((__u32)(__be32)(x))
+#define __constant_cpu_to_be16(x) ((__be16)___constant_swab16((x)))
+#define __constant_be16_to_cpu(x) ___constant_swab16((__u16)(__be16)(x))
+#define __cpu_to_le64(x) ((__le64)(__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(__le64)(x))
+#define __cpu_to_le32(x) ((__le32)(__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(__le32)(x))
+#define __cpu_to_le16(x) ((__le16)(__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(__le16)(x))
+#define __cpu_to_be64(x) ((__be64)__swab64((x)))
+#define __be64_to_cpu(x) __swab64((__u64)(__be64)(x))
+#define __cpu_to_be32(x) ((__be32)__swab32((x)))
+#define __be32_to_cpu(x) __swab32((__u32)(__be32)(x))
+#define __cpu_to_be16(x) ((__be16)__swab16((x)))
+#define __be16_to_cpu(x) __swab16((__u16)(__be16)(x))
+
+static __inline__ __le64 __cpu_to_le64p(const __u64 *p)
+{
+	return (__le64)*p;
+}
+static __inline__ __u64 __le64_to_cpup(const __le64 *p)
+{
+	return (__u64)*p;
+}
+static __inline__ __le32 __cpu_to_le32p(const __u32 *p)
+{
+	return (__le32)*p;
+}
+static __inline__ __u32 __le32_to_cpup(const __le32 *p)
+{
+	return (__u32)*p;
+}
+static __inline__ __le16 __cpu_to_le16p(const __u16 *p)
+{
+	return (__le16)*p;
+}
+static __inline__ __u16 __le16_to_cpup(const __le16 *p)
+{
+	return (__u16)*p;
+}
+static __inline__ __be64 __cpu_to_be64p(const __u64 *p)
+{
+	return (__be64)__swab64p(p);
+}
+static __inline__ __u64 __be64_to_cpup(const __be64 *p)
+{
+	return __swab64p((__u64 *)p);
+}
+static __inline__ __be32 __cpu_to_be32p(const __u32 *p)
+{
+	return (__be32)__swab32p(p);
+}
+static __inline__ __u32 __be32_to_cpup(const __be32 *p)
+{
+	return __swab32p((__u32 *)p);
+}
+static __inline__ __be16 __cpu_to_be16p(const __u16 *p)
+{
+	return (__be16)__swab16p(p);
+}
+static __inline__ __u16 __be16_to_cpup(const __be16 *p)
+{
+	return __swab16p((__u16 *)p);
+}
+#define __cpu_to_le64s(x) do { (void)(x); } while (0)
+#define __le64_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_le32s(x) do { (void)(x); } while (0)
+#define __le32_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_le16s(x) do { (void)(x); } while (0)
+#define __le16_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
diff -uNr linux-2.6.32/usr/include/linux/can/bcm.h clean_modified/linux-2.6.32/usr/include/linux/can/bcm.h
--- linux-2.6.32/usr/include/linux/can/bcm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/can/bcm.h	2019-04-14 13:24:02.925637914 -0500
@@ -0,0 +1,67 @@
+/*
+ * linux/can/bcm.h
+ *
+ * Definitions for CAN Broadcast Manager (BCM)
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_BCM_H
+#define CAN_BCM_H
+
+#include <linux/types.h>
+
+/**
+ * struct bcm_msg_head - head of messages to/from the broadcast manager
+ * @opcode:    opcode, see enum below.
+ * @flags:     special flags, see below.
+ * @count:     number of frames to send before changing interval.
+ * @ival1:     interval for the first @count frames.
+ * @ival2:     interval for the following frames.
+ * @can_id:    CAN ID of frames to be sent or received.
+ * @nframes:   number of frames appended to the message head.
+ * @frames:    array of CAN frames.
+ */
+struct bcm_msg_head {
+	__u32 opcode;
+	__u32 flags;
+	__u32 count;
+	struct timeval ival1, ival2;
+	canid_t can_id;
+	__u32 nframes;
+	struct can_frame frames[0];
+};
+
+enum {
+	TX_SETUP = 1,	/* create (cyclic) transmission task */
+	TX_DELETE,	/* remove (cyclic) transmission task */
+	TX_READ,	/* read properties of (cyclic) transmission task */
+	TX_SEND,	/* send one CAN frame */
+	RX_SETUP,	/* create RX content filter subscription */
+	RX_DELETE,	/* remove RX content filter subscription */
+	RX_READ,	/* read properties of RX content filter subscription */
+	TX_STATUS,	/* reply to TX_READ request */
+	TX_EXPIRED,	/* notification on performed transmissions (count=0) */
+	RX_STATUS,	/* reply to RX_READ request */
+	RX_TIMEOUT,	/* cyclic message is absent */
+	RX_CHANGED	/* updated CAN frame (detected content change) */
+};
+
+#define SETTIMER            0x0001
+#define STARTTIMER          0x0002
+#define TX_COUNTEVT         0x0004
+#define TX_ANNOUNCE         0x0008
+#define TX_CP_CAN_ID        0x0010
+#define RX_FILTER_ID        0x0020
+#define RX_CHECK_DLC        0x0040
+#define RX_NO_AUTOTIMER     0x0080
+#define RX_ANNOUNCE_RESUME  0x0100
+#define TX_RESET_MULTI_IDX  0x0200
+#define RX_RTR_FRAME        0x0400
+
+#endif /* CAN_BCM_H */
diff -uNr linux-2.6.32/usr/include/linux/can/error.h clean_modified/linux-2.6.32/usr/include/linux/can/error.h
--- linux-2.6.32/usr/include/linux/can/error.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/can/error.h	2019-04-14 13:24:02.925637914 -0500
@@ -0,0 +1,93 @@
+/*
+ * linux/can/error.h
+ *
+ * Definitions of the CAN error frame to be filtered and passed to the user.
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_ERROR_H
+#define CAN_ERROR_H
+
+#define CAN_ERR_DLC 8 /* dlc for error frames */
+
+/* error class (mask) in can_id */
+#define CAN_ERR_TX_TIMEOUT   0x00000001U /* TX timeout (by netdevice driver) */
+#define CAN_ERR_LOSTARB      0x00000002U /* lost arbitration    / data[0]    */
+#define CAN_ERR_CRTL         0x00000004U /* controller problems / data[1]    */
+#define CAN_ERR_PROT         0x00000008U /* protocol violations / data[2..3] */
+#define CAN_ERR_TRX          0x00000010U /* transceiver status  / data[4]    */
+#define CAN_ERR_ACK          0x00000020U /* received no ACK on transmission */
+#define CAN_ERR_BUSOFF       0x00000040U /* bus off */
+#define CAN_ERR_BUSERROR     0x00000080U /* bus error (may flood!) */
+#define CAN_ERR_RESTARTED    0x00000100U /* controller restarted */
+
+/* arbitration lost in bit ... / data[0] */
+#define CAN_ERR_LOSTARB_UNSPEC   0x00 /* unspecified */
+				      /* else bit number in bitstream */
+
+/* error status of CAN-controller / data[1] */
+#define CAN_ERR_CRTL_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_CRTL_RX_OVERFLOW 0x01 /* RX buffer overflow */
+#define CAN_ERR_CRTL_TX_OVERFLOW 0x02 /* TX buffer overflow */
+#define CAN_ERR_CRTL_RX_WARNING  0x04 /* reached warning level for RX errors */
+#define CAN_ERR_CRTL_TX_WARNING  0x08 /* reached warning level for TX errors */
+#define CAN_ERR_CRTL_RX_PASSIVE  0x10 /* reached error passive status RX */
+#define CAN_ERR_CRTL_TX_PASSIVE  0x20 /* reached error passive status TX */
+				      /* (at least one error counter exceeds */
+				      /* the protocol-defined level of 127)  */
+
+/* error in CAN protocol (type) / data[2] */
+#define CAN_ERR_PROT_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_PROT_BIT         0x01 /* single bit error */
+#define CAN_ERR_PROT_FORM        0x02 /* frame format error */
+#define CAN_ERR_PROT_STUFF       0x04 /* bit stuffing error */
+#define CAN_ERR_PROT_BIT0        0x08 /* unable to send dominant bit */
+#define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
+#define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
+#define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
+#define CAN_ERR_PROT_TX          0x80 /* error occured on transmission */
+
+/* error in CAN protocol (location) / data[3] */
+#define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
+#define CAN_ERR_PROT_LOC_SOF     0x03 /* start of frame */
+#define CAN_ERR_PROT_LOC_ID28_21 0x02 /* ID bits 28 - 21 (SFF: 10 - 3) */
+#define CAN_ERR_PROT_LOC_ID20_18 0x06 /* ID bits 20 - 18 (SFF: 2 - 0 )*/
+#define CAN_ERR_PROT_LOC_SRTR    0x04 /* substitute RTR (SFF: RTR) */
+#define CAN_ERR_PROT_LOC_IDE     0x05 /* identifier extension */
+#define CAN_ERR_PROT_LOC_ID17_13 0x07 /* ID bits 17-13 */
+#define CAN_ERR_PROT_LOC_ID12_05 0x0F /* ID bits 12-5 */
+#define CAN_ERR_PROT_LOC_ID04_00 0x0E /* ID bits 4-0 */
+#define CAN_ERR_PROT_LOC_RTR     0x0C /* RTR */
+#define CAN_ERR_PROT_LOC_RES1    0x0D /* reserved bit 1 */
+#define CAN_ERR_PROT_LOC_RES0    0x09 /* reserved bit 0 */
+#define CAN_ERR_PROT_LOC_DLC     0x0B /* data length code */
+#define CAN_ERR_PROT_LOC_DATA    0x0A /* data section */
+#define CAN_ERR_PROT_LOC_CRC_SEQ 0x08 /* CRC sequence */
+#define CAN_ERR_PROT_LOC_CRC_DEL 0x18 /* CRC delimiter */
+#define CAN_ERR_PROT_LOC_ACK     0x19 /* ACK slot */
+#define CAN_ERR_PROT_LOC_ACK_DEL 0x1B /* ACK delimiter */
+#define CAN_ERR_PROT_LOC_EOF     0x1A /* end of frame */
+#define CAN_ERR_PROT_LOC_INTERM  0x12 /* intermission */
+
+/* error status of CAN-transceiver / data[4] */
+/*                                             CANH CANL */
+#define CAN_ERR_TRX_UNSPEC             0x00 /* 0000 0000 */
+#define CAN_ERR_TRX_CANH_NO_WIRE       0x04 /* 0000 0100 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_BAT  0x05 /* 0000 0101 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_VCC  0x06 /* 0000 0110 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_GND  0x07 /* 0000 0111 */
+#define CAN_ERR_TRX_CANL_NO_WIRE       0x40 /* 0100 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_BAT  0x50 /* 0101 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_VCC  0x60 /* 0110 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_GND  0x70 /* 0111 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_CANH 0x80 /* 1000 0000 */
+
+/* controller specific additional information / data[5..7] */
+
+#endif /* CAN_ERROR_H */
diff -uNr linux-2.6.32/usr/include/linux/can/netlink.h clean_modified/linux-2.6.32/usr/include/linux/can/netlink.h
--- linux-2.6.32/usr/include/linux/can/netlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/can/netlink.h	2019-04-14 13:24:02.926612618 -0500
@@ -0,0 +1,113 @@
+/*
+ * linux/can/netlink.h
+ *
+ * Definitions for the CAN netlink interface
+ *
+ * Copyright (c) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_NETLINK_H
+#define CAN_NETLINK_H
+
+#include <linux/types.h>
+
+/*
+ * CAN bit-timing parameters
+ *
+ * For futher information, please read chapter "8 BIT TIMING
+ * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
+ * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
+ */
+struct can_bittiming {
+	__u32 bitrate;		/* Bit-rate in bits/second */
+	__u32 sample_point;	/* Sample point in one-tenth of a percent */
+	__u32 tq;		/* Time quanta (TQ) in nanoseconds */
+	__u32 prop_seg;		/* Propagation segment in TQs */
+	__u32 phase_seg1;	/* Phase buffer segment 1 in TQs */
+	__u32 phase_seg2;	/* Phase buffer segment 2 in TQs */
+	__u32 sjw;		/* Synchronisation jump width in TQs */
+	__u32 brp;		/* Bit-rate prescaler */
+};
+
+/*
+ * CAN harware-dependent bit-timing constant
+ *
+ * Used for calculating and checking bit-timing parameters
+ */
+struct can_bittiming_const {
+	char name[16];		/* Name of the CAN controller hardware */
+	__u32 tseg1_min;	/* Time segement 1 = prop_seg + phase_seg1 */
+	__u32 tseg1_max;
+	__u32 tseg2_min;	/* Time segement 2 = phase_seg2 */
+	__u32 tseg2_max;
+	__u32 sjw_max;		/* Synchronisation jump width */
+	__u32 brp_min;		/* Bit-rate prescaler */
+	__u32 brp_max;
+	__u32 brp_inc;
+};
+
+/*
+ * CAN clock parameters
+ */
+struct can_clock {
+	__u32 freq;		/* CAN system clock frequency in Hz */
+};
+
+/*
+ * CAN operational and error states
+ */
+enum can_state {
+	CAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
+	CAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
+	CAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
+	CAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
+	CAN_STATE_STOPPED,		/* Device is stopped */
+	CAN_STATE_SLEEPING,		/* Device is sleeping */
+	CAN_STATE_MAX
+};
+
+/*
+ * CAN controller mode
+ */
+struct can_ctrlmode {
+	__u32 mask;
+	__u32 flags;
+};
+
+#define CAN_CTRLMODE_LOOPBACK	0x1	/* Loopback mode */
+#define CAN_CTRLMODE_LISTENONLY	0x2 	/* Listen-only mode */
+#define CAN_CTRLMODE_3_SAMPLES	0x4	/* Triple sampling mode */
+
+/*
+ * CAN device statistics
+ */
+struct can_device_stats {
+	__u32 bus_error;	/* Bus errors */
+	__u32 error_warning;	/* Changes to error warning state */
+	__u32 error_passive;	/* Changes to error passive state */
+	__u32 bus_off;		/* Changes to bus off state */
+	__u32 arbitration_lost; /* Arbitration lost errors */
+	__u32 restarts;		/* CAN controller re-starts */
+};
+
+/*
+ * CAN netlink interface
+ */
+enum {
+	IFLA_CAN_UNSPEC,
+	IFLA_CAN_BITTIMING,
+	IFLA_CAN_BITTIMING_CONST,
+	IFLA_CAN_CLOCK,
+	IFLA_CAN_STATE,
+	IFLA_CAN_CTRLMODE,
+	IFLA_CAN_RESTART_MS,
+	IFLA_CAN_RESTART,
+	__IFLA_CAN_MAX
+};
+
+#define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
+
+#endif /* CAN_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/can/raw.h clean_modified/linux-2.6.32/usr/include/linux/can/raw.h
--- linux-2.6.32/usr/include/linux/can/raw.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/can/raw.h	2019-04-14 13:24:02.926612618 -0500
@@ -0,0 +1,31 @@
+/*
+ * linux/can/raw.h
+ *
+ * Definitions for raw CAN sockets
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_RAW_H
+#define CAN_RAW_H
+
+#include <linux/can.h>
+
+#define SOL_CAN_RAW (SOL_CAN_BASE + CAN_RAW)
+
+/* for socket options affecting the socket (not the global system) */
+
+enum {
+	CAN_RAW_FILTER = 1,	/* set 0 .. n can_filter(s)          */
+	CAN_RAW_ERR_FILTER,	/* set filter for error frames       */
+	CAN_RAW_LOOPBACK,	/* local loopback (default:on)       */
+	CAN_RAW_RECV_OWN_MSGS	/* receive my own msgs (default:off) */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/can.h clean_modified/linux-2.6.32/usr/include/linux/can.h
--- linux-2.6.32/usr/include/linux/can.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/can.h	2019-04-14 13:24:02.926612618 -0500
@@ -0,0 +1,111 @@
+/*
+ * linux/can.h
+ *
+ * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_H
+#define CAN_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* controller area network (CAN) kernel definitions */
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/*
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28	: CAN identifier (11/29 bit)
+ * bit 29	: error frame flag (0 = data frame, 1 = error frame)
+ * bit 30	: remote transmission request flag (1 = rtr frame)
+ * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+typedef __u32 canid_t;
+
+/*
+ * Controller Area Network Error Frame Mask structure
+ *
+ * bit 0-28	: error class mask (see include/linux/can/error.h)
+ * bit 29-31	: set to zero
+ */
+typedef __u32 can_err_mask_t;
+
+/**
+ * struct can_frame - basic CAN frame structure
+ * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.
+ * @can_dlc: the data length field of the CAN frame
+ * @data:    the CAN frame payload.
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    can_dlc; /* data length code: 0 .. 8 */
+	__u8    data[8] __attribute__((aligned(8)));
+};
+
+/* particular protocols of the protocol family PF_CAN */
+#define CAN_RAW		1 /* RAW sockets */
+#define CAN_BCM		2 /* Broadcast Manager */
+#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
+#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
+#define CAN_MCNET	5 /* Bosch MCNet */
+#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
+#define CAN_NPROTO	7
+
+#define SOL_CAN_BASE 100
+
+/**
+ * struct sockaddr_can - the sockaddr structure for CAN sockets
+ * @can_family:  address family number AF_CAN.
+ * @can_ifindex: CAN network interface index.
+ * @can_addr:    protocol specific address information
+ */
+struct sockaddr_can {
+	sa_family_t can_family;
+	int         can_ifindex;
+	union {
+		/* transport protocol class address information (e.g. ISOTP) */
+		struct { canid_t rx_id, tx_id; } tp;
+
+		/* reserved for future CAN protocols address information */
+	} can_addr;
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
+
+#endif /* CAN_H */
diff -uNr linux-2.6.32/usr/include/linux/capability.h clean_modified/linux-2.6.32/usr/include/linux/capability.h
--- linux-2.6.32/usr/include/linux/capability.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/capability.h	2019-04-14 13:24:02.927591245 -0500
@@ -0,0 +1,347 @@
+/*
+ * This is <linux/capability.h>
+ *
+ * Andrew G. Morgan <morgan@kernel.org>
+ * Alexander Kjeldaas <astor@guardian.no>
+ * with help from Aleph1, Roland Buresund and Andrew Main.
+ *
+ * See here for the libcap library ("POSIX draft" compliance):
+ *
+ * ftp://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.6/
+ */
+
+#ifndef _LINUX_CAPABILITY_H
+#define _LINUX_CAPABILITY_H
+
+#include <linux/types.h>
+
+struct task_struct;
+
+/* User-level do most of the mapping between kernel and user
+   capabilities based on the version tag given by the kernel. The
+   kernel might be somewhat backwards compatible, but don't bet on
+   it. */
+
+/* Note, cap_t, is defined by POSIX (draft) to be an "opaque" pointer to
+   a set of three capability sets.  The transposition of 3*the
+   following structure to such a composite is better handled in a user
+   library since the draft standard requires the use of malloc/free
+   etc.. */
+
+#define _LINUX_CAPABILITY_VERSION_1  0x19980330
+#define _LINUX_CAPABILITY_U32S_1     1
+
+#define _LINUX_CAPABILITY_VERSION_2  0x20071026  /* deprecated - use v3 */
+#define _LINUX_CAPABILITY_U32S_2     2
+
+#define _LINUX_CAPABILITY_VERSION_3  0x20080522
+#define _LINUX_CAPABILITY_U32S_3     2
+
+typedef struct __user_cap_header_struct {
+	__u32 version;
+	int pid;
+} *cap_user_header_t;
+
+typedef struct __user_cap_data_struct {
+        __u32 effective;
+        __u32 permitted;
+        __u32 inheritable;
+} *cap_user_data_t;
+
+
+#define XATTR_CAPS_SUFFIX "capability"
+#define XATTR_NAME_CAPS XATTR_SECURITY_PREFIX XATTR_CAPS_SUFFIX
+
+#define VFS_CAP_REVISION_MASK	0xFF000000
+#define VFS_CAP_REVISION_SHIFT	24
+#define VFS_CAP_FLAGS_MASK	~VFS_CAP_REVISION_MASK
+#define VFS_CAP_FLAGS_EFFECTIVE	0x000001
+
+#define VFS_CAP_REVISION_1	0x01000000
+#define VFS_CAP_U32_1           1
+#define XATTR_CAPS_SZ_1         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_1))
+
+#define VFS_CAP_REVISION_2	0x02000000
+#define VFS_CAP_U32_2           2
+#define XATTR_CAPS_SZ_2         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))
+
+#define XATTR_CAPS_SZ           XATTR_CAPS_SZ_2
+#define VFS_CAP_U32             VFS_CAP_U32_2
+#define VFS_CAP_REVISION	VFS_CAP_REVISION_2
+
+struct vfs_cap_data {
+	__le32 magic_etc;            /* Little endian */
+	struct {
+		__le32 permitted;    /* Little endian */
+		__le32 inheritable;  /* Little endian */
+	} data[VFS_CAP_U32];
+};
+
+
+/*
+ * Backwardly compatible definition for source code - trapped in a
+ * 32-bit world. If you find you need this, please consider using
+ * libcap to untrap yourself...
+ */
+#define _LINUX_CAPABILITY_VERSION  _LINUX_CAPABILITY_VERSION_1
+#define _LINUX_CAPABILITY_U32S     _LINUX_CAPABILITY_U32S_1
+
+
+
+/**
+ ** POSIX-draft defined capabilities.
+ **/
+
+/* In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this
+   overrides the restriction of changing file ownership and group
+   ownership. */
+
+#define CAP_CHOWN            0
+
+/* Override all DAC access, including ACL execute access if
+   [_POSIX_ACL] is defined. Excluding DAC access covered by
+   CAP_LINUX_IMMUTABLE. */
+
+#define CAP_DAC_OVERRIDE     1
+
+/* Overrides all DAC restrictions regarding read and search on files
+   and directories, including ACL restrictions if [_POSIX_ACL] is
+   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */
+
+#define CAP_DAC_READ_SEARCH  2
+
+/* Overrides all restrictions about allowed operations on files, where
+   file owner ID must be equal to the user ID, except where CAP_FSETID
+   is applicable. It doesn't override MAC and DAC restrictions. */
+
+#define CAP_FOWNER           3
+
+/* Overrides the following restrictions that the effective user ID
+   shall match the file owner ID when setting the S_ISUID and S_ISGID
+   bits on that file; that the effective group ID (or one of the
+   supplementary group IDs) shall match the file owner ID when setting
+   the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
+   cleared on successful return from chown(2) (not implemented). */
+
+#define CAP_FSETID           4
+
+/* Overrides the restriction that the real or effective user ID of a
+   process sending a signal must match the real or effective user ID
+   of the process receiving the signal. */
+
+#define CAP_KILL             5
+
+/* Allows setgid(2) manipulation */
+/* Allows setgroups(2) */
+/* Allows forged gids on socket credentials passing. */
+
+#define CAP_SETGID           6
+
+/* Allows set*uid(2) manipulation (including fsuid). */
+/* Allows forged pids on socket credentials passing. */
+
+#define CAP_SETUID           7
+
+
+/**
+ ** Linux-specific capabilities
+ **/
+
+/* Without VFS support for capabilities:
+ *   Transfer any capability in your permitted set to any pid,
+ *   remove any capability in your permitted set from any pid
+ * With VFS support for capabilities (neither of above, but)
+ *   Add any capability from current's capability bounding set
+ *       to the current process' inheritable set
+ *   Allow taking bits out of capability bounding set
+ *   Allow modification of the securebits for a process
+ */
+
+#define CAP_SETPCAP          8
+
+/* Allow modification of S_IMMUTABLE and S_APPEND file attributes */
+
+#define CAP_LINUX_IMMUTABLE  9
+
+/* Allows binding to TCP/UDP sockets below 1024 */
+/* Allows binding to ATM VCIs below 32 */
+
+#define CAP_NET_BIND_SERVICE 10
+
+/* Allow broadcasting, listen to multicast */
+
+#define CAP_NET_BROADCAST    11
+
+/* Allow interface configuration */
+/* Allow administration of IP firewall, masquerading and accounting */
+/* Allow setting debug option on sockets */
+/* Allow modification of routing tables */
+/* Allow setting arbitrary process / process group ownership on
+   sockets */
+/* Allow binding to any address for transparent proxying */
+/* Allow setting TOS (type of service) */
+/* Allow setting promiscuous mode */
+/* Allow clearing driver statistics */
+/* Allow multicasting */
+/* Allow read/write of device-specific registers */
+/* Allow activation of ATM control sockets */
+
+#define CAP_NET_ADMIN        12
+
+/* Allow use of RAW sockets */
+/* Allow use of PACKET sockets */
+
+#define CAP_NET_RAW          13
+
+/* Allow locking of shared memory segments */
+/* Allow mlock and mlockall (which doesn't really have anything to do
+   with IPC) */
+
+#define CAP_IPC_LOCK         14
+
+/* Override IPC ownership checks */
+
+#define CAP_IPC_OWNER        15
+
+/* Insert and remove kernel modules - modify kernel without limit */
+#define CAP_SYS_MODULE       16
+
+/* Allow ioperm/iopl access */
+/* Allow sending USB messages to any device via /proc/bus/usb */
+
+#define CAP_SYS_RAWIO        17
+
+/* Allow use of chroot() */
+
+#define CAP_SYS_CHROOT       18
+
+/* Allow ptrace() of any process */
+
+#define CAP_SYS_PTRACE       19
+
+/* Allow configuration of process accounting */
+
+#define CAP_SYS_PACCT        20
+
+/* Allow configuration of the secure attention key */
+/* Allow administration of the random device */
+/* Allow examination and configuration of disk quotas */
+/* Allow configuring the kernel's syslog (printk behaviour) */
+/* Allow setting the domainname */
+/* Allow setting the hostname */
+/* Allow calling bdflush() */
+/* Allow mount() and umount(), setting up new smb connection */
+/* Allow some autofs root ioctls */
+/* Allow nfsservctl */
+/* Allow VM86_REQUEST_IRQ */
+/* Allow to read/write pci config on alpha */
+/* Allow irix_prctl on mips (setstacksize) */
+/* Allow flushing all cache on m68k (sys_cacheflush) */
+/* Allow removing semaphores */
+/* Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
+   and shared memory */
+/* Allow locking/unlocking of shared memory segment */
+/* Allow turning swap on/off */
+/* Allow forged pids on socket credentials passing */
+/* Allow setting readahead and flushing buffers on block devices */
+/* Allow setting geometry in floppy driver */
+/* Allow turning DMA on/off in xd driver */
+/* Allow administration of md devices (mostly the above, but some
+   extra ioctls) */
+/* Allow tuning the ide driver */
+/* Allow access to the nvram device */
+/* Allow administration of apm_bios, serial and bttv (TV) device */
+/* Allow manufacturer commands in isdn CAPI support driver */
+/* Allow reading non-standardized portions of pci configuration space */
+/* Allow DDI debug ioctl on sbpcd driver */
+/* Allow setting up serial ports */
+/* Allow sending raw qic-117 commands */
+/* Allow enabling/disabling tagged queuing on SCSI controllers and sending
+   arbitrary SCSI commands */
+/* Allow setting encryption key on loopback filesystem */
+/* Allow setting zone reclaim policy */
+
+#define CAP_SYS_ADMIN        21
+
+/* Allow use of reboot() */
+
+#define CAP_SYS_BOOT         22
+
+/* Allow raising priority and setting priority on other (different
+   UID) processes */
+/* Allow use of FIFO and round-robin (realtime) scheduling on own
+   processes and setting the scheduling algorithm used by another
+   process. */
+/* Allow setting cpu affinity on other processes */
+
+#define CAP_SYS_NICE         23
+
+/* Override resource limits. Set resource limits. */
+/* Override quota limits. */
+/* Override reserved space on ext2 filesystem */
+/* Modify data journaling mode on ext3 filesystem (uses journaling
+   resources) */
+/* NOTE: ext2 honors fsuid when checking for resource overrides, so
+   you can override using fsuid too */
+/* Override size restrictions on IPC message queues */
+/* Allow more than 64hz interrupts from the real-time clock */
+/* Override max number of consoles on console allocation */
+/* Override max number of keymaps */
+
+#define CAP_SYS_RESOURCE     24
+
+/* Allow manipulation of system clock */
+/* Allow irix_stime on mips */
+/* Allow setting the real-time clock */
+
+#define CAP_SYS_TIME         25
+
+/* Allow configuration of tty devices */
+/* Allow vhangup() of tty */
+
+#define CAP_SYS_TTY_CONFIG   26
+
+/* Allow the privileged aspects of mknod() */
+
+#define CAP_MKNOD            27
+
+/* Allow taking of leases on files */
+
+#define CAP_LEASE            28
+
+#define CAP_AUDIT_WRITE      29
+
+#define CAP_AUDIT_CONTROL    30
+
+#define CAP_SETFCAP	     31
+
+/* Override MAC access.
+   The base kernel enforces no MAC policy.
+   An LSM may enforce a MAC policy, and if it does and it chooses
+   to implement capability based overrides of that policy, this is
+   the capability it should use to do so. */
+
+#define CAP_MAC_OVERRIDE     32
+
+/* Allow MAC configuration or state changes.
+   The base kernel requires no MAC configuration.
+   An LSM may enforce a MAC policy, and if it does and it chooses
+   to implement capability based checks on modifications to that
+   policy or the data required to maintain it, this is the
+   capability it should use to do so. */
+
+#define CAP_MAC_ADMIN        33
+
+#define CAP_LAST_CAP         CAP_MAC_ADMIN
+
+#define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
+
+/*
+ * Bit location of each capability (used by user-space library and kernel)
+ */
+
+#define CAP_TO_INDEX(x)     ((x) >> 5)        /* 1 << 5 == bits in __u32 */
+#define CAP_TO_MASK(x)      (1 << ((x) & 31)) /* mask for indexed __u32 */
+
+
+#endif /* !_LINUX_CAPABILITY_H */
diff -uNr linux-2.6.32/usr/include/linux/capi.h clean_modified/linux-2.6.32/usr/include/linux/capi.h
--- linux-2.6.32/usr/include/linux/capi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/capi.h	2019-04-14 13:24:02.927591245 -0500
@@ -0,0 +1,131 @@
+/* $Id: capi.h,v 1.4.6.1 2001/09/23 22:25:05 kai Exp $
+ * 
+ * CAPI 2.0 Interface for Linux
+ * 
+ * Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef __LINUX_CAPI_H__
+#define __LINUX_CAPI_H__
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/kernelcapi.h>
+
+/*
+ * CAPI_REGISTER
+ */
+
+typedef struct capi_register_params {	/* CAPI_REGISTER */
+	__u32 level3cnt;	/* No. of simulatneous user data connections */
+	__u32 datablkcnt;	/* No. of buffered data messages */
+	__u32 datablklen;	/* Size of buffered data messages */
+} capi_register_params;
+
+#define	CAPI_REGISTER	_IOW('C',0x01,struct capi_register_params)
+
+/*
+ * CAPI_GET_MANUFACTURER
+ */
+
+#define CAPI_MANUFACTURER_LEN		64
+
+#define	CAPI_GET_MANUFACTURER	_IOWR('C',0x06,int)	/* broken: wanted size 64 (CAPI_MANUFACTURER_LEN) */
+
+/*
+ * CAPI_GET_VERSION
+ */
+
+typedef struct capi_version {
+	__u32 majorversion;
+	__u32 minorversion;
+	__u32 majormanuversion;
+	__u32 minormanuversion;
+} capi_version;
+
+#define CAPI_GET_VERSION	_IOWR('C',0x07,struct capi_version)
+
+/*
+ * CAPI_GET_SERIAL
+ */
+
+#define CAPI_SERIAL_LEN		8
+#define CAPI_GET_SERIAL		_IOWR('C',0x08,int)	/* broken: wanted size 8 (CAPI_SERIAL_LEN) */
+
+/*
+ * CAPI_GET_PROFILE
+ */
+
+typedef struct capi_profile {
+	__u16 ncontroller;	/* number of installed controller */
+	__u16 nbchannel;	/* number of B-Channels */
+	__u32 goptions;		/* global options */
+	__u32 support1;		/* B1 protocols support */
+	__u32 support2;		/* B2 protocols support */
+	__u32 support3;		/* B3 protocols support */
+	__u32 reserved[6];	/* reserved */
+	__u32 manu[5];		/* manufacturer specific information */
+} capi_profile;
+
+#define CAPI_GET_PROFILE	_IOWR('C',0x09,struct capi_profile)
+
+typedef struct capi_manufacturer_cmd {
+	unsigned long cmd;
+	void *data;
+} capi_manufacturer_cmd;
+
+/*
+ * CAPI_MANUFACTURER_CMD
+ */
+
+#define CAPI_MANUFACTURER_CMD	_IOWR('C',0x20, struct capi_manufacturer_cmd)
+
+/*
+ * CAPI_GET_ERRCODE
+ * capi errcode is set, * if read, write, or ioctl returns EIO,
+ * ioctl returns errcode directly, and in arg, if != 0
+ */
+
+#define CAPI_GET_ERRCODE	_IOR('C',0x21, __u16)
+
+/*
+ * CAPI_INSTALLED
+ */
+#define CAPI_INSTALLED		_IOR('C',0x22, __u16)
+
+
+/*
+ * member contr is input for
+ * CAPI_GET_MANUFACTURER, CAPI_VERSION, CAPI_GET_SERIAL
+ * and CAPI_GET_PROFILE
+ */
+typedef union capi_ioctl_struct {
+	__u32 contr;
+	capi_register_params rparams;
+	__u8 manufacturer[CAPI_MANUFACTURER_LEN];
+	capi_version version;
+	__u8 serial[CAPI_SERIAL_LEN];
+	capi_profile profile;
+	capi_manufacturer_cmd cmd;
+	__u16 errcode;
+} capi_ioctl_struct;
+
+/*
+ * Middleware extension
+ */
+
+#define CAPIFLAG_HIGHJACKING	0x0001
+
+#define CAPI_GET_FLAGS		_IOR('C',0x23, unsigned)
+#define CAPI_SET_FLAGS		_IOR('C',0x24, unsigned)
+#define CAPI_CLR_FLAGS		_IOR('C',0x25, unsigned)
+
+#define CAPI_NCCI_OPENCOUNT	_IOR('C',0x26, unsigned)
+
+#define CAPI_NCCI_GETUNIT	_IOR('C',0x27, unsigned)
+
+#endif				/* __LINUX_CAPI_H__ */
diff -uNr linux-2.6.32/usr/include/linux/cciss_ioctl.h clean_modified/linux-2.6.32/usr/include/linux/cciss_ioctl.h
--- linux-2.6.32/usr/include/linux/cciss_ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cciss_ioctl.h	2019-04-14 13:24:02.928564326 -0500
@@ -0,0 +1,214 @@
+#ifndef CCISS_IOCTLH
+#define CCISS_IOCTLH
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define CCISS_IOC_MAGIC 'B'
+
+
+typedef struct _cciss_pci_info_struct
+{
+	unsigned char 	bus;
+	unsigned char 	dev_fn;
+	unsigned short	domain;
+	__u32 		board_id;
+} cciss_pci_info_struct; 
+
+typedef struct _cciss_coalint_struct
+{
+	__u32  delay;
+	__u32  count;
+} cciss_coalint_struct;
+
+typedef char NodeName_type[16];
+
+typedef __u32 Heartbeat_type;
+
+#define CISS_PARSCSIU2 	0x0001
+#define CISS_PARCSCIU3 	0x0002
+#define CISS_FIBRE1G	0x0100
+#define CISS_FIBRE2G	0x0200
+typedef __u32 BusTypes_type;
+
+typedef char FirmwareVer_type[4];
+typedef __u32 DriverVer_type;
+
+#define MAX_KMALLOC_SIZE 128000
+
+#ifndef CCISS_CMD_H
+// This defines are duplicated in cciss_cmd.h in the driver directory 
+
+//general boundary defintions
+#define SENSEINFOBYTES          32//note that this value may vary between host implementations
+
+//Command Status value
+#define CMD_SUCCESS             0x0000
+#define CMD_TARGET_STATUS       0x0001
+#define CMD_DATA_UNDERRUN       0x0002
+#define CMD_DATA_OVERRUN        0x0003
+#define CMD_INVALID             0x0004
+#define CMD_PROTOCOL_ERR        0x0005
+#define CMD_HARDWARE_ERR        0x0006
+#define CMD_CONNECTION_LOST     0x0007
+#define CMD_ABORTED             0x0008
+#define CMD_ABORT_FAILED        0x0009
+#define CMD_UNSOLICITED_ABORT   0x000A
+#define CMD_TIMEOUT             0x000B
+#define CMD_UNABORTABLE		0x000C
+
+//transfer direction
+#define XFER_NONE               0x00
+#define XFER_WRITE              0x01
+#define XFER_READ               0x02
+#define XFER_RSVD               0x03
+
+//task attribute
+#define ATTR_UNTAGGED           0x00
+#define ATTR_SIMPLE             0x04
+#define ATTR_HEADOFQUEUE        0x05
+#define ATTR_ORDERED            0x06
+#define ATTR_ACA                0x07
+
+//cdb type
+#define TYPE_CMD				0x00
+#define TYPE_MSG				0x01
+
+// Type defs used in the following structs
+#define BYTE __u8
+#define WORD __u16
+#define HWORD __u16
+#define DWORD __u32
+
+#define CISS_MAX_LUN	1024
+
+#define LEVEL2LUN   1   // index into Target(x) structure, due to byte swapping
+#define LEVEL3LUN   0
+
+#pragma pack(1)
+
+//Command List Structure
+typedef union _SCSI3Addr_struct {
+   struct {
+    BYTE Dev;
+    BYTE Bus:6;
+    BYTE Mode:2;        // b00
+  } PeripDev;
+   struct {
+    BYTE DevLSB;
+    BYTE DevMSB:6;
+    BYTE Mode:2;        // b01
+  } LogDev;
+   struct {
+    BYTE Dev:5;
+    BYTE Bus:3;
+    BYTE Targ:6;
+    BYTE Mode:2;        // b10
+  } LogUnit;
+} SCSI3Addr_struct;
+
+typedef struct _PhysDevAddr_struct {
+  DWORD             TargetId:24;
+  DWORD             Bus:6;
+  DWORD             Mode:2;
+  SCSI3Addr_struct  Target[2]; //2 level target device addr
+} PhysDevAddr_struct;
+  
+typedef struct _LogDevAddr_struct {
+  DWORD            VolId:30;
+  DWORD            Mode:2;
+  BYTE             reserved[4];
+} LogDevAddr_struct;
+
+typedef union _LUNAddr_struct {
+  BYTE               LunAddrBytes[8];
+  SCSI3Addr_struct   SCSI3Lun[4];
+  PhysDevAddr_struct PhysDev;
+  LogDevAddr_struct  LogDev;
+} LUNAddr_struct;
+
+typedef struct _RequestBlock_struct {
+  BYTE   CDBLen;
+  struct {
+    BYTE Type:3;
+    BYTE Attribute:3;
+    BYTE Direction:2;
+  } Type;
+  HWORD  Timeout;
+  BYTE   CDB[16];
+} RequestBlock_struct;
+
+typedef union _MoreErrInfo_struct{
+  struct {
+    BYTE  Reserved[3];
+    BYTE  Type;
+    DWORD ErrorInfo;
+  }Common_Info;
+  struct{
+    BYTE  Reserved[2];
+    BYTE  offense_size;//size of offending entry
+    BYTE  offense_num; //byte # of offense 0-base
+    DWORD offense_value;
+  }Invalid_Cmd;
+}MoreErrInfo_struct;
+typedef struct _ErrorInfo_struct {
+  BYTE               ScsiStatus;
+  BYTE               SenseLen;
+  HWORD              CommandStatus;
+  DWORD              ResidualCnt;
+  MoreErrInfo_struct MoreErrInfo;
+  BYTE               SenseInfo[SENSEINFOBYTES];
+} ErrorInfo_struct;
+
+#pragma pack()
+#endif /* CCISS_CMD_H */ 
+
+typedef struct _IOCTL_Command_struct {
+  LUNAddr_struct	   LUN_info;
+  RequestBlock_struct      Request;
+  ErrorInfo_struct  	   error_info; 
+  WORD			   buf_size;  /* size in bytes of the buf */
+  BYTE			   *buf;
+} IOCTL_Command_struct;
+
+typedef struct _BIG_IOCTL_Command_struct {
+  LUNAddr_struct	   LUN_info;
+  RequestBlock_struct      Request;
+  ErrorInfo_struct  	   error_info;
+  DWORD			   malloc_size; /* < MAX_KMALLOC_SIZE in cciss.c */
+  DWORD			   buf_size;    /* size in bytes of the buf */
+  				        /* < malloc_size * MAXSGENTRIES */
+  BYTE			   *buf;
+} BIG_IOCTL_Command_struct;
+
+typedef struct _LogvolInfo_struct{
+	__u32	LunID;
+	int	num_opens;  /* number of opens on the logical volume */
+	int	num_parts;  /* number of partitions configured on logvol */
+} LogvolInfo_struct;
+
+#define CCISS_GETPCIINFO _IOR(CCISS_IOC_MAGIC, 1, cciss_pci_info_struct)
+
+#define CCISS_GETINTINFO _IOR(CCISS_IOC_MAGIC, 2, cciss_coalint_struct)
+#define CCISS_SETINTINFO _IOW(CCISS_IOC_MAGIC, 3, cciss_coalint_struct)
+
+#define CCISS_GETNODENAME _IOR(CCISS_IOC_MAGIC, 4, NodeName_type)
+#define CCISS_SETNODENAME _IOW(CCISS_IOC_MAGIC, 5, NodeName_type)
+
+#define CCISS_GETHEARTBEAT _IOR(CCISS_IOC_MAGIC, 6, Heartbeat_type)
+#define CCISS_GETBUSTYPES  _IOR(CCISS_IOC_MAGIC, 7, BusTypes_type)
+#define CCISS_GETFIRMVER   _IOR(CCISS_IOC_MAGIC, 8, FirmwareVer_type)
+#define CCISS_GETDRIVVER   _IOR(CCISS_IOC_MAGIC, 9, DriverVer_type)
+#define CCISS_REVALIDVOLS  _IO(CCISS_IOC_MAGIC, 10)
+#define CCISS_PASSTHRU	   _IOWR(CCISS_IOC_MAGIC, 11, IOCTL_Command_struct)
+#define CCISS_DEREGDISK	   _IO(CCISS_IOC_MAGIC, 12)
+
+/* no longer used... use REGNEWD instead */ 
+#define CCISS_REGNEWDISK  _IOW(CCISS_IOC_MAGIC, 13, int)
+
+#define CCISS_REGNEWD	   _IO(CCISS_IOC_MAGIC, 14)
+#define CCISS_RESCANDISK   _IO(CCISS_IOC_MAGIC, 16)
+#define CCISS_GETLUNINFO   _IOR(CCISS_IOC_MAGIC, 17, LogvolInfo_struct)
+#define CCISS_BIG_PASSTHRU _IOWR(CCISS_IOC_MAGIC, 18, BIG_IOCTL_Command_struct)
+
+#endif  
diff -uNr linux-2.6.32/usr/include/linux/cdk.h clean_modified/linux-2.6.32/usr/include/linux/cdk.h
--- linux-2.6.32/usr/include/linux/cdk.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cdk.h	2019-04-14 13:24:02.929539332 -0500
@@ -0,0 +1,486 @@
+/*****************************************************************************/
+
+/*
+ *	cdk.h  -- CDK interface definitions.
+ *
+ *	Copyright (C) 1996-1998  Stallion Technologies
+ *	Copyright (C) 1994-1996  Greg Ungerer.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*****************************************************************************/
+#ifndef	_CDK_H
+#define	_CDK_H
+/*****************************************************************************/
+
+#pragma	pack(2)
+
+/*
+ *	The following set of definitions is used to communicate with the
+ *	shared memory interface of the Stallion intelligent multiport serial
+ *	boards. The definitions in this file are taken directly from the
+ *	document titled "Generic Stackable Interface, Downloader and
+ *	Communications Development Kit".
+ */
+
+/*
+ *	Define the set of important shared memory addresses. These are
+ *	required to initialize the board and get things started. All of these
+ *	addresses are relative to the start of the shared memory.
+ */
+#define	CDK_SIGADDR	0x200
+#define	CDK_FEATADDR	0x280
+#define	CDK_CDKADDR	0x300
+#define	CDK_RDYADDR	0x262
+
+#define	CDK_ALIVEMARKER	13
+
+/*
+ *	On hardware power up the ROMs located on the EasyConnection 8/64 will
+ *	fill out the following signature information into shared memory. This
+ *	way the host system can quickly determine that the board is present
+ *	and is operational.
+ */
+typedef struct cdkecpsig {
+	unsigned long	magic;
+	unsigned short	romver;
+	unsigned short	cputype;
+	unsigned char	panelid[8];
+} cdkecpsig_t;
+
+#define	ECP_MAGIC	0x21504345
+
+/*
+ *	On hardware power up the ROMs located on the ONboard, Stallion and
+ *	Brumbys will fill out the following signature information into shared
+ *	memory. This way the host system can quickly determine that the board
+ *	is present and is operational.
+ */
+typedef struct cdkonbsig {
+	unsigned short	magic0;
+	unsigned short	magic1;
+	unsigned short	magic2;
+	unsigned short	magic3;
+	unsigned short	romver;
+	unsigned short	memoff;
+	unsigned short	memseg;
+	unsigned short	amask0;
+	unsigned short	pic;
+	unsigned short	status;
+	unsigned short	btype;
+	unsigned short	clkticks;
+	unsigned short	clkspeed;
+	unsigned short	amask1;
+	unsigned short	amask2;
+} cdkonbsig_t;
+
+#define	ONB_MAGIC0	0xf2a7
+#define	ONB_MAGIC1	0xa149
+#define	ONB_MAGIC2	0x6352
+#define	ONB_MAGIC3	0xf121
+
+/*
+ *	Define the feature area structure. The feature area is the set of
+ *	startup parameters used by the slave image when it starts executing.
+ *	They allow for the specification of buffer sizes, debug trace, etc.
+ */
+typedef struct cdkfeature {
+	unsigned long	debug;
+	unsigned long	banner;
+	unsigned long	etype;
+	unsigned long	nrdevs;
+	unsigned long	brdspec;
+	unsigned long	txrqsize;
+	unsigned long	rxrqsize;
+	unsigned long	flags;
+} cdkfeature_t;
+
+#define	ETYP_DDK	0
+#define	ETYP_CDK	1
+
+/*
+ *	Define the CDK header structure. This is the info that the slave
+ *	environment sets up after it has been downloaded and started. It
+ *	essentially provides a memory map for the shared memory interface.
+ */
+typedef struct cdkhdr {
+	unsigned short	command;
+	unsigned short	status;
+	unsigned short	port;
+	unsigned short	mode;
+	unsigned long	cmd_buf[14];
+	unsigned short	alive_cnt;
+	unsigned short	intrpt_mode;
+	unsigned char	intrpt_id[8];
+	unsigned char	ver_release;
+	unsigned char	ver_modification;
+	unsigned char	ver_fix;
+	unsigned char	deadman_restart;
+	unsigned short	deadman;
+	unsigned short	nrdevs;
+	unsigned long	memp;
+	unsigned long	hostp;
+	unsigned long	slavep;
+	unsigned char	hostreq;
+	unsigned char	slavereq;
+	unsigned char	cmd_reserved[30];
+} cdkhdr_t;
+
+#define	MODE_DDK	0
+#define	MODE_CDK	1
+
+#define	IMD_INTR	0x0
+#define	IMD_PPINTR	0x1
+#define	IMD_POLL	0xff
+
+/*
+ *	Define the memory mapping structure. This structure is pointed to by
+ *	the memp field in the stlcdkhdr struct. As many as these structures
+ *	as required are layed out in shared memory to define how the rest of
+ *	shared memory is divided up. There will be one for each port.
+ */
+typedef struct cdkmem {
+	unsigned short	dtype;
+	unsigned long	offset;
+} cdkmem_t;
+
+#define	TYP_UNDEFINED	0x0
+#define	TYP_ASYNCTRL	0x1
+#define	TYP_ASYNC	0x20
+#define	TYP_PARALLEL	0x40
+#define	TYP_SYNCX21	0x60
+
+/*****************************************************************************/
+
+/*
+ *	Following is a set of defines and structures used to actually deal
+ *	with the serial ports on the board. Firstly is the set of commands
+ *	that can be applied to ports.
+ */
+#define	ASYCMD		(((unsigned long) 'a') << 8)
+
+#define	A_NULL		(ASYCMD | 0)
+#define	A_FLUSH		(ASYCMD | 1)
+#define	A_BREAK		(ASYCMD | 2)
+#define	A_GETPORT	(ASYCMD | 3)
+#define	A_SETPORT	(ASYCMD | 4)
+#define	A_SETPORTF	(ASYCMD | 5)
+#define	A_SETPORTFTX	(ASYCMD | 6)
+#define	A_SETPORTFRX	(ASYCMD | 7)
+#define	A_GETSIGNALS	(ASYCMD | 8)
+#define	A_SETSIGNALS	(ASYCMD | 9)
+#define	A_SETSIGNALSF	(ASYCMD | 10)
+#define	A_SETSIGNALSFTX	(ASYCMD | 11)
+#define	A_SETSIGNALSFRX	(ASYCMD | 12)
+#define	A_GETNOTIFY	(ASYCMD | 13)
+#define	A_SETNOTIFY	(ASYCMD | 14)
+#define	A_NOTIFY	(ASYCMD | 15)
+#define	A_PORTCTRL	(ASYCMD | 16)
+#define	A_GETSTATS	(ASYCMD | 17)
+#define	A_RQSTATE	(ASYCMD | 18)
+#define	A_FLOWSTATE	(ASYCMD | 19)
+#define	A_CLEARSTATS	(ASYCMD | 20)
+
+/*
+ *	Define those arguments used for simple commands.
+ */
+#define	FLUSHRX		0x1
+#define	FLUSHTX		0x2
+
+#define	BREAKON		-1
+#define	BREAKOFF	-2
+
+/*
+ *	Define the port setting structure, and all those defines that go along
+ *	with it. Basically this structure defines the characteristics of this
+ *	port: baud rate, chars, parity, input/output char cooking etc.
+ */
+typedef struct asyport {
+	unsigned long	baudout;
+	unsigned long	baudin;
+	unsigned long	iflag;
+	unsigned long	oflag;
+	unsigned long	lflag;
+	unsigned long	pflag;
+	unsigned long	flow;
+	unsigned long	spare1;
+	unsigned short	vtime;
+	unsigned short	vmin;
+	unsigned short	txlo;
+	unsigned short	txhi;
+	unsigned short	rxlo;
+	unsigned short	rxhi;
+	unsigned short	rxhog;
+	unsigned short	spare2;
+	unsigned char	csize;
+	unsigned char	stopbs;
+	unsigned char	parity;
+	unsigned char	stopin;
+	unsigned char	startin;
+	unsigned char	stopout;
+	unsigned char	startout;
+	unsigned char	parmark;
+	unsigned char	brkmark;
+	unsigned char	cc[11];
+} asyport_t;
+
+#define	PT_STOP1	0x0
+#define	PT_STOP15	0x1
+#define	PT_STOP2	0x2
+
+#define	PT_NOPARITY	0x0
+#define	PT_ODDPARITY	0x1
+#define	PT_EVENPARITY	0x2
+#define	PT_MARKPARITY	0x3
+#define	PT_SPACEPARITY	0x4
+
+#define	F_NONE		0x0
+#define	F_IXON		0x1
+#define	F_IXOFF		0x2
+#define	F_IXANY		0x4
+#define	F_IOXANY	0x8
+#define	F_RTSFLOW	0x10
+#define	F_CTSFLOW	0x20
+#define	F_DTRFLOW	0x40
+#define	F_DCDFLOW	0x80
+#define	F_DSROFLOW	0x100
+#define	F_DSRIFLOW	0x200
+
+#define	FI_NORX		0x1
+#define	FI_RAW		0x2
+#define	FI_ISTRIP	0x4
+#define	FI_UCLC		0x8
+#define	FI_INLCR	0x10
+#define	FI_ICRNL	0x20
+#define	FI_IGNCR	0x40
+#define	FI_IGNBREAK	0x80
+#define	FI_DSCRDBREAK	0x100
+#define	FI_1MARKBREAK	0x200
+#define	FI_2MARKBREAK	0x400
+#define	FI_XCHNGBREAK	0x800
+#define	FI_IGNRXERRS	0x1000
+#define	FI_DSCDRXERRS	0x2000
+#define	FI_1MARKRXERRS	0x4000
+#define	FI_2MARKRXERRS	0x8000
+#define	FI_XCHNGRXERRS	0x10000
+#define	FI_DSCRDNULL	0x20000
+
+#define	FO_OLCUC	0x1
+#define	FO_ONLCR	0x2
+#define	FO_OOCRNL	0x4
+#define	FO_ONOCR	0x8
+#define	FO_ONLRET	0x10
+#define	FO_ONL		0x20
+#define	FO_OBS		0x40
+#define	FO_OVT		0x80
+#define	FO_OFF		0x100
+#define	FO_OTAB1	0x200
+#define	FO_OTAB2	0x400
+#define	FO_OTAB3	0x800
+#define	FO_OCR1		0x1000
+#define	FO_OCR2		0x2000
+#define	FO_OCR3		0x4000
+#define	FO_OFILL	0x8000
+#define	FO_ODELL	0x10000
+
+#define	P_RTSLOCK	0x1
+#define	P_CTSLOCK	0x2
+#define	P_MAPRTS	0x4
+#define	P_MAPCTS	0x8
+#define	P_LOOPBACK	0x10
+#define	P_DTRFOLLOW	0x20
+#define	P_FAKEDCD	0x40
+
+#define	P_RXIMIN	0x10000
+#define	P_RXITIME	0x20000
+#define	P_RXTHOLD	0x40000
+
+/*
+ *	Define a structure to communicate serial port signal and data state
+ *	information.
+ */
+typedef struct asysigs {
+	unsigned long	data;
+	unsigned long	signal;
+	unsigned long	sigvalue;
+} asysigs_t;
+
+#define	DT_TXBUSY	0x1
+#define	DT_TXEMPTY	0x2
+#define	DT_TXLOW	0x4
+#define	DT_TXHIGH	0x8
+#define	DT_TXFULL	0x10
+#define	DT_TXHOG	0x20
+#define	DT_TXFLOWED	0x40
+#define	DT_TXBREAK	0x80
+
+#define	DT_RXBUSY	0x100
+#define	DT_RXEMPTY	0x200
+#define	DT_RXLOW	0x400
+#define	DT_RXHIGH	0x800
+#define	DT_RXFULL	0x1000
+#define	DT_RXHOG	0x2000
+#define	DT_RXFLOWED	0x4000
+#define	DT_RXBREAK	0x8000
+
+#define	SG_DTR		0x1
+#define	SG_DCD		0x2
+#define	SG_RTS		0x4
+#define	SG_CTS		0x8
+#define	SG_DSR		0x10
+#define	SG_RI		0x20
+
+/*
+ *	Define the notification setting structure. This is used to tell the
+ *	port what events we want to be informed about. Fields here use the
+ *	same defines as for the asysigs structure above.
+ */
+typedef struct asynotify {
+	unsigned long	ctrl;
+	unsigned long	data;
+	unsigned long	signal;
+	unsigned long	sigvalue;
+} asynotify_t;
+
+/*
+ *	Define the port control structure. It is used to do fine grain
+ *	control operations on the port.
+ */
+typedef struct {
+	unsigned long	rxctrl;
+	unsigned long	txctrl;
+	char		rximdch;
+	char		tximdch;
+	char		spare1;
+	char		spare2;
+} asyctrl_t;
+
+#define	CT_ENABLE	0x1
+#define	CT_DISABLE	0x2
+#define	CT_STOP		0x4
+#define	CT_START	0x8
+#define	CT_STARTFLOW	0x10
+#define	CT_STOPFLOW	0x20
+#define	CT_SENDCHR	0x40
+
+/*
+ *	Define the stats structure kept for each port. This is a useful set
+ *	of data collected for each port on the slave. The A_GETSTATS command
+ *	is used to retrieve this data from the slave.
+ */
+typedef struct asystats {
+	unsigned long	opens;
+	unsigned long	txchars;
+	unsigned long	rxchars;
+	unsigned long	txringq;
+	unsigned long	rxringq;
+	unsigned long	txmsgs;
+	unsigned long	rxmsgs;
+	unsigned long	txflushes;
+	unsigned long	rxflushes;
+	unsigned long	overruns;
+	unsigned long	framing;
+	unsigned long	parity;
+	unsigned long	ringover;
+	unsigned long	lost;
+	unsigned long	rxstart;
+	unsigned long	rxstop;
+	unsigned long	txstart;
+	unsigned long	txstop;
+	unsigned long	dcdcnt;
+	unsigned long	dtrcnt;
+	unsigned long	ctscnt;
+	unsigned long	rtscnt;
+	unsigned long	dsrcnt;
+	unsigned long	ricnt;
+	unsigned long	txbreaks;
+	unsigned long	rxbreaks;
+	unsigned long	signals;
+	unsigned long	state;
+	unsigned long	hwid;
+} asystats_t;
+
+/*****************************************************************************/
+
+/*
+ *	All command and control communication with a device on the slave is
+ *	via a control block in shared memory. Each device has its own control
+ *	block, defined by the following structure. The control block allows
+ *	the host to open, close and control the device on the slave.
+ */
+typedef struct cdkctrl {
+	unsigned char	open;
+	unsigned char	close;
+	unsigned long	openarg;
+	unsigned long	closearg;
+	unsigned long	cmd;
+	unsigned long	status;
+	unsigned long	args[32];
+} cdkctrl_t;
+
+/*
+ *	Each device on the slave passes data to and from the host via a ring
+ *	queue in shared memory. Define a ring queue structure to hold the
+ *	vital information about each ring queue. Two ring queues will be
+ *	allocated for each port, one for receive data and one for transmit
+ *	data.
+ */
+typedef struct cdkasyrq {
+	unsigned long	offset;
+	unsigned short	size;
+	unsigned short	head;
+	unsigned short	tail;
+} cdkasyrq_t;
+
+/*
+ *	Each asynchronous port is defined in shared memory by the following
+ *	structure. It contains a control block to command a device, and also
+ *	the necessary data channel information as well.
+ */
+typedef struct cdkasy {
+	cdkctrl_t	ctrl;
+	unsigned short	notify;
+	asynotify_t	changed;
+	unsigned short	receive;
+	cdkasyrq_t	rxq;
+	unsigned short	transmit;
+	cdkasyrq_t	txq;
+} cdkasy_t;
+
+#pragma	pack()
+
+/*****************************************************************************/
+
+/*
+ *	Define the set of ioctls used by the driver to do special things
+ *	to the board. These include interrupting it, and initializing
+ *	the driver after board startup and shutdown.
+ */
+#include <linux/ioctl.h>
+
+#define	STL_BINTR	_IO('s',20)
+#define	STL_BSTART	_IO('s',21)
+#define	STL_BSTOP	_IO('s',22)
+#define	STL_BRESET	_IO('s',23)
+
+/*
+ *	Define a set of ioctl extensions, used to get at special stuff.
+ */
+#define	STL_GETPFLAG	_IO('s',80)
+#define	STL_SETPFLAG	_IO('s',81)
+
+/*****************************************************************************/
+#endif
diff -uNr linux-2.6.32/usr/include/linux/cdrom.h clean_modified/linux-2.6.32/usr/include/linux/cdrom.h
--- linux-2.6.32/usr/include/linux/cdrom.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cdrom.h	2019-04-14 13:24:02.930788776 -0500
@@ -0,0 +1,912 @@
+/*
+ * -- <linux/cdrom.h>
+ * General header file for linux CD-ROM drivers 
+ * Copyright (C) 1992         David Giller, rafetmad@oxy.edu
+ *               1994, 1995   Eberhard Mönkeberg, emoenke@gwdg.de
+ *               1996         David van Leeuwen, david@tm.tno.nl
+ *               1997, 1998   Erik Andersen, andersee@debian.org
+ *               1998-2002    Jens Axboe, axboe@suse.de
+ */
+ 
+#ifndef	_LINUX_CDROM_H
+#define	_LINUX_CDROM_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/*******************************************************
+ * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
+ * (and only this) include file.  It is my hope to provide Linux with
+ * a uniform interface between software accessing CD-ROMs and the various 
+ * device drivers that actually talk to the drives.  There may still be
+ * 23 different kinds of strange CD-ROM drives, but at least there will 
+ * now be one, and only one, Linux CD-ROM interface.
+ *
+ * Additionally, as of Linux 2.1.x, all Linux application programs 
+ * should use the O_NONBLOCK option when opening a CD-ROM device 
+ * for subsequent ioctl commands.  This allows for neat system errors 
+ * like "No medium found" or "Wrong medium type" upon attempting to 
+ * mount or play an empty slot, mount an audio disc, or play a data disc.
+ * Generally, changing an application program to support O_NONBLOCK
+ * is as easy as the following:
+ *       -    drive = open("/dev/cdrom", O_RDONLY);
+ *       +    drive = open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
+ * It is worth the small change.
+ *
+ *  Patches for many common CD programs (provided by David A. van Leeuwen)
+ *  can be found at:  ftp://ftp.gwdg.de/pub/linux/cdrom/drivers/cm206/
+ * 
+ *******************************************************/
+
+/* When a driver supports a certain function, but the cdrom drive we are 
+ * using doesn't, we will return the error EDRIVE_CANT_DO_THIS.  We will 
+ * borrow the "Operation not supported" error from the network folks to 
+ * accomplish this.  Maybe someday we will get a more targeted error code, 
+ * but this will do for now... */
+#define EDRIVE_CANT_DO_THIS  EOPNOTSUPP
+
+/*******************************************************
+ * The CD-ROM IOCTL commands  -- these should be supported by 
+ * all the various cdrom drivers.  For the CD-ROM ioctls, we 
+ * will commandeer byte 0x53, or 'S'.
+ *******************************************************/
+#define CDROMPAUSE		0x5301 /* Pause Audio Operation */ 
+#define CDROMRESUME		0x5302 /* Resume paused Audio Operation */
+#define CDROMPLAYMSF		0x5303 /* Play Audio MSF (struct cdrom_msf) */
+#define CDROMPLAYTRKIND		0x5304 /* Play Audio Track/index 
+                                           (struct cdrom_ti) */
+#define CDROMREADTOCHDR		0x5305 /* Read TOC header 
+                                           (struct cdrom_tochdr) */
+#define CDROMREADTOCENTRY	0x5306 /* Read TOC entry 
+                                           (struct cdrom_tocentry) */
+#define CDROMSTOP		0x5307 /* Stop the cdrom drive */
+#define CDROMSTART		0x5308 /* Start the cdrom drive */
+#define CDROMEJECT		0x5309 /* Ejects the cdrom media */
+#define CDROMVOLCTRL		0x530a /* Control output volume 
+                                           (struct cdrom_volctrl) */
+#define CDROMSUBCHNL		0x530b /* Read subchannel data 
+                                           (struct cdrom_subchnl) */
+#define CDROMREADMODE2		0x530c /* Read CDROM mode 2 data (2336 Bytes) 
+                                           (struct cdrom_read) */
+#define CDROMREADMODE1		0x530d /* Read CDROM mode 1 data (2048 Bytes)
+                                           (struct cdrom_read) */
+#define CDROMREADAUDIO		0x530e /* (struct cdrom_read_audio) */
+#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
+#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
+                                           address of multi session disks 
+                                           (struct cdrom_multisession) */
+#define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
+                                           if available (struct cdrom_mcn) */
+#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is deprecated, 
+                                          but here anyway for compatibility */
+#define CDROMRESET		0x5312 /* hard-reset the drive */
+#define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
+                                          (struct cdrom_volctrl) */
+#define CDROMREADRAW		0x5314	/* read data in raw mode (2352 Bytes)
+                                           (struct cdrom_read) */
+/* 
+ * These ioctls are used only used in aztcd.c and optcd.c
+ */
+#define CDROMREADCOOKED		0x5315	/* read data in cooked mode */
+#define CDROMSEEK		0x5316  /* seek msf address */
+  
+/*
+ * This ioctl is only used by the scsi-cd driver.  
+   It is for playing audio in logical block addressing mode.
+ */
+#define CDROMPLAYBLK		0x5317	/* (struct cdrom_blk) */
+
+/* 
+ * These ioctls are only used in optcd.c
+ */
+#define CDROMREADALL		0x5318	/* read all 2646 bytes */
+
+/* 
+ * These ioctls are (now) only in ide-cd.c for controlling 
+ * drive spindown time.  They should be implemented in the
+ * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,
+ * GPCMD_MODE_SENSE_10 and the GPMODE_POWER_PAGE...
+ *  -Erik
+ */
+#define CDROMGETSPINDOWN        0x531d
+#define CDROMSETSPINDOWN        0x531e
+
+/* 
+ * These ioctls are implemented through the uniform CD-ROM driver
+ * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
+ * drivers are eventually ported to the uniform CD-ROM driver interface.
+ */
+#define CDROMCLOSETRAY		0x5319	/* pendant of CDROMEJECT */
+#define CDROM_SET_OPTIONS	0x5320  /* Set behavior options */
+#define CDROM_CLEAR_OPTIONS	0x5321  /* Clear behavior options */
+#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
+#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
+#define CDROM_MEDIA_CHANGED	0x5325  /* Check is media changed  */
+#define CDROM_DRIVE_STATUS	0x5326  /* Get tray position, etc. */
+#define CDROM_DISC_STATUS	0x5327  /* Get disc type, etc. */
+#define CDROM_CHANGER_NSLOTS    0x5328  /* Get number of slots */
+#define CDROM_LOCKDOOR		0x5329  /* lock or unlock door */
+#define CDROM_DEBUG		0x5330	/* Turn debug messages on/off */
+#define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */
+
+/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
+ * Future CDROM ioctls should be kept below 0x537F
+ */
+
+/* This ioctl is only used by sbpcd at the moment */
+#define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */
+					/* conflict with SCSI_IOCTL_GET_IDLUN */
+
+/* DVD-ROM Specific ioctls */
+#define DVD_READ_STRUCT		0x5390  /* Read structure */
+#define DVD_WRITE_STRUCT	0x5391  /* Write structure */
+#define DVD_AUTH		0x5392  /* Authentication */
+
+#define CDROM_SEND_PACKET	0x5393	/* send a packet to the drive */
+#define CDROM_NEXT_WRITABLE	0x5394	/* get next writable block */
+#define CDROM_LAST_WRITTEN	0x5395	/* get last block written on disc */
+
+/*******************************************************
+ * CDROM IOCTL structures
+ *******************************************************/
+
+/* Address in MSF format */
+struct cdrom_msf0		
+{
+	__u8	minute;
+	__u8	second;
+	__u8	frame;
+};
+
+/* Address in either MSF or logical format */
+union cdrom_addr		
+{
+	struct cdrom_msf0	msf;
+	int			lba;
+};
+
+/* This struct is used by the CDROMPLAYMSF ioctl */ 
+struct cdrom_msf 
+{
+	__u8	cdmsf_min0;	/* start minute */
+	__u8	cdmsf_sec0;	/* start second */
+	__u8	cdmsf_frame0;	/* start frame */
+	__u8	cdmsf_min1;	/* end minute */
+	__u8	cdmsf_sec1;	/* end second */
+	__u8	cdmsf_frame1;	/* end frame */
+};
+
+/* This struct is used by the CDROMPLAYTRKIND ioctl */
+struct cdrom_ti 
+{
+	__u8	cdti_trk0;	/* start track */
+	__u8	cdti_ind0;	/* start index */
+	__u8	cdti_trk1;	/* end track */
+	__u8	cdti_ind1;	/* end index */
+};
+
+/* This struct is used by the CDROMREADTOCHDR ioctl */
+struct cdrom_tochdr 	
+{
+	__u8	cdth_trk0;	/* start track */
+	__u8	cdth_trk1;	/* end track */
+};
+
+/* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */
+struct cdrom_volctrl
+{
+	__u8	channel0;
+	__u8	channel1;
+	__u8	channel2;
+	__u8	channel3;
+};
+
+/* This struct is used by the CDROMSUBCHNL ioctl */
+struct cdrom_subchnl 
+{
+	__u8	cdsc_format;
+	__u8	cdsc_audiostatus;
+	__u8	cdsc_adr:	4;
+	__u8	cdsc_ctrl:	4;
+	__u8	cdsc_trk;
+	__u8	cdsc_ind;
+	union cdrom_addr cdsc_absaddr;
+	union cdrom_addr cdsc_reladdr;
+};
+
+
+/* This struct is used by the CDROMREADTOCENTRY ioctl */
+struct cdrom_tocentry 
+{
+	__u8	cdte_track;
+	__u8	cdte_adr	:4;
+	__u8	cdte_ctrl	:4;
+	__u8	cdte_format;
+	union cdrom_addr cdte_addr;
+	__u8	cdte_datamode;
+};
+
+/* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */
+struct cdrom_read      
+{
+	int	cdread_lba;
+	char 	*cdread_bufaddr;
+	int	cdread_buflen;
+};
+
+/* This struct is used by the CDROMREADAUDIO ioctl */
+struct cdrom_read_audio
+{
+	union cdrom_addr addr; /* frame address */
+	__u8 addr_format;      /* CDROM_LBA or CDROM_MSF */
+	int nframes;           /* number of 2352-byte-frames to read at once */
+	__u8 *buf;      /* frame buffer (size: nframes*2352 bytes) */
+};
+
+/* This struct is used with the CDROMMULTISESSION ioctl */
+struct cdrom_multisession
+{
+	union cdrom_addr addr; /* frame address: start-of-last-session 
+	                           (not the new "frame 16"!).  Only valid
+	                           if the "xa_flag" is true. */
+	__u8 xa_flag;        /* 1: "is XA disk" */
+	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
+};
+
+/* This struct is used with the CDROM_GET_MCN ioctl.  
+ * Very few audio discs actually have Universal Product Code information, 
+ * which should just be the Medium Catalog Number on the box.  Also note 
+ * that the way the codeis written on CD is _not_ uniform across all discs!
+ */  
+struct cdrom_mcn 
+{
+  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
+};
+
+/* This is used by the CDROMPLAYBLK ioctl */
+struct cdrom_blk 
+{
+	unsigned from;
+	unsigned short len;
+};
+
+#define CDROM_PACKET_SIZE	12
+
+#define CGC_DATA_UNKNOWN	0
+#define CGC_DATA_WRITE		1
+#define CGC_DATA_READ		2
+#define CGC_DATA_NONE		3
+
+/* for CDROM_PACKET_COMMAND ioctl */
+struct cdrom_generic_command
+{
+	unsigned char 		cmd[CDROM_PACKET_SIZE];
+	unsigned char		*buffer;
+	unsigned int 		buflen;
+	int			stat;
+	struct request_sense	*sense;
+	unsigned char		data_direction;
+	int			quiet;
+	int			timeout;
+	void			*reserved[1];	/* unused, actually */
+};
+
+/*
+ * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
+ * 2340, or 2352 bytes long.  
+
+*         Sector types of the standard CD-ROM data formats:
+ *
+ * format   sector type               user data size (bytes)
+ * -----------------------------------------------------------------------------
+ *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
+ *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
+ *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
+ *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
+ *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
+ *
+ *
+ *       The layout of the standard CD-ROM data formats:
+ * -----------------------------------------------------------------------------
+ * - audio (red):                  | audio_sample_bytes |
+ *                                 |        2352        |
+ *
+ * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
+ *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
+ *
+ * - data (yellow, mode2):         | sync - head - data |
+ *                                 |  12  -   4  - 2336 |
+ *
+ * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
+ *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
+ *
+ * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
+ *                                 |  12  -   4  -  8  - 2324 -  4    |
+ *
+ */
+
+/* Some generally useful CD-ROM information -- mostly based on the above */
+#define CD_MINS              74 /* max. minutes per CD, not really a limit */
+#define CD_SECS              60 /* seconds per minute */
+#define CD_FRAMES            75 /* frames per second */
+#define CD_SYNC_SIZE         12 /* 12 sync bytes per raw data frame */
+#define CD_MSF_OFFSET       150 /* MSF numbering offset of first frame */
+#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
+#define CD_NUM_OF_CHUNKS     98 /* chunks per frame */
+#define CD_FRAMESIZE_SUB     96 /* subchannel data "frame" size */
+#define CD_HEAD_SIZE          4 /* header (address) bytes per raw data frame */
+#define CD_SUBHEAD_SIZE       8 /* subheader bytes per raw XA data frame */
+#define CD_EDC_SIZE           4 /* bytes EDC per most raw data frame types */
+#define CD_ZERO_SIZE          8 /* bytes zero per yellow book mode 1 frame */
+#define CD_ECC_SIZE         276 /* bytes ECC per most raw data frame types */
+#define CD_FRAMESIZE       2048 /* bytes per frame, "cooked" mode */
+#define CD_FRAMESIZE_RAW   2352 /* bytes per frame, "raw" mode */
+#define CD_FRAMESIZE_RAWER 2646 /* The maximum possible returned bytes */ 
+/* most drives don't deliver everything: */
+#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
+#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
+
+#define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* "before data" part of raw XA frame */
+#define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* "after data" part of raw XA frame */
+#define CD_XA_SYNC_HEAD   (CD_SYNC_SIZE+CD_XA_HEAD) /* sync bytes + header of XA frame */
+
+/* CD-ROM address types (cdrom_tocentry.cdte_format) */
+#define	CDROM_LBA 0x01 /* "logical block": first frame is #0 */
+#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */
+
+/* bit to tell whether track is data or audio (cdrom_tocentry.cdte_ctrl) */
+#define	CDROM_DATA_TRACK	0x04
+
+/* The leadout track is always 0xAA, regardless of # of tracks on disc */
+#define	CDROM_LEADOUT		0xAA
+
+/* audio states (from SCSI-2, but seen with other drives, too) */
+#define	CDROM_AUDIO_INVALID	0x00	/* audio status not supported */
+#define	CDROM_AUDIO_PLAY	0x11	/* audio play operation in progress */
+#define	CDROM_AUDIO_PAUSED	0x12	/* audio play operation paused */
+#define	CDROM_AUDIO_COMPLETED	0x13	/* audio play successfully completed */
+#define	CDROM_AUDIO_ERROR	0x14	/* audio play stopped due to error */
+#define	CDROM_AUDIO_NO_STATUS	0x15	/* no current audio status to return */
+
+/* capability flags used with the uniform CD-ROM driver */ 
+#define CDC_CLOSE_TRAY		0x1     /* caddy systems _can't_ close */
+#define CDC_OPEN_TRAY		0x2     /* but _can_ eject.  */
+#define CDC_LOCK		0x4     /* disable manual eject */
+#define CDC_SELECT_SPEED 	0x8     /* programmable speed */
+#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
+#define CDC_MULTI_SESSION 	0x20    /* read sessions>1 */
+#define CDC_MCN			0x40    /* Medium Catalog Number */
+#define CDC_MEDIA_CHANGED 	0x80    /* media changed */
+#define CDC_PLAY_AUDIO		0x100   /* audio functions */
+#define CDC_RESET               0x200   /* hard reset device */
+#define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
+#define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
+#define CDC_CD_R		0x2000	/* drive is a CD-R */
+#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
+#define CDC_DVD			0x8000	/* drive is a DVD */
+#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
+#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
+#define CDC_MO_DRIVE		0x40000 /* drive is an MO device */
+#define CDC_MRW			0x80000 /* drive can read MRW */
+#define CDC_MRW_W		0x100000 /* drive can write MRW */
+#define CDC_RAM			0x200000 /* ok to open for WRITE */
+
+/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
+#define CDS_NO_INFO		0	/* if not implemented */
+#define CDS_NO_DISC		1
+#define CDS_TRAY_OPEN		2
+#define CDS_DRIVE_NOT_READY	3
+#define CDS_DISC_OK		4
+
+/* return values for the CDROM_DISC_STATUS ioctl */
+/* can also return CDS_NO_[INFO|DISC], from above */
+#define CDS_AUDIO		100
+#define CDS_DATA_1		101
+#define CDS_DATA_2		102
+#define CDS_XA_2_1		103
+#define CDS_XA_2_2		104
+#define CDS_MIXED		105
+
+/* User-configurable behavior options for the uniform CD-ROM driver */
+#define CDO_AUTO_CLOSE		0x1     /* close tray on first open() */
+#define CDO_AUTO_EJECT		0x2     /* open tray on last release() */
+#define CDO_USE_FFLAGS		0x4     /* use O_NONBLOCK information on open */
+#define CDO_LOCK		0x8     /* lock tray on open files */
+#define CDO_CHECK_TYPE		0x10    /* check type on open for data */
+
+/* Special codes used when specifying changer slots. */
+#define CDSL_NONE       	(INT_MAX-1)
+#define CDSL_CURRENT    	INT_MAX
+
+/* For partition based multisession access. IDE can handle 64 partitions
+ * per drive - SCSI CD-ROM's use minors to differentiate between the
+ * various drives, so we can't do multisessions the same way there.
+ * Use the -o session=x option to mount on them.
+ */
+#define CD_PART_MAX		64
+#define CD_PART_MASK		(CD_PART_MAX - 1)
+
+/*********************************************************************
+ * Generic Packet commands, MMC commands, and such
+ *********************************************************************/
+
+ /* The generic packet command opcodes for CD/DVD Logical Units,
+ * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
+#define GPCMD_BLANK			    0xa1
+#define GPCMD_CLOSE_TRACK		    0x5b
+#define GPCMD_FLUSH_CACHE		    0x35
+#define GPCMD_FORMAT_UNIT		    0x04
+#define GPCMD_GET_CONFIGURATION		    0x46
+#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
+#define GPCMD_GET_PERFORMANCE		    0xac
+#define GPCMD_INQUIRY			    0x12
+#define GPCMD_LOAD_UNLOAD		    0xa6
+#define GPCMD_MECHANISM_STATUS		    0xbd
+#define GPCMD_MODE_SELECT_10		    0x55
+#define GPCMD_MODE_SENSE_10		    0x5a
+#define GPCMD_PAUSE_RESUME		    0x4b
+#define GPCMD_PLAY_AUDIO_10		    0x45
+#define GPCMD_PLAY_AUDIO_MSF		    0x47
+#define GPCMD_PLAY_AUDIO_TI		    0x48
+#define GPCMD_PLAY_CD			    0xbc
+#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
+#define GPCMD_READ_10			    0x28
+#define GPCMD_READ_12			    0xa8
+#define GPCMD_READ_BUFFER		    0x3c
+#define GPCMD_READ_BUFFER_CAPACITY	    0x5c
+#define GPCMD_READ_CDVD_CAPACITY	    0x25
+#define GPCMD_READ_CD			    0xbe
+#define GPCMD_READ_CD_MSF		    0xb9
+#define GPCMD_READ_DISC_INFO		    0x51
+#define GPCMD_READ_DVD_STRUCTURE	    0xad
+#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
+#define GPCMD_READ_HEADER		    0x44
+#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
+#define GPCMD_READ_SUBCHANNEL		    0x42
+#define GPCMD_READ_TOC_PMA_ATIP		    0x43
+#define GPCMD_REPAIR_RZONE_TRACK	    0x58
+#define GPCMD_REPORT_KEY		    0xa4
+#define GPCMD_REQUEST_SENSE		    0x03
+#define GPCMD_RESERVE_RZONE_TRACK	    0x53
+#define GPCMD_SEND_CUE_SHEET		    0x5d
+#define GPCMD_SCAN			    0xba
+#define GPCMD_SEEK			    0x2b
+#define GPCMD_SEND_DVD_STRUCTURE	    0xbf
+#define GPCMD_SEND_EVENT		    0xa2
+#define GPCMD_SEND_KEY			    0xa3
+#define GPCMD_SEND_OPC			    0x54
+#define GPCMD_SET_READ_AHEAD		    0xa7
+#define GPCMD_SET_STREAMING		    0xb6
+#define GPCMD_START_STOP_UNIT		    0x1b
+#define GPCMD_STOP_PLAY_SCAN		    0x4e
+#define GPCMD_TEST_UNIT_READY		    0x00
+#define GPCMD_VERIFY_10			    0x2f
+#define GPCMD_WRITE_10			    0x2a
+#define GPCMD_WRITE_12			    0xaa
+#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+#define GPCMD_WRITE_BUFFER		    0x3b
+/* This is listed as optional in ATAPI 2.6, but is (curiously) 
+ * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
+ * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
+ * drives support it. */
+#define GPCMD_SET_SPEED			    0xbb
+/* This seems to be a SCSI specific CD-ROM opcode 
+ * to play data at track/index */
+#define GPCMD_PLAYAUDIO_TI		    0x48
+/*
+ * From MS Media Status Notification Support Specification. For
+ * older drives only.
+ */
+#define GPCMD_GET_MEDIA_STATUS		    0xda
+
+/* Mode page codes for mode sense/set */
+#define GPMODE_VENDOR_PAGE		0x00
+#define GPMODE_R_W_ERROR_PAGE		0x01
+#define GPMODE_WRITE_PARMS_PAGE		0x05
+#define GPMODE_WCACHING_PAGE		0x08
+#define GPMODE_AUDIO_CTL_PAGE		0x0e
+#define GPMODE_POWER_PAGE		0x1a
+#define GPMODE_FAULT_FAIL_PAGE		0x1c
+#define GPMODE_TO_PROTECT_PAGE		0x1d
+#define GPMODE_CAPABILITIES_PAGE	0x2a
+#define GPMODE_ALL_PAGES		0x3f
+/* Not in Mt. Fuji, but in ATAPI 2.6 -- deprecated now in favor
+ * of MODE_SENSE_POWER_PAGE */
+#define GPMODE_CDROM_PAGE		0x0d
+
+
+
+/* DVD struct types */
+#define DVD_STRUCT_PHYSICAL	0x00
+#define DVD_STRUCT_COPYRIGHT	0x01
+#define DVD_STRUCT_DISCKEY	0x02
+#define DVD_STRUCT_BCA		0x03
+#define DVD_STRUCT_MANUFACT	0x04
+
+struct dvd_layer {
+	__u8 book_version	: 4;
+	__u8 book_type		: 4;
+	__u8 min_rate		: 4;
+	__u8 disc_size		: 4;
+	__u8 layer_type		: 4;
+	__u8 track_path		: 1;
+	__u8 nlayers		: 2;
+	__u8 track_density	: 4;
+	__u8 linear_density	: 4;
+	__u8 bca		: 1;
+	__u32 start_sector;
+	__u32 end_sector;
+	__u32 end_sector_l0;
+};
+
+#define DVD_LAYERS	4
+
+struct dvd_physical {
+	__u8 type;
+	__u8 layer_num;
+	struct dvd_layer layer[DVD_LAYERS];
+};
+
+struct dvd_copyright {
+	__u8 type;
+
+	__u8 layer_num;
+	__u8 cpst;
+	__u8 rmi;
+};
+
+struct dvd_disckey {
+	__u8 type;
+
+	unsigned agid		: 2;
+	__u8 value[2048];
+};
+
+struct dvd_bca {
+	__u8 type;
+
+	int len;
+	__u8 value[188];
+};
+
+struct dvd_manufact {
+	__u8 type;
+
+	__u8 layer_num;
+	int len;
+	__u8 value[2048];
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_physical	physical;
+	struct dvd_copyright	copyright;
+	struct dvd_disckey	disckey;
+	struct dvd_bca		bca;
+	struct dvd_manufact	manufact;
+} dvd_struct;
+
+/*
+ * DVD authentication ioctl
+ */
+
+/* Authentication states */
+#define DVD_LU_SEND_AGID	0
+#define DVD_HOST_SEND_CHALLENGE	1
+#define DVD_LU_SEND_KEY1	2
+#define DVD_LU_SEND_CHALLENGE	3
+#define DVD_HOST_SEND_KEY2	4
+
+/* Termination states */
+#define DVD_AUTH_ESTABLISHED	5
+#define DVD_AUTH_FAILURE	6
+
+/* Other functions */
+#define DVD_LU_SEND_TITLE_KEY	7
+#define DVD_LU_SEND_ASF		8
+#define DVD_INVALIDATE_AGID	9
+#define DVD_LU_SEND_RPC_STATE	10
+#define DVD_HOST_SEND_RPC_STATE	11
+
+/* State data */
+typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
+typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
+
+struct dvd_lu_send_agid {
+	__u8 type;
+	unsigned agid		: 2;
+};
+
+struct dvd_host_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+struct dvd_send_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key key;
+};
+
+struct dvd_lu_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+#define DVD_CPM_NO_COPYRIGHT	0
+#define DVD_CPM_COPYRIGHTED	1
+
+#define DVD_CP_SEC_NONE		0
+#define DVD_CP_SEC_EXIST	1
+
+#define DVD_CGMS_UNRESTRICTED	0
+#define DVD_CGMS_SINGLE		2
+#define DVD_CGMS_RESTRICTED	3
+
+struct dvd_lu_send_title_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key title_key;
+	int lba;
+	unsigned cpm		: 1;
+	unsigned cp_sec		: 1;
+	unsigned cgms		: 2;
+};
+
+struct dvd_lu_send_asf {
+	__u8 type;
+	unsigned agid		: 2;
+
+	unsigned asf		: 1;
+};
+
+struct dvd_host_send_rpcstate {
+	__u8 type;
+	__u8 pdrc;
+};
+
+struct dvd_lu_send_rpcstate {
+	__u8 type		: 2;
+	__u8 vra		: 3;
+	__u8 ucca		: 3;
+	__u8 region_mask;
+	__u8 rpc_scheme;
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_lu_send_agid		lsa;
+	struct dvd_host_send_challenge	hsc;
+	struct dvd_send_key		lsk;
+	struct dvd_lu_send_challenge	lsc;
+	struct dvd_send_key		hsk;
+	struct dvd_lu_send_title_key	lstk;
+	struct dvd_lu_send_asf		lsasf;
+	struct dvd_host_send_rpcstate	hrpcs;
+	struct dvd_lu_send_rpcstate	lrpcs;
+} dvd_authinfo;
+
+struct request_sense {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 valid		: 1;
+	__u8 error_code		: 7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 error_code		: 7;
+	__u8 valid		: 1;
+#endif
+	__u8 segment_number;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 ili		: 1;
+	__u8 reserved2		: 1;
+	__u8 sense_key		: 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 sense_key		: 4;
+	__u8 reserved2		: 1;
+	__u8 ili		: 1;
+	__u8 reserved1		: 2;
+#endif
+	__u8 information[4];
+	__u8 add_sense_len;
+	__u8 command_info[4];
+	__u8 asc;
+	__u8 ascq;
+	__u8 fruc;
+	__u8 sks[3];
+	__u8 asb[46];
+};
+
+/*
+ * feature profile
+ */
+#define CDF_RWRT	0x0020	/* "Random Writable" */
+#define CDF_HWDM	0x0024	/* "Hardware Defect Management" */
+#define CDF_MRW 	0x0028
+
+/*
+ * media status bits
+ */
+#define CDM_MRW_NOTMRW			0
+#define CDM_MRW_BGFORMAT_INACTIVE	1
+#define CDM_MRW_BGFORMAT_ACTIVE		2
+#define CDM_MRW_BGFORMAT_COMPLETE	3
+
+/*
+ * mrw address spaces
+ */
+#define MRW_LBA_DMA			0
+#define MRW_LBA_GAA			1
+
+/*
+ * mrw mode pages (first is deprecated) -- probed at init time and
+ * cdi->mrw_mode_page is set
+ */
+#define MRW_MODE_PC_PRE1		0x2c
+#define MRW_MODE_PC			0x03
+
+struct mrw_feature_desc {
+	__be16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 write		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 write		: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+	__u8 reserved4;
+	__u8 reserved5;
+};
+
+/* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
+struct rwrt_feature_desc {
+	__be16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+	__u32 last_lba;
+	__u32 block_size;
+	__u16 blocking;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 page_present	: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 page_present	: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+};
+
+typedef struct {
+	__be16 disc_information_length;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1			: 3;
+        __u8 erasable			: 1;
+        __u8 border_status		: 2;
+        __u8 disc_status		: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 disc_status		: 2;
+        __u8 border_status		: 2;
+        __u8 erasable			: 1;
+	__u8 reserved1			: 3;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	__u8 n_first_track;
+	__u8 n_sessions_lsb;
+	__u8 first_track_lsb;
+	__u8 last_track_lsb;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 did_v			: 1;
+        __u8 dbc_v			: 1;
+        __u8 uru			: 1;
+        __u8 reserved2			: 2;
+	__u8 dbit			: 1;
+	__u8 mrw_status			: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 mrw_status			: 2;
+	__u8 dbit			: 1;
+        __u8 reserved2			: 2;
+        __u8 uru			: 1;
+        __u8 dbc_v			: 1;
+	__u8 did_v			: 1;
+#endif
+	__u8 disc_type;
+	__u8 n_sessions_msb;
+	__u8 first_track_msb;
+	__u8 last_track_msb;
+	__u32 disc_id;
+	__u32 lead_in;
+	__u32 lead_out;
+	__u8 disc_bar_code[8];
+	__u8 reserved3;
+	__u8 n_opc;
+} disc_information;
+
+typedef struct {
+	__be16 track_information_length;
+	__u8 track_lsb;
+	__u8 session_lsb;
+	__u8 reserved1;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2			: 2;
+        __u8 damage			: 1;
+        __u8 copy			: 1;
+        __u8 track_mode			: 4;
+	__u8 rt				: 1;
+	__u8 blank			: 1;
+	__u8 packet			: 1;
+	__u8 fp				: 1;
+	__u8 data_mode			: 4;
+	__u8 reserved3			: 6;
+	__u8 lra_v			: 1;
+	__u8 nwa_v			: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 track_mode			: 4;
+        __u8 copy			: 1;
+        __u8 damage			: 1;
+	__u8 reserved2			: 2;
+	__u8 data_mode			: 4;
+	__u8 fp				: 1;
+	__u8 packet			: 1;
+	__u8 blank			: 1;
+	__u8 rt				: 1;
+	__u8 nwa_v			: 1;
+	__u8 lra_v			: 1;
+	__u8 reserved3			: 6;
+#endif
+	__be32 track_start;
+	__be32 next_writable;
+	__be32 free_blocks;
+	__be32 fixed_packet_size;
+	__be32 track_size;
+	__be32 last_rec_address;
+} track_information;
+
+struct feature_header {
+	__u32 data_len;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u16 curr_profile;
+};
+
+struct mode_page_header {
+	__be16 mode_data_length;
+	__u8 medium_type;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u8 reserved3;
+	__be16 desc_length;
+};
+
+
+#endif  /* _LINUX_CDROM_H */
diff -uNr linux-2.6.32/usr/include/linux/cgroupstats.h clean_modified/linux-2.6.32/usr/include/linux/cgroupstats.h
--- linux-2.6.32/usr/include/linux/cgroupstats.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cgroupstats.h	2019-04-14 13:24:02.930788776 -0500
@@ -0,0 +1,71 @@
+/* cgroupstats.h - exporting per-cgroup statistics
+ *
+ * Copyright IBM Corporation, 2007
+ * Author Balbir Singh <balbir@linux.vnet.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _LINUX_CGROUPSTATS_H
+#define _LINUX_CGROUPSTATS_H
+
+#include <linux/types.h>
+#include <linux/taskstats.h>
+
+/*
+ * Data shared between user space and kernel space on a per cgroup
+ * basis. This data is shared using taskstats.
+ *
+ * Most of these states are derived by looking at the task->state value
+ * For the nr_io_wait state, a flag in the delay accounting structure
+ * indicates that the task is waiting on IO
+ *
+ * Each member is aligned to a 8 byte boundary.
+ */
+struct cgroupstats {
+	__u64	nr_sleeping;		/* Number of tasks sleeping */
+	__u64	nr_running;		/* Number of tasks running */
+	__u64	nr_stopped;		/* Number of tasks in stopped state */
+	__u64	nr_uninterruptible;	/* Number of tasks in uninterruptible */
+					/* state */
+	__u64	nr_io_wait;		/* Number of tasks waiting on IO */
+};
+
+/*
+ * Commands sent from userspace
+ * Not versioned. New commands should only be inserted at the enum's end
+ * prior to __CGROUPSTATS_CMD_MAX
+ */
+
+enum {
+	CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX,	/* Reserved */
+	CGROUPSTATS_CMD_GET,		/* user->kernel request/get-response */
+	CGROUPSTATS_CMD_NEW,		/* kernel->user event */
+	__CGROUPSTATS_CMD_MAX,
+};
+
+#define CGROUPSTATS_CMD_MAX (__CGROUPSTATS_CMD_MAX - 1)
+
+enum {
+	CGROUPSTATS_TYPE_UNSPEC = 0,	/* Reserved */
+	CGROUPSTATS_TYPE_CGROUP_STATS,	/* contains name + stats */
+	__CGROUPSTATS_TYPE_MAX,
+};
+
+#define CGROUPSTATS_TYPE_MAX (__CGROUPSTATS_TYPE_MAX - 1)
+
+enum {
+	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
+	CGROUPSTATS_CMD_ATTR_FD,
+	__CGROUPSTATS_CMD_ATTR_MAX,
+};
+
+#define CGROUPSTATS_CMD_ATTR_MAX (__CGROUPSTATS_CMD_ATTR_MAX - 1)
+
+#endif /* _LINUX_CGROUPSTATS_H */
diff -uNr linux-2.6.32/usr/include/linux/chio.h clean_modified/linux-2.6.32/usr/include/linux/chio.h
--- linux-2.6.32/usr/include/linux/chio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/chio.h	2019-04-14 13:24:02.932464398 -0500
@@ -0,0 +1,168 @@
+/*
+ * ioctl interface for the scsi media changer driver
+ */
+
+/* changer element types */
+#define CHET_MT   0	/* media transport element (robot) */
+#define CHET_ST   1	/* storage element (media slots) */
+#define CHET_IE   2	/* import/export element */
+#define CHET_DT   3	/* data transfer element (tape/cdrom/whatever) */
+#define CHET_V1   4	/* vendor specific #1 */
+#define CHET_V2   5	/* vendor specific #2 */
+#define CHET_V3   6	/* vendor specific #3 */
+#define CHET_V4   7	/* vendor specific #4 */
+
+
+/*
+ * CHIOGPARAMS
+ *    query changer properties
+ *
+ * CHIOVGPARAMS
+ *    query vendor-specific element types
+ *
+ *    accessing elements works by specifing type and unit of the element.
+ *    for eample, storage elements are addressed with type = CHET_ST and
+ *    unit = 0 .. cp_nslots-1
+ *
+ */
+struct changer_params {
+	int cp_curpicker;  /* current transport element */
+	int cp_npickers;   /* number of transport elements      (CHET_MT) */
+	int cp_nslots;     /* number of storage elements        (CHET_ST) */
+	int cp_nportals;   /* number of import/export elements  (CHET_IE) */
+	int cp_ndrives;    /* number of data transfer elements  (CHET_DT) */
+};
+struct changer_vendor_params {
+	int  cvp_n1;       /* number of vendor specific elems   (CHET_V1) */
+	char cvp_label1[16];
+	int  cvp_n2;       /* number of vendor specific elems   (CHET_V2) */
+	char cvp_label2[16];
+	int  cvp_n3;       /* number of vendor specific elems   (CHET_V3) */
+	char cvp_label3[16];
+	int  cvp_n4;       /* number of vendor specific elems   (CHET_V4) */
+	char cvp_label4[16];
+	int  reserved[8];
+};
+
+
+/*
+ * CHIOMOVE
+ *    move a medium from one element to another
+ */
+struct changer_move {
+	int cm_fromtype;	/* type/unit of source element */
+	int cm_fromunit;	
+	int cm_totype;	/* type/unit of destination element */
+	int cm_tounit;
+	int cm_flags;
+};
+#define CM_INVERT   1   /* flag: rotate media (for double-sided like MOD) */
+
+
+/*
+ * CHIOEXCHANGE
+ *    move one medium from element #1 to element #2,
+ *    and another one from element #2 to element #3.
+ *    element #1 and #3 are allowed to be identical.
+ */
+struct changer_exchange {
+	int ce_srctype;	    /* type/unit of element #1 */
+	int ce_srcunit;
+	int ce_fdsttype;    /* type/unit of element #2 */
+	int ce_fdstunit;
+	int ce_sdsttype;    /* type/unit of element #3 */
+	int ce_sdstunit;
+	int ce_flags;
+};
+#define CE_INVERT1   1
+#define CE_INVERT2   2
+
+
+/*
+ * CHIOPOSITION
+ *    move the transport element (robot arm) to a specific element.
+ */
+struct changer_position {
+	int cp_type;
+	int cp_unit;
+	int cp_flags;
+};
+#define CP_INVERT   1
+
+
+/*
+ * CHIOGSTATUS
+ *    get element status for all elements of a specific type
+ */
+struct changer_element_status {
+	int             ces_type;
+	unsigned char   *ces_data;
+};
+#define CESTATUS_FULL     0x01 /* full */
+#define CESTATUS_IMPEXP   0x02	/* media was imported (inserted by sysop) */
+#define CESTATUS_EXCEPT   0x04	/* error condition */
+#define CESTATUS_ACCESS   0x08	/* access allowed */
+#define CESTATUS_EXENAB   0x10	/* element can export media */
+#define CESTATUS_INENAB   0x20	/* element can import media */
+
+
+/*
+ * CHIOGELEM
+ *    get more detailed status information for a single element
+ */
+struct changer_get_element {
+	int	cge_type;	 /* type/unit */
+	int	cge_unit;
+	int	cge_status;      /* status */
+	int     cge_errno;       /* errno */
+	int     cge_srctype;     /* source element of the last move/exchange */
+	int     cge_srcunit;
+	int     cge_id;          /* scsi id  (for data transfer elements) */
+	int     cge_lun;         /* scsi lun (for data transfer elements) */
+	char    cge_pvoltag[36]; /* primary volume tag */
+	char    cge_avoltag[36]; /* alternate volume tag */
+	int     cge_flags;
+};
+/* flags */
+#define CGE_ERRNO     0x01       /* errno available       */
+#define CGE_INVERT    0x02       /* media inverted        */
+#define CGE_SRC       0x04       /* media src available   */
+#define CGE_IDLUN     0x08       /* ID+LUN available      */
+#define CGE_PVOLTAG   0x10       /* primary volume tag available */
+#define CGE_AVOLTAG   0x20       /* alternate volume tag available */
+
+
+/*
+ * CHIOSVOLTAG
+ *    set volume tag
+ */
+struct changer_set_voltag {
+	int	csv_type;	 /* type/unit */
+	int	csv_unit;
+	char    csv_voltag[36];  /* volume tag */
+	int     csv_flags;
+};
+#define CSV_PVOLTAG   0x01       /* primary volume tag */
+#define CSV_AVOLTAG   0x02       /* alternate volume tag */
+#define CSV_CLEARTAG  0x04       /* clear volume tag */
+
+/* ioctls */
+#define CHIOMOVE       _IOW('c', 1,struct changer_move)
+#define CHIOEXCHANGE   _IOW('c', 2,struct changer_exchange)
+#define CHIOPOSITION   _IOW('c', 3,struct changer_position)
+#define CHIOGPICKER    _IOR('c', 4,int)                        /* not impl. */
+#define CHIOSPICKER    _IOW('c', 5,int)                        /* not impl. */
+#define CHIOGPARAMS    _IOR('c', 6,struct changer_params)
+#define CHIOGSTATUS    _IOW('c', 8,struct changer_element_status)
+#define CHIOGELEM      _IOW('c',16,struct changer_get_element)
+#define CHIOINITELEM   _IO('c',17)
+#define CHIOSVOLTAG    _IOW('c',18,struct changer_set_voltag)
+#define CHIOGVPARAMS   _IOR('c',19,struct changer_vendor_params)
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -uNr linux-2.6.32/usr/include/linux/cm4000_cs.h clean_modified/linux-2.6.32/usr/include/linux/cm4000_cs.h
--- linux-2.6.32/usr/include/linux/cm4000_cs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cm4000_cs.h	2019-04-14 13:24:02.932464398 -0500
@@ -0,0 +1,62 @@
+#ifndef	_CM4000_H_
+#define	_CM4000_H_
+
+#include <linux/types.h>
+
+#define	MAX_ATR			33
+
+#define	CM4000_MAX_DEV		4
+
+/* those two structures are passed via ioctl() from/to userspace.  They are
+ * used by existing userspace programs, so I kepth the awkward "bIFSD" naming
+ * not to break compilation of userspace apps. -HW */
+
+typedef struct atreq {
+	__s32 atr_len;
+	unsigned char atr[64];
+	__s32 power_act;
+	unsigned char bIFSD;
+	unsigned char bIFSC;
+} atreq_t;
+
+
+/* what is particularly stupid in the original driver is the arch-dependant
+ * member sizes. This leads to CONFIG_COMPAT breakage, since 32bit userspace
+ * will lay out the structure members differently than the 64bit kernel.
+ *
+ * I've changed "ptsreq.protocol" from "unsigned long" to "__u32".
+ * On 32bit this will make no difference.  With 64bit kernels, it will make
+ * 32bit apps work, too.
+ */
+
+typedef struct ptsreq {
+	__u32 protocol; /*T=0: 2^0, T=1:  2^1*/
+ 	unsigned char flags;
+ 	unsigned char pts1;
+ 	unsigned char pts2;
+	unsigned char pts3;
+} ptsreq_t;
+
+#define	CM_IOC_MAGIC		'c'
+#define	CM_IOC_MAXNR	        255
+
+#define	CM_IOCGSTATUS		_IOR (CM_IOC_MAGIC, 0, unsigned char *)
+#define	CM_IOCGATR		_IOWR(CM_IOC_MAGIC, 1, atreq_t *)
+#define	CM_IOCSPTS		_IOW (CM_IOC_MAGIC, 2, ptsreq_t *)
+#define	CM_IOCSRDR		_IO  (CM_IOC_MAGIC, 3)
+#define CM_IOCARDOFF            _IO  (CM_IOC_MAGIC, 4)
+
+#define CM_IOSDBGLVL            _IOW(CM_IOC_MAGIC, 250, int*)
+
+/* card and device states */
+#define	CM_CARD_INSERTED		0x01
+#define	CM_CARD_POWERED			0x02
+#define	CM_ATR_PRESENT			0x04
+#define	CM_ATR_VALID	 		0x08
+#define	CM_STATE_VALID			0x0f
+/* extra info only from CM4000 */
+#define	CM_NO_READER			0x10
+#define	CM_BAD_CARD			0x20
+
+
+#endif	/* _CM4000_H_ */
diff -uNr linux-2.6.32/usr/include/linux/cn_proc.h clean_modified/linux-2.6.32/usr/include/linux/cn_proc.h
--- linux-2.6.32/usr/include/linux/cn_proc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cn_proc.h	2019-04-14 13:24:02.932464398 -0500
@@ -0,0 +1,106 @@
+/*
+ * cn_proc.h - process events connector
+ *
+ * Copyright (C) Matt Helsley, IBM Corp. 2005
+ * Based on cn_fork.h by Nguyen Anh Quynh and Guillaume Thouvenin
+ * Copyright (C) 2005 Nguyen Anh Quynh <aquynh@gmail.com>
+ * Copyright (C) 2005 Guillaume Thouvenin <guillaume.thouvenin@bull.net>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CN_PROC_H
+#define CN_PROC_H
+
+#include <linux/types.h>
+
+/*
+ * Userspace sends this enum to register with the kernel that it is listening
+ * for events on the connector.
+ */
+enum proc_cn_mcast_op {
+	PROC_CN_MCAST_LISTEN = 1,
+	PROC_CN_MCAST_IGNORE = 2
+};
+
+/*
+ * From the user's point of view, the process
+ * ID is the thread group ID and thread ID is the internal
+ * kernel "pid". So, fields are assigned as follow:
+ *
+ *  In user space     -  In  kernel space
+ *
+ * parent process ID  =  parent->tgid
+ * parent thread  ID  =  parent->pid
+ * child  process ID  =  child->tgid
+ * child  thread  ID  =  child->pid
+ */
+
+struct proc_event {
+	enum what {
+		/* Use successive bits so the enums can be used to record
+		 * sets of events as well
+		 */
+		PROC_EVENT_NONE = 0x00000000,
+		PROC_EVENT_FORK = 0x00000001,
+		PROC_EVENT_EXEC = 0x00000002,
+		PROC_EVENT_UID  = 0x00000004,
+		PROC_EVENT_GID  = 0x00000040,
+		PROC_EVENT_SID  = 0x00000080,
+		/* "next" should be 0x00000400 */
+		/* "last" is the last process event: exit */
+		PROC_EVENT_EXIT = 0x80000000
+	} what;
+	__u32 cpu;
+	__u64 __attribute__((aligned(8))) timestamp_ns;
+		/* Number of nano seconds since system boot */
+	union { /* must be last field of proc_event struct */
+		struct {
+			__u32 err;
+		} ack;
+
+		struct fork_proc_event {
+			__kernel_pid_t parent_pid;
+			__kernel_pid_t parent_tgid;
+			__kernel_pid_t child_pid;
+			__kernel_pid_t child_tgid;
+		} fork;
+
+		struct exec_proc_event {
+			__kernel_pid_t process_pid;
+			__kernel_pid_t process_tgid;
+		} exec;
+
+		struct id_proc_event {
+			__kernel_pid_t process_pid;
+			__kernel_pid_t process_tgid;
+			union {
+				__u32 ruid; /* task uid */
+				__u32 rgid; /* task gid */
+			} r;
+			union {
+				__u32 euid;
+				__u32 egid;
+			} e;
+		} id;
+
+		struct sid_proc_event {
+			__kernel_pid_t process_pid;
+			__kernel_pid_t process_tgid;
+		} sid;
+
+		struct exit_proc_event {
+			__kernel_pid_t process_pid;
+			__kernel_pid_t process_tgid;
+			__u32 exit_code, exit_signal;
+		} exit;
+	} event_data;
+};
+
+#endif	/* CN_PROC_H */
diff -uNr linux-2.6.32/usr/include/linux/coda.h clean_modified/linux-2.6.32/usr/include/linux/coda.h
--- linux-2.6.32/usr/include/linux/coda.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/coda.h	2019-04-14 13:24:02.933443113 -0500
@@ -0,0 +1,737 @@
+/* 
+   You may distribute this file under either of the two licenses that
+   follow at your discretion.
+*/
+
+/* BLURB lgpl
+
+                           Coda File System
+                              Release 5
+
+          Copyright (c) 1987-1999 Carnegie Mellon University
+                  Additional copyrights listed below
+
+This code is distributed "AS IS" without warranty of any kind under
+the terms of the GNU Library General Public Licence Version 2, as
+shown in the file LICENSE, or under the license shown below. The
+technical and financial contributors to Coda are listed in the file
+CREDITS.
+
+                        Additional copyrights 
+*/
+
+/*
+
+            Coda: an Experimental Distributed File System
+                             Release 4.0
+
+          Copyright (c) 1987-1999 Carnegie Mellon University
+                         All Rights Reserved
+
+Permission  to  use, copy, modify and distribute this software and its
+documentation is hereby granted,  provided  that  both  the  copyright
+notice  and  this  permission  notice  appear  in  all  copies  of the
+software, derivative works or  modified  versions,  and  any  portions
+thereof, and that both notices appear in supporting documentation, and
+that credit is given to Carnegie Mellon University  in  all  documents
+and publicity pertaining to direct or indirect use of this code or its
+derivatives.
+
+CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
+SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
+FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
+DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
+RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
+ANY DERIVATIVE WORK.
+
+Carnegie  Mellon  encourages  users  of  this  software  to return any
+improvements or extensions that  they  make,  and  to  grant  Carnegie
+Mellon the rights to redistribute these changes without encumbrance.
+*/
+
+/*
+ *
+ * Based on cfs.h from Mach, but revamped for increased simplicity.
+ * Linux modifications by 
+ * Peter Braam, Aug 1996
+ */
+
+#ifndef _CODA_HEADER_
+#define _CODA_HEADER_
+
+
+/* Catch new _KERNEL defn for NetBSD and DJGPP/__CYGWIN32__ */
+#if defined(__NetBSD__) || \
+  ((defined(DJGPP) || defined(__CYGWIN32__)) && !defined(KERNEL))
+#include <sys/types.h>
+#endif 
+
+#ifndef CODA_MAXSYMLINKS
+#define CODA_MAXSYMLINKS 10
+#endif
+
+#if defined(DJGPP) || defined(__CYGWIN32__)
+#ifdef KERNEL
+typedef unsigned long u_long;
+typedef unsigned int u_int;
+typedef unsigned short u_short;
+typedef u_long ino_t;
+typedef u_long dev_t;
+typedef void * caddr_t;
+#ifdef DOS
+typedef unsigned __int64 u_quad_t;
+#else 
+typedef unsigned long long u_quad_t;
+#endif
+
+#define __inline__
+
+struct timespec {
+        long       ts_sec;
+        long       ts_nsec;
+};
+#else  /* DJGPP but not KERNEL */
+#include <sys/time.h>
+typedef unsigned long long u_quad_t;
+#endif /* !KERNEL */
+#endif /* !DJGPP */
+
+
+#if defined(__linux__)
+#include <linux/time.h>
+#define cdev_t u_quad_t
+#if !defined(_UQUAD_T_) && (!defined(__GLIBC__) || __GLIBC__ < 2)
+#define _UQUAD_T_ 1
+typedef unsigned long long u_quad_t;
+#endif
+#else
+#define cdev_t dev_t
+#endif
+
+#ifdef __CYGWIN32__
+struct timespec {
+        time_t  tv_sec;         /* seconds */
+        long    tv_nsec;        /* nanoseconds */
+};
+#endif
+
+#ifndef __BIT_TYPES_DEFINED__
+#define __BIT_TYPES_DEFINED__
+typedef signed char	      int8_t;
+typedef unsigned char	    u_int8_t;
+typedef short		     int16_t;
+typedef unsigned short	   u_int16_t;
+typedef int		     int32_t;
+typedef unsigned int	   u_int32_t;
+#endif
+
+
+/*
+ * Cfs constants
+ */
+#define CODA_MAXNAMLEN   255
+#define CODA_MAXPATHLEN  1024
+#define CODA_MAXSYMLINK  10
+
+/* these are Coda's version of O_RDONLY etc combinations
+ * to deal with VFS open modes
+ */
+#define	C_O_READ	0x001
+#define	C_O_WRITE       0x002
+#define C_O_TRUNC       0x010
+#define C_O_EXCL	0x100
+#define C_O_CREAT	0x200
+
+/* these are to find mode bits in Venus */ 
+#define C_M_READ  00400
+#define C_M_WRITE 00200
+
+/* for access Venus will use */
+#define C_A_C_OK    8               /* Test for writing upon create.  */
+#define C_A_R_OK    4               /* Test for read permission.  */
+#define C_A_W_OK    2               /* Test for write permission.  */
+#define C_A_X_OK    1               /* Test for execute permission.  */
+#define C_A_F_OK    0               /* Test for existence.  */
+
+
+
+#ifndef _VENUS_DIRENT_T_
+#define _VENUS_DIRENT_T_ 1
+struct venus_dirent {
+        u_int32_t d_fileno;		/* file number of entry */
+        u_int16_t d_reclen;		/* length of this record */
+        u_int8_t  d_type;			/* file type, see below */
+        u_int8_t  d_namlen;		/* length of string in d_name */
+        char	  d_name[CODA_MAXNAMLEN + 1];/* name must be no longer than this */
+};
+#undef DIRSIZ
+#define DIRSIZ(dp)      ((sizeof (struct venus_dirent) - (CODA_MAXNAMLEN+1)) + \
+                         (((dp)->d_namlen+1 + 3) &~ 3))
+
+/*
+ * File types
+ */
+#define	CDT_UNKNOWN	 0
+#define	CDT_FIFO	 1
+#define	CDT_CHR		 2
+#define	CDT_DIR		 4
+#define	CDT_BLK		 6
+#define	CDT_REG		 8
+#define	CDT_LNK		10
+#define	CDT_SOCK	12
+#define	CDT_WHT		14
+
+/*
+ * Convert between stat structure types and directory types.
+ */
+#define	IFTOCDT(mode)	(((mode) & 0170000) >> 12)
+#define	CDTTOIF(dirtype)	((dirtype) << 12)
+
+#endif
+
+#ifndef _VUID_T_
+#define _VUID_T_
+typedef u_int32_t vuid_t;
+typedef u_int32_t vgid_t;
+#endif /*_VUID_T_ */
+
+struct CodaFid {
+	u_int32_t opaque[4];
+};
+
+#define coda_f2i(fid)\
+	(fid ? (fid->opaque[3] ^ (fid->opaque[2]<<10) ^ (fid->opaque[1]<<20) ^ fid->opaque[0]) : 0)
+
+#ifndef _VENUS_VATTR_T_
+#define _VENUS_VATTR_T_
+/*
+ * Vnode types.  VNON means no type.
+ */
+enum coda_vtype	{ C_VNON, C_VREG, C_VDIR, C_VBLK, C_VCHR, C_VLNK, C_VSOCK, C_VFIFO, C_VBAD };
+
+struct coda_vattr {
+	long     	va_type;	/* vnode type (for create) */
+	u_short		va_mode;	/* files access mode and type */
+	short		va_nlink;	/* number of references to file */
+	vuid_t		va_uid;		/* owner user id */
+	vgid_t		va_gid;		/* owner group id */
+	long		va_fileid;	/* file id */
+	u_quad_t	va_size;	/* file size in bytes */
+	long		va_blocksize;	/* blocksize preferred for i/o */
+	struct timespec	va_atime;	/* time of last access */
+	struct timespec	va_mtime;	/* time of last modification */
+	struct timespec	va_ctime;	/* time file changed */
+	u_long		va_gen;		/* generation number of file */
+	u_long		va_flags;	/* flags defined for file */
+	cdev_t	        va_rdev;	/* device special file represents */
+	u_quad_t	va_bytes;	/* bytes of disk space held by file */
+	u_quad_t	va_filerev;	/* file modification number */
+};
+
+#endif 
+
+/* structure used by CODA_STATFS for getting cache information from venus */
+struct coda_statfs {
+    int32_t f_blocks;
+    int32_t f_bfree;
+    int32_t f_bavail;
+    int32_t f_files;
+    int32_t f_ffree;
+};
+
+/*
+ * Kernel <--> Venus communications.
+ */
+
+#define CODA_ROOT	2
+#define CODA_OPEN_BY_FD	3
+#define CODA_OPEN	4
+#define CODA_CLOSE	5
+#define CODA_IOCTL	6
+#define CODA_GETATTR	7
+#define CODA_SETATTR	8
+#define CODA_ACCESS	9
+#define CODA_LOOKUP	10
+#define CODA_CREATE	11
+#define CODA_REMOVE	12
+#define CODA_LINK	13
+#define CODA_RENAME	14
+#define CODA_MKDIR	15
+#define CODA_RMDIR	16
+#define CODA_SYMLINK	18
+#define CODA_READLINK	19
+#define CODA_FSYNC	20
+#define CODA_VGET	22
+#define CODA_SIGNAL	23
+#define CODA_REPLACE	 24 /* DOWNCALL */
+#define CODA_FLUSH       25 /* DOWNCALL */
+#define CODA_PURGEUSER   26 /* DOWNCALL */
+#define CODA_ZAPFILE     27 /* DOWNCALL */
+#define CODA_ZAPDIR      28 /* DOWNCALL */
+#define CODA_PURGEFID    30 /* DOWNCALL */
+#define CODA_OPEN_BY_PATH 31
+#define CODA_RESOLVE     32
+#define CODA_REINTEGRATE 33
+#define CODA_STATFS	 34
+#define CODA_STORE	 35
+#define CODA_RELEASE	 36
+#define CODA_NCALLS 37
+
+#define DOWNCALL(opcode) (opcode >= CODA_REPLACE && opcode <= CODA_PURGEFID)
+
+#define VC_MAXDATASIZE	    8192
+#define VC_MAXMSGSIZE      sizeof(union inputArgs)+sizeof(union outputArgs) +\
+                            VC_MAXDATASIZE  
+
+#define CIOC_KERNEL_VERSION _IOWR('c', 10, size_t)
+
+#define CODA_KERNEL_VERSION 3 /* 128-bit file identifiers */
+
+/*
+ *        Venus <-> Coda  RPC arguments
+ */
+struct coda_in_hdr {
+    u_int32_t opcode;
+    u_int32_t unique;	    /* Keep multiple outstanding msgs distinct */
+    pid_t pid;
+    pid_t pgid;
+    vuid_t uid;
+};
+
+/* Really important that opcode and unique are 1st two fields! */
+struct coda_out_hdr {
+    u_int32_t opcode;
+    u_int32_t unique;	
+    u_int32_t result;
+};
+
+/* coda_root: NO_IN */
+struct coda_root_out {
+    struct coda_out_hdr oh;
+    struct CodaFid VFid;
+};
+
+struct coda_root_in {
+    struct coda_in_hdr in;
+};
+
+/* coda_open: */
+struct coda_open_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_open_out {
+    struct coda_out_hdr oh;
+    cdev_t	dev;
+    ino_t	inode;
+};
+
+
+/* coda_store: */
+struct coda_store_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_store_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_release: */
+struct coda_release_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_release_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_close: */
+struct coda_close_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_close_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_ioctl: */
+struct coda_ioctl_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	cmd;
+    int	len;
+    int	rwflag;
+    char *data;			/* Place holder for data. */
+};
+
+struct coda_ioctl_out {
+    struct coda_out_hdr oh;
+    int	len;
+    caddr_t	data;		/* Place holder for data. */
+};
+
+
+/* coda_getattr: */
+struct coda_getattr_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+};
+
+struct coda_getattr_out {
+    struct coda_out_hdr oh;
+    struct coda_vattr attr;
+};
+
+
+/* coda_setattr: NO_OUT */
+struct coda_setattr_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    struct coda_vattr attr;
+};
+
+struct coda_setattr_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_access: NO_OUT */
+struct coda_access_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_access_out {
+    struct coda_out_hdr out;
+};
+
+
+/* lookup flags */
+#define CLU_CASE_SENSITIVE     0x01
+#define CLU_CASE_INSENSITIVE   0x02
+
+/* coda_lookup: */
+struct  coda_lookup_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int         name;		/* Place holder for data. */
+    int         flags;	
+};
+
+struct coda_lookup_out {
+    struct coda_out_hdr oh;
+    struct CodaFid VFid;
+    int	vtype;
+};
+
+
+/* coda_create: */
+struct coda_create_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    struct coda_vattr attr;
+    int excl;
+    int mode;
+    int 	name;		/* Place holder for data. */
+};
+
+struct coda_create_out {
+    struct coda_out_hdr oh;
+    struct CodaFid VFid;
+    struct coda_vattr attr;
+};
+
+
+/* coda_remove: NO_OUT */
+struct coda_remove_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int name;		/* Place holder for data. */
+};
+
+struct coda_remove_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_link: NO_OUT */
+struct coda_link_in {
+    struct coda_in_hdr ih;
+    struct CodaFid sourceFid;	/* cnode to link *to* */
+    struct CodaFid destFid;	/* Directory in which to place link */
+    int tname;		/* Place holder for data. */
+};
+
+struct coda_link_out {
+    struct coda_out_hdr out;
+};
+
+
+/* coda_rename: NO_OUT */
+struct coda_rename_in {
+    struct coda_in_hdr ih;
+    struct CodaFid sourceFid;
+    int 	srcname;
+    struct CodaFid destFid;
+    int 	destname;
+};
+
+struct coda_rename_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_mkdir: */
+struct coda_mkdir_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    struct coda_vattr attr;
+    int	   name;		/* Place holder for data. */
+};
+
+struct coda_mkdir_out {
+    struct coda_out_hdr oh;
+    struct CodaFid VFid;
+    struct coda_vattr attr;
+};
+
+
+/* coda_rmdir: NO_OUT */
+struct coda_rmdir_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int name;		/* Place holder for data. */
+};
+
+struct coda_rmdir_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_symlink: NO_OUT */
+struct coda_symlink_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;	/* Directory to put symlink in */
+    int srcname;
+    struct coda_vattr attr;
+    int tname;
+};
+
+struct coda_symlink_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_readlink: */
+struct coda_readlink_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+};
+
+struct coda_readlink_out {
+    struct coda_out_hdr oh;
+    int	count;
+    caddr_t	data;		/* Place holder for data. */
+};
+
+
+/* coda_fsync: NO_OUT */
+struct coda_fsync_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+};
+
+struct coda_fsync_out {
+    struct coda_out_hdr out;
+};
+
+/* coda_vget: */
+struct coda_vget_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+};
+
+struct coda_vget_out {
+    struct coda_out_hdr oh;
+    struct CodaFid VFid;
+    int	vtype;
+};
+
+
+/* CODA_SIGNAL is out-of-band, doesn't need data. */
+/* CODA_INVALIDATE is a venus->kernel call */
+/* CODA_FLUSH is a venus->kernel call */
+
+/* coda_purgeuser: */
+/* CODA_PURGEUSER is a venus->kernel call */
+struct coda_purgeuser_out {
+    struct coda_out_hdr oh;
+    vuid_t uid;
+};
+
+/* coda_zapfile: */
+/* CODA_ZAPFILE is a venus->kernel call */
+struct coda_zapfile_out {  
+    struct coda_out_hdr oh;
+    struct CodaFid CodaFid;
+};
+
+/* coda_zapdir: */
+/* CODA_ZAPDIR is a venus->kernel call */	
+struct coda_zapdir_out {	  
+    struct coda_out_hdr oh;
+    struct CodaFid CodaFid;
+};
+
+/* coda_purgefid: */
+/* CODA_PURGEFID is a venus->kernel call */	
+struct coda_purgefid_out { 
+    struct coda_out_hdr oh;
+    struct CodaFid CodaFid;
+};
+
+/* coda_replace: */
+/* CODA_REPLACE is a venus->kernel call */	
+struct coda_replace_out { /* coda_replace is a venus->kernel call */
+    struct coda_out_hdr oh;
+    struct CodaFid NewFid;
+    struct CodaFid OldFid;
+};
+
+/* coda_open_by_fd: */
+struct coda_open_by_fd_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int        flags;
+};
+
+struct coda_open_by_fd_out {
+    struct coda_out_hdr oh;
+    int fd;
+
+};
+
+/* coda_open_by_path: */
+struct coda_open_by_path_in {
+    struct coda_in_hdr ih;
+    struct CodaFid VFid;
+    int	flags;
+};
+
+struct coda_open_by_path_out {
+    struct coda_out_hdr oh;
+	int path;
+};
+
+/* coda_statfs: NO_IN */
+struct coda_statfs_in {
+    struct coda_in_hdr in;
+};
+
+struct coda_statfs_out {
+    struct coda_out_hdr oh;
+    struct coda_statfs stat;
+};
+
+/* 
+ * Occasionally, we don't cache the fid returned by CODA_LOOKUP. 
+ * For instance, if the fid is inconsistent. 
+ * This case is handled by setting the top bit of the type result parameter.
+ */
+#define CODA_NOCACHE          0x80000000
+
+union inputArgs {
+    struct coda_in_hdr ih;		/* NB: every struct below begins with an ih */
+    struct coda_open_in coda_open;
+    struct coda_store_in coda_store;
+    struct coda_release_in coda_release;
+    struct coda_close_in coda_close;
+    struct coda_ioctl_in coda_ioctl;
+    struct coda_getattr_in coda_getattr;
+    struct coda_setattr_in coda_setattr;
+    struct coda_access_in coda_access;
+    struct coda_lookup_in coda_lookup;
+    struct coda_create_in coda_create;
+    struct coda_remove_in coda_remove;
+    struct coda_link_in coda_link;
+    struct coda_rename_in coda_rename;
+    struct coda_mkdir_in coda_mkdir;
+    struct coda_rmdir_in coda_rmdir;
+    struct coda_symlink_in coda_symlink;
+    struct coda_readlink_in coda_readlink;
+    struct coda_fsync_in coda_fsync;
+    struct coda_vget_in coda_vget;
+    struct coda_open_by_fd_in coda_open_by_fd;
+    struct coda_open_by_path_in coda_open_by_path;
+    struct coda_statfs_in coda_statfs;
+};
+
+union outputArgs {
+    struct coda_out_hdr oh;		/* NB: every struct below begins with an oh */
+    struct coda_root_out coda_root;
+    struct coda_open_out coda_open;
+    struct coda_ioctl_out coda_ioctl;
+    struct coda_getattr_out coda_getattr;
+    struct coda_lookup_out coda_lookup;
+    struct coda_create_out coda_create;
+    struct coda_mkdir_out coda_mkdir;
+    struct coda_readlink_out coda_readlink;
+    struct coda_vget_out coda_vget;
+    struct coda_purgeuser_out coda_purgeuser;
+    struct coda_zapfile_out coda_zapfile;
+    struct coda_zapdir_out coda_zapdir;
+    struct coda_purgefid_out coda_purgefid;
+    struct coda_replace_out coda_replace;
+    struct coda_open_by_fd_out coda_open_by_fd;
+    struct coda_open_by_path_out coda_open_by_path;
+    struct coda_statfs_out coda_statfs;
+};    
+
+union coda_downcalls {
+    /* CODA_INVALIDATE is a venus->kernel call */
+    /* CODA_FLUSH is a venus->kernel call */
+    struct coda_purgeuser_out purgeuser;
+    struct coda_zapfile_out zapfile;
+    struct coda_zapdir_out zapdir;
+    struct coda_purgefid_out purgefid;
+    struct coda_replace_out replace;
+};
+
+
+/*
+ * Used for identifying usage of "Control" and pioctls
+ */
+
+#define PIOCPARM_MASK 0x0000ffff
+struct ViceIoctl {
+        void *in;        /* Data to be transferred in */
+        void *out;       /* Data to be transferred out */
+        u_short in_size;        /* Size of input buffer <= 2K */
+        u_short out_size;       /* Maximum size of output buffer, <= 2K */
+};
+
+struct PioctlData {
+        const char *path;
+        int follow;
+        struct ViceIoctl vi;
+};
+
+#define CODA_CONTROL		".CONTROL"
+#define CODA_CONTROLLEN		8
+#define CTL_INO			-1
+
+/* Data passed to mount */
+
+#define CODA_MOUNT_VERSION 1
+
+struct coda_mount_data {
+	int		version;
+	int		fd;       /* Opened device */
+};
+
+#endif 
+
diff -uNr linux-2.6.32/usr/include/linux/coda_psdev.h clean_modified/linux-2.6.32/usr/include/linux/coda_psdev.h
--- linux-2.6.32/usr/include/linux/coda_psdev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/coda_psdev.h	2019-04-14 13:24:02.933443113 -0500
@@ -0,0 +1,27 @@
+#ifndef __CODA_PSDEV_H
+#define __CODA_PSDEV_H
+
+#include <linux/magic.h>
+
+#define CODA_PSDEV_MAJOR 67
+#define MAX_CODADEVS  5	   /* how many do we allow */
+
+
+/* messages between coda filesystem in kernel and Venus */
+struct upc_req {
+	struct list_head    uc_chain;
+	caddr_t	            uc_data;
+	u_short	            uc_flags;
+	u_short             uc_inSize;  /* Size is at most 5000 bytes */
+	u_short	            uc_outSize;
+	u_short	            uc_opcode;  /* copied from data to save lookup */
+	int		    uc_unique;
+	wait_queue_head_t   uc_sleep;   /* process' wait queue */
+};
+
+#define REQ_ASYNC  0x1
+#define REQ_READ   0x2
+#define REQ_WRITE  0x4
+#define REQ_ABORT  0x8
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/coff.h clean_modified/linux-2.6.32/usr/include/linux/coff.h
--- linux-2.6.32/usr/include/linux/coff.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/coff.h	2019-04-14 13:24:02.934424506 -0500
@@ -0,0 +1,351 @@
+/* This file is derived from the GAS 2.1.4 assembler control file.
+   The GAS product is under the GNU General Public License, version 2 or later.
+   As such, this file is also under that license.
+
+   If the file format changes in the COFF object, this file should be
+   subsequently updated to reflect the changes.
+
+   The actual loader module only uses a few of these structures. The full
+   set is documented here because I received the full set. If you wish
+   more information about COFF, then O'Reilly has a very excellent book.
+*/
+
+#define  E_SYMNMLEN  8   /* Number of characters in a symbol name         */
+#define  E_FILNMLEN 14   /* Number of characters in a file name           */
+#define  E_DIMNUM    4   /* Number of array dimensions in auxiliary entry */
+
+/*
+ * These defines are byte order independent. There is no alignment of fields
+ * permitted in the structures. Therefore they are declared as characters
+ * and the values loaded from the character positions. It also makes it
+ * nice to have it "endian" independent.
+ */
+ 
+/* Load a short int from the following tables with little-endian formats */
+#define COFF_SHORT_L(ps) ((short)(((unsigned short)((unsigned char)ps[1])<<8)|\
+				  ((unsigned short)((unsigned char)ps[0]))))
+
+/* Load a long int from the following tables with little-endian formats */
+#define COFF_LONG_L(ps) (((long)(((unsigned long)((unsigned char)ps[3])<<24) |\
+				 ((unsigned long)((unsigned char)ps[2])<<16) |\
+				 ((unsigned long)((unsigned char)ps[1])<<8)  |\
+				 ((unsigned long)((unsigned char)ps[0])))))
+ 
+/* Load a short int from the following tables with big-endian formats */
+#define COFF_SHORT_H(ps) ((short)(((unsigned short)((unsigned char)ps[0])<<8)|\
+				  ((unsigned short)((unsigned char)ps[1]))))
+
+/* Load a long int from the following tables with big-endian formats */
+#define COFF_LONG_H(ps) (((long)(((unsigned long)((unsigned char)ps[0])<<24) |\
+				 ((unsigned long)((unsigned char)ps[1])<<16) |\
+				 ((unsigned long)((unsigned char)ps[2])<<8)  |\
+				 ((unsigned long)((unsigned char)ps[3])))))
+
+/* These may be overridden later by brain dead implementations which generate
+   a big-endian header with little-endian data. In that case, generate a
+   replacement macro which tests a flag and uses either of the two above
+   as appropriate. */
+
+#define COFF_LONG(v)   COFF_LONG_L(v)
+#define COFF_SHORT(v)  COFF_SHORT_L(v)
+
+/*** coff information for Intel 386/486.  */
+
+/********************** FILE HEADER **********************/
+
+struct COFF_filehdr {
+	char f_magic[2];	/* magic number			*/
+	char f_nscns[2];	/* number of sections		*/
+	char f_timdat[4];	/* time & date stamp		*/
+	char f_symptr[4];	/* file pointer to symtab	*/
+	char f_nsyms[4];	/* number of symtab entries	*/
+	char f_opthdr[2];	/* sizeof(optional hdr)		*/
+	char f_flags[2];	/* flags			*/
+};
+
+/*
+ *   Bits for f_flags:
+ *
+ *	F_RELFLG	relocation info stripped from file
+ *	F_EXEC		file is executable  (i.e. no unresolved external
+ *			references)
+ *	F_LNNO		line numbers stripped from file
+ *	F_LSYMS		local symbols stripped from file
+ *	F_MINMAL	this is a minimal object file (".m") output of fextract
+ *	F_UPDATE	this is a fully bound update file, output of ogen
+ *	F_SWABD		this file has had its bytes swabbed (in names)
+ *	F_AR16WR	this file has the byte ordering of an AR16WR
+ *			(e.g. 11/70) machine
+ *	F_AR32WR	this file has the byte ordering of an AR32WR machine
+ *			(e.g. vax and iNTEL 386)
+ *	F_AR32W		this file has the byte ordering of an AR32W machine
+ *			(e.g. 3b,maxi)
+ *	F_PATCH		file contains "patch" list in optional header
+ *	F_NODF		(minimal file only) no decision functions for
+ *			replaced functions
+ */
+
+#define  COFF_F_RELFLG		0000001
+#define  COFF_F_EXEC		0000002
+#define  COFF_F_LNNO		0000004
+#define  COFF_F_LSYMS		0000010
+#define  COFF_F_MINMAL		0000020
+#define  COFF_F_UPDATE		0000040
+#define  COFF_F_SWABD		0000100
+#define  COFF_F_AR16WR		0000200
+#define  COFF_F_AR32WR		0000400
+#define  COFF_F_AR32W		0001000
+#define  COFF_F_PATCH		0002000
+#define  COFF_F_NODF		0002000
+
+#define	COFF_I386MAGIC	        0x14c   /* Linux's system    */
+
+#if 0   /* Perhaps, someday, these formats may be used.      */
+#define COFF_I386PTXMAGIC	0x154
+#define COFF_I386AIXMAGIC	0x175   /* IBM's AIX system  */
+#define COFF_I386BADMAG(x) ((COFF_SHORT((x).f_magic) != COFF_I386MAGIC) \
+			  && COFF_SHORT((x).f_magic) != COFF_I386PTXMAGIC \
+			  && COFF_SHORT((x).f_magic) != COFF_I386AIXMAGIC)
+#else
+#define COFF_I386BADMAG(x) (COFF_SHORT((x).f_magic) != COFF_I386MAGIC)
+#endif
+
+#define	COFF_FILHDR	struct COFF_filehdr
+#define	COFF_FILHSZ	sizeof(COFF_FILHDR)
+
+/********************** AOUT "OPTIONAL HEADER" **********************/
+
+/* Linux COFF must have this "optional" header. Standard COFF has no entry
+   location for the "entry" point. They normally would start with the first
+   location of the .text section. This is not a good idea for linux. So,
+   the use of this "optional" header is not optional. It is required.
+
+   Do not be tempted to assume that the size of the optional header is
+   a constant and simply index the next byte by the size of this structure.
+   Use the 'f_opthdr' field in the main coff header for the size of the
+   structure actually written to the file!!
+*/
+
+typedef struct 
+{
+  char 	magic[2];		/* type of file				 */
+  char	vstamp[2];		/* version stamp			 */
+  char	tsize[4];		/* text size in bytes, padded to FW bdry */
+  char	dsize[4];		/* initialized   data "   "		 */
+  char	bsize[4];		/* uninitialized data "   "		 */
+  char	entry[4];		/* entry pt.				 */
+  char 	text_start[4];		/* base of text used for this file       */
+  char 	data_start[4];		/* base of data used for this file       */
+}
+COFF_AOUTHDR;
+
+#define COFF_AOUTSZ (sizeof(COFF_AOUTHDR))
+
+#define COFF_STMAGIC	0401
+#define COFF_OMAGIC     0404
+#define COFF_JMAGIC     0407    /* dirty text and data image, can't share  */
+#define COFF_DMAGIC     0410    /* dirty text segment, data aligned        */
+#define COFF_ZMAGIC     0413    /* The proper magic number for executables  */
+#define COFF_SHMAGIC	0443	/* shared library header                   */
+
+/********************** SECTION HEADER **********************/
+
+struct COFF_scnhdr {
+  char		s_name[8];	/* section name			    */
+  char		s_paddr[4];	/* physical address, aliased s_nlib */
+  char		s_vaddr[4];	/* virtual address		    */
+  char		s_size[4];	/* section size			    */
+  char		s_scnptr[4];	/* file ptr to raw data for section */
+  char		s_relptr[4];	/* file ptr to relocation	    */
+  char		s_lnnoptr[4];	/* file ptr to line numbers	    */
+  char		s_nreloc[2];	/* number of relocation entries	    */
+  char		s_nlnno[2];	/* number of line number entries    */
+  char		s_flags[4];	/* flags			    */
+};
+
+#define	COFF_SCNHDR	struct COFF_scnhdr
+#define	COFF_SCNHSZ	sizeof(COFF_SCNHDR)
+
+/*
+ * names of "special" sections
+ */
+
+#define COFF_TEXT	".text"
+#define COFF_DATA	".data"
+#define COFF_BSS	".bss"
+#define COFF_COMMENT    ".comment"
+#define COFF_LIB        ".lib"
+
+#define COFF_SECT_TEXT  0      /* Section for instruction code             */
+#define COFF_SECT_DATA  1      /* Section for initialized globals          */
+#define COFF_SECT_BSS   2      /* Section for un-initialized globals       */
+#define COFF_SECT_REQD  3      /* Minimum number of sections for good file */
+
+#define COFF_STYP_REG     0x00 /* regular segment                          */
+#define COFF_STYP_DSECT   0x01 /* dummy segment                            */
+#define COFF_STYP_NOLOAD  0x02 /* no-load segment                          */
+#define COFF_STYP_GROUP   0x04 /* group segment                            */
+#define COFF_STYP_PAD     0x08 /* .pad segment                             */
+#define COFF_STYP_COPY    0x10 /* copy section                             */
+#define COFF_STYP_TEXT    0x20 /* .text segment                            */
+#define COFF_STYP_DATA    0x40 /* .data segment                            */
+#define COFF_STYP_BSS     0x80 /* .bss segment                             */
+#define COFF_STYP_INFO   0x200 /* .comment section                         */
+#define COFF_STYP_OVER   0x400 /* overlay section                          */
+#define COFF_STYP_LIB    0x800 /* library section                          */
+
+/*
+ * Shared libraries have the following section header in the data field for
+ * each library.
+ */
+
+struct COFF_slib {
+  char		sl_entsz[4];	/* Size of this entry               */
+  char		sl_pathndx[4];	/* size of the header field         */
+};
+
+#define	COFF_SLIBHD	struct COFF_slib
+#define	COFF_SLIBSZ	sizeof(COFF_SLIBHD)
+
+/********************** LINE NUMBERS **********************/
+
+/* 1 line number entry for every "breakpointable" source line in a section.
+ * Line numbers are grouped on a per function basis; first entry in a function
+ * grouping will have l_lnno = 0 and in place of physical address will be the
+ * symbol table index of the function name.
+ */
+
+struct COFF_lineno {
+  union {
+    char l_symndx[4];	/* function name symbol index, iff l_lnno == 0*/
+    char l_paddr[4];	/* (physical) address of line number	*/
+  } l_addr;
+  char l_lnno[2];	/* line number		*/
+};
+
+#define	COFF_LINENO	struct COFF_lineno
+#define	COFF_LINESZ	6
+
+/********************** SYMBOLS **********************/
+
+#define COFF_E_SYMNMLEN	 8	/* # characters in a short symbol name	*/
+#define COFF_E_FILNMLEN	14	/* # characters in a file name		*/
+#define COFF_E_DIMNUM	 4	/* # array dimensions in auxiliary entry */
+
+/*
+ *  All symbols and sections have the following definition
+ */
+
+struct COFF_syment 
+{
+  union {
+    char e_name[E_SYMNMLEN];    /* Symbol name (first 8 characters) */
+    struct {
+      char e_zeroes[4];         /* Leading zeros */
+      char e_offset[4];         /* Offset if this is a header section */
+    } e;
+  } e;
+
+  char e_value[4];              /* Value (address) of the segment */
+  char e_scnum[2];              /* Section number */
+  char e_type[2];               /* Type of section */
+  char e_sclass[1];             /* Loader class */
+  char e_numaux[1];             /* Number of auxiliary entries which follow */
+};
+
+#define COFF_N_BTMASK	(0xf)   /* Mask for important class bits */
+#define COFF_N_TMASK	(0x30)  /* Mask for important type bits  */
+#define COFF_N_BTSHFT	(4)     /* # bits to shift class field   */
+#define COFF_N_TSHIFT	(2)     /* # bits to shift type field    */
+
+/*
+ *  Auxiliary entries because the main table is too limiting.
+ */
+  
+union COFF_auxent {
+
+/*
+ *  Debugger information
+ */
+
+  struct {
+    char x_tagndx[4];	        /* str, un, or enum tag indx */
+    union {
+      struct {
+	char  x_lnno[2];        /* declaration line number */
+	char  x_size[2];        /* str/union/array size */
+      } x_lnsz;
+      char x_fsize[4];	        /* size of function */
+    } x_misc;
+
+    union {
+      struct {		        /* if ISFCN, tag, or .bb */
+	char x_lnnoptr[4];	/* ptr to fcn line # */
+	char x_endndx[4];	/* entry ndx past block end */
+      } x_fcn;
+
+      struct {		        /* if ISARY, up to 4 dimen. */
+	char x_dimen[E_DIMNUM][2];
+      } x_ary;
+    } x_fcnary;
+
+    char x_tvndx[2];	/* tv index */
+  } x_sym;
+
+/*
+ *   Source file names (debugger information)
+ */
+
+  union {
+    char x_fname[E_FILNMLEN];
+    struct {
+      char x_zeroes[4];
+      char x_offset[4];
+    } x_n;
+  } x_file;
+
+/*
+ *   Section information
+ */
+
+  struct {
+    char x_scnlen[4];	/* section length */
+    char x_nreloc[2];	/* # relocation entries */
+    char x_nlinno[2];	/* # line numbers */
+  } x_scn;
+
+/*
+ *   Transfer vector (branch table)
+ */
+  
+  struct {
+    char x_tvfill[4];	/* tv fill value */
+    char x_tvlen[2];	/* length of .tv */
+    char x_tvran[2][2];	/* tv range */
+  } x_tv;		/* info about .tv section (in auxent of symbol .tv)) */
+};
+
+#define	COFF_SYMENT	struct COFF_syment
+#define	COFF_SYMESZ	18	
+#define	COFF_AUXENT	union COFF_auxent
+#define	COFF_AUXESZ	18
+
+#define COFF_ETEXT	"etext"
+
+/********************** RELOCATION DIRECTIVES **********************/
+
+struct COFF_reloc {
+  char r_vaddr[4];        /* Virtual address of item    */
+  char r_symndx[4];       /* Symbol index in the symtab */
+  char r_type[2];         /* Relocation type            */
+};
+
+#define COFF_RELOC struct COFF_reloc
+#define COFF_RELSZ 10
+
+#define COFF_DEF_DATA_SECTION_ALIGNMENT  4
+#define COFF_DEF_BSS_SECTION_ALIGNMENT   4
+#define COFF_DEF_TEXT_SECTION_ALIGNMENT  4
+
+/* For new sections we haven't heard of before */
+#define COFF_DEF_SECTION_ALIGNMENT       4
diff -uNr linux-2.6.32/usr/include/linux/comstats.h clean_modified/linux-2.6.32/usr/include/linux/comstats.h
--- linux-2.6.32/usr/include/linux/comstats.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/comstats.h	2019-04-14 13:24:02.935403339 -0500
@@ -0,0 +1,119 @@
+/*****************************************************************************/
+
+/*
+ *	comstats.h  -- Serial Port Stats.
+ *
+ *	Copyright (C) 1996-1998  Stallion Technologies
+ *	Copyright (C) 1994-1996  Greg Ungerer.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*****************************************************************************/
+#ifndef	_COMSTATS_H
+#define	_COMSTATS_H
+/*****************************************************************************/
+
+/*
+ *	Serial port stats structure. The structure itself is UART
+ *	independent, but some fields may be UART/driver specific (for
+ *	example state).
+ */
+
+typedef struct {
+	unsigned long	brd;
+	unsigned long	panel;
+	unsigned long	port;
+	unsigned long	hwid;
+	unsigned long	type;
+	unsigned long	txtotal;
+	unsigned long	rxtotal;
+	unsigned long	txbuffered;
+	unsigned long	rxbuffered;
+	unsigned long	rxoverrun;
+	unsigned long	rxparity;
+	unsigned long	rxframing;
+	unsigned long	rxlost;
+	unsigned long	txbreaks;
+	unsigned long	rxbreaks;
+	unsigned long	txxon;
+	unsigned long	txxoff;
+	unsigned long	rxxon;
+	unsigned long	rxxoff;
+	unsigned long	txctson;
+	unsigned long	txctsoff;
+	unsigned long	rxrtson;
+	unsigned long	rxrtsoff;
+	unsigned long	modem;
+	unsigned long	state;
+	unsigned long	flags;
+	unsigned long	ttystate;
+	unsigned long	cflags;
+	unsigned long	iflags;
+	unsigned long	oflags;
+	unsigned long	lflags;
+	unsigned long	signals;
+} comstats_t;
+
+
+/*
+ *	Board stats structure. Returns useful info about the board.
+ */
+
+#define	COM_MAXPANELS	8
+
+typedef struct {
+	unsigned long	panel;
+	unsigned long	type;
+	unsigned long	hwid;
+	unsigned long	nrports;
+} companel_t;
+
+typedef struct {
+	unsigned long	brd;
+	unsigned long	type;
+	unsigned long	hwid;
+	unsigned long	state;
+	unsigned long	ioaddr;
+	unsigned long	ioaddr2;
+	unsigned long	memaddr;
+	unsigned long	irq;
+	unsigned long	nrpanels;
+	unsigned long	nrports;
+	companel_t	panels[COM_MAXPANELS];
+} combrd_t;
+
+
+/*
+ *	Define the ioctl operations for stats stuff.
+ */
+#include <linux/ioctl.h>
+
+#define	COM_GETPORTSTATS	_IO('c',30)
+#define	COM_CLRPORTSTATS	_IO('c',31)
+#define	COM_GETBRDSTATS		_IO('c',32)
+
+
+/*
+ *	Define the set of ioctls that give user level access to the
+ *	private port, panel and board structures. The argument required
+ *	will be driver dependent!  
+ */
+#define	COM_READPORT		_IO('c',40)
+#define	COM_READBOARD		_IO('c',41)
+#define	COM_READPANEL		_IO('c',42)
+
+/*****************************************************************************/
+#endif
diff -uNr linux-2.6.32/usr/include/linux/connector.h clean_modified/linux-2.6.32/usr/include/linux/connector.h
--- linux-2.6.32/usr/include/linux/connector.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/connector.h	2019-04-14 13:24:02.936502480 -0500
@@ -0,0 +1,100 @@
+/*
+ * 	connector.h
+ * 
+ * 2004-2005 Copyright (c) Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ * All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CONNECTOR_H
+#define __CONNECTOR_H
+
+#include <linux/types.h>
+
+#define CN_IDX_CONNECTOR		0xffffffff
+#define CN_VAL_CONNECTOR		0xffffffff
+
+/*
+ * Process Events connector unique ids -- used for message routing
+ */
+#define CN_IDX_PROC			0x1
+#define CN_VAL_PROC			0x1
+#define CN_IDX_CIFS			0x2
+#define CN_VAL_CIFS                     0x1
+#define CN_W1_IDX			0x3	/* w1 communication */
+#define CN_W1_VAL			0x1
+#define CN_IDX_V86D			0x4
+#define CN_VAL_V86D_UVESAFB		0x1
+#define CN_IDX_BB			0x5	/* BlackBoard, from the TSP GPL sampling framework */
+#define CN_DST_IDX			0x6
+#define CN_DST_VAL			0x1
+#define CN_IDX_DM			0x7	/* Device Mapper */
+#define CN_VAL_DM_USERSPACE_LOG		0x1
+
+#define CN_NETLINK_USERS		8
+
+/*
+ * Maximum connector's message size.
+ */
+#define CONNECTOR_MAX_MSG_SIZE		16384
+
+/*
+ * idx and val are unique identifiers which 
+ * are used for message routing and 
+ * must be registered in connector.h for in-kernel usage.
+ */
+
+struct cb_id {
+	__u32 idx;
+	__u32 val;
+};
+
+struct cn_msg {
+	struct cb_id id;
+
+	__u32 seq;
+	__u32 ack;
+
+	__u16 len;		/* Length of the following data */
+	__u16 flags;
+	__u8 data[0];
+};
+
+/*
+ * Notify structure - requests notification about
+ * registering/unregistering idx/val in range [first, first+range].
+ */
+struct cn_notify_req {
+	__u32 first;
+	__u32 range;
+};
+
+/*
+ * Main notification control message
+ * *_notify_num 	- number of appropriate cn_notify_req structures after 
+ *				this struct.
+ * group 		- notification receiver's idx.
+ * len 			- total length of the attached data.
+ */
+struct cn_ctl_msg {
+	__u32 idx_notify_num;
+	__u32 val_notify_num;
+	__u32 group;
+	__u32 len;
+	__u8 data[0];
+};
+
+#endif				/* __CONNECTOR_H */
diff -uNr linux-2.6.32/usr/include/linux/const.h clean_modified/linux-2.6.32/usr/include/linux/const.h
--- linux-2.6.32/usr/include/linux/const.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/const.h	2019-04-14 13:24:02.936502480 -0500
@@ -0,0 +1,24 @@
+/* const.h: Macros for dealing with constants.  */
+
+#ifndef _LINUX_CONST_H
+#define _LINUX_CONST_H
+
+/* Some constant macros are used in both assembler and
+ * C code.  Therefore we cannot annotate them always with
+ * 'UL' and other type specifiers unilaterally.  We
+ * use the following macros to deal with this.
+ *
+ * Similarly, _AT() will cast an expression with a type in C, but
+ * leave it unchanged in asm.
+ */
+
+#ifdef __ASSEMBLY__
+#define _AC(X,Y)	X
+#define _AT(T,X)	X
+#else
+#define __AC(X,Y)	(X##Y)
+#define _AC(X,Y)	__AC(X,Y)
+#define _AT(T,X)	((T)(X))
+#endif
+
+#endif /* !(_LINUX_CONST_H) */
diff -uNr linux-2.6.32/usr/include/linux/cramfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/cramfs_fs.h
--- linux-2.6.32/usr/include/linux/cramfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cramfs_fs.h	2019-04-14 13:24:02.937473841 -0500
@@ -0,0 +1,92 @@
+#ifndef __CRAMFS_H
+#define __CRAMFS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+#define CRAMFS_SIGNATURE	"Compressed ROMFS"
+
+/*
+ * Width of various bitfields in struct cramfs_inode.
+ * Primarily used to generate warnings in mkcramfs.
+ */
+#define CRAMFS_MODE_WIDTH 16
+#define CRAMFS_UID_WIDTH 16
+#define CRAMFS_SIZE_WIDTH 24
+#define CRAMFS_GID_WIDTH 8
+#define CRAMFS_NAMELEN_WIDTH 6
+#define CRAMFS_OFFSET_WIDTH 26
+
+/*
+ * Since inode.namelen is a unsigned 6-bit number, the maximum cramfs
+ * path length is 63 << 2 = 252.
+ */
+#define CRAMFS_MAXPATHLEN (((1 << CRAMFS_NAMELEN_WIDTH) - 1) << 2)
+
+/*
+ * Reasonably terse representation of the inode data.
+ */
+struct cramfs_inode {
+	__u32 mode:CRAMFS_MODE_WIDTH, uid:CRAMFS_UID_WIDTH;
+	/* SIZE for device files is i_rdev */
+	__u32 size:CRAMFS_SIZE_WIDTH, gid:CRAMFS_GID_WIDTH;
+	/* NAMELEN is the length of the file name, divided by 4 and
+           rounded up.  (cramfs doesn't support hard links.) */
+	/* OFFSET: For symlinks and non-empty regular files, this
+	   contains the offset (divided by 4) of the file data in
+	   compressed form (starting with an array of block pointers;
+	   see README).  For non-empty directories it is the offset
+	   (divided by 4) of the inode of the first file in that
+	   directory.  For anything else, offset is zero. */
+	__u32 namelen:CRAMFS_NAMELEN_WIDTH, offset:CRAMFS_OFFSET_WIDTH;
+};
+
+struct cramfs_info {
+	__u32 crc;
+	__u32 edition;
+	__u32 blocks;
+	__u32 files;
+};
+
+/*
+ * Superblock information at the beginning of the FS.
+ */
+struct cramfs_super {
+	__u32 magic;			/* 0x28cd3d45 - random number */
+	__u32 size;			/* length in bytes */
+	__u32 flags;			/* feature flags */
+	__u32 future;			/* reserved for future use */
+	__u8 signature[16];		/* "Compressed ROMFS" */
+	struct cramfs_info fsid;	/* unique filesystem info */
+	__u8 name[16];			/* user-defined name */
+	struct cramfs_inode root;	/* root inode data */
+};
+
+/*
+ * Feature flags
+ *
+ * 0x00000000 - 0x000000ff: features that work for all past kernels
+ * 0x00000100 - 0xffffffff: features that don't work for past kernels
+ */
+#define CRAMFS_FLAG_FSID_VERSION_2	0x00000001	/* fsid version #2 */
+#define CRAMFS_FLAG_SORTED_DIRS		0x00000002	/* sorted dirs */
+#define CRAMFS_FLAG_HOLES		0x00000100	/* support for holes */
+#define CRAMFS_FLAG_WRONG_SIGNATURE	0x00000200	/* reserved */
+#define CRAMFS_FLAG_SHIFTED_ROOT_OFFSET	0x00000400	/* shifted root fs */
+
+/*
+ * Valid values in super.flags.  Currently we refuse to mount
+ * if (flags & ~CRAMFS_SUPPORTED_FLAGS).  Maybe that should be
+ * changed to test super.future instead.
+ */
+#define CRAMFS_SUPPORTED_FLAGS	( 0x000000ff \
+				| CRAMFS_FLAG_HOLES \
+				| CRAMFS_FLAG_WRONG_SIGNATURE \
+				| CRAMFS_FLAG_SHIFTED_ROOT_OFFSET )
+
+/* Uncompression interfaces to the underlying zlib */
+int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen);
+int cramfs_uncompress_init(void);
+void cramfs_uncompress_exit(void);
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/cuda.h clean_modified/linux-2.6.32/usr/include/linux/cuda.h
--- linux-2.6.32/usr/include/linux/cuda.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cuda.h	2019-04-14 13:24:02.937473841 -0500
@@ -0,0 +1,28 @@
+/*
+ * Definitions for talking to the CUDA.  The CUDA is a microcontroller
+ * which controls the ADB, system power, RTC, and various other things.
+ *
+ * Copyright (C) 1996 Paul Mackerras.
+ */
+
+/* CUDA commands (2nd byte) */
+#define CUDA_WARM_START		0
+#define CUDA_AUTOPOLL		1
+#define CUDA_GET_6805_ADDR	2
+#define CUDA_GET_TIME		3
+#define CUDA_GET_PRAM		7
+#define CUDA_SET_6805_ADDR	8
+#define CUDA_SET_TIME		9
+#define CUDA_POWERDOWN		0xa
+#define CUDA_POWERUP_TIME	0xb
+#define CUDA_SET_PRAM		0xc
+#define CUDA_MS_RESET		0xd
+#define CUDA_SEND_DFAC		0xe
+#define CUDA_RESET_SYSTEM	0x11
+#define CUDA_SET_IPL		0x12
+#define CUDA_SET_AUTO_RATE	0x14
+#define CUDA_GET_AUTO_RATE	0x16
+#define CUDA_SET_DEVICE_LIST	0x19
+#define CUDA_GET_DEVICE_LIST	0x1a
+#define CUDA_GET_SET_IIC	0x22
+
diff -uNr linux-2.6.32/usr/include/linux/cyclades.h clean_modified/linux-2.6.32/usr/include/linux/cyclades.h
--- linux-2.6.32/usr/include/linux/cyclades.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cyclades.h	2019-04-14 13:24:02.938337819 -0500
@@ -0,0 +1,493 @@
+/* $Revision: 3.0 $$Date: 1998/11/02 14:20:59 $
+ * linux/include/linux/cyclades.h
+ *
+ * This file was initially written by
+ * Randolph Bentson <bentson@grieg.seaslug.org> and is maintained by
+ * Ivan Passos <ivan@cyclades.com>.
+ *
+ * This file contains the general definitions for the cyclades.c driver
+ *$Log: cyclades.h,v $
+ *Revision 3.1  2002/01/29 11:36:16  henrique
+ *added throttle field on struct cyclades_port to indicate whether the
+ *port is throttled or not
+ *
+ *Revision 3.1  2000/04/19 18:52:52  ivan
+ *converted address fields to unsigned long and added fields for physical
+ *addresses on cyclades_card structure;
+ *
+ *Revision 3.0  1998/11/02 14:20:59  ivan
+ *added nports field on cyclades_card structure;
+ *
+ *Revision 2.5  1998/08/03 16:57:01  ivan
+ *added cyclades_idle_stats structure;
+ * 
+ *Revision 2.4  1998/06/01 12:09:53  ivan
+ *removed closing_wait2 from cyclades_port structure;
+ *
+ *Revision 2.3  1998/03/16 18:01:12  ivan
+ *changes in the cyclades_port structure to get it closer to the 
+ *standard serial port structure;
+ *added constants for new ioctls;
+ *
+ *Revision 2.2  1998/02/17 16:50:00  ivan
+ *changes in the cyclades_port structure (addition of shutdown_wait and 
+ *chip_rev variables);
+ *added constants for new ioctls and for CD1400 rev. numbers.
+ *
+ *Revision 2.1	1997/10/24 16:03:00  ivan
+ *added rflow (which allows enabling the CD1400 special flow control 
+ *feature) and rtsdtr_inv (which allows DTR/RTS pin inversion) to 
+ *cyclades_port structure;
+ *added Alpha support
+ *
+ *Revision 2.0  1997/06/30 10:30:00  ivan
+ *added some new doorbell command constants related to IOCTLW and
+ *UART error signaling
+ *
+ *Revision 1.8  1997/06/03 15:30:00  ivan
+ *added constant ZFIRM_HLT
+ *added constant CyPCI_Ze_win ( = 2 * Cy_PCI_Zwin)
+ *
+ *Revision 1.7  1997/03/26 10:30:00  daniel
+ *new entries at the end of cyclades_port struct to reallocate
+ *variables illegally allocated within card memory.
+ *
+ *Revision 1.6  1996/09/09 18:35:30  bentson
+ *fold in changes for Cyclom-Z -- including structures for
+ *communicating with board as well modest changes to original
+ *structures to support new features.
+ *
+ *Revision 1.5  1995/11/13 21:13:31  bentson
+ *changes suggested by Michael Chastain <mec@duracef.shout.net>
+ *to support use of this file in non-kernel applications
+ *
+ *
+ */
+
+#ifndef _LINUX_CYCLADES_H
+#define _LINUX_CYCLADES_H
+
+#include <linux/types.h>
+
+struct cyclades_monitor {
+        unsigned long           int_count;
+        unsigned long           char_count;
+        unsigned long           char_max;
+        unsigned long           char_last;
+};
+
+/*
+ * These stats all reflect activity since the device was last initialized.
+ * (i.e., since the port was opened with no other processes already having it
+ * open)
+ */
+struct cyclades_idle_stats {
+    __kernel_time_t in_use;	/* Time device has been in use (secs) */
+    __kernel_time_t recv_idle;	/* Time since last char received (secs) */
+    __kernel_time_t xmit_idle;	/* Time since last char transmitted (secs) */
+    unsigned long  recv_bytes;	/* Bytes received */
+    unsigned long  xmit_bytes;	/* Bytes transmitted */
+    unsigned long  overruns;	/* Input overruns */
+    unsigned long  frame_errs;	/* Input framing errors */
+    unsigned long  parity_errs;	/* Input parity errors */
+};
+
+#define CYCLADES_MAGIC  0x4359
+
+#define CYGETMON                0x435901
+#define CYGETTHRESH             0x435902
+#define CYSETTHRESH             0x435903
+#define CYGETDEFTHRESH          0x435904
+#define CYSETDEFTHRESH          0x435905
+#define CYGETTIMEOUT            0x435906
+#define CYSETTIMEOUT            0x435907
+#define CYGETDEFTIMEOUT         0x435908
+#define CYSETDEFTIMEOUT         0x435909
+#define CYSETRFLOW		0x43590a
+#define CYGETRFLOW		0x43590b
+#define CYSETRTSDTR_INV		0x43590c
+#define CYGETRTSDTR_INV		0x43590d
+#define CYZSETPOLLCYCLE		0x43590e
+#define CYZGETPOLLCYCLE		0x43590f
+#define CYGETCD1400VER		0x435910
+#define	CYSETWAIT		0x435912
+#define	CYGETWAIT		0x435913
+
+/*************** CYCLOM-Z ADDITIONS ***************/
+
+#define CZIOC           ('M' << 8)
+#define CZ_NBOARDS      (CZIOC|0xfa)
+#define CZ_BOOT_START   (CZIOC|0xfb)
+#define CZ_BOOT_DATA    (CZIOC|0xfc)
+#define CZ_BOOT_END     (CZIOC|0xfd)
+#define CZ_TEST         (CZIOC|0xfe)
+
+#define CZ_DEF_POLL	(HZ/25)
+
+#define MAX_BOARD       4       /* Max number of boards */
+#define MAX_DEV         256     /* Max number of ports total */
+#define	CYZ_MAX_SPEED	921600
+
+#define	CYZ_FIFO_SIZE	16
+
+#define CYZ_BOOT_NWORDS 0x100
+struct CYZ_BOOT_CTRL {
+        unsigned short  nboard;
+        int             status[MAX_BOARD];
+        int             nchannel[MAX_BOARD];
+        int             fw_rev[MAX_BOARD];
+        unsigned long   offset;
+        unsigned long   data[CYZ_BOOT_NWORDS];
+};
+
+
+#ifndef DP_WINDOW_SIZE
+/*
+ *	Memory Window Sizes
+ */
+
+#define	DP_WINDOW_SIZE		(0x00080000)	/* window size 512 Kb */
+#define	ZE_DP_WINDOW_SIZE	(0x00100000)	/* window size 1 Mb (Ze and
+						  8Zo V.2 */
+#define	CTRL_WINDOW_SIZE	(0x00000080)	/* runtime regs 128 bytes */
+
+/*
+ *	CUSTOM_REG - Cyclom-Z/PCI Custom Registers Set. The driver
+ *	normally will access only interested on the fpga_id, fpga_version,
+ *	start_cpu and stop_cpu.
+ */
+
+struct	CUSTOM_REG {
+	__u32	fpga_id;		/* FPGA Identification Register */
+	__u32	fpga_version;		/* FPGA Version Number Register */
+	__u32	cpu_start;		/* CPU start Register (write) */
+	__u32	cpu_stop;		/* CPU stop Register (write) */
+	__u32	misc_reg;		/* Miscellaneous Register */
+	__u32	idt_mode;		/* IDT mode Register */
+	__u32	uart_irq_status;	/* UART IRQ status Register */
+	__u32	clear_timer0_irq;	/* Clear timer interrupt Register */
+	__u32	clear_timer1_irq;	/* Clear timer interrupt Register */
+	__u32	clear_timer2_irq;	/* Clear timer interrupt Register */
+	__u32	test_register;		/* Test Register */
+	__u32	test_count;		/* Test Count Register */
+	__u32	timer_select;		/* Timer select register */
+	__u32	pr_uart_irq_status;	/* Prioritized UART IRQ stat Reg */
+	__u32	ram_wait_state;		/* RAM wait-state Register */
+	__u32	uart_wait_state;	/* UART wait-state Register */
+	__u32	timer_wait_state;	/* timer wait-state Register */
+	__u32	ack_wait_state;		/* ACK wait State Register */
+};
+
+/*
+ *	RUNTIME_9060 - PLX PCI9060ES local configuration and shared runtime
+ *	registers. This structure can be used to access the 9060 registers
+ *	(memory mapped).
+ */
+
+struct RUNTIME_9060 {
+	__u32	loc_addr_range;	/* 00h - Local Address Range */
+	__u32	loc_addr_base;	/* 04h - Local Address Base */
+	__u32	loc_arbitr;	/* 08h - Local Arbitration */
+	__u32	endian_descr;	/* 0Ch - Big/Little Endian Descriptor */
+	__u32	loc_rom_range;	/* 10h - Local ROM Range */
+	__u32	loc_rom_base;	/* 14h - Local ROM Base */
+	__u32	loc_bus_descr;	/* 18h - Local Bus descriptor */
+	__u32	loc_range_mst;	/* 1Ch - Local Range for Master to PCI */
+	__u32	loc_base_mst;	/* 20h - Local Base for Master PCI */
+	__u32	loc_range_io;	/* 24h - Local Range for Master IO */
+	__u32	pci_base_mst;	/* 28h - PCI Base for Master PCI */
+	__u32	pci_conf_io;	/* 2Ch - PCI configuration for Master IO */
+	__u32	filler1;	/* 30h */
+	__u32	filler2;	/* 34h */
+	__u32	filler3;	/* 38h */
+	__u32	filler4;	/* 3Ch */
+	__u32	mail_box_0;	/* 40h - Mail Box 0 */
+	__u32	mail_box_1;	/* 44h - Mail Box 1 */
+	__u32	mail_box_2;	/* 48h - Mail Box 2 */
+	__u32	mail_box_3;	/* 4Ch - Mail Box 3 */
+	__u32	filler5;	/* 50h */
+	__u32	filler6;	/* 54h */
+	__u32	filler7;	/* 58h */
+	__u32	filler8;	/* 5Ch */
+	__u32	pci_doorbell;	/* 60h - PCI to Local Doorbell */
+	__u32	loc_doorbell;	/* 64h - Local to PCI Doorbell */
+	__u32	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
+	__u32	init_ctrl;	/* 6Ch - EEPROM control, Init Control, etc */
+};
+
+/* Values for the Local Base Address re-map register */
+
+#define	WIN_RAM		0x00000001L	/* set the sliding window to RAM */
+#define	WIN_CREG	0x14000001L	/* set the window to custom Registers */
+
+/* Values timer select registers */
+
+#define	TIMER_BY_1M	0x00		/* clock divided by 1M */
+#define	TIMER_BY_256K	0x01		/* clock divided by 256k */
+#define	TIMER_BY_128K	0x02		/* clock divided by 128k */
+#define	TIMER_BY_32K	0x03		/* clock divided by 32k */
+
+/****************** ****************** *******************/
+#endif
+
+#ifndef ZFIRM_ID
+/* #include "zfwint.h" */
+/****************** ****************** *******************/
+/*
+ *	This file contains the definitions for interfacing with the
+ *	Cyclom-Z ZFIRM Firmware.
+ */
+
+/* General Constant definitions */
+
+#define	MAX_CHAN	64		/* max number of channels per board */
+
+/* firmware id structure (set after boot) */
+
+#define ID_ADDRESS	0x00000180L	/* signature/pointer address */
+#define	ZFIRM_ID	0x5557465AL	/* ZFIRM/U signature */
+#define	ZFIRM_HLT	0x59505B5CL	/* ZFIRM needs external power supply */
+#define	ZFIRM_RST	0x56040674L	/* RST signal (due to FW reset) */
+
+#define	ZF_TINACT_DEF	1000		/* default inactivity timeout 
+					   (1000 ms) */
+#define	ZF_TINACT	ZF_TINACT_DEF
+
+struct	FIRM_ID {
+	__u32	signature;		/* ZFIRM/U signature */
+	__u32	zfwctrl_addr;		/* pointer to ZFW_CTRL structure */
+};
+
+/* Op. System id */
+
+#define	C_OS_LINUX	0x00000030	/* generic Linux system */
+
+/* channel op_mode */
+
+#define	C_CH_DISABLE	0x00000000	/* channel is disabled */
+#define	C_CH_TXENABLE	0x00000001	/* channel Tx enabled */
+#define	C_CH_RXENABLE	0x00000002	/* channel Rx enabled */
+#define	C_CH_ENABLE	0x00000003	/* channel Tx/Rx enabled */
+#define	C_CH_LOOPBACK	0x00000004	/* Loopback mode */
+
+/* comm_parity - parity */
+
+#define	C_PR_NONE	0x00000000	/* None */
+#define	C_PR_ODD	0x00000001	/* Odd */
+#define C_PR_EVEN	0x00000002	/* Even */
+#define C_PR_MARK	0x00000004	/* Mark */
+#define C_PR_SPACE	0x00000008	/* Space */
+#define C_PR_PARITY	0x000000ff
+
+#define	C_PR_DISCARD	0x00000100	/* discard char with frame/par error */
+#define C_PR_IGNORE	0x00000200	/* ignore frame/par error */
+
+/* comm_data_l - data length and stop bits */
+
+#define C_DL_CS5	0x00000001
+#define C_DL_CS6	0x00000002
+#define C_DL_CS7	0x00000004
+#define C_DL_CS8	0x00000008
+#define	C_DL_CS		0x0000000f
+#define C_DL_1STOP	0x00000010
+#define C_DL_15STOP	0x00000020
+#define C_DL_2STOP	0x00000040
+#define	C_DL_STOP	0x000000f0
+
+/* interrupt enabling/status */
+
+#define	C_IN_DISABLE	0x00000000	/* zero, disable interrupts */
+#define	C_IN_TXBEMPTY	0x00000001	/* tx buffer empty */
+#define	C_IN_TXLOWWM	0x00000002	/* tx buffer below LWM */
+#define	C_IN_RXHIWM	0x00000010	/* rx buffer above HWM */
+#define	C_IN_RXNNDT	0x00000020	/* rx no new data timeout */
+#define	C_IN_MDCD	0x00000100	/* modem DCD change */
+#define	C_IN_MDSR	0x00000200	/* modem DSR change */
+#define	C_IN_MRI	0x00000400	/* modem RI change */
+#define	C_IN_MCTS	0x00000800	/* modem CTS change */
+#define	C_IN_RXBRK	0x00001000	/* Break received */
+#define	C_IN_PR_ERROR	0x00002000	/* parity error */
+#define	C_IN_FR_ERROR	0x00004000	/* frame error */
+#define C_IN_OVR_ERROR  0x00008000      /* overrun error */
+#define C_IN_RXOFL	0x00010000      /* RX buffer overflow */
+#define C_IN_IOCTLW	0x00020000      /* I/O control w/ wait */
+#define C_IN_MRTS	0x00040000	/* modem RTS drop */
+#define C_IN_ICHAR	0x00080000
+ 
+/* flow control */
+
+#define	C_FL_OXX	0x00000001	/* output Xon/Xoff flow control */
+#define	C_FL_IXX	0x00000002	/* output Xon/Xoff flow control */
+#define C_FL_OIXANY	0x00000004	/* output Xon/Xoff (any xon) */
+#define	C_FL_SWFLOW	0x0000000f
+
+/* flow status */
+
+#define	C_FS_TXIDLE	0x00000000	/* no Tx data in the buffer or UART */
+#define	C_FS_SENDING	0x00000001	/* UART is sending data */
+#define	C_FS_SWFLOW	0x00000002	/* Tx is stopped by received Xoff */
+
+/* rs_control/rs_status RS-232 signals */
+
+#define C_RS_PARAM	0x80000000	/* Indicates presence of parameter in 
+					   IOCTLM command */
+#define	C_RS_RTS	0x00000001	/* RTS */
+#define	C_RS_DTR	0x00000004	/* DTR */
+#define	C_RS_DCD	0x00000100	/* CD */
+#define	C_RS_DSR	0x00000200	/* DSR */
+#define	C_RS_RI		0x00000400	/* RI */
+#define	C_RS_CTS	0x00000800	/* CTS */
+
+/* commands Host <-> Board */
+
+#define	C_CM_RESET	0x01		/* reset/flush buffers */
+#define	C_CM_IOCTL	0x02		/* re-read CH_CTRL */
+#define	C_CM_IOCTLW	0x03		/* re-read CH_CTRL, intr when done */
+#define	C_CM_IOCTLM	0x04		/* RS-232 outputs change */
+#define	C_CM_SENDXOFF	0x10		/* send Xoff */
+#define	C_CM_SENDXON	0x11		/* send Xon */
+#define C_CM_CLFLOW	0x12		/* Clear flow control (resume) */
+#define	C_CM_SENDBRK	0x41		/* send break */
+#define	C_CM_INTBACK	0x42		/* Interrupt back */
+#define	C_CM_SET_BREAK	0x43		/* Tx break on */
+#define	C_CM_CLR_BREAK	0x44		/* Tx break off */
+#define	C_CM_CMD_DONE	0x45		/* Previous command done */
+#define C_CM_INTBACK2	0x46		/* Alternate Interrupt back */
+#define	C_CM_TINACT	0x51		/* set inactivity detection */
+#define	C_CM_IRQ_ENBL	0x52		/* enable generation of interrupts */
+#define	C_CM_IRQ_DSBL	0x53		/* disable generation of interrupts */
+#define	C_CM_ACK_ENBL	0x54		/* enable acknowledged interrupt mode */
+#define	C_CM_ACK_DSBL	0x55		/* disable acknowledged intr mode */
+#define	C_CM_FLUSH_RX	0x56		/* flushes Rx buffer */
+#define	C_CM_FLUSH_TX	0x57		/* flushes Tx buffer */
+#define C_CM_Q_ENABLE	0x58		/* enables queue access from the 
+					   driver */
+#define C_CM_Q_DISABLE  0x59            /* disables queue access from the 
+					   driver */
+
+#define	C_CM_TXBEMPTY	0x60		/* Tx buffer is empty */
+#define	C_CM_TXLOWWM	0x61		/* Tx buffer low water mark */
+#define	C_CM_RXHIWM	0x62		/* Rx buffer high water mark */
+#define	C_CM_RXNNDT	0x63		/* rx no new data timeout */
+#define	C_CM_TXFEMPTY	0x64
+#define	C_CM_ICHAR	0x65
+#define	C_CM_MDCD	0x70		/* modem DCD change */
+#define	C_CM_MDSR	0x71		/* modem DSR change */
+#define	C_CM_MRI	0x72		/* modem RI change */
+#define	C_CM_MCTS	0x73		/* modem CTS change */
+#define C_CM_MRTS	0x74		/* modem RTS drop */
+#define	C_CM_RXBRK	0x84		/* Break received */
+#define	C_CM_PR_ERROR	0x85		/* Parity error */
+#define	C_CM_FR_ERROR	0x86		/* Frame error */
+#define C_CM_OVR_ERROR  0x87            /* Overrun error */
+#define C_CM_RXOFL	0x88            /* RX buffer overflow */
+#define	C_CM_CMDERROR	0x90		/* command error */
+#define	C_CM_FATAL	0x91		/* fatal error */
+#define	C_CM_HW_RESET	0x92		/* reset board */
+
+/*
+ *	CH_CTRL - This per port structure contains all parameters
+ *	that control an specific port. It can be seen as the
+ *	configuration registers of a "super-serial-controller".
+ */
+
+struct CH_CTRL {
+	__u32	op_mode;	/* operation mode */
+	__u32	intr_enable;	/* interrupt masking */
+	__u32	sw_flow;	/* SW flow control */
+	__u32	flow_status;	/* output flow status */
+	__u32	comm_baud;	/* baud rate  - numerically specified */
+	__u32	comm_parity;	/* parity */
+	__u32	comm_data_l;	/* data length/stop */
+	__u32	comm_flags;	/* other flags */
+	__u32	hw_flow;	/* HW flow control */
+	__u32	rs_control;	/* RS-232 outputs */
+	__u32	rs_status;	/* RS-232 inputs */
+	__u32	flow_xon;	/* xon char */
+	__u32	flow_xoff;	/* xoff char */
+	__u32	hw_overflow;	/* hw overflow counter */
+	__u32	sw_overflow;	/* sw overflow counter */
+	__u32	comm_error;	/* frame/parity error counter */
+	__u32 ichar;
+	__u32 filler[7];
+};
+
+
+/*
+ *	BUF_CTRL - This per channel structure contains
+ *	all Tx and Rx buffer control for a given channel.
+ */
+
+struct	BUF_CTRL	{
+	__u32	flag_dma;	/* buffers are in Host memory */
+	__u32	tx_bufaddr;	/* address of the tx buffer */
+	__u32	tx_bufsize;	/* tx buffer size */
+	__u32	tx_threshold;	/* tx low water mark */
+	__u32	tx_get;		/* tail index tx buf */
+	__u32	tx_put;		/* head index tx buf */
+	__u32	rx_bufaddr;	/* address of the rx buffer */
+	__u32	rx_bufsize;	/* rx buffer size */
+	__u32	rx_threshold;	/* rx high water mark */
+	__u32	rx_get;		/* tail index rx buf */
+	__u32	rx_put;		/* head index rx buf */
+	__u32	filler[5];	/* filler to align structures */
+};
+
+/*
+ *	BOARD_CTRL - This per board structure contains all global 
+ *	control fields related to the board.
+ */
+
+struct BOARD_CTRL {
+
+	/* static info provided by the on-board CPU */
+	__u32	n_channel;	/* number of channels */
+	__u32	fw_version;	/* firmware version */
+
+	/* static info provided by the driver */
+	__u32	op_system;	/* op_system id */
+	__u32	dr_version;	/* driver version */
+
+	/* board control area */
+	__u32	inactivity;	/* inactivity control */
+
+	/* host to FW commands */
+	__u32	hcmd_channel;	/* channel number */
+	__u32	hcmd_param;	/* pointer to parameters */
+
+	/* FW to Host commands */
+	__u32	fwcmd_channel;	/* channel number */
+	__u32	fwcmd_param;	/* pointer to parameters */
+	__u32	zf_int_queue_addr; /* offset for INT_QUEUE structure */
+
+	/* filler so the structures are aligned */
+	__u32	filler[6];
+};
+
+/* Host Interrupt Queue */
+
+#define QUEUE_SIZE	(10*MAX_CHAN)
+
+struct	INT_QUEUE {
+	unsigned char	intr_code[QUEUE_SIZE];
+	unsigned long	channel[QUEUE_SIZE];
+	unsigned long	param[QUEUE_SIZE];
+	unsigned long	put;
+	unsigned long	get;
+};
+
+/*
+ *	ZFW_CTRL - This is the data structure that includes all other
+ *	data structures used by the Firmware.
+ */
+ 
+struct ZFW_CTRL {
+	struct BOARD_CTRL	board_ctrl;
+	struct CH_CTRL		ch_ctrl[MAX_CHAN];
+	struct BUF_CTRL		buf_ctrl[MAX_CHAN];
+};
+
+/****************** ****************** *******************/
+#endif
+
+#endif /* _LINUX_CYCLADES_H */
diff -uNr linux-2.6.32/usr/include/linux/cycx_cfm.h clean_modified/linux-2.6.32/usr/include/linux/cycx_cfm.h
--- linux-2.6.32/usr/include/linux/cycx_cfm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/cycx_cfm.h	2019-04-14 13:24:02.939295589 -0500
@@ -0,0 +1,101 @@
+/*
+* cycx_cfm.h	Cyclom 2X WAN Link Driver.
+*		Definitions for the Cyclom 2X Firmware Module (CFM).
+*
+* Author:	Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+*
+* Copyright:	(c) 1998-2003 Arnaldo Carvalho de Melo
+*
+* Based on sdlasfm.h by Gene Kozin <74604.152@compuserve.com>
+*
+*		This program is free software; you can redistribute it and/or
+*		modify it under the terms of the GNU General Public License
+*		as published by the Free Software Foundation; either version
+*		2 of the License, or (at your option) any later version.
+* ============================================================================
+* 1998/08/08	acme		Initial version.
+*/
+#ifndef	_CYCX_CFM_H
+#define	_CYCX_CFM_H
+
+/* Defines */
+
+#define	CFM_VERSION	2
+#define	CFM_SIGNATURE	"CFM - Cyclades CYCX Firmware Module"
+
+/* min/max */
+#define	CFM_IMAGE_SIZE	0x20000	/* max size of CYCX code image file */
+#define	CFM_DESCR_LEN	256	/* max length of description string */
+#define	CFM_MAX_CYCX	1	/* max number of compatible adapters */
+#define	CFM_LOAD_BUFSZ	0x400	/* buffer size for reset code (buffer_load) */
+
+/* Firmware Commands */
+#define GEN_POWER_ON	0x1280
+
+#define GEN_SET_SEG	0x1401	/* boot segment setting. */
+#define GEN_BOOT_DAT	0x1402	/* boot data. */
+#define GEN_START	0x1403	/* board start. */
+#define GEN_DEFPAR	0x1404	/* buffer length for boot. */
+
+/* Adapter Types */
+#define CYCX_2X		2
+/* for now only the 2X is supported, no plans to support 8X or 16X */
+#define CYCX_8X		8
+#define CYCX_16X	16
+
+#define	CFID_X25_2X	5200
+
+/**
+ *	struct cycx_fw_info - firmware module information.
+ *	@codeid - firmware ID
+ *	@version - firmware version number
+ *	@adapter - compatible adapter types
+ *	@memsize - minimum memory size
+ *	@reserved - reserved
+ *	@startoffs - entry point offset
+ *	@winoffs - dual-port memory window offset
+ *	@codeoffs - code load offset
+ *	@codesize - code size
+ *	@dataoffs - configuration data load offset
+ *	@datasize - configuration data size
+ */
+struct cycx_fw_info {
+	unsigned short	codeid;
+	unsigned short	version;
+	unsigned short	adapter[CFM_MAX_CYCX];
+	unsigned long	memsize;
+	unsigned short	reserved[2];
+	unsigned short	startoffs;
+	unsigned short	winoffs;
+	unsigned short	codeoffs;
+	unsigned long	codesize;
+	unsigned short	dataoffs;
+	unsigned long	datasize;
+};
+
+/**
+ *	struct cycx_firmware - CYCX firmware file structure
+ *	@signature - CFM file signature
+ *	@version - file format version
+ *	@checksum - info + image
+ *	@reserved - reserved
+ *	@descr - description string
+ *	@info - firmware module info
+ *	@image - code image (variable size)
+ */
+struct cycx_firmware {
+	char		    signature[80];
+	unsigned short	    version;
+	unsigned short	    checksum;
+	unsigned short	    reserved[6];
+	char		    descr[CFM_DESCR_LEN];
+	struct cycx_fw_info info;
+	unsigned char	    image[0];
+};
+
+struct cycx_fw_header {
+	unsigned long  reset_size;
+	unsigned long  data_size;
+	unsigned long  code_size;
+};
+#endif	/* _CYCX_CFM_H */
diff -uNr linux-2.6.32/usr/include/linux/dcbnl.h clean_modified/linux-2.6.32/usr/include/linux/dcbnl.h
--- linux-2.6.32/usr/include/linux/dcbnl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dcbnl.h	2019-04-14 13:24:02.939295589 -0500
@@ -0,0 +1,360 @@
+/*
+ * Copyright (c) 2008, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Author: Lucy Liu <lucy.liu@intel.com>
+ */
+
+#ifndef __LINUX_DCBNL_H__
+#define __LINUX_DCBNL_H__
+
+#include <linux/types.h>
+
+#define DCB_PROTO_VERSION 1
+
+struct dcbmsg {
+	__u8               dcb_family;
+	__u8               cmd;
+	__u16              dcb_pad;
+};
+
+/**
+ * enum dcbnl_commands - supported DCB commands
+ *
+ * @DCB_CMD_UNDEFINED: unspecified command to catch errors
+ * @DCB_CMD_GSTATE: request the state of DCB in the device
+ * @DCB_CMD_SSTATE: set the state of DCB in the device
+ * @DCB_CMD_PGTX_GCFG: request the priority group configuration for Tx
+ * @DCB_CMD_PGTX_SCFG: set the priority group configuration for Tx
+ * @DCB_CMD_PGRX_GCFG: request the priority group configuration for Rx
+ * @DCB_CMD_PGRX_SCFG: set the priority group configuration for Rx
+ * @DCB_CMD_PFC_GCFG: request the priority flow control configuration
+ * @DCB_CMD_PFC_SCFG: set the priority flow control configuration
+ * @DCB_CMD_SET_ALL: apply all changes to the underlying device
+ * @DCB_CMD_GPERM_HWADDR: get the permanent MAC address of the underlying
+ *                        device.  Only useful when using bonding.
+ * @DCB_CMD_GCAP: request the DCB capabilities of the device
+ * @DCB_CMD_GNUMTCS: get the number of traffic classes currently supported
+ * @DCB_CMD_SNUMTCS: set the number of traffic classes
+ * @DCB_CMD_GBCN: set backward congestion notification configuration
+ * @DCB_CMD_SBCN: get backward congestion notification configration.
+ * @DCB_CMD_GAPP: get application protocol configuration
+ * @DCB_CMD_SAPP: set application protocol configuration
+ */
+enum dcbnl_commands {
+	DCB_CMD_UNDEFINED,
+
+	DCB_CMD_GSTATE,
+	DCB_CMD_SSTATE,
+
+	DCB_CMD_PGTX_GCFG,
+	DCB_CMD_PGTX_SCFG,
+	DCB_CMD_PGRX_GCFG,
+	DCB_CMD_PGRX_SCFG,
+
+	DCB_CMD_PFC_GCFG,
+	DCB_CMD_PFC_SCFG,
+
+	DCB_CMD_SET_ALL,
+
+	DCB_CMD_GPERM_HWADDR,
+
+	DCB_CMD_GCAP,
+
+	DCB_CMD_GNUMTCS,
+	DCB_CMD_SNUMTCS,
+
+	DCB_CMD_PFC_GSTATE,
+	DCB_CMD_PFC_SSTATE,
+
+	DCB_CMD_BCN_GCFG,
+	DCB_CMD_BCN_SCFG,
+
+	DCB_CMD_GAPP,
+	DCB_CMD_SAPP,
+
+	__DCB_CMD_ENUM_MAX,
+	DCB_CMD_MAX = __DCB_CMD_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_attrs - DCB top-level netlink attributes
+ *
+ * @DCB_ATTR_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_ATTR_IFNAME: interface name of the underlying device (NLA_STRING)
+ * @DCB_ATTR_STATE: enable state of DCB in the device (NLA_U8)
+ * @DCB_ATTR_PFC_STATE: enable state of PFC in the device (NLA_U8)
+ * @DCB_ATTR_PFC_CFG: priority flow control configuration (NLA_NESTED)
+ * @DCB_ATTR_NUM_TC: number of traffic classes supported in the device (NLA_U8)
+ * @DCB_ATTR_PG_CFG: priority group configuration (NLA_NESTED)
+ * @DCB_ATTR_SET_ALL: bool to commit changes to hardware or not (NLA_U8)
+ * @DCB_ATTR_PERM_HWADDR: MAC address of the physical device (NLA_NESTED)
+ * @DCB_ATTR_CAP: DCB capabilities of the device (NLA_NESTED)
+ * @DCB_ATTR_NUMTCS: number of traffic classes supported (NLA_NESTED)
+ * @DCB_ATTR_BCN: backward congestion notification configuration (NLA_NESTED)
+ */
+enum dcbnl_attrs {
+	DCB_ATTR_UNDEFINED,
+
+	DCB_ATTR_IFNAME,
+	DCB_ATTR_STATE,
+	DCB_ATTR_PFC_STATE,
+	DCB_ATTR_PFC_CFG,
+	DCB_ATTR_NUM_TC,
+	DCB_ATTR_PG_CFG,
+	DCB_ATTR_SET_ALL,
+	DCB_ATTR_PERM_HWADDR,
+	DCB_ATTR_CAP,
+	DCB_ATTR_NUMTCS,
+	DCB_ATTR_BCN,
+	DCB_ATTR_APP,
+
+	__DCB_ATTR_ENUM_MAX,
+	DCB_ATTR_MAX = __DCB_ATTR_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_pfc_attrs - DCB Priority Flow Control user priority nested attrs
+ *
+ * @DCB_PFC_UP_ATTR_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_PFC_UP_ATTR_0: Priority Flow Control value for User Priority 0 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_1: Priority Flow Control value for User Priority 1 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_2: Priority Flow Control value for User Priority 2 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_3: Priority Flow Control value for User Priority 3 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_4: Priority Flow Control value for User Priority 4 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_5: Priority Flow Control value for User Priority 5 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_6: Priority Flow Control value for User Priority 6 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_7: Priority Flow Control value for User Priority 7 (NLA_U8)
+ * @DCB_PFC_UP_ATTR_MAX: highest attribute number currently defined
+ * @DCB_PFC_UP_ATTR_ALL: apply to all priority flow control attrs (NLA_FLAG)
+ *
+ */
+enum dcbnl_pfc_up_attrs {
+	DCB_PFC_UP_ATTR_UNDEFINED,
+
+	DCB_PFC_UP_ATTR_0,
+	DCB_PFC_UP_ATTR_1,
+	DCB_PFC_UP_ATTR_2,
+	DCB_PFC_UP_ATTR_3,
+	DCB_PFC_UP_ATTR_4,
+	DCB_PFC_UP_ATTR_5,
+	DCB_PFC_UP_ATTR_6,
+	DCB_PFC_UP_ATTR_7,
+	DCB_PFC_UP_ATTR_ALL,
+
+	__DCB_PFC_UP_ATTR_ENUM_MAX,
+	DCB_PFC_UP_ATTR_MAX = __DCB_PFC_UP_ATTR_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_pg_attrs - DCB Priority Group attributes
+ *
+ * @DCB_PG_ATTR_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_PG_ATTR_TC_0: Priority Group Traffic Class 0 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_1: Priority Group Traffic Class 1 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_2: Priority Group Traffic Class 2 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_3: Priority Group Traffic Class 3 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_4: Priority Group Traffic Class 4 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_5: Priority Group Traffic Class 5 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_6: Priority Group Traffic Class 6 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_7: Priority Group Traffic Class 7 configuration (NLA_NESTED)
+ * @DCB_PG_ATTR_TC_MAX: highest attribute number currently defined
+ * @DCB_PG_ATTR_TC_ALL: apply to all traffic classes (NLA_NESTED)
+ * @DCB_PG_ATTR_BW_ID_0: Percent of link bandwidth for Priority Group 0 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_1: Percent of link bandwidth for Priority Group 1 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_2: Percent of link bandwidth for Priority Group 2 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_3: Percent of link bandwidth for Priority Group 3 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_4: Percent of link bandwidth for Priority Group 4 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_5: Percent of link bandwidth for Priority Group 5 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_6: Percent of link bandwidth for Priority Group 6 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_7: Percent of link bandwidth for Priority Group 7 (NLA_U8)
+ * @DCB_PG_ATTR_BW_ID_MAX: highest attribute number currently defined
+ * @DCB_PG_ATTR_BW_ID_ALL: apply to all priority groups (NLA_FLAG)
+ *
+ */
+enum dcbnl_pg_attrs {
+	DCB_PG_ATTR_UNDEFINED,
+
+	DCB_PG_ATTR_TC_0,
+	DCB_PG_ATTR_TC_1,
+	DCB_PG_ATTR_TC_2,
+	DCB_PG_ATTR_TC_3,
+	DCB_PG_ATTR_TC_4,
+	DCB_PG_ATTR_TC_5,
+	DCB_PG_ATTR_TC_6,
+	DCB_PG_ATTR_TC_7,
+	DCB_PG_ATTR_TC_MAX,
+	DCB_PG_ATTR_TC_ALL,
+
+	DCB_PG_ATTR_BW_ID_0,
+	DCB_PG_ATTR_BW_ID_1,
+	DCB_PG_ATTR_BW_ID_2,
+	DCB_PG_ATTR_BW_ID_3,
+	DCB_PG_ATTR_BW_ID_4,
+	DCB_PG_ATTR_BW_ID_5,
+	DCB_PG_ATTR_BW_ID_6,
+	DCB_PG_ATTR_BW_ID_7,
+	DCB_PG_ATTR_BW_ID_MAX,
+	DCB_PG_ATTR_BW_ID_ALL,
+
+	__DCB_PG_ATTR_ENUM_MAX,
+	DCB_PG_ATTR_MAX = __DCB_PG_ATTR_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_tc_attrs - DCB Traffic Class attributes
+ *
+ * @DCB_TC_ATTR_PARAM_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_TC_ATTR_PARAM_PGID: (NLA_U8) Priority group the traffic class belongs to
+ *                          Valid values are:  0-7
+ * @DCB_TC_ATTR_PARAM_UP_MAPPING: (NLA_U8) Traffic class to user priority map
+ *                                Some devices may not support changing the
+ *                                user priority map of a TC.
+ * @DCB_TC_ATTR_PARAM_STRICT_PRIO: (NLA_U8) Strict priority setting
+ *                                 0 - none
+ *                                 1 - group strict
+ *                                 2 - link strict
+ * @DCB_TC_ATTR_PARAM_BW_PCT: optional - (NLA_U8) If supported by the device and
+ *                            not configured to use link strict priority,
+ *                            this is the percentage of bandwidth of the
+ *                            priority group this traffic class belongs to
+ * @DCB_TC_ATTR_PARAM_ALL: (NLA_FLAG) all traffic class parameters
+ *
+ */
+enum dcbnl_tc_attrs {
+	DCB_TC_ATTR_PARAM_UNDEFINED,
+
+	DCB_TC_ATTR_PARAM_PGID,
+	DCB_TC_ATTR_PARAM_UP_MAPPING,
+	DCB_TC_ATTR_PARAM_STRICT_PRIO,
+	DCB_TC_ATTR_PARAM_BW_PCT,
+	DCB_TC_ATTR_PARAM_ALL,
+
+	__DCB_TC_ATTR_PARAM_ENUM_MAX,
+	DCB_TC_ATTR_PARAM_MAX = __DCB_TC_ATTR_PARAM_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_cap_attrs - DCB Capability attributes
+ *
+ * @DCB_CAP_ATTR_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_CAP_ATTR_ALL: (NLA_FLAG) all capability parameters
+ * @DCB_CAP_ATTR_PG: (NLA_U8) device supports Priority Groups
+ * @DCB_CAP_ATTR_PFC: (NLA_U8) device supports Priority Flow Control
+ * @DCB_CAP_ATTR_UP2TC: (NLA_U8) device supports user priority to
+ *                               traffic class mapping
+ * @DCB_CAP_ATTR_PG_TCS: (NLA_U8) bitmap where each bit represents a
+ *                                number of traffic classes the device
+ *                                can be configured to use for Priority Groups
+ * @DCB_CAP_ATTR_PFC_TCS: (NLA_U8) bitmap where each bit represents a
+ *                                 number of traffic classes the device can be
+ *                                 configured to use for Priority Flow Control
+ * @DCB_CAP_ATTR_GSP: (NLA_U8) device supports group strict priority
+ * @DCB_CAP_ATTR_BCN: (NLA_U8) device supports Backwards Congestion
+ *                             Notification
+ */
+enum dcbnl_cap_attrs {
+	DCB_CAP_ATTR_UNDEFINED,
+	DCB_CAP_ATTR_ALL,
+	DCB_CAP_ATTR_PG,
+	DCB_CAP_ATTR_PFC,
+	DCB_CAP_ATTR_UP2TC,
+	DCB_CAP_ATTR_PG_TCS,
+	DCB_CAP_ATTR_PFC_TCS,
+	DCB_CAP_ATTR_GSP,
+	DCB_CAP_ATTR_BCN,
+
+	__DCB_CAP_ATTR_ENUM_MAX,
+	DCB_CAP_ATTR_MAX = __DCB_CAP_ATTR_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcbnl_numtcs_attrs - number of traffic classes
+ *
+ * @DCB_NUMTCS_ATTR_UNDEFINED: unspecified attribute to catch errors
+ * @DCB_NUMTCS_ATTR_ALL: (NLA_FLAG) all traffic class attributes
+ * @DCB_NUMTCS_ATTR_PG: (NLA_U8) number of traffic classes used for
+ *                               priority groups
+ * @DCB_NUMTCS_ATTR_PFC: (NLA_U8) number of traffic classes which can
+ *                                support priority flow control
+ */
+enum dcbnl_numtcs_attrs {
+	DCB_NUMTCS_ATTR_UNDEFINED,
+	DCB_NUMTCS_ATTR_ALL,
+	DCB_NUMTCS_ATTR_PG,
+	DCB_NUMTCS_ATTR_PFC,
+
+	__DCB_NUMTCS_ATTR_ENUM_MAX,
+	DCB_NUMTCS_ATTR_MAX = __DCB_NUMTCS_ATTR_ENUM_MAX - 1,
+};
+
+enum dcbnl_bcn_attrs{
+	DCB_BCN_ATTR_UNDEFINED = 0,
+
+	DCB_BCN_ATTR_RP_0,
+	DCB_BCN_ATTR_RP_1,
+	DCB_BCN_ATTR_RP_2,
+	DCB_BCN_ATTR_RP_3,
+	DCB_BCN_ATTR_RP_4,
+	DCB_BCN_ATTR_RP_5,
+	DCB_BCN_ATTR_RP_6,
+	DCB_BCN_ATTR_RP_7,
+	DCB_BCN_ATTR_RP_ALL,
+
+	DCB_BCN_ATTR_BCNA_0,
+	DCB_BCN_ATTR_BCNA_1,
+	DCB_BCN_ATTR_ALPHA,
+	DCB_BCN_ATTR_BETA,
+	DCB_BCN_ATTR_GD,
+	DCB_BCN_ATTR_GI,
+	DCB_BCN_ATTR_TMAX,
+	DCB_BCN_ATTR_TD,
+	DCB_BCN_ATTR_RMIN,
+	DCB_BCN_ATTR_W,
+	DCB_BCN_ATTR_RD,
+	DCB_BCN_ATTR_RU,
+	DCB_BCN_ATTR_WRTT,
+	DCB_BCN_ATTR_RI,
+	DCB_BCN_ATTR_C,
+	DCB_BCN_ATTR_ALL,
+
+	__DCB_BCN_ATTR_ENUM_MAX,
+	DCB_BCN_ATTR_MAX = __DCB_BCN_ATTR_ENUM_MAX - 1,
+};
+
+/**
+ * enum dcb_general_attr_values - general DCB attribute values
+ *
+ * @DCB_ATTR_UNDEFINED: value used to indicate an attribute is not supported
+ *
+ */
+enum dcb_general_attr_values {
+	DCB_ATTR_VALUE_UNDEFINED = 0xff
+};
+
+#define DCB_APP_IDTYPE_ETHTYPE	0x00
+#define DCB_APP_IDTYPE_PORTNUM	0x01
+enum dcbnl_app_attrs {
+	DCB_APP_ATTR_UNDEFINED,
+
+	DCB_APP_ATTR_IDTYPE,
+	DCB_APP_ATTR_ID,
+	DCB_APP_ATTR_PRIORITY,
+
+	__DCB_APP_ATTR_ENUM_MAX,
+	DCB_APP_ATTR_MAX = __DCB_APP_ATTR_ENUM_MAX - 1,
+};
+
+#endif /* __LINUX_DCBNL_H__ */
diff -uNr linux-2.6.32/usr/include/linux/dccp.h clean_modified/linux-2.6.32/usr/include/linux/dccp.h
--- linux-2.6.32/usr/include/linux/dccp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dccp.h	2019-04-14 13:24:02.940257545 -0500
@@ -0,0 +1,218 @@
+#ifndef _LINUX_DCCP_H
+#define _LINUX_DCCP_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/**
+ * struct dccp_hdr - generic part of DCCP packet header
+ *
+ * @dccph_sport - Relevant port on the endpoint that sent this packet
+ * @dccph_dport - Relevant port on the other endpoint
+ * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
+ * @dccph_ccval - Used by the HC-Sender CCID
+ * @dccph_cscov - Parts of the packet that are covered by the Checksum field
+ * @dccph_checksum - Internet checksum, depends on dccph_cscov
+ * @dccph_x - 0 = 24 bit sequence number, 1 = 48
+ * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
+ * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
+ */
+struct dccp_hdr {
+	__be16	dccph_sport,
+		dccph_dport;
+	__u8	dccph_doff;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	dccph_cscov:4,
+		dccph_ccval:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8	dccph_ccval:4,
+		dccph_cscov:4;
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+	__sum16	dccph_checksum;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	dccph_x:1,
+		dccph_type:4,
+		dccph_reserved:3;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8	dccph_reserved:3,
+		dccph_type:4,
+		dccph_x:1;
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+	__u8	dccph_seq2;
+	__be16	dccph_seq;
+};
+
+/**
+ * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
+ *
+ * @dccph_seq_low - low 24 bits of a 48 bit seq packet
+ */
+struct dccp_hdr_ext {
+	__be32	dccph_seq_low;
+};
+
+/**
+ * struct dccp_hdr_request - Connection initiation request header
+ *
+ * @dccph_req_service - Service to which the client app wants to connect
+ */
+struct dccp_hdr_request {
+	__be32	dccph_req_service;
+};
+/**
+ * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
+ *
+ * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
+ * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
+ */
+struct dccp_hdr_ack_bits {
+	__be16	dccph_reserved1;
+	__be16	dccph_ack_nr_high;
+	__be32	dccph_ack_nr_low;
+};
+/**
+ * struct dccp_hdr_response - Connection initiation response header
+ *
+ * @dccph_resp_ack - 48 bit Acknowledgment Number Subheader (5.3)
+ * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
+ */
+struct dccp_hdr_response {
+	struct dccp_hdr_ack_bits	dccph_resp_ack;
+	__be32				dccph_resp_service;
+};
+
+/**
+ * struct dccp_hdr_reset - Unconditionally shut down a connection
+ *
+ * @dccph_reset_ack - 48 bit Acknowledgment Number Subheader (5.6)
+ * @dccph_reset_code - one of %dccp_reset_codes
+ * @dccph_reset_data - the Data 1 ... Data 3 fields from 5.6
+ */
+struct dccp_hdr_reset {
+	struct dccp_hdr_ack_bits	dccph_reset_ack;
+	__u8				dccph_reset_code,
+					dccph_reset_data[3];
+};
+
+enum dccp_pkt_type {
+	DCCP_PKT_REQUEST = 0,
+	DCCP_PKT_RESPONSE,
+	DCCP_PKT_DATA,
+	DCCP_PKT_ACK,
+	DCCP_PKT_DATAACK,
+	DCCP_PKT_CLOSEREQ,
+	DCCP_PKT_CLOSE,
+	DCCP_PKT_RESET,
+	DCCP_PKT_SYNC,
+	DCCP_PKT_SYNCACK,
+	DCCP_PKT_INVALID,
+};
+
+#define DCCP_NR_PKT_TYPES DCCP_PKT_INVALID
+
+static __inline__ unsigned int dccp_packet_hdr_len(const __u8 type)
+{
+	if (type == DCCP_PKT_DATA)
+		return 0;
+	if (type == DCCP_PKT_DATAACK	||
+	    type == DCCP_PKT_ACK	||
+	    type == DCCP_PKT_SYNC	||
+	    type == DCCP_PKT_SYNCACK	||
+	    type == DCCP_PKT_CLOSE	||
+	    type == DCCP_PKT_CLOSEREQ)
+		return sizeof(struct dccp_hdr_ack_bits);
+	if (type == DCCP_PKT_REQUEST)
+		return sizeof(struct dccp_hdr_request);
+	if (type == DCCP_PKT_RESPONSE)
+		return sizeof(struct dccp_hdr_response);
+	return sizeof(struct dccp_hdr_reset);
+}
+enum dccp_reset_codes {
+	DCCP_RESET_CODE_UNSPECIFIED = 0,
+	DCCP_RESET_CODE_CLOSED,
+	DCCP_RESET_CODE_ABORTED,
+	DCCP_RESET_CODE_NO_CONNECTION,
+	DCCP_RESET_CODE_PACKET_ERROR,
+	DCCP_RESET_CODE_OPTION_ERROR,
+	DCCP_RESET_CODE_MANDATORY_ERROR,
+	DCCP_RESET_CODE_CONNECTION_REFUSED,
+	DCCP_RESET_CODE_BAD_SERVICE_CODE,
+	DCCP_RESET_CODE_TOO_BUSY,
+	DCCP_RESET_CODE_BAD_INIT_COOKIE,
+	DCCP_RESET_CODE_AGGRESSION_PENALTY,
+
+	DCCP_MAX_RESET_CODES		/* Leave at the end!  */
+};
+
+/* DCCP options */
+enum {
+	DCCPO_PADDING = 0,
+	DCCPO_MANDATORY = 1,
+	DCCPO_MIN_RESERVED = 3,
+	DCCPO_MAX_RESERVED = 31,
+	DCCPO_CHANGE_L = 32,
+	DCCPO_CONFIRM_L = 33,
+	DCCPO_CHANGE_R = 34,
+	DCCPO_CONFIRM_R = 35,
+	DCCPO_NDP_COUNT = 37,
+	DCCPO_ACK_VECTOR_0 = 38,
+	DCCPO_ACK_VECTOR_1 = 39,
+	DCCPO_TIMESTAMP = 41,
+	DCCPO_TIMESTAMP_ECHO = 42,
+	DCCPO_ELAPSED_TIME = 43,
+	DCCPO_MAX = 45,
+	DCCPO_MIN_CCID_SPECIFIC = 128,
+	DCCPO_MAX_CCID_SPECIFIC = 255,
+};
+/* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
+#define DCCP_SINGLE_OPT_MAXLEN	253
+
+/* DCCP CCIDS */
+enum {
+	DCCPC_CCID2 = 2,
+	DCCPC_CCID3 = 3,
+};
+
+/* DCCP features (RFC 4340 section 6.4) */
+enum dccp_feature_numbers {
+	DCCPF_RESERVED = 0,
+	DCCPF_CCID = 1,
+	DCCPF_SHORT_SEQNOS = 2,
+	DCCPF_SEQUENCE_WINDOW = 3,
+	DCCPF_ECN_INCAPABLE = 4,
+	DCCPF_ACK_RATIO = 5,
+	DCCPF_SEND_ACK_VECTOR = 6,
+	DCCPF_SEND_NDP_COUNT = 7,
+	DCCPF_MIN_CSUM_COVER = 8,
+	DCCPF_DATA_CHECKSUM = 9,
+	/* 10-127 reserved */
+	DCCPF_MIN_CCID_SPECIFIC = 128,
+	DCCPF_SEND_LEV_RATE = 192,	/* RFC 4342, sec. 8.4 */
+	DCCPF_MAX_CCID_SPECIFIC = 255,
+};
+
+/* DCCP socket options */
+#define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
+#define DCCP_SOCKOPT_SERVICE		2
+#define DCCP_SOCKOPT_CHANGE_L		3
+#define DCCP_SOCKOPT_CHANGE_R		4
+#define DCCP_SOCKOPT_GET_CUR_MPS	5
+#define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
+#define DCCP_SOCKOPT_SEND_CSCOV		10
+#define DCCP_SOCKOPT_RECV_CSCOV		11
+#define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
+#define DCCP_SOCKOPT_CCID		13
+#define DCCP_SOCKOPT_TX_CCID		14
+#define DCCP_SOCKOPT_RX_CCID		15
+#define DCCP_SOCKOPT_CCID_RX_INFO	128
+#define DCCP_SOCKOPT_CCID_TX_INFO	192
+
+/* maximum number of services provided on the same listening port */
+#define DCCP_SERVICE_LIST_MAX_LEN      32
+
+
+#endif /* _LINUX_DCCP_H */
diff -uNr linux-2.6.32/usr/include/linux/dlmconstants.h clean_modified/linux-2.6.32/usr/include/linux/dlmconstants.h
--- linux-2.6.32/usr/include/linux/dlmconstants.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dlmconstants.h	2019-04-14 13:24:02.940257545 -0500
@@ -0,0 +1,163 @@
+/******************************************************************************
+*******************************************************************************
+**
+**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
+**  Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
+**
+**  This copyrighted material is made available to anyone wishing to use,
+**  modify, copy, or redistribute it subject to the terms and conditions
+**  of the GNU General Public License v.2.
+**
+*******************************************************************************
+******************************************************************************/
+
+#ifndef __DLMCONSTANTS_DOT_H__
+#define __DLMCONSTANTS_DOT_H__
+
+/*
+ * Constants used by DLM interface.
+ */
+
+#define DLM_LOCKSPACE_LEN       64
+#define DLM_RESNAME_MAXLEN      64
+
+
+/*
+ * Lock Modes
+ */
+
+#define DLM_LOCK_IV		(-1)	/* invalid */
+#define DLM_LOCK_NL		0	/* null */
+#define DLM_LOCK_CR		1	/* concurrent read */
+#define DLM_LOCK_CW		2	/* concurrent write */
+#define DLM_LOCK_PR		3	/* protected read */
+#define DLM_LOCK_PW		4	/* protected write */
+#define DLM_LOCK_EX		5	/* exclusive */
+
+
+/*
+ * Flags to dlm_lock
+ *
+ * DLM_LKF_NOQUEUE
+ *
+ * Do not queue the lock request on the wait queue if it cannot be granted
+ * immediately.  If the lock cannot be granted because of this flag, DLM will
+ * either return -EAGAIN from the dlm_lock call or will return 0 from
+ * dlm_lock and -EAGAIN in the lock status block when the AST is executed.
+ *
+ * DLM_LKF_CANCEL
+ *
+ * Used to cancel a pending lock request or conversion.  A converting lock is
+ * returned to its previously granted mode.
+ *
+ * DLM_LKF_CONVERT
+ *
+ * Indicates a lock conversion request.  For conversions the name and namelen
+ * are ignored and the lock ID in the LKSB is used to identify the lock.
+ *
+ * DLM_LKF_VALBLK
+ *
+ * Requests DLM to return the current contents of the lock value block in the
+ * lock status block.  When this flag is set in a lock conversion from PW or EX
+ * modes, DLM assigns the value specified in the lock status block to the lock
+ * value block of the lock resource.  The LVB is a DLM_LVB_LEN size array
+ * containing application-specific information.
+ *
+ * DLM_LKF_QUECVT
+ *
+ * Force a conversion request to be queued, even if it is compatible with
+ * the granted modes of other locks on the same resource.
+ *
+ * DLM_LKF_IVVALBLK
+ *
+ * Invalidate the lock value block.
+ *
+ * DLM_LKF_CONVDEADLK
+ *
+ * Allows the dlm to resolve conversion deadlocks internally by demoting the
+ * granted mode of a converting lock to NL.  The DLM_SBF_DEMOTED flag is
+ * returned for a conversion that's been effected by this.
+ *
+ * DLM_LKF_PERSISTENT
+ *
+ * Only relevant to locks originating in userspace.  A persistent lock will not
+ * be removed if the process holding the lock exits.
+ *
+ * DLM_LKF_NODLCKWT
+ *
+ * Do not cancel the lock if it gets into conversion deadlock.
+ * Exclude this lock from being monitored due to DLM_LSFL_TIMEWARN.
+ *
+ * DLM_LKF_NODLCKBLK
+ *
+ * net yet implemented
+ *
+ * DLM_LKF_EXPEDITE
+ *
+ * Used only with new requests for NL mode locks.  Tells the lock manager
+ * to grant the lock, ignoring other locks in convert and wait queues.
+ *
+ * DLM_LKF_NOQUEUEBAST
+ *
+ * Send blocking AST's before returning -EAGAIN to the caller.  It is only
+ * used along with the NOQUEUE flag.  Blocking AST's are not sent for failed
+ * NOQUEUE requests otherwise.
+ *
+ * DLM_LKF_HEADQUE
+ *
+ * Add a lock to the head of the convert or wait queue rather than the tail.
+ *
+ * DLM_LKF_NOORDER
+ *
+ * Disregard the standard grant order rules and grant a lock as soon as it
+ * is compatible with other granted locks.
+ *
+ * DLM_LKF_ORPHAN
+ *
+ * not yet implemented
+ *
+ * DLM_LKF_ALTPR
+ *
+ * If the requested mode cannot be granted immediately, try to grant the lock
+ * in PR mode instead.  If this alternate mode is granted instead of the
+ * requested mode, DLM_SBF_ALTMODE is returned in the lksb.
+ *
+ * DLM_LKF_ALTCW
+ *
+ * The same as ALTPR, but the alternate mode is CW.
+ *
+ * DLM_LKF_FORCEUNLOCK
+ *
+ * Unlock the lock even if it is converting or waiting or has sublocks.
+ * Only really for use by the userland device.c code.
+ *
+ */
+
+#define DLM_LKF_NOQUEUE		0x00000001
+#define DLM_LKF_CANCEL		0x00000002
+#define DLM_LKF_CONVERT		0x00000004
+#define DLM_LKF_VALBLK		0x00000008
+#define DLM_LKF_QUECVT		0x00000010
+#define DLM_LKF_IVVALBLK	0x00000020
+#define DLM_LKF_CONVDEADLK	0x00000040
+#define DLM_LKF_PERSISTENT	0x00000080
+#define DLM_LKF_NODLCKWT	0x00000100
+#define DLM_LKF_NODLCKBLK	0x00000200
+#define DLM_LKF_EXPEDITE	0x00000400
+#define DLM_LKF_NOQUEUEBAST	0x00000800
+#define DLM_LKF_HEADQUE		0x00001000
+#define DLM_LKF_NOORDER		0x00002000
+#define DLM_LKF_ORPHAN		0x00004000
+#define DLM_LKF_ALTPR		0x00008000
+#define DLM_LKF_ALTCW		0x00010000
+#define DLM_LKF_FORCEUNLOCK	0x00020000
+#define DLM_LKF_TIMEOUT		0x00040000
+
+/*
+ * Some return codes that are not in errno.h
+ */
+
+#define DLM_ECANCEL		0x10001
+#define DLM_EUNLOCK		0x10002
+
+#endif  /* __DLMCONSTANTS_DOT_H__ */
diff -uNr linux-2.6.32/usr/include/linux/dlm_device.h clean_modified/linux-2.6.32/usr/include/linux/dlm_device.h
--- linux-2.6.32/usr/include/linux/dlm_device.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dlm_device.h	2019-04-14 13:24:02.940257545 -0500
@@ -0,0 +1,108 @@
+/******************************************************************************
+*******************************************************************************
+**
+**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
+**  Copyright (C) 2004-2007 Red Hat, Inc.  All rights reserved.
+**
+**  This copyrighted material is made available to anyone wishing to use,
+**  modify, copy, or redistribute it subject to the terms and conditions
+**  of the GNU General Public License v.2.
+**
+*******************************************************************************
+******************************************************************************/
+
+#ifndef _LINUX_DLM_DEVICE_H
+#define _LINUX_DLM_DEVICE_H
+
+/* This is the device interface for dlm, most users will use a library
+ * interface.
+ */
+
+#include <linux/dlm.h>
+#include <linux/types.h>
+
+#define DLM_USER_LVB_LEN	32
+
+/* Version of the device interface */
+#define DLM_DEVICE_VERSION_MAJOR 6
+#define DLM_DEVICE_VERSION_MINOR 0
+#define DLM_DEVICE_VERSION_PATCH 1
+
+/* struct passed to the lock write */
+struct dlm_lock_params {
+	__u8 mode;
+	__u8 namelen;
+	__u16 unused;
+	__u32 flags;
+	__u32 lkid;
+	__u32 parent;
+	__u64 xid;
+	__u64 timeout;
+	void *castparam;
+	void *castaddr;
+	void *bastparam;
+	void *bastaddr;
+	struct dlm_lksb *lksb;
+	char lvb[DLM_USER_LVB_LEN];
+	char name[0];
+};
+
+struct dlm_lspace_params {
+	__u32 flags;
+	__u32 minor;
+	char name[0];
+};
+
+struct dlm_purge_params {
+	__u32 nodeid;
+	__u32 pid;
+};
+
+struct dlm_write_request {
+	__u32 version[3];
+	__u8 cmd;
+	__u8 is64bit;
+	__u8 unused[2];
+
+	union  {
+		struct dlm_lock_params   lock;
+		struct dlm_lspace_params lspace;
+		struct dlm_purge_params  purge;
+	} i;
+};
+
+struct dlm_device_version {
+	__u32 version[3];
+};
+
+/* struct read from the "device" fd,
+   consists mainly of userspace pointers for the library to use */
+
+struct dlm_lock_result {
+	__u32 version[3];
+	__u32 length;
+	void * user_astaddr;
+	void * user_astparam;
+	struct dlm_lksb * user_lksb;
+	struct dlm_lksb lksb;
+	__u8 bast_mode;
+	__u8 unused[3];
+	/* Offsets may be zero if no data is present */
+	__u32 lvb_offset;
+};
+
+/* Commands passed to the device */
+#define DLM_USER_LOCK         1
+#define DLM_USER_UNLOCK       2
+#define DLM_USER_QUERY        3
+#define DLM_USER_CREATE_LOCKSPACE  4
+#define DLM_USER_REMOVE_LOCKSPACE  5
+#define DLM_USER_PURGE        6
+#define DLM_USER_DEADLOCK     7
+
+/* Lockspace flags */
+#define DLM_USER_LSFLG_AUTOFREE   1
+#define DLM_USER_LSFLG_FORCEFREE  2
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/dlm.h clean_modified/linux-2.6.32/usr/include/linux/dlm.h
--- linux-2.6.32/usr/include/linux/dlm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dlm.h	2019-04-14 13:24:02.941256781 -0500
@@ -0,0 +1,77 @@
+/******************************************************************************
+*******************************************************************************
+**
+**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.
+**  Copyright (C) 2004-2008 Red Hat, Inc.  All rights reserved.
+**
+**  This copyrighted material is made available to anyone wishing to use,
+**  modify, copy, or redistribute it subject to the terms and conditions
+**  of the GNU General Public License v.2.
+**
+*******************************************************************************
+******************************************************************************/
+
+#ifndef __DLM_DOT_H__
+#define __DLM_DOT_H__
+
+/*
+ * Interface to Distributed Lock Manager (DLM)
+ * routines and structures to use DLM lockspaces
+ */
+
+/* Lock levels and flags are here */
+#include <linux/dlmconstants.h>
+#include <linux/types.h>
+
+typedef void dlm_lockspace_t;
+
+/*
+ * Lock status block
+ *
+ * Use this structure to specify the contents of the lock value block.  For a
+ * conversion request, this structure is used to specify the lock ID of the
+ * lock.  DLM writes the status of the lock request and the lock ID assigned
+ * to the request in the lock status block.
+ *
+ * sb_lkid: the returned lock ID.  It is set on new (non-conversion) requests.
+ * It is available when dlm_lock returns.
+ *
+ * sb_lvbptr: saves or returns the contents of the lock's LVB according to rules
+ * shown for the DLM_LKF_VALBLK flag.
+ *
+ * sb_flags: DLM_SBF_DEMOTED is returned if in the process of promoting a lock,
+ * it was first demoted to NL to avoid conversion deadlock.
+ * DLM_SBF_VALNOTVALID is returned if the resource's LVB is marked invalid.
+ *
+ * sb_status: the returned status of the lock request set prior to AST
+ * execution.  Possible return values:
+ *
+ * 0 if lock request was successful
+ * -EAGAIN if request would block and is flagged DLM_LKF_NOQUEUE
+ * -ENOMEM if there is no memory to process request
+ * -EINVAL if there are invalid parameters
+ * -DLM_EUNLOCK if unlock request was successful
+ * -DLM_ECANCEL if a cancel completed successfully
+ */
+
+#define DLM_SBF_DEMOTED		0x01
+#define DLM_SBF_VALNOTVALID	0x02
+#define DLM_SBF_ALTMODE		0x04
+
+struct dlm_lksb {
+	int 	 sb_status;
+	__u32	 sb_lkid;
+	char 	 sb_flags;
+	char *	 sb_lvbptr;
+};
+
+/* dlm_new_lockspace() flags */
+
+#define DLM_LSFL_NODIR		0x00000001
+#define DLM_LSFL_TIMEWARN	0x00000002
+#define DLM_LSFL_FS     	0x00000004
+#define DLM_LSFL_NEWEXCL     	0x00000008
+
+
+#endif				/* __DLM_DOT_H__ */
+
diff -uNr linux-2.6.32/usr/include/linux/dlm_netlink.h clean_modified/linux-2.6.32/usr/include/linux/dlm_netlink.h
--- linux-2.6.32/usr/include/linux/dlm_netlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dlm_netlink.h	2019-04-14 13:24:02.941256781 -0500
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2007 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef _DLM_NETLINK_H
+#define _DLM_NETLINK_H
+
+#include <linux/types.h>
+
+enum {
+	DLM_STATUS_WAITING = 1,
+	DLM_STATUS_GRANTED = 2,
+	DLM_STATUS_CONVERT = 3,
+};
+
+#define DLM_LOCK_DATA_VERSION 1
+
+struct dlm_lock_data {
+	__u16 version;
+	__u32 lockspace_id;
+	int nodeid;
+	int ownpid;
+	__u32 id;
+	__u32 remid;
+	__u64 xid;
+	__s8 status;
+	__s8 grmode;
+	__s8 rqmode;
+	unsigned long timestamp;
+	int resource_namelen;
+	char resource_name[DLM_RESNAME_MAXLEN];
+};
+
+enum {
+	DLM_CMD_UNSPEC = 0,
+	DLM_CMD_HELLO,		/* user->kernel */
+	DLM_CMD_TIMEOUT,	/* kernel->user */
+	__DLM_CMD_MAX,
+};
+
+#define DLM_CMD_MAX (__DLM_CMD_MAX - 1)
+
+enum {
+	DLM_TYPE_UNSPEC = 0,
+	DLM_TYPE_LOCK,
+	__DLM_TYPE_MAX,
+};
+
+#define DLM_TYPE_MAX (__DLM_TYPE_MAX - 1)
+
+#define DLM_GENL_VERSION 0x1
+#define DLM_GENL_NAME "DLM"
+
+#endif /* _DLM_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/dlm_plock.h clean_modified/linux-2.6.32/usr/include/linux/dlm_plock.h
--- linux-2.6.32/usr/include/linux/dlm_plock.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dlm_plock.h	2019-04-14 13:24:02.941256781 -0500
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2005-2008 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef __DLM_PLOCK_DOT_H__
+#define __DLM_PLOCK_DOT_H__
+
+#include <linux/types.h>
+
+#define DLM_PLOCK_MISC_NAME		"dlm_plock"
+
+#define DLM_PLOCK_VERSION_MAJOR	1
+#define DLM_PLOCK_VERSION_MINOR	1
+#define DLM_PLOCK_VERSION_PATCH	0
+
+enum {
+	DLM_PLOCK_OP_LOCK = 1,
+	DLM_PLOCK_OP_UNLOCK,
+	DLM_PLOCK_OP_GET,
+};
+
+struct dlm_plock_info {
+	__u32 version[3];
+	__u8 optype;
+	__u8 ex;
+	__u8 wait;
+	__u8 pad;
+	__u32 pid;
+	__s32 nodeid;
+	__s32 rv;
+	__u32 fsid;
+	__u64 number;
+	__u64 start;
+	__u64 end;
+	__u64 owner;
+};
+
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/dm-ioctl.h clean_modified/linux-2.6.32/usr/include/linux/dm-ioctl.h
--- linux-2.6.32/usr/include/linux/dm-ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dm-ioctl.h	2019-04-14 13:24:02.942551487 -0500
@@ -0,0 +1,312 @@
+/*
+ * Copyright (C) 2001 - 2003 Sistina Software (UK) Limited.
+ * Copyright (C) 2004 - 2005 Red Hat, Inc. All rights reserved.
+ *
+ * This file is released under the LGPL.
+ */
+
+#ifndef _LINUX_DM_IOCTL_V4_H
+#define _LINUX_DM_IOCTL_V4_H
+
+#include <linux/types.h>
+
+#define DM_DIR "mapper"		/* Slashes not supported */
+#define DM_MAX_TYPE_NAME 16
+#define DM_NAME_LEN 128
+#define DM_UUID_LEN 129
+
+/*
+ * A traditional ioctl interface for the device mapper.
+ *
+ * Each device can have two tables associated with it, an
+ * 'active' table which is the one currently used by io passing
+ * through the device, and an 'inactive' one which is a table
+ * that is being prepared as a replacement for the 'active' one.
+ *
+ * DM_VERSION:
+ * Just get the version information for the ioctl interface.
+ *
+ * DM_REMOVE_ALL:
+ * Remove all dm devices, destroy all tables.  Only really used
+ * for debug.
+ *
+ * DM_LIST_DEVICES:
+ * Get a list of all the dm device names.
+ *
+ * DM_DEV_CREATE:
+ * Create a new device, neither the 'active' or 'inactive' table
+ * slots will be filled.  The device will be in suspended state
+ * after creation, however any io to the device will get errored
+ * since it will be out-of-bounds.
+ *
+ * DM_DEV_REMOVE:
+ * Remove a device, destroy any tables.
+ *
+ * DM_DEV_RENAME:
+ * Rename a device.
+ *
+ * DM_SUSPEND:
+ * This performs both suspend and resume, depending which flag is
+ * passed in.
+ * Suspend: This command will not return until all pending io to
+ * the device has completed.  Further io will be deferred until
+ * the device is resumed.
+ * Resume: It is no longer an error to issue this command on an
+ * unsuspended device.  If a table is present in the 'inactive'
+ * slot, it will be moved to the active slot, then the old table
+ * from the active slot will be _destroyed_.  Finally the device
+ * is resumed.
+ *
+ * DM_DEV_STATUS:
+ * Retrieves the status for the table in the 'active' slot.
+ *
+ * DM_DEV_WAIT:
+ * Wait for a significant event to occur to the device.  This
+ * could either be caused by an event triggered by one of the
+ * targets of the table in the 'active' slot, or a table change.
+ *
+ * DM_TABLE_LOAD:
+ * Load a table into the 'inactive' slot for the device.  The
+ * device does _not_ need to be suspended prior to this command.
+ *
+ * DM_TABLE_CLEAR:
+ * Destroy any table in the 'inactive' slot (ie. abort).
+ *
+ * DM_TABLE_DEPS:
+ * Return a set of device dependencies for the 'active' table.
+ *
+ * DM_TABLE_STATUS:
+ * Return the targets status for the 'active' table.
+ *
+ * DM_TARGET_MSG:
+ * Pass a message string to the target at a specific offset of a device.
+ *
+ * DM_DEV_SET_GEOMETRY:
+ * Set the geometry of a device by passing in a string in this format:
+ *
+ * "cylinders heads sectors_per_track start_sector"
+ *
+ * Beware that CHS geometry is nearly obsolete and only provided
+ * for compatibility with dm devices that can be booted by a PC
+ * BIOS.  See struct hd_geometry for range limits.  Also note that
+ * the geometry is erased if the device size changes.
+ */
+
+/*
+ * All ioctl arguments consist of a single chunk of memory, with
+ * this structure at the start.  If a uuid is specified any
+ * lookup (eg. for a DM_INFO) will be done on that, *not* the
+ * name.
+ */
+struct dm_ioctl {
+	/*
+	 * The version number is made up of three parts:
+	 * major - no backward or forward compatibility,
+	 * minor - only backwards compatible,
+	 * patch - both backwards and forwards compatible.
+	 *
+	 * All clients of the ioctl interface should fill in the
+	 * version number of the interface that they were
+	 * compiled with.
+	 *
+	 * All recognised ioctl commands (ie. those that don't
+	 * return -ENOTTY) fill out this field, even if the
+	 * command failed.
+	 */
+	__u32 version[3];	/* in/out */
+	__u32 data_size;	/* total size of data passed in
+				 * including this struct */
+
+	__u32 data_start;	/* offset to start of data
+				 * relative to start of this struct */
+
+	__u32 target_count;	/* in/out */
+	__s32 open_count;	/* out */
+	__u32 flags;		/* in/out */
+
+	/*
+	 * event_nr holds either the event number (input and output) or the
+	 * udev cookie value (input only).
+	 * The DM_DEV_WAIT ioctl takes an event number as input.
+	 * The DM_SUSPEND, DM_DEV_REMOVE and DM_DEV_RENAME ioctls
+	 * use the field as a cookie to return in the DM_COOKIE
+	 * variable with the uevents they issue.
+	 * For output, the ioctls return the event number, not the cookie.
+	 */
+	__u32 event_nr;      	/* in/out */
+	__u32 padding;
+
+	__u64 dev;		/* in/out */
+
+	char name[DM_NAME_LEN];	/* device name */
+	char uuid[DM_UUID_LEN];	/* unique identifier for
+				 * the block device */
+	char data[7];		/* padding or data */
+};
+
+/*
+ * Used to specify tables.  These structures appear after the
+ * dm_ioctl.
+ */
+struct dm_target_spec {
+	__u64 sector_start;
+	__u64 length;
+	__s32 status;		/* used when reading from kernel only */
+
+	/*
+	 * Location of the next dm_target_spec.
+	 * - When specifying targets on a DM_TABLE_LOAD command, this value is
+	 *   the number of bytes from the start of the "current" dm_target_spec
+	 *   to the start of the "next" dm_target_spec.
+	 * - When retrieving targets on a DM_TABLE_STATUS command, this value
+	 *   is the number of bytes from the start of the first dm_target_spec
+	 *   (that follows the dm_ioctl struct) to the start of the "next"
+	 *   dm_target_spec.
+	 */
+	__u32 next;
+
+	char target_type[DM_MAX_TYPE_NAME];
+
+	/*
+	 * Parameter string starts immediately after this object.
+	 * Be careful to add padding after string to ensure correct
+	 * alignment of subsequent dm_target_spec.
+	 */
+};
+
+/*
+ * Used to retrieve the target dependencies.
+ */
+struct dm_target_deps {
+	__u32 count;	/* Array size */
+	__u32 padding;	/* unused */
+	__u64 dev[0];	/* out */
+};
+
+/*
+ * Used to get a list of all dm devices.
+ */
+struct dm_name_list {
+	__u64 dev;
+	__u32 next;		/* offset to the next record from
+				   the _start_ of this */
+	char name[0];
+};
+
+/*
+ * Used to retrieve the target versions
+ */
+struct dm_target_versions {
+        __u32 next;
+        __u32 version[3];
+
+        char name[0];
+};
+
+/*
+ * Used to pass message to a target
+ */
+struct dm_target_msg {
+	__u64 sector;	/* Device sector */
+
+	char message[0];
+};
+
+/*
+ * If you change this make sure you make the corresponding change
+ * to dm-ioctl.c:lookup_ioctl()
+ */
+enum {
+	/* Top level cmds */
+	DM_VERSION_CMD = 0,
+	DM_REMOVE_ALL_CMD,
+	DM_LIST_DEVICES_CMD,
+
+	/* device level cmds */
+	DM_DEV_CREATE_CMD,
+	DM_DEV_REMOVE_CMD,
+	DM_DEV_RENAME_CMD,
+	DM_DEV_SUSPEND_CMD,
+	DM_DEV_STATUS_CMD,
+	DM_DEV_WAIT_CMD,
+
+	/* Table level cmds */
+	DM_TABLE_LOAD_CMD,
+	DM_TABLE_CLEAR_CMD,
+	DM_TABLE_DEPS_CMD,
+	DM_TABLE_STATUS_CMD,
+
+	/* Added later */
+	DM_LIST_VERSIONS_CMD,
+	DM_TARGET_MSG_CMD,
+	DM_DEV_SET_GEOMETRY_CMD
+};
+
+#define DM_IOCTL 0xfd
+
+#define DM_VERSION       _IOWR(DM_IOCTL, DM_VERSION_CMD, struct dm_ioctl)
+#define DM_REMOVE_ALL    _IOWR(DM_IOCTL, DM_REMOVE_ALL_CMD, struct dm_ioctl)
+#define DM_LIST_DEVICES  _IOWR(DM_IOCTL, DM_LIST_DEVICES_CMD, struct dm_ioctl)
+
+#define DM_DEV_CREATE    _IOWR(DM_IOCTL, DM_DEV_CREATE_CMD, struct dm_ioctl)
+#define DM_DEV_REMOVE    _IOWR(DM_IOCTL, DM_DEV_REMOVE_CMD, struct dm_ioctl)
+#define DM_DEV_RENAME    _IOWR(DM_IOCTL, DM_DEV_RENAME_CMD, struct dm_ioctl)
+#define DM_DEV_SUSPEND   _IOWR(DM_IOCTL, DM_DEV_SUSPEND_CMD, struct dm_ioctl)
+#define DM_DEV_STATUS    _IOWR(DM_IOCTL, DM_DEV_STATUS_CMD, struct dm_ioctl)
+#define DM_DEV_WAIT      _IOWR(DM_IOCTL, DM_DEV_WAIT_CMD, struct dm_ioctl)
+
+#define DM_TABLE_LOAD    _IOWR(DM_IOCTL, DM_TABLE_LOAD_CMD, struct dm_ioctl)
+#define DM_TABLE_CLEAR   _IOWR(DM_IOCTL, DM_TABLE_CLEAR_CMD, struct dm_ioctl)
+#define DM_TABLE_DEPS    _IOWR(DM_IOCTL, DM_TABLE_DEPS_CMD, struct dm_ioctl)
+#define DM_TABLE_STATUS  _IOWR(DM_IOCTL, DM_TABLE_STATUS_CMD, struct dm_ioctl)
+
+#define DM_LIST_VERSIONS _IOWR(DM_IOCTL, DM_LIST_VERSIONS_CMD, struct dm_ioctl)
+
+#define DM_TARGET_MSG	 _IOWR(DM_IOCTL, DM_TARGET_MSG_CMD, struct dm_ioctl)
+#define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)
+
+#define DM_VERSION_MAJOR	4
+#define DM_VERSION_MINOR	15
+#define DM_VERSION_PATCHLEVEL	0
+#define DM_VERSION_EXTRA	"-ioctl (2009-04-01)"
+
+/* Status bits */
+#define DM_READONLY_FLAG	(1 << 0) /* In/Out */
+#define DM_SUSPEND_FLAG		(1 << 1) /* In/Out */
+#define DM_PERSISTENT_DEV_FLAG	(1 << 3) /* In */
+
+/*
+ * Flag passed into ioctl STATUS command to get table information
+ * rather than current status.
+ */
+#define DM_STATUS_TABLE_FLAG	(1 << 4) /* In */
+
+/*
+ * Flags that indicate whether a table is present in either of
+ * the two table slots that a device has.
+ */
+#define DM_ACTIVE_PRESENT_FLAG   (1 << 5) /* Out */
+#define DM_INACTIVE_PRESENT_FLAG (1 << 6) /* Out */
+
+/*
+ * Indicates that the buffer passed in wasn't big enough for the
+ * results.
+ */
+#define DM_BUFFER_FULL_FLAG	(1 << 8) /* Out */
+
+/*
+ * This flag is now ignored.
+ */
+#define DM_SKIP_BDGET_FLAG	(1 << 9) /* In */
+
+/*
+ * Set this to avoid attempting to freeze any filesystem when suspending.
+ */
+#define DM_SKIP_LOCKFS_FLAG	(1 << 10) /* In */
+
+/*
+ * Set this to suspend without flushing queued ios.
+ */
+#define DM_NOFLUSH_FLAG		(1 << 11) /* In */
+
+#endif				/* _LINUX_DM_IOCTL_H */
diff -uNr linux-2.6.32/usr/include/linux/dm-log-userspace.h clean_modified/linux-2.6.32/usr/include/linux/dm-log-userspace.h
--- linux-2.6.32/usr/include/linux/dm-log-userspace.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dm-log-userspace.h	2019-04-14 13:24:02.944193851 -0500
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2006-2009 Red Hat, Inc.
+ *
+ * This file is released under the LGPL.
+ */
+
+#ifndef __DM_LOG_USERSPACE_H__
+#define __DM_LOG_USERSPACE_H__
+
+#include <linux/dm-ioctl.h> /* For DM_UUID_LEN */
+
+/*
+ * The device-mapper userspace log module consists of a kernel component and
+ * a user-space component.  The kernel component implements the API defined
+ * in dm-dirty-log.h.  Its purpose is simply to pass the parameters and
+ * return values of those API functions between kernel and user-space.
+ *
+ * Below are defined the 'request_types' - DM_ULOG_CTR, DM_ULOG_DTR, etc.
+ * These request types represent the different functions in the device-mapper
+ * dirty log API.  Each of these is described in more detail below.
+ *
+ * The user-space program must listen for requests from the kernel (representing
+ * the various API functions) and process them.
+ *
+ * User-space begins by setting up the communication link (error checking
+ * removed for clarity):
+ *	fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);
+ *	addr.nl_family = AF_NETLINK;
+ *	addr.nl_groups = CN_IDX_DM;
+ *	addr.nl_pid = 0;
+ *	r = bind(fd, (struct sockaddr *) &addr, sizeof(addr));
+ *	opt = addr.nl_groups;
+ *	setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &opt, sizeof(opt));
+ *
+ * User-space will then wait to receive requests form the kernel, which it
+ * will process as described below.  The requests are received in the form,
+ * ((struct dm_ulog_request) + (additional data)).  Depending on the request
+ * type, there may or may not be 'additional data'.  In the descriptions below,
+ * you will see 'Payload-to-userspace' and 'Payload-to-kernel'.  The
+ * 'Payload-to-userspace' is what the kernel sends in 'additional data' as
+ * necessary parameters to complete the request.  The 'Payload-to-kernel' is
+ * the 'additional data' returned to the kernel that contains the necessary
+ * results of the request.  The 'data_size' field in the dm_ulog_request
+ * structure denotes the availability and amount of payload data.
+ */
+
+/*
+ * DM_ULOG_CTR corresponds to (found in dm-dirty-log.h):
+ * int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
+ *	      unsigned argc, char **argv);
+ *
+ * Payload-to-userspace:
+ *	A single string containing all the argv arguments separated by ' 's
+ * Payload-to-kernel:
+ *	None.  ('data_size' in the dm_ulog_request struct should be 0.)
+ *
+ * The UUID contained in the dm_ulog_request structure is the reference that
+ * will be used by all request types to a specific log.  The constructor must
+ * record this assotiation with instance created.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_CTR                    1
+
+/*
+ * DM_ULOG_DTR corresponds to (found in dm-dirty-log.h):
+ * void (*dtr)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	A single string containing all the argv arguments separated by ' 's
+ * Payload-to-kernel:
+ *	None.  ('data_size' in the dm_ulog_request struct should be 0.)
+ *
+ * The UUID contained in the dm_ulog_request structure is all that is
+ * necessary to identify the log instance being destroyed.  There is no
+ * payload data.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and clearing
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_DTR                    2
+
+/*
+ * DM_ULOG_PRESUSPEND corresponds to (found in dm-dirty-log.h):
+ * int (*presuspend)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	None.
+ *
+ * The UUID contained in the dm_ulog_request structure is all that is
+ * necessary to identify the log instance being presuspended.  There is no
+ * payload data.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_PRESUSPEND             3
+
+/*
+ * DM_ULOG_POSTSUSPEND corresponds to (found in dm-dirty-log.h):
+ * int (*postsuspend)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	None.
+ *
+ * The UUID contained in the dm_ulog_request structure is all that is
+ * necessary to identify the log instance being postsuspended.  There is no
+ * payload data.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_POSTSUSPEND            4
+
+/*
+ * DM_ULOG_RESUME corresponds to (found in dm-dirty-log.h):
+ * int (*resume)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	None.
+ *
+ * The UUID contained in the dm_ulog_request structure is all that is
+ * necessary to identify the log instance being resumed.  There is no
+ * payload data.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_RESUME                 5
+
+/*
+ * DM_ULOG_GET_REGION_SIZE corresponds to (found in dm-dirty-log.h):
+ * uint32_t (*get_region_size)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	uint64_t - contains the region size
+ *
+ * The region size is something that was determined at constructor time.
+ * It is returned in the payload area and 'data_size' is set to
+ * reflect this.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field appropriately.
+ */
+#define DM_ULOG_GET_REGION_SIZE        6
+
+/*
+ * DM_ULOG_IS_CLEAN corresponds to (found in dm-dirty-log.h):
+ * int (*is_clean)(struct dm_dirty_log *log, region_t region);
+ *
+ * Payload-to-userspace:
+ *	uint64_t - the region to get clean status on
+ * Payload-to-kernel:
+ *	int64_t  - 1 if clean, 0 otherwise
+ *
+ * Payload is sizeof(uint64_t) and contains the region for which the clean
+ * status is being made.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - filling the payload with 0 (not clean) or
+ * 1 (clean), setting 'data_size' and 'error' appropriately.
+ */
+#define DM_ULOG_IS_CLEAN               7
+
+/*
+ * DM_ULOG_IN_SYNC corresponds to (found in dm-dirty-log.h):
+ * int (*in_sync)(struct dm_dirty_log *log, region_t region,
+ *		  int can_block);
+ *
+ * Payload-to-userspace:
+ *	uint64_t - the region to get sync status on
+ * Payload-to-kernel:
+ *	int64_t - 1 if in-sync, 0 otherwise
+ *
+ * Exactly the same as 'is_clean' above, except this time asking "has the
+ * region been recovered?" vs. "is the region not being modified?"
+ */
+#define DM_ULOG_IN_SYNC                8
+
+/*
+ * DM_ULOG_FLUSH corresponds to (found in dm-dirty-log.h):
+ * int (*flush)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	None.
+ *
+ * No incoming or outgoing payload.  Simply flush log state to disk.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and clearing
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_FLUSH                  9
+
+/*
+ * DM_ULOG_MARK_REGION corresponds to (found in dm-dirty-log.h):
+ * void (*mark_region)(struct dm_dirty_log *log, region_t region);
+ *
+ * Payload-to-userspace:
+ *	uint64_t [] - region(s) to mark
+ * Payload-to-kernel:
+ *	None.
+ *
+ * Incoming payload contains the one or more regions to mark dirty.
+ * The number of regions contained in the payload can be determined from
+ * 'data_size/sizeof(uint64_t)'.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and clearing
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_MARK_REGION           10
+
+/*
+ * DM_ULOG_CLEAR_REGION corresponds to (found in dm-dirty-log.h):
+ * void (*clear_region)(struct dm_dirty_log *log, region_t region);
+ *
+ * Payload-to-userspace:
+ *	uint64_t [] - region(s) to clear
+ * Payload-to-kernel:
+ *	None.
+ *
+ * Incoming payload contains the one or more regions to mark clean.
+ * The number of regions contained in the payload can be determined from
+ * 'data_size/sizeof(uint64_t)'.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and clearing
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_CLEAR_REGION          11
+
+/*
+ * DM_ULOG_GET_RESYNC_WORK corresponds to (found in dm-dirty-log.h):
+ * int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	{
+ *		int64_t i; -- 1 if recovery necessary, 0 otherwise
+ *		uint64_t r; -- The region to recover if i=1
+ *	}
+ * 'data_size' should be set appropriately.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field appropriately.
+ */
+#define DM_ULOG_GET_RESYNC_WORK       12
+
+/*
+ * DM_ULOG_SET_REGION_SYNC corresponds to (found in dm-dirty-log.h):
+ * void (*set_region_sync)(struct dm_dirty_log *log,
+ *			   region_t region, int in_sync);
+ *
+ * Payload-to-userspace:
+ *	{
+ *		uint64_t - region to set sync state on
+ *		int64_t  - 0 if not-in-sync, 1 if in-sync
+ *	}
+ * Payload-to-kernel:
+ *	None.
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and clearing
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_SET_REGION_SYNC       13
+
+/*
+ * DM_ULOG_GET_SYNC_COUNT corresponds to (found in dm-dirty-log.h):
+ * region_t (*get_sync_count)(struct dm_dirty_log *log);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	uint64_t - the number of in-sync regions
+ *
+ * No incoming payload.  Kernel-bound payload contains the number of
+ * regions that are in-sync (in a size_t).
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_GET_SYNC_COUNT        14
+
+/*
+ * DM_ULOG_STATUS_INFO corresponds to (found in dm-dirty-log.h):
+ * int (*status)(struct dm_dirty_log *log, STATUSTYPE_INFO,
+ *		 char *result, unsigned maxlen);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	Character string containing STATUSTYPE_INFO
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_STATUS_INFO           15
+
+/*
+ * DM_ULOG_STATUS_TABLE corresponds to (found in dm-dirty-log.h):
+ * int (*status)(struct dm_dirty_log *log, STATUSTYPE_TABLE,
+ *		 char *result, unsigned maxlen);
+ *
+ * Payload-to-userspace:
+ *	None.
+ * Payload-to-kernel:
+ *	Character string containing STATUSTYPE_TABLE
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_STATUS_TABLE          16
+
+/*
+ * DM_ULOG_IS_REMOTE_RECOVERING corresponds to (found in dm-dirty-log.h):
+ * int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);
+ *
+ * Payload-to-userspace:
+ *	uint64_t - region to determine recovery status on
+ * Payload-to-kernel:
+ *	{
+ *		int64_t is_recovering;  -- 0 if no, 1 if yes
+ *		uint64_t in_sync_hint;  -- lowest region still needing resync
+ *	}
+ *
+ * When the request has been processed, user-space must return the
+ * dm_ulog_request to the kernel - setting the 'error' field and
+ * 'data_size' appropriately.
+ */
+#define DM_ULOG_IS_REMOTE_RECOVERING  17
+
+/*
+ * (DM_ULOG_REQUEST_MASK & request_type) to get the request type
+ *
+ * Payload-to-userspace:
+ *	A single string containing all the argv arguments separated by ' 's
+ * Payload-to-kernel:
+ *	None.  ('data_size' in the dm_ulog_request struct should be 0.)
+ *
+ * We are reserving 8 bits of the 32-bit 'request_type' field for the
+ * various request types above.  The remaining 24-bits are currently
+ * set to zero and are reserved for future use and compatibility concerns.
+ *
+ * User-space should always use DM_ULOG_REQUEST_TYPE to aquire the
+ * request type from the 'request_type' field to maintain forward compatibility.
+ */
+#define DM_ULOG_REQUEST_MASK 0xFF
+#define DM_ULOG_REQUEST_TYPE(request_type) \
+	(DM_ULOG_REQUEST_MASK & (request_type))
+
+struct dm_ulog_request {
+	/*
+	 * The local unique identifier (luid) and the universally unique
+	 * identifier (uuid) are used to tie a request to a specific
+	 * mirror log.  A single machine log could probably make due with
+	 * just the 'luid', but a cluster-aware log must use the 'uuid' and
+	 * the 'luid'.  The uuid is what is required for node to node
+	 * communication concerning a particular log, but the 'luid' helps
+	 * differentiate between logs that are being swapped and have the
+	 * same 'uuid'.  (Think "live" and "inactive" device-mapper tables.)
+	 */
+	uint64_t luid;
+	char uuid[DM_UUID_LEN];
+	char padding[7];        /* Padding because DM_UUID_LEN = 129 */
+
+	int32_t error;          /* Used to report back processing errors */
+
+	uint32_t seq;           /* Sequence number for request */
+	uint32_t request_type;  /* DM_ULOG_* defined above */
+	uint32_t data_size;     /* How much data (not including this struct) */
+
+	char data[0];
+};
+
+#endif /* __DM_LOG_USERSPACE_H__ */
diff -uNr linux-2.6.32/usr/include/linux/dn.h clean_modified/linux-2.6.32/usr/include/linux/dn.h
--- linux-2.6.32/usr/include/linux/dn.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dn.h	2019-04-14 13:24:02.944193851 -0500
@@ -0,0 +1,149 @@
+#ifndef _LINUX_DN_H
+#define _LINUX_DN_H
+
+#include <linux/types.h>
+
+/*
+
+	DECnet Data Structures and Constants
+
+*/
+
+/* 
+ * DNPROTO_NSP can't be the same as SOL_SOCKET, 
+ * so increment each by one (compared to ULTRIX)
+ */
+#define DNPROTO_NSP     2                       /* NSP protocol number       */
+#define DNPROTO_ROU     3                       /* Routing protocol number   */
+#define DNPROTO_NML     4                       /* Net mgt protocol number   */
+#define DNPROTO_EVL     5                       /* Evl protocol number (usr) */
+#define DNPROTO_EVR     6                       /* Evl protocol number (evl) */
+#define DNPROTO_NSPT    7                       /* NSP trace protocol number */
+
+
+#define DN_ADDL		2
+#define DN_MAXADDL	2 /* ULTRIX headers have 20 here, but pathworks has 2 */
+#define DN_MAXOPTL	16
+#define DN_MAXOBJL	16
+#define DN_MAXACCL	40
+#define DN_MAXALIASL	128
+#define DN_MAXNODEL	256
+#define DNBUFSIZE	65023
+
+/* 
+ * SET/GET Socket options  - must match the DSO_ numbers below
+ */
+#define SO_CONDATA      1
+#define SO_CONACCESS    2
+#define SO_PROXYUSR     3
+#define SO_LINKINFO     7
+
+#define DSO_CONDATA     1        /* Set/Get connect data                */
+#define DSO_DISDATA     10       /* Set/Get disconnect data             */
+#define DSO_CONACCESS   2        /* Set/Get connect access data         */
+#define DSO_ACCEPTMODE  4        /* Set/Get accept mode                 */
+#define DSO_CONACCEPT   5        /* Accept deferred connection          */
+#define DSO_CONREJECT   6        /* Reject deferred connection          */
+#define DSO_LINKINFO    7        /* Set/Get link information            */
+#define DSO_STREAM      8        /* Set socket type to stream           */
+#define DSO_SEQPACKET   9        /* Set socket type to sequenced packet */
+#define DSO_MAXWINDOW   11       /* Maximum window size allowed         */
+#define DSO_NODELAY	12       /* Turn off nagle                      */
+#define DSO_CORK        13       /* Wait for more data!                 */
+#define DSO_SERVICES	14       /* NSP Services field                  */
+#define DSO_INFO	15       /* NSP Info field                      */
+#define DSO_MAX         15       /* Maximum option number               */
+
+
+/* LINK States */
+#define LL_INACTIVE	0
+#define LL_CONNECTING	1
+#define LL_RUNNING	2
+#define LL_DISCONNECTING 3
+
+#define ACC_IMMED 0
+#define ACC_DEFER 1
+
+#define SDF_WILD        1                  /* Wild card object          */
+#define SDF_PROXY       2                  /* Addr eligible for proxy   */
+#define SDF_UICPROXY    4                  /* Use uic-based proxy       */
+
+/* Structures */
+
+
+struct dn_naddr 
+{
+	__le16		a_len;
+	__u8 a_addr[DN_MAXADDL]; /* Two bytes little endian */
+};
+
+struct sockaddr_dn
+{
+	__u16		sdn_family;
+	__u8		sdn_flags;
+	__u8		sdn_objnum;
+	__le16		sdn_objnamel;
+	__u8		sdn_objname[DN_MAXOBJL];
+	struct   dn_naddr	sdn_add;
+};
+#define sdn_nodeaddrl   sdn_add.a_len   /* Node address length  */
+#define sdn_nodeaddr    sdn_add.a_addr  /* Node address         */
+
+
+
+/*
+ * DECnet set/get DSO_CONDATA, DSO_DISDATA (optional data) structure
+ */
+struct optdata_dn {
+        __le16  opt_status;     /* Extended status return */
+#define opt_sts opt_status
+        __le16  opt_optl;       /* Length of user data    */
+        __u8   opt_data[16];   /* User data              */
+};
+
+struct accessdata_dn
+{
+	__u8		acc_accl;
+	__u8		acc_acc[DN_MAXACCL];
+	__u8 		acc_passl;
+	__u8		acc_pass[DN_MAXACCL];
+	__u8 		acc_userl;
+	__u8		acc_user[DN_MAXACCL];
+};
+
+/*
+ * DECnet logical link information structure
+ */
+struct linkinfo_dn {
+        __u16  idn_segsize;    /* Segment size for link */
+        __u8   idn_linkstate;  /* Logical link state    */
+};
+
+/*
+ * Ethernet address format (for DECnet)
+ */
+union etheraddress {
+        __u8 dne_addr[6];             /* Full ethernet address */
+  struct {
+                __u8 dne_hiord[4];    /* DECnet HIORD prefix   */
+                __u8 dne_nodeaddr[2]; /* DECnet node address   */
+  } dne_remote;
+};
+
+
+/*
+ * DECnet physical socket address format
+ */
+struct dn_addr {
+        __le16 dna_family;      /* AF_DECnet               */
+        union etheraddress dna_netaddr; /* DECnet ethernet address */
+};
+
+#define DECNET_IOCTL_BASE 0x89 /* PROTOPRIVATE range */
+
+#define SIOCSNETADDR  _IOW(DECNET_IOCTL_BASE, 0xe0, struct dn_naddr)
+#define SIOCGNETADDR  _IOR(DECNET_IOCTL_BASE, 0xe1, struct dn_naddr)
+#define OSIOCSNETADDR _IOW(DECNET_IOCTL_BASE, 0xe0, int)
+#define OSIOCGNETADDR _IOR(DECNET_IOCTL_BASE, 0xe1, int)
+
+#endif /* _LINUX_DN_H */
diff -uNr linux-2.6.32/usr/include/linux/dqblk_xfs.h clean_modified/linux-2.6.32/usr/include/linux/dqblk_xfs.h
--- linux-2.6.32/usr/include/linux/dqblk_xfs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dqblk_xfs.h	2019-04-14 13:24:02.945157535 -0500
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 1995-2001,2004 Silicon Graphics, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesset General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _LINUX_DQBLK_XFS_H
+#define _LINUX_DQBLK_XFS_H
+
+#include <linux/types.h>
+
+/*
+ * Disk quota - quotactl(2) commands for the XFS Quota Manager (XQM).
+ */
+
+#define XQM_CMD(x)	(('X'<<8)+(x))	/* note: forms first QCMD argument */
+#define XQM_COMMAND(x)	(((x) & (0xff<<8)) == ('X'<<8))	/* test if for XFS */
+
+#define XQM_USRQUOTA	0	/* system call user quota type */
+#define XQM_GRPQUOTA	1	/* system call group quota type */
+#define XQM_PRJQUOTA	2	/* system call project quota type */
+#define XQM_MAXQUOTAS	3
+
+#define Q_XQUOTAON	XQM_CMD(1)	/* enable accounting/enforcement */
+#define Q_XQUOTAOFF	XQM_CMD(2)	/* disable accounting/enforcement */
+#define Q_XGETQUOTA	XQM_CMD(3)	/* get disk limits and usage */
+#define Q_XSETQLIM	XQM_CMD(4)	/* set disk limits */
+#define Q_XGETQSTAT	XQM_CMD(5)	/* get quota subsystem status */
+#define Q_XQUOTARM	XQM_CMD(6)	/* free disk space used by dquots */
+#define Q_XQUOTASYNC	XQM_CMD(7)	/* delalloc flush, updates dquots */
+
+/*
+ * fs_disk_quota structure:
+ *
+ * This contains the current quota information regarding a user/proj/group.
+ * It is 64-bit aligned, and all the blk units are in BBs (Basic Blocks) of
+ * 512 bytes.
+ */
+#define FS_DQUOT_VERSION	1	/* fs_disk_quota.d_version */
+typedef struct fs_disk_quota {
+	__s8		d_version;	/* version of this structure */
+	__s8		d_flags;	/* XFS_{USER,PROJ,GROUP}_QUOTA */
+	__u16		d_fieldmask;	/* field specifier */
+	__u32		d_id;		/* user, project, or group ID */
+	__u64		d_blk_hardlimit;/* absolute limit on disk blks */
+	__u64		d_blk_softlimit;/* preferred limit on disk blks */
+	__u64		d_ino_hardlimit;/* maximum # allocated inodes */
+	__u64		d_ino_softlimit;/* preferred inode limit */
+	__u64		d_bcount;	/* # disk blocks owned by the user */
+	__u64		d_icount;	/* # inodes owned by the user */
+	__s32		d_itimer;	/* zero if within inode limits */
+					/* if not, we refuse service */
+	__s32		d_btimer;	/* similar to above; for disk blocks */
+	__u16	  	d_iwarns;       /* # warnings issued wrt num inodes */
+	__u16	  	d_bwarns;       /* # warnings issued wrt disk blocks */
+	__s32		d_padding2;	/* padding2 - for future use */
+	__u64		d_rtb_hardlimit;/* absolute limit on realtime blks */
+	__u64		d_rtb_softlimit;/* preferred limit on RT disk blks */
+	__u64		d_rtbcount;	/* # realtime blocks owned */
+	__s32		d_rtbtimer;	/* similar to above; for RT disk blks */
+	__u16	  	d_rtbwarns;     /* # warnings issued wrt RT disk blks */
+	__s16		d_padding3;	/* padding3 - for future use */	
+	char		d_padding4[8];	/* yet more padding */
+} fs_disk_quota_t;
+
+/*
+ * These fields are sent to Q_XSETQLIM to specify fields that need to change.
+ */
+#define FS_DQ_ISOFT	(1<<0)
+#define FS_DQ_IHARD	(1<<1)
+#define FS_DQ_BSOFT	(1<<2)
+#define FS_DQ_BHARD 	(1<<3)
+#define FS_DQ_RTBSOFT	(1<<4)
+#define FS_DQ_RTBHARD	(1<<5)
+#define FS_DQ_LIMIT_MASK	(FS_DQ_ISOFT | FS_DQ_IHARD | FS_DQ_BSOFT | \
+				 FS_DQ_BHARD | FS_DQ_RTBSOFT | FS_DQ_RTBHARD)
+/*
+ * These timers can only be set in super user's dquot. For others, timers are
+ * automatically started and stopped. Superusers timer values set the limits
+ * for the rest.  In case these values are zero, the DQ_{F,B}TIMELIMIT values
+ * defined below are used. 
+ * These values also apply only to the d_fieldmask field for Q_XSETQLIM.
+ */
+#define FS_DQ_BTIMER	(1<<6)
+#define FS_DQ_ITIMER	(1<<7)
+#define FS_DQ_RTBTIMER 	(1<<8)
+#define FS_DQ_TIMER_MASK	(FS_DQ_BTIMER | FS_DQ_ITIMER | FS_DQ_RTBTIMER)
+
+/*
+ * Warning counts are set in both super user's dquot and others. For others,
+ * warnings are set/cleared by the administrators (or automatically by going
+ * below the soft limit).  Superusers warning values set the warning limits
+ * for the rest.  In case these values are zero, the DQ_{F,B}WARNLIMIT values
+ * defined below are used. 
+ * These values also apply only to the d_fieldmask field for Q_XSETQLIM.
+ */
+#define FS_DQ_BWARNS	(1<<9)
+#define FS_DQ_IWARNS	(1<<10)
+#define FS_DQ_RTBWARNS	(1<<11)
+#define FS_DQ_WARNS_MASK	(FS_DQ_BWARNS | FS_DQ_IWARNS | FS_DQ_RTBWARNS)
+
+/*
+ * Various flags related to quotactl(2).  Only relevant to XFS filesystems.
+ */
+#define XFS_QUOTA_UDQ_ACCT	(1<<0)  /* user quota accounting */
+#define XFS_QUOTA_UDQ_ENFD	(1<<1)  /* user quota limits enforcement */
+#define XFS_QUOTA_GDQ_ACCT	(1<<2)  /* group quota accounting */
+#define XFS_QUOTA_GDQ_ENFD	(1<<3)  /* group quota limits enforcement */
+#define XFS_QUOTA_PDQ_ACCT	(1<<4)  /* project quota accounting */
+#define XFS_QUOTA_PDQ_ENFD	(1<<5)  /* project quota limits enforcement */
+
+#define XFS_USER_QUOTA		(1<<0)	/* user quota type */
+#define XFS_PROJ_QUOTA		(1<<1)	/* project quota type */
+#define XFS_GROUP_QUOTA		(1<<2)	/* group quota type */
+
+/*
+ * fs_quota_stat is the struct returned in Q_XGETQSTAT for a given file system.
+ * Provides a centralized way to get meta information about the quota subsystem.
+ * eg. space taken up for user and group quotas, number of dquots currently
+ * incore.
+ */
+#define FS_QSTAT_VERSION	1	/* fs_quota_stat.qs_version */
+
+/*
+ * Some basic information about 'quota files'.
+ */
+typedef struct fs_qfilestat {
+	__u64		qfs_ino;	/* inode number */
+	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
+	__u32		qfs_nextents;	/* number of extents */
+} fs_qfilestat_t;
+
+typedef struct fs_quota_stat {
+	__s8		qs_version;	/* version number for future changes */
+	__u16		qs_flags;	/* XFS_QUOTA_{U,P,G}DQ_{ACCT,ENFD} */
+	__s8		qs_pad;		/* unused */
+	fs_qfilestat_t	qs_uquota;	/* user quota storage information */
+	fs_qfilestat_t	qs_gquota;	/* group quota storage information */
+	__u32		qs_incoredqs;	/* number of dquots incore */
+	__s32		qs_btimelimit;  /* limit for blks timer */	
+	__s32		qs_itimelimit;  /* limit for inodes timer */	
+	__s32		qs_rtbtimelimit;/* limit for rt blks timer */	
+	__u16		qs_bwarnlimit;	/* limit for num warnings */
+	__u16		qs_iwarnlimit;	/* limit for num warnings */
+} fs_quota_stat_t;
+
+#endif	/* _LINUX_DQBLK_XFS_H */
diff -uNr linux-2.6.32/usr/include/linux/dvb/audio.h clean_modified/linux-2.6.32/usr/include/linux/dvb/audio.h
--- linux-2.6.32/usr/include/linux/dvb/audio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/audio.h	2019-04-14 13:24:02.945157535 -0500
@@ -0,0 +1,135 @@
+/*
+ * audio.h
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBAUDIO_H_
+#define _DVBAUDIO_H_
+
+#include <linux/types.h>
+
+typedef enum {
+	AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
+	AUDIO_SOURCE_MEMORY /* Select internal memory as the main source */
+} audio_stream_source_t;
+
+
+typedef enum {
+	AUDIO_STOPPED,      /* Device is stopped */
+	AUDIO_PLAYING,      /* Device is currently playing */
+	AUDIO_PAUSED        /* Device is paused */
+} audio_play_state_t;
+
+
+typedef enum {
+	AUDIO_STEREO,
+	AUDIO_MONO_LEFT,
+	AUDIO_MONO_RIGHT,
+	AUDIO_MONO,
+	AUDIO_STEREO_SWAPPED
+} audio_channel_select_t;
+
+
+typedef struct audio_mixer {
+	unsigned int volume_left;
+	unsigned int volume_right;
+  // what else do we need? bass, pass-through, ...
+} audio_mixer_t;
+
+
+typedef struct audio_status {
+	int                    AV_sync_state;  /* sync audio and video? */
+	int                    mute_state;     /* audio is muted */
+	audio_play_state_t     play_state;     /* current playback state */
+	audio_stream_source_t  stream_source;  /* current stream source */
+	audio_channel_select_t channel_select; /* currently selected channel */
+	int                    bypass_mode;    /* pass on audio data to */
+	audio_mixer_t	       mixer_state;    /* current mixer state */
+} audio_status_t;                              /* separate decoder hardware */
+
+
+typedef
+struct audio_karaoke{  /* if Vocal1 or Vocal2 are non-zero, they get mixed  */
+	int vocal1;    /* into left and right t at 70% each */
+	int vocal2;    /* if both, Vocal1 and Vocal2 are non-zero, Vocal1 gets*/
+	int melody;    /* mixed into the left channel and */
+		       /* Vocal2 into the right channel at 100% each. */
+		       /* if Melody is non-zero, the melody channel gets mixed*/
+} audio_karaoke_t;     /* into left and right  */
+
+
+typedef __u16 audio_attributes_t;
+/*   bits: descr. */
+/*   15-13 audio coding mode (0=ac3, 2=mpeg1, 3=mpeg2ext, 4=LPCM, 6=DTS, */
+/*   12    multichannel extension */
+/*   11-10 audio type (0=not spec, 1=language included) */
+/*    9- 8 audio application mode (0=not spec, 1=karaoke, 2=surround) */
+/*    7- 6 Quantization / DRC (mpeg audio: 1=DRC exists)(lpcm: 0=16bit,  */
+/*    5- 4 Sample frequency fs (0=48kHz, 1=96kHz) */
+/*    2- 0 number of audio channels (n+1 channels) */
+
+
+/* for GET_CAPABILITIES and SET_FORMAT, the latter should only set one bit */
+#define AUDIO_CAP_DTS    1
+#define AUDIO_CAP_LPCM   2
+#define AUDIO_CAP_MP1    4
+#define AUDIO_CAP_MP2    8
+#define AUDIO_CAP_MP3   16
+#define AUDIO_CAP_AAC   32
+#define AUDIO_CAP_OGG   64
+#define AUDIO_CAP_SDDS 128
+#define AUDIO_CAP_AC3  256
+
+#define AUDIO_STOP                 _IO('o', 1)
+#define AUDIO_PLAY                 _IO('o', 2)
+#define AUDIO_PAUSE                _IO('o', 3)
+#define AUDIO_CONTINUE             _IO('o', 4)
+#define AUDIO_SELECT_SOURCE        _IO('o', 5)
+#define AUDIO_SET_MUTE             _IO('o', 6)
+#define AUDIO_SET_AV_SYNC          _IO('o', 7)
+#define AUDIO_SET_BYPASS_MODE      _IO('o', 8)
+#define AUDIO_CHANNEL_SELECT       _IO('o', 9)
+#define AUDIO_GET_STATUS           _IOR('o', 10, audio_status_t)
+
+#define AUDIO_GET_CAPABILITIES     _IOR('o', 11, unsigned int)
+#define AUDIO_CLEAR_BUFFER         _IO('o',  12)
+#define AUDIO_SET_ID               _IO('o', 13)
+#define AUDIO_SET_MIXER            _IOW('o', 14, audio_mixer_t)
+#define AUDIO_SET_STREAMTYPE       _IO('o', 15)
+#define AUDIO_SET_EXT_ID           _IO('o', 16)
+#define AUDIO_SET_ATTRIBUTES       _IOW('o', 17, audio_attributes_t)
+#define AUDIO_SET_KARAOKE          _IOW('o', 18, audio_karaoke_t)
+
+/**
+ * AUDIO_GET_PTS
+ *
+ * Read the 33 bit presentation time stamp as defined
+ * in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
+ *
+ * The PTS should belong to the currently played
+ * frame if possible, but may also be a value close to it
+ * like the PTS of the last decoded frame or the last PTS
+ * extracted by the PES parser.
+ */
+#define AUDIO_GET_PTS              _IOR('o', 19, __u64)
+#define AUDIO_BILINGUAL_CHANNEL_SELECT _IO('o', 20)
+
+#endif /* _DVBAUDIO_H_ */
diff -uNr linux-2.6.32/usr/include/linux/dvb/ca.h clean_modified/linux-2.6.32/usr/include/linux/dvb/ca.h
--- linux-2.6.32/usr/include/linux/dvb/ca.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/ca.h	2019-04-14 13:24:02.946131142 -0500
@@ -0,0 +1,90 @@
+/*
+ * ca.h
+ *
+ * Copyright (C) 2000 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBCA_H_
+#define _DVBCA_H_
+
+/* slot interface types and info */
+
+typedef struct ca_slot_info {
+	int num;               /* slot number */
+
+	int type;              /* CA interface this slot supports */
+#define CA_CI            1     /* CI high level interface */
+#define CA_CI_LINK       2     /* CI link layer level interface */
+#define CA_CI_PHYS       4     /* CI physical layer level interface */
+#define CA_DESCR         8     /* built-in descrambler */
+#define CA_SC          128     /* simple smart card interface */
+
+	unsigned int flags;
+#define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
+#define CA_CI_MODULE_READY   2
+} ca_slot_info_t;
+
+
+/* descrambler types and info */
+
+typedef struct ca_descr_info {
+	unsigned int num;          /* number of available descramblers (keys) */
+	unsigned int type;         /* type of supported scrambling system */
+#define CA_ECD           1
+#define CA_NDS           2
+#define CA_DSS           4
+} ca_descr_info_t;
+
+typedef struct ca_caps {
+	unsigned int slot_num;     /* total number of CA card and module slots */
+	unsigned int slot_type;    /* OR of all supported types */
+	unsigned int descr_num;    /* total number of descrambler slots (keys) */
+	unsigned int descr_type;   /* OR of all supported types */
+} ca_caps_t;
+
+/* a message to/from a CI-CAM */
+typedef struct ca_msg {
+	unsigned int index;
+	unsigned int type;
+	unsigned int length;
+	unsigned char msg[256];
+} ca_msg_t;
+
+typedef struct ca_descr {
+	unsigned int index;
+	unsigned int parity;	/* 0 == even, 1 == odd */
+	unsigned char cw[8];
+} ca_descr_t;
+
+typedef struct ca_pid {
+	unsigned int pid;
+	int index;		/* -1 == disable*/
+} ca_pid_t;
+
+#define CA_RESET          _IO('o', 128)
+#define CA_GET_CAP        _IOR('o', 129, ca_caps_t)
+#define CA_GET_SLOT_INFO  _IOR('o', 130, ca_slot_info_t)
+#define CA_GET_DESCR_INFO _IOR('o', 131, ca_descr_info_t)
+#define CA_GET_MSG        _IOR('o', 132, ca_msg_t)
+#define CA_SEND_MSG       _IOW('o', 133, ca_msg_t)
+#define CA_SET_DESCR      _IOW('o', 134, ca_descr_t)
+#define CA_SET_PID        _IOW('o', 135, ca_pid_t)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/dvb/dmx.h clean_modified/linux-2.6.32/usr/include/linux/dvb/dmx.h
--- linux-2.6.32/usr/include/linux/dvb/dmx.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/dmx.h	2019-04-14 13:24:02.946131142 -0500
@@ -0,0 +1,153 @@
+/*
+ * dmx.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBDMX_H_
+#define _DVBDMX_H_
+
+#include <linux/types.h>
+#include <time.h>
+
+
+#define DMX_FILTER_SIZE 16
+
+typedef enum
+{
+	DMX_OUT_DECODER, /* Streaming directly to decoder. */
+	DMX_OUT_TAP,     /* Output going to a memory buffer */
+			 /* (to be retrieved via the read command).*/
+	DMX_OUT_TS_TAP,  /* Output multiplexed into a new TS  */
+			 /* (to be retrieved by reading from the */
+			 /* logical DVR device).                 */
+	DMX_OUT_TSDEMUX_TAP /* Like TS_TAP but retrieved from the DMX device */
+} dmx_output_t;
+
+
+typedef enum
+{
+	DMX_IN_FRONTEND, /* Input from a front-end device.  */
+	DMX_IN_DVR       /* Input from the logical DVR device.  */
+} dmx_input_t;
+
+
+typedef enum
+{
+	DMX_PES_AUDIO0,
+	DMX_PES_VIDEO0,
+	DMX_PES_TELETEXT0,
+	DMX_PES_SUBTITLE0,
+	DMX_PES_PCR0,
+
+	DMX_PES_AUDIO1,
+	DMX_PES_VIDEO1,
+	DMX_PES_TELETEXT1,
+	DMX_PES_SUBTITLE1,
+	DMX_PES_PCR1,
+
+	DMX_PES_AUDIO2,
+	DMX_PES_VIDEO2,
+	DMX_PES_TELETEXT2,
+	DMX_PES_SUBTITLE2,
+	DMX_PES_PCR2,
+
+	DMX_PES_AUDIO3,
+	DMX_PES_VIDEO3,
+	DMX_PES_TELETEXT3,
+	DMX_PES_SUBTITLE3,
+	DMX_PES_PCR3,
+
+	DMX_PES_OTHER
+} dmx_pes_type_t;
+
+#define DMX_PES_AUDIO    DMX_PES_AUDIO0
+#define DMX_PES_VIDEO    DMX_PES_VIDEO0
+#define DMX_PES_TELETEXT DMX_PES_TELETEXT0
+#define DMX_PES_SUBTITLE DMX_PES_SUBTITLE0
+#define DMX_PES_PCR      DMX_PES_PCR0
+
+
+typedef struct dmx_filter
+{
+	__u8  filter[DMX_FILTER_SIZE];
+	__u8  mask[DMX_FILTER_SIZE];
+	__u8  mode[DMX_FILTER_SIZE];
+} dmx_filter_t;
+
+
+struct dmx_sct_filter_params
+{
+	__u16          pid;
+	dmx_filter_t   filter;
+	__u32          timeout;
+	__u32          flags;
+#define DMX_CHECK_CRC       1
+#define DMX_ONESHOT         2
+#define DMX_IMMEDIATE_START 4
+#define DMX_KERNEL_CLIENT   0x8000
+};
+
+
+struct dmx_pes_filter_params
+{
+	__u16          pid;
+	dmx_input_t    input;
+	dmx_output_t   output;
+	dmx_pes_type_t pes_type;
+	__u32          flags;
+};
+
+typedef struct dmx_caps {
+	__u32 caps;
+	int num_decoders;
+} dmx_caps_t;
+
+typedef enum {
+	DMX_SOURCE_FRONT0 = 0,
+	DMX_SOURCE_FRONT1,
+	DMX_SOURCE_FRONT2,
+	DMX_SOURCE_FRONT3,
+	DMX_SOURCE_DVR0   = 16,
+	DMX_SOURCE_DVR1,
+	DMX_SOURCE_DVR2,
+	DMX_SOURCE_DVR3
+} dmx_source_t;
+
+struct dmx_stc {
+	unsigned int num;	/* input : which STC? 0..N */
+	unsigned int base;	/* output: divisor for stc to get 90 kHz clock */
+	__u64 stc;		/* output: stc in 'base'*90 kHz units */
+};
+
+
+#define DMX_START                _IO('o', 41)
+#define DMX_STOP                 _IO('o', 42)
+#define DMX_SET_FILTER           _IOW('o', 43, struct dmx_sct_filter_params)
+#define DMX_SET_PES_FILTER       _IOW('o', 44, struct dmx_pes_filter_params)
+#define DMX_SET_BUFFER_SIZE      _IO('o', 45)
+#define DMX_GET_PES_PIDS         _IOR('o', 47, __u16[5])
+#define DMX_GET_CAPS             _IOR('o', 48, dmx_caps_t)
+#define DMX_SET_SOURCE           _IOW('o', 49, dmx_source_t)
+#define DMX_GET_STC              _IOWR('o', 50, struct dmx_stc)
+#define DMX_ADD_PID              _IOW('o', 51, __u16)
+#define DMX_REMOVE_PID           _IOW('o', 52, __u16)
+
+#endif /*_DVBDMX_H_*/
diff -uNr linux-2.6.32/usr/include/linux/dvb/frontend.h clean_modified/linux-2.6.32/usr/include/linux/dvb/frontend.h
--- linux-2.6.32/usr/include/linux/dvb/frontend.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/frontend.h	2019-04-14 13:24:02.947110688 -0500
@@ -0,0 +1,413 @@
+/*
+ * frontend.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *		    Ralph  Metzler <ralph@convergence.de>
+ *		    Holger Waechtler <holger@convergence.de>
+ *		    Andre Draszik <ad@convergence.de>
+ *		    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBFRONTEND_H_
+#define _DVBFRONTEND_H_
+
+#include <linux/types.h>
+
+typedef enum fe_type {
+	FE_QPSK,
+	FE_QAM,
+	FE_OFDM,
+	FE_ATSC
+} fe_type_t;
+
+
+typedef enum fe_caps {
+	FE_IS_STUPID			= 0,
+	FE_CAN_INVERSION_AUTO		= 0x1,
+	FE_CAN_FEC_1_2			= 0x2,
+	FE_CAN_FEC_2_3			= 0x4,
+	FE_CAN_FEC_3_4			= 0x8,
+	FE_CAN_FEC_4_5			= 0x10,
+	FE_CAN_FEC_5_6			= 0x20,
+	FE_CAN_FEC_6_7			= 0x40,
+	FE_CAN_FEC_7_8			= 0x80,
+	FE_CAN_FEC_8_9			= 0x100,
+	FE_CAN_FEC_AUTO			= 0x200,
+	FE_CAN_QPSK			= 0x400,
+	FE_CAN_QAM_16			= 0x800,
+	FE_CAN_QAM_32			= 0x1000,
+	FE_CAN_QAM_64			= 0x2000,
+	FE_CAN_QAM_128			= 0x4000,
+	FE_CAN_QAM_256			= 0x8000,
+	FE_CAN_QAM_AUTO			= 0x10000,
+	FE_CAN_TRANSMISSION_MODE_AUTO	= 0x20000,
+	FE_CAN_BANDWIDTH_AUTO		= 0x40000,
+	FE_CAN_GUARD_INTERVAL_AUTO	= 0x80000,
+	FE_CAN_HIERARCHY_AUTO		= 0x100000,
+	FE_CAN_8VSB			= 0x200000,
+	FE_CAN_16VSB			= 0x400000,
+	FE_HAS_EXTENDED_CAPS		= 0x800000,   /* We need more bitspace for newer APIs, indicate this. */
+	FE_CAN_2G_MODULATION		= 0x10000000, /* frontend supports "2nd generation modulation" (DVB-S2) */
+	FE_NEEDS_BENDING		= 0x20000000, /* not supported anymore, don't use (frontend requires frequency bending) */
+	FE_CAN_RECOVER			= 0x40000000, /* frontend can recover from a cable unplug automatically */
+	FE_CAN_MUTE_TS			= 0x80000000  /* frontend can stop spurious TS data output */
+} fe_caps_t;
+
+
+struct dvb_frontend_info {
+	char       name[128];
+	fe_type_t  type;
+	__u32      frequency_min;
+	__u32      frequency_max;
+	__u32      frequency_stepsize;
+	__u32      frequency_tolerance;
+	__u32      symbol_rate_min;
+	__u32      symbol_rate_max;
+	__u32      symbol_rate_tolerance;	/* ppm */
+	__u32      notifier_delay;		/* DEPRECATED */
+	fe_caps_t  caps;
+};
+
+
+/**
+ *  Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
+ *  the meaning of this struct...
+ */
+struct dvb_diseqc_master_cmd {
+	__u8 msg [6];	/*  { framing, address, command, data [3] } */
+	__u8 msg_len;	/*  valid values are 3...6  */
+};
+
+
+struct dvb_diseqc_slave_reply {
+	__u8 msg [4];	/*  { framing, data [3] } */
+	__u8 msg_len;	/*  valid values are 0...4, 0 means no msg  */
+	int  timeout;	/*  return from ioctl after timeout ms with */
+};			/*  errorcode when no message was received  */
+
+
+typedef enum fe_sec_voltage {
+	SEC_VOLTAGE_13,
+	SEC_VOLTAGE_18,
+	SEC_VOLTAGE_OFF
+} fe_sec_voltage_t;
+
+
+typedef enum fe_sec_tone_mode {
+	SEC_TONE_ON,
+	SEC_TONE_OFF
+} fe_sec_tone_mode_t;
+
+
+typedef enum fe_sec_mini_cmd {
+	SEC_MINI_A,
+	SEC_MINI_B
+} fe_sec_mini_cmd_t;
+
+
+typedef enum fe_status {
+	FE_HAS_SIGNAL	= 0x01,   /* found something above the noise level */
+	FE_HAS_CARRIER	= 0x02,   /* found a DVB signal  */
+	FE_HAS_VITERBI	= 0x04,   /* FEC is stable  */
+	FE_HAS_SYNC	= 0x08,   /* found sync bytes  */
+	FE_HAS_LOCK	= 0x10,   /* everything's working... */
+	FE_TIMEDOUT	= 0x20,   /* no lock within the last ~2 seconds */
+	FE_REINIT	= 0x40    /* frontend was reinitialized,  */
+} fe_status_t;			  /* application is recommended to reset */
+				  /* DiSEqC, tone and parameters */
+
+typedef enum fe_spectral_inversion {
+	INVERSION_OFF,
+	INVERSION_ON,
+	INVERSION_AUTO
+} fe_spectral_inversion_t;
+
+
+typedef enum fe_code_rate {
+	FEC_NONE = 0,
+	FEC_1_2,
+	FEC_2_3,
+	FEC_3_4,
+	FEC_4_5,
+	FEC_5_6,
+	FEC_6_7,
+	FEC_7_8,
+	FEC_8_9,
+	FEC_AUTO,
+	FEC_3_5,
+	FEC_9_10,
+} fe_code_rate_t;
+
+
+typedef enum fe_modulation {
+	QPSK,
+	QAM_16,
+	QAM_32,
+	QAM_64,
+	QAM_128,
+	QAM_256,
+	QAM_AUTO,
+	VSB_8,
+	VSB_16,
+	PSK_8,
+	APSK_16,
+	APSK_32,
+	DQPSK,
+} fe_modulation_t;
+
+typedef enum fe_transmit_mode {
+	TRANSMISSION_MODE_2K,
+	TRANSMISSION_MODE_8K,
+	TRANSMISSION_MODE_AUTO,
+	TRANSMISSION_MODE_4K
+} fe_transmit_mode_t;
+
+typedef enum fe_bandwidth {
+	BANDWIDTH_8_MHZ,
+	BANDWIDTH_7_MHZ,
+	BANDWIDTH_6_MHZ,
+	BANDWIDTH_AUTO
+} fe_bandwidth_t;
+
+
+typedef enum fe_guard_interval {
+	GUARD_INTERVAL_1_32,
+	GUARD_INTERVAL_1_16,
+	GUARD_INTERVAL_1_8,
+	GUARD_INTERVAL_1_4,
+	GUARD_INTERVAL_AUTO
+} fe_guard_interval_t;
+
+
+typedef enum fe_hierarchy {
+	HIERARCHY_NONE,
+	HIERARCHY_1,
+	HIERARCHY_2,
+	HIERARCHY_4,
+	HIERARCHY_AUTO
+} fe_hierarchy_t;
+
+
+struct dvb_qpsk_parameters {
+	__u32		symbol_rate;  /* symbol rate in Symbols per second */
+	fe_code_rate_t	fec_inner;    /* forward error correction (see above) */
+};
+
+struct dvb_qam_parameters {
+	__u32		symbol_rate; /* symbol rate in Symbols per second */
+	fe_code_rate_t	fec_inner;   /* forward error correction (see above) */
+	fe_modulation_t	modulation;  /* modulation type (see above) */
+};
+
+struct dvb_vsb_parameters {
+	fe_modulation_t	modulation;  /* modulation type (see above) */
+};
+
+struct dvb_ofdm_parameters {
+	fe_bandwidth_t      bandwidth;
+	fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
+	fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
+	fe_modulation_t     constellation; /* modulation type (see above) */
+	fe_transmit_mode_t  transmission_mode;
+	fe_guard_interval_t guard_interval;
+	fe_hierarchy_t      hierarchy_information;
+};
+
+
+struct dvb_frontend_parameters {
+	__u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
+			     /* intermediate frequency in kHz for QPSK */
+	fe_spectral_inversion_t inversion;
+	union {
+		struct dvb_qpsk_parameters qpsk;
+		struct dvb_qam_parameters  qam;
+		struct dvb_ofdm_parameters ofdm;
+		struct dvb_vsb_parameters vsb;
+	} u;
+};
+
+
+struct dvb_frontend_event {
+	fe_status_t status;
+	struct dvb_frontend_parameters parameters;
+};
+
+/* S2API Commands */
+#define DTV_UNDEFINED		0
+#define DTV_TUNE		1
+#define DTV_CLEAR		2
+#define DTV_FREQUENCY		3
+#define DTV_MODULATION		4
+#define DTV_BANDWIDTH_HZ	5
+#define DTV_INVERSION		6
+#define DTV_DISEQC_MASTER	7
+#define DTV_SYMBOL_RATE		8
+#define DTV_INNER_FEC		9
+#define DTV_VOLTAGE		10
+#define DTV_TONE		11
+#define DTV_PILOT		12
+#define DTV_ROLLOFF		13
+#define DTV_DISEQC_SLAVE_REPLY	14
+
+/* Basic enumeration set for querying unlimited capabilities */
+#define DTV_FE_CAPABILITY_COUNT	15
+#define DTV_FE_CAPABILITY	16
+#define DTV_DELIVERY_SYSTEM	17
+
+/* ISDB-T and ISDB-Tsb */
+#define DTV_ISDBT_PARTIAL_RECEPTION	18
+#define DTV_ISDBT_SOUND_BROADCASTING	19
+
+#define DTV_ISDBT_SB_SUBCHANNEL_ID	20
+#define DTV_ISDBT_SB_SEGMENT_IDX	21
+#define DTV_ISDBT_SB_SEGMENT_COUNT	22
+
+#define DTV_ISDBT_LAYERA_FEC			23
+#define DTV_ISDBT_LAYERA_MODULATION		24
+#define DTV_ISDBT_LAYERA_SEGMENT_COUNT		25
+#define DTV_ISDBT_LAYERA_TIME_INTERLEAVING	26
+
+#define DTV_ISDBT_LAYERB_FEC			27
+#define DTV_ISDBT_LAYERB_MODULATION		28
+#define DTV_ISDBT_LAYERB_SEGMENT_COUNT		29
+#define DTV_ISDBT_LAYERB_TIME_INTERLEAVING	30
+
+#define DTV_ISDBT_LAYERC_FEC			31
+#define DTV_ISDBT_LAYERC_MODULATION		32
+#define DTV_ISDBT_LAYERC_SEGMENT_COUNT		33
+#define DTV_ISDBT_LAYERC_TIME_INTERLEAVING	34
+
+#define DTV_API_VERSION		35
+
+#define DTV_CODE_RATE_HP	36
+#define DTV_CODE_RATE_LP	37
+#define DTV_GUARD_INTERVAL	38
+#define DTV_TRANSMISSION_MODE	39
+#define DTV_HIERARCHY		40
+
+#define DTV_ISDBT_LAYER_ENABLED	41
+
+#define DTV_ISDBS_TS_ID		42
+
+#define DTV_MAX_COMMAND				DTV_ISDBS_TS_ID
+
+typedef enum fe_pilot {
+	PILOT_ON,
+	PILOT_OFF,
+	PILOT_AUTO,
+} fe_pilot_t;
+
+typedef enum fe_rolloff {
+	ROLLOFF_35, /* Implied value in DVB-S, default for DVB-S2 */
+	ROLLOFF_20,
+	ROLLOFF_25,
+	ROLLOFF_AUTO,
+} fe_rolloff_t;
+
+typedef enum fe_delivery_system {
+	SYS_UNDEFINED,
+	SYS_DVBC_ANNEX_AC,
+	SYS_DVBC_ANNEX_B,
+	SYS_DVBT,
+	SYS_DSS,
+	SYS_DVBS,
+	SYS_DVBS2,
+	SYS_DVBH,
+	SYS_ISDBT,
+	SYS_ISDBS,
+	SYS_ISDBC,
+	SYS_ATSC,
+	SYS_ATSCMH,
+	SYS_DMBTH,
+	SYS_CMMB,
+	SYS_DAB,
+} fe_delivery_system_t;
+
+struct dtv_cmds_h {
+	char	*name;		/* A display name for debugging purposes */
+
+	__u32	cmd;		/* A unique ID */
+
+	/* Flags */
+	__u32	set:1;		/* Either a set or get property */
+	__u32	buffer:1;	/* Does this property use the buffer? */
+	__u32	reserved:30;	/* Align */
+};
+
+struct dtv_property {
+	__u32 cmd;
+	__u32 reserved[3];
+	union {
+		__u32 data;
+		struct {
+			__u8 data[32];
+			__u32 len;
+			__u32 reserved1[3];
+			void *reserved2;
+		} buffer;
+	} u;
+	int result;
+} __attribute__ ((packed));
+
+/* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
+#define DTV_IOCTL_MAX_MSGS 64
+
+struct dtv_properties {
+	__u32 num;
+	struct dtv_property *props;
+};
+
+#define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
+#define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
+
+
+/**
+ * When set, this flag will disable any zigzagging or other "normal" tuning
+ * behaviour. Additionally, there will be no automatic monitoring of the lock
+ * status, and hence no frontend events will be generated. If a frontend device
+ * is closed, this flag will be automatically turned off when the device is
+ * reopened read-write.
+ */
+#define FE_TUNE_MODE_ONESHOT 0x01
+
+
+#define FE_GET_INFO		   _IOR('o', 61, struct dvb_frontend_info)
+
+#define FE_DISEQC_RESET_OVERLOAD   _IO('o', 62)
+#define FE_DISEQC_SEND_MASTER_CMD  _IOW('o', 63, struct dvb_diseqc_master_cmd)
+#define FE_DISEQC_RECV_SLAVE_REPLY _IOR('o', 64, struct dvb_diseqc_slave_reply)
+#define FE_DISEQC_SEND_BURST       _IO('o', 65)  /* fe_sec_mini_cmd_t */
+
+#define FE_SET_TONE		   _IO('o', 66)  /* fe_sec_tone_mode_t */
+#define FE_SET_VOLTAGE		   _IO('o', 67)  /* fe_sec_voltage_t */
+#define FE_ENABLE_HIGH_LNB_VOLTAGE _IO('o', 68)  /* int */
+
+#define FE_READ_STATUS		   _IOR('o', 69, fe_status_t)
+#define FE_READ_BER		   _IOR('o', 70, __u32)
+#define FE_READ_SIGNAL_STRENGTH    _IOR('o', 71, __u16)
+#define FE_READ_SNR		   _IOR('o', 72, __u16)
+#define FE_READ_UNCORRECTED_BLOCKS _IOR('o', 73, __u32)
+
+#define FE_SET_FRONTEND		   _IOW('o', 76, struct dvb_frontend_parameters)
+#define FE_GET_FRONTEND		   _IOR('o', 77, struct dvb_frontend_parameters)
+#define FE_SET_FRONTEND_TUNE_MODE  _IO('o', 81) /* unsigned int */
+#define FE_GET_EVENT		   _IOR('o', 78, struct dvb_frontend_event)
+
+#define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
+
+#endif /*_DVBFRONTEND_H_*/
diff -uNr linux-2.6.32/usr/include/linux/dvb/net.h clean_modified/linux-2.6.32/usr/include/linux/dvb/net.h
--- linux-2.6.32/usr/include/linux/dvb/net.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/net.h	2019-04-14 13:24:02.952915617 -0500
@@ -0,0 +1,52 @@
+/*
+ * net.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBNET_H_
+#define _DVBNET_H_
+
+#include <linux/types.h>
+
+struct dvb_net_if {
+	__u16 pid;
+	__u16 if_num;
+	__u8  feedtype;
+#define DVB_NET_FEEDTYPE_MPE 0	/* multi protocol encapsulation */
+#define DVB_NET_FEEDTYPE_ULE 1	/* ultra lightweight encapsulation */
+};
+
+
+#define NET_ADD_IF    _IOWR('o', 52, struct dvb_net_if)
+#define NET_REMOVE_IF _IO('o', 53)
+#define NET_GET_IF    _IOWR('o', 54, struct dvb_net_if)
+
+
+/* binary compatibility cruft: */
+struct __dvb_net_if_old {
+	__u16 pid;
+	__u16 if_num;
+};
+#define __NET_ADD_IF_OLD _IOWR('o', 52, struct __dvb_net_if_old)
+#define __NET_GET_IF_OLD _IOWR('o', 54, struct __dvb_net_if_old)
+
+
+#endif /*_DVBNET_H_*/
diff -uNr linux-2.6.32/usr/include/linux/dvb/osd.h clean_modified/linux-2.6.32/usr/include/linux/dvb/osd.h
--- linux-2.6.32/usr/include/linux/dvb/osd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/osd.h	2019-04-14 13:24:02.953945329 -0500
@@ -0,0 +1,144 @@
+/*
+ * osd.h
+ *
+ * Copyright (C) 2001 Ralph  Metzler <ralph@convergence.de>
+ *                  & Marcus Metzler <marcus@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Lesser Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBOSD_H_
+#define _DVBOSD_H_
+
+
+
+typedef enum {
+  // All functions return -2 on "not open"
+  OSD_Close=1,    // ()
+  // Disables OSD and releases the buffers
+  // returns 0 on success
+  OSD_Open,       // (x0,y0,x1,y1,BitPerPixel[2/4/8](color&0x0F),mix[0..15](color&0xF0))
+  // Opens OSD with this size and bit depth
+  // returns 0 on success, -1 on DRAM allocation error, -2 on "already open"
+  OSD_Show,       // ()
+  // enables OSD mode
+  // returns 0 on success
+  OSD_Hide,       // ()
+  // disables OSD mode
+  // returns 0 on success
+  OSD_Clear,      // ()
+  // Sets all pixel to color 0
+  // returns 0 on success
+  OSD_Fill,       // (color)
+  // Sets all pixel to color <col>
+  // returns 0 on success
+  OSD_SetColor,   // (color,R{x0},G{y0},B{x1},opacity{y1})
+  // set palette entry <num> to <r,g,b>, <mix> and <trans> apply
+  // R,G,B: 0..255
+  // R=Red, G=Green, B=Blue
+  // opacity=0:      pixel opacity 0% (only video pixel shows)
+  // opacity=1..254: pixel opacity as specified in header
+  // opacity=255:    pixel opacity 100% (only OSD pixel shows)
+  // returns 0 on success, -1 on error
+  OSD_SetPalette, // (firstcolor{color},lastcolor{x0},data)
+  // Set a number of entries in the palette
+  // sets the entries "firstcolor" through "lastcolor" from the array "data"
+  // data has 4 byte for each color:
+  // R,G,B, and a opacity value: 0->transparent, 1..254->mix, 255->pixel
+  OSD_SetTrans,   // (transparency{color})
+  // Sets transparency of mixed pixel (0..15)
+  // returns 0 on success
+  OSD_SetPixel,   // (x0,y0,color)
+  // sets pixel <x>,<y> to color number <col>
+  // returns 0 on success, -1 on error
+  OSD_GetPixel,   // (x0,y0)
+  // returns color number of pixel <x>,<y>,  or -1
+  OSD_SetRow,     // (x0,y0,x1,data)
+  // fills pixels x0,y through  x1,y with the content of data[]
+  // returns 0 on success, -1 on clipping all pixel (no pixel drawn)
+  OSD_SetBlock,   // (x0,y0,x1,y1,increment{color},data)
+  // fills pixels x0,y0 through  x1,y1 with the content of data[]
+  // inc contains the width of one line in the data block,
+  // inc<=0 uses blockwidth as linewidth
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_FillRow,    // (x0,y0,x1,color)
+  // fills pixels x0,y through  x1,y with the color <col>
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_FillBlock,  // (x0,y0,x1,y1,color)
+  // fills pixels x0,y0 through  x1,y1 with the color <col>
+  // returns 0 on success, -1 on clipping all pixel
+  OSD_Line,       // (x0,y0,x1,y1,color)
+  // draw a line from x0,y0 to x1,y1 with the color <col>
+  // returns 0 on success
+  OSD_Query,      // (x0,y0,x1,y1,xasp{color}}), yasp=11
+  // fills parameters with the picture dimensions and the pixel aspect ratio
+  // returns 0 on success
+  OSD_Test,       // ()
+  // draws a test picture. for debugging purposes only
+  // returns 0 on success
+// TODO: remove "test" in final version
+  OSD_Text,       // (x0,y0,size,color,text)
+  OSD_SetWindow, //  (x0) set window with number 0<x0<8 as current
+  OSD_MoveWindow, //  move current window to (x0, y0)
+  OSD_OpenRaw,	// Open other types of OSD windows
+} OSD_Command;
+
+typedef struct osd_cmd_s {
+	OSD_Command cmd;
+	int x0;
+	int y0;
+	int x1;
+	int y1;
+	int color;
+	void *data;
+} osd_cmd_t;
+
+/* OSD_OpenRaw: set 'color' to desired window type */
+typedef enum {
+	OSD_BITMAP1,           /* 1 bit bitmap */
+	OSD_BITMAP2,           /* 2 bit bitmap */
+	OSD_BITMAP4,           /* 4 bit bitmap */
+	OSD_BITMAP8,           /* 8 bit bitmap */
+	OSD_BITMAP1HR,         /* 1 Bit bitmap half resolution */
+	OSD_BITMAP2HR,         /* 2 bit bitmap half resolution */
+	OSD_BITMAP4HR,         /* 4 bit bitmap half resolution */
+	OSD_BITMAP8HR,         /* 8 bit bitmap half resolution */
+	OSD_YCRCB422,          /* 4:2:2 YCRCB Graphic Display */
+	OSD_YCRCB444,          /* 4:4:4 YCRCB Graphic Display */
+	OSD_YCRCB444HR,        /* 4:4:4 YCRCB graphic half resolution */
+	OSD_VIDEOTSIZE,        /* True Size Normal MPEG Video Display */
+	OSD_VIDEOHSIZE,        /* MPEG Video Display Half Resolution */
+	OSD_VIDEOQSIZE,        /* MPEG Video Display Quarter Resolution */
+	OSD_VIDEODSIZE,        /* MPEG Video Display Double Resolution */
+	OSD_VIDEOTHSIZE,       /* True Size MPEG Video Display Half Resolution */
+	OSD_VIDEOTQSIZE,       /* True Size MPEG Video Display Quarter Resolution*/
+	OSD_VIDEOTDSIZE,       /* True Size MPEG Video Display Double Resolution */
+	OSD_VIDEONSIZE,        /* Full Size MPEG Video Display */
+	OSD_CURSOR             /* Cursor */
+} osd_raw_window_t;
+
+typedef struct osd_cap_s {
+	int  cmd;
+#define OSD_CAP_MEMSIZE         1  /* memory size */
+	long val;
+} osd_cap_t;
+
+
+#define OSD_SEND_CMD            _IOW('o', 160, osd_cmd_t)
+#define OSD_GET_CAPABILITY      _IOR('o', 161, osd_cap_t)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/dvb/version.h clean_modified/linux-2.6.32/usr/include/linux/dvb/version.h
--- linux-2.6.32/usr/include/linux/dvb/version.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/version.h	2019-04-14 13:24:02.954892065 -0500
@@ -0,0 +1,29 @@
+/*
+ * version.h
+ *
+ * Copyright (C) 2000 Holger Waechtler <holger@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBVERSION_H_
+#define _DVBVERSION_H_
+
+#define DVB_API_VERSION 5
+#define DVB_API_VERSION_MINOR 1
+
+#endif /*_DVBVERSION_H_*/
diff -uNr linux-2.6.32/usr/include/linux/dvb/video.h clean_modified/linux-2.6.32/usr/include/linux/dvb/video.h
--- linux-2.6.32/usr/include/linux/dvb/video.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/dvb/video.h	2019-04-14 13:24:02.955874409 -0500
@@ -0,0 +1,272 @@
+/*
+ * video.h
+ *
+ * Copyright (C) 2000 Marcus Metzler <marcus@convergence.de>
+ *                  & Ralph  Metzler <ralph@convergence.de>
+ *                    for convergence integrated media GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef _DVBVIDEO_H_
+#define _DVBVIDEO_H_
+
+#include <linux/types.h>
+#include <stdint.h>
+#include <time.h>
+
+typedef enum {
+	VIDEO_FORMAT_4_3,     /* Select 4:3 format */
+	VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
+	VIDEO_FORMAT_221_1    /* 2.21:1 */
+} video_format_t;
+
+
+typedef enum {
+	 VIDEO_SYSTEM_PAL,
+	 VIDEO_SYSTEM_NTSC,
+	 VIDEO_SYSTEM_PALN,
+	 VIDEO_SYSTEM_PALNc,
+	 VIDEO_SYSTEM_PALM,
+	 VIDEO_SYSTEM_NTSC60,
+	 VIDEO_SYSTEM_PAL60,
+	 VIDEO_SYSTEM_PALM60
+} video_system_t;
+
+
+typedef enum {
+	VIDEO_PAN_SCAN,       /* use pan and scan format */
+	VIDEO_LETTER_BOX,     /* use letterbox format */
+	VIDEO_CENTER_CUT_OUT  /* use center cut out format */
+} video_displayformat_t;
+
+typedef struct {
+	int w;
+	int h;
+	video_format_t aspect_ratio;
+} video_size_t;
+
+typedef enum {
+	VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
+	VIDEO_SOURCE_MEMORY /* If this source is selected, the stream
+			       comes from the user through the write
+			       system call */
+} video_stream_source_t;
+
+
+typedef enum {
+	VIDEO_STOPPED, /* Video is stopped */
+	VIDEO_PLAYING, /* Video is currently playing */
+	VIDEO_FREEZED  /* Video is freezed */
+} video_play_state_t;
+
+
+/* Decoder commands */
+#define VIDEO_CMD_PLAY        (0)
+#define VIDEO_CMD_STOP        (1)
+#define VIDEO_CMD_FREEZE      (2)
+#define VIDEO_CMD_CONTINUE    (3)
+
+/* Flags for VIDEO_CMD_FREEZE */
+#define VIDEO_CMD_FREEZE_TO_BLACK     	(1 << 0)
+
+/* Flags for VIDEO_CMD_STOP */
+#define VIDEO_CMD_STOP_TO_BLACK      	(1 << 0)
+#define VIDEO_CMD_STOP_IMMEDIATELY     	(1 << 1)
+
+/* Play input formats: */
+/* The decoder has no special format requirements */
+#define VIDEO_PLAY_FMT_NONE         (0)
+/* The decoder requires full GOPs */
+#define VIDEO_PLAY_FMT_GOP          (1)
+
+/* The structure must be zeroed before use by the application
+   This ensures it can be extended safely in the future. */
+struct video_command {
+	__u32 cmd;
+	__u32 flags;
+	union {
+		struct {
+			__u64 pts;
+		} stop;
+
+		struct {
+			/* 0 or 1000 specifies normal speed,
+			   1 specifies forward single stepping,
+			   -1 specifies backward single stepping,
+			   >1: playback at speed/1000 of the normal speed,
+			   <-1: reverse playback at (-speed/1000) of the normal speed. */
+			__s32 speed;
+			__u32 format;
+		} play;
+
+		struct {
+			__u32 data[16];
+		} raw;
+	};
+};
+
+/* FIELD_UNKNOWN can be used if the hardware does not know whether
+   the Vsync is for an odd, even or progressive (i.e. non-interlaced)
+   field. */
+#define VIDEO_VSYNC_FIELD_UNKNOWN  	(0)
+#define VIDEO_VSYNC_FIELD_ODD 		(1)
+#define VIDEO_VSYNC_FIELD_EVEN		(2)
+#define VIDEO_VSYNC_FIELD_PROGRESSIVE	(3)
+
+struct video_event {
+	__s32 type;
+#define VIDEO_EVENT_SIZE_CHANGED	1
+#define VIDEO_EVENT_FRAME_RATE_CHANGED	2
+#define VIDEO_EVENT_DECODER_STOPPED 	3
+#define VIDEO_EVENT_VSYNC 		4
+	__kernel_time_t timestamp;
+	union {
+		video_size_t size;
+		unsigned int frame_rate;	/* in frames per 1000sec */
+		unsigned char vsync_field;	/* unknown/odd/even/progressive */
+	} u;
+};
+
+
+struct video_status {
+	int                   video_blank;   /* blank video on freeze? */
+	video_play_state_t    play_state;    /* current state of playback */
+	video_stream_source_t stream_source; /* current source (demux/memory) */
+	video_format_t        video_format;  /* current aspect ratio of stream*/
+	video_displayformat_t display_format;/* selected cropping mode */
+};
+
+
+struct video_still_picture {
+	char *iFrame;        /* pointer to a single iframe in memory */
+	__s32 size;
+};
+
+
+typedef
+struct video_highlight {
+	int     active;      /*    1=show highlight, 0=hide highlight */
+	__u8    contrast1;   /*    7- 4  Pattern pixel contrast */
+			     /*    3- 0  Background pixel contrast */
+	__u8    contrast2;   /*    7- 4  Emphasis pixel-2 contrast */
+			     /*    3- 0  Emphasis pixel-1 contrast */
+	__u8    color1;      /*    7- 4  Pattern pixel color */
+			     /*    3- 0  Background pixel color */
+	__u8    color2;      /*    7- 4  Emphasis pixel-2 color */
+			     /*    3- 0  Emphasis pixel-1 color */
+	__u32    ypos;       /*   23-22  auto action mode */
+			     /*   21-12  start y */
+			     /*    9- 0  end y */
+	__u32    xpos;       /*   23-22  button color number */
+			     /*   21-12  start x */
+			     /*    9- 0  end x */
+} video_highlight_t;
+
+
+typedef struct video_spu {
+	int active;
+	int stream_id;
+} video_spu_t;
+
+
+typedef struct video_spu_palette {      /* SPU Palette information */
+	int length;
+	__u8 *palette;
+} video_spu_palette_t;
+
+
+typedef struct video_navi_pack {
+	int length;          /* 0 ... 1024 */
+	__u8 data[1024];
+} video_navi_pack_t;
+
+
+typedef __u16 video_attributes_t;
+/*   bits: descr. */
+/*   15-14 Video compression mode (0=MPEG-1, 1=MPEG-2) */
+/*   13-12 TV system (0=525/60, 1=625/50) */
+/*   11-10 Aspect ratio (0=4:3, 3=16:9) */
+/*    9- 8 permitted display mode on 4:3 monitor (0=both, 1=only pan-sca */
+/*    7    line 21-1 data present in GOP (1=yes, 0=no) */
+/*    6    line 21-2 data present in GOP (1=yes, 0=no) */
+/*    5- 3 source resolution (0=720x480/576, 1=704x480/576, 2=352x480/57 */
+/*    2    source letterboxed (1=yes, 0=no) */
+/*    0    film/camera mode (0=camera, 1=film (625/50 only)) */
+
+
+/* bit definitions for capabilities: */
+/* can the hardware decode MPEG1 and/or MPEG2? */
+#define VIDEO_CAP_MPEG1   1
+#define VIDEO_CAP_MPEG2   2
+/* can you send a system and/or program stream to video device?
+   (you still have to open the video and the audio device but only
+    send the stream to the video device) */
+#define VIDEO_CAP_SYS     4
+#define VIDEO_CAP_PROG    8
+/* can the driver also handle SPU, NAVI and CSS encoded data?
+   (CSS API is not present yet) */
+#define VIDEO_CAP_SPU    16
+#define VIDEO_CAP_NAVI   32
+#define VIDEO_CAP_CSS    64
+
+
+#define VIDEO_STOP                 _IO('o', 21)
+#define VIDEO_PLAY                 _IO('o', 22)
+#define VIDEO_FREEZE               _IO('o', 23)
+#define VIDEO_CONTINUE             _IO('o', 24)
+#define VIDEO_SELECT_SOURCE        _IO('o', 25)
+#define VIDEO_SET_BLANK            _IO('o', 26)
+#define VIDEO_GET_STATUS           _IOR('o', 27, struct video_status)
+#define VIDEO_GET_EVENT            _IOR('o', 28, struct video_event)
+#define VIDEO_SET_DISPLAY_FORMAT   _IO('o', 29)
+#define VIDEO_STILLPICTURE         _IOW('o', 30, struct video_still_picture)
+#define VIDEO_FAST_FORWARD         _IO('o', 31)
+#define VIDEO_SLOWMOTION           _IO('o', 32)
+#define VIDEO_GET_CAPABILITIES     _IOR('o', 33, unsigned int)
+#define VIDEO_CLEAR_BUFFER         _IO('o',  34)
+#define VIDEO_SET_ID               _IO('o', 35)
+#define VIDEO_SET_STREAMTYPE       _IO('o', 36)
+#define VIDEO_SET_FORMAT           _IO('o', 37)
+#define VIDEO_SET_SYSTEM           _IO('o', 38)
+#define VIDEO_SET_HIGHLIGHT        _IOW('o', 39, video_highlight_t)
+#define VIDEO_SET_SPU              _IOW('o', 50, video_spu_t)
+#define VIDEO_SET_SPU_PALETTE      _IOW('o', 51, video_spu_palette_t)
+#define VIDEO_GET_NAVI             _IOR('o', 52, video_navi_pack_t)
+#define VIDEO_SET_ATTRIBUTES       _IO('o', 53)
+#define VIDEO_GET_SIZE             _IOR('o', 55, video_size_t)
+#define VIDEO_GET_FRAME_RATE       _IOR('o', 56, unsigned int)
+
+/**
+ * VIDEO_GET_PTS
+ *
+ * Read the 33 bit presentation time stamp as defined
+ * in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
+ *
+ * The PTS should belong to the currently played
+ * frame if possible, but may also be a value close to it
+ * like the PTS of the last decoded frame or the last PTS
+ * extracted by the PES parser.
+ */
+#define VIDEO_GET_PTS              _IOR('o', 57, __u64)
+
+/* Read the number of displayed frames since the decoder was started */
+#define VIDEO_GET_FRAME_COUNT  	   _IOR('o', 58, __u64)
+
+#define VIDEO_COMMAND     	   _IOWR('o', 59, struct video_command)
+#define VIDEO_TRY_COMMAND 	   _IOWR('o', 60, struct video_command)
+
+#endif /*_DVBVIDEO_H_*/
diff -uNr linux-2.6.32/usr/include/linux/edd.h clean_modified/linux-2.6.32/usr/include/linux/edd.h
--- linux-2.6.32/usr/include/linux/edd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/edd.h	2019-04-14 13:24:02.955874409 -0500
@@ -0,0 +1,191 @@
+/*
+ * linux/include/linux/edd.h
+ *  Copyright (C) 2002, 2003, 2004 Dell Inc.
+ *  by Matt Domsch <Matt_Domsch@dell.com>
+ *
+ * structures and definitions for the int 13h, ax={41,48}h
+ * BIOS Enhanced Disk Drive Services
+ * This is based on the T13 group document D1572 Revision 0 (August 14 2002)
+ * available at http://www.t13.org/docs2002/d1572r0.pdf.  It is
+ * very similar to D1484 Revision 3 http://www.t13.org/docs2002/d1484r3.pdf
+ *
+ * In a nutshell, arch/{i386,x86_64}/boot/setup.S populates a scratch
+ * table in the boot_params that contains a list of BIOS-enumerated
+ * boot devices.
+ * In arch/{i386,x86_64}/kernel/setup.c, this information is
+ * transferred into the edd structure, and in drivers/firmware/edd.c, that
+ * information is used to identify BIOS boot disk.  The code in setup.S
+ * is very sensitive to the size of these structures.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License v2.0 as published by
+ * the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_EDD_H
+#define _LINUX_EDD_H
+
+#include <linux/types.h>
+
+#define EDDNR 0x1e9		/* addr of number of edd_info structs at EDDBUF
+				   in boot_params - treat this as 1 byte  */
+#define EDDBUF	0xd00		/* addr of edd_info structs in boot_params */
+#define EDDMAXNR 6		/* number of edd_info structs starting at EDDBUF  */
+#define EDDEXTSIZE 8		/* change these if you muck with the structures */
+#define EDDPARMSIZE 74
+#define CHECKEXTENSIONSPRESENT 0x41
+#define GETDEVICEPARAMETERS 0x48
+#define LEGACYGETDEVICEPARAMETERS 0x08
+#define EDDMAGIC1 0x55AA
+#define EDDMAGIC2 0xAA55
+
+
+#define READ_SECTORS 0x02         /* int13 AH=0x02 is READ_SECTORS command */
+#define EDD_MBR_SIG_OFFSET 0x1B8  /* offset of signature in the MBR */
+#define EDD_MBR_SIG_BUF    0x290  /* addr in boot params */
+#define EDD_MBR_SIG_MAX 16        /* max number of signatures to store */
+#define EDD_MBR_SIG_NR_BUF 0x1ea  /* addr of number of MBR signtaures at EDD_MBR_SIG_BUF
+				     in boot_params - treat this as 1 byte  */
+
+#ifndef __ASSEMBLY__
+
+#define EDD_EXT_FIXED_DISK_ACCESS           (1 << 0)
+#define EDD_EXT_DEVICE_LOCKING_AND_EJECTING (1 << 1)
+#define EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT (1 << 2)
+#define EDD_EXT_64BIT_EXTENSIONS            (1 << 3)
+
+#define EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT (1 << 0)
+#define EDD_INFO_GEOMETRY_VALID                (1 << 1)
+#define EDD_INFO_REMOVABLE                     (1 << 2)
+#define EDD_INFO_WRITE_VERIFY                  (1 << 3)
+#define EDD_INFO_MEDIA_CHANGE_NOTIFICATION     (1 << 4)
+#define EDD_INFO_LOCKABLE                      (1 << 5)
+#define EDD_INFO_NO_MEDIA_PRESENT              (1 << 6)
+#define EDD_INFO_USE_INT13_FN50                (1 << 7)
+
+struct edd_device_params {
+	__u16 length;
+	__u16 info_flags;
+	__u32 num_default_cylinders;
+	__u32 num_default_heads;
+	__u32 sectors_per_track;
+	__u64 number_of_sectors;
+	__u16 bytes_per_sector;
+	__u32 dpte_ptr;		/* 0xFFFFFFFF for our purposes */
+	__u16 key;		/* = 0xBEDD */
+	__u8 device_path_info_length;	/* = 44 */
+	__u8 reserved2;
+	__u16 reserved3;
+	__u8 host_bus_type[4];
+	__u8 interface_type[8];
+	union {
+		struct {
+			__u16 base_address;
+			__u16 reserved1;
+			__u32 reserved2;
+		} __attribute__ ((packed)) isa;
+		struct {
+			__u8 bus;
+			__u8 slot;
+			__u8 function;
+			__u8 channel;
+			__u32 reserved;
+		} __attribute__ ((packed)) pci;
+		/* pcix is same as pci */
+		struct {
+			__u64 reserved;
+		} __attribute__ ((packed)) ibnd;
+		struct {
+			__u64 reserved;
+		} __attribute__ ((packed)) xprs;
+		struct {
+			__u64 reserved;
+		} __attribute__ ((packed)) htpt;
+		struct {
+			__u64 reserved;
+		} __attribute__ ((packed)) unknown;
+	} interface_path;
+	union {
+		struct {
+			__u8 device;
+			__u8 reserved1;
+			__u16 reserved2;
+			__u32 reserved3;
+			__u64 reserved4;
+		} __attribute__ ((packed)) ata;
+		struct {
+			__u8 device;
+			__u8 lun;
+			__u8 reserved1;
+			__u8 reserved2;
+			__u32 reserved3;
+			__u64 reserved4;
+		} __attribute__ ((packed)) atapi;
+		struct {
+			__u16 id;
+			__u64 lun;
+			__u16 reserved1;
+			__u32 reserved2;
+		} __attribute__ ((packed)) scsi;
+		struct {
+			__u64 serial_number;
+			__u64 reserved;
+		} __attribute__ ((packed)) usb;
+		struct {
+			__u64 eui;
+			__u64 reserved;
+		} __attribute__ ((packed)) i1394;
+		struct {
+			__u64 wwid;
+			__u64 lun;
+		} __attribute__ ((packed)) fibre;
+		struct {
+			__u64 identity_tag;
+			__u64 reserved;
+		} __attribute__ ((packed)) i2o;
+		struct {
+			__u32 array_number;
+			__u32 reserved1;
+			__u64 reserved2;
+		} __attribute__ ((packed)) raid;
+		struct {
+			__u8 device;
+			__u8 reserved1;
+			__u16 reserved2;
+			__u32 reserved3;
+			__u64 reserved4;
+		} __attribute__ ((packed)) sata;
+		struct {
+			__u64 reserved1;
+			__u64 reserved2;
+		} __attribute__ ((packed)) unknown;
+	} device_path;
+	__u8 reserved4;
+	__u8 checksum;
+} __attribute__ ((packed));
+
+struct edd_info {
+	__u8 device;
+	__u8 version;
+	__u16 interface_support;
+	__u16 legacy_max_cylinder;
+	__u8 legacy_max_head;
+	__u8 legacy_sectors_per_track;
+	struct edd_device_params params;
+} __attribute__ ((packed));
+
+struct edd {
+	unsigned int mbr_signature[EDD_MBR_SIG_MAX];
+	struct edd_info edd_info[EDDMAXNR];
+	unsigned char mbr_signature_nr;
+	unsigned char edd_info_nr;
+};
+
+#endif				/*!__ASSEMBLY__ */
+
+#endif				/* _LINUX_EDD_H */
diff -uNr linux-2.6.32/usr/include/linux/efs_fs_sb.h clean_modified/linux-2.6.32/usr/include/linux/efs_fs_sb.h
--- linux-2.6.32/usr/include/linux/efs_fs_sb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/efs_fs_sb.h	2019-04-14 13:24:02.955874409 -0500
@@ -0,0 +1,62 @@
+/*
+ * efs_fs_sb.h
+ *
+ * Copyright (c) 1999 Al Smith
+ *
+ * Portions derived from IRIX header files (c) 1988 Silicon Graphics
+ */
+
+#ifndef __EFS_FS_SB_H__
+#define __EFS_FS_SB_H__
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/* EFS superblock magic numbers */
+#define EFS_MAGIC	0x072959
+#define EFS_NEWMAGIC	0x07295a
+
+#define IS_EFS_MAGIC(x)	((x == EFS_MAGIC) || (x == EFS_NEWMAGIC))
+
+#define EFS_SUPER		1
+#define EFS_ROOTINODE		2
+
+/* efs superblock on disk */
+struct efs_super {
+	__be32		fs_size;        /* size of filesystem, in sectors */
+	__be32		fs_firstcg;     /* bb offset to first cg */
+	__be32		fs_cgfsize;     /* size of cylinder group in bb's */
+	__be16		fs_cgisize;     /* bb's of inodes per cylinder group */
+	__be16		fs_sectors;     /* sectors per track */
+	__be16		fs_heads;       /* heads per cylinder */
+	__be16		fs_ncg;         /* # of cylinder groups in filesystem */
+	__be16		fs_dirty;       /* fs needs to be fsck'd */
+	__be32		fs_time;        /* last super-block update */
+	__be32		fs_magic;       /* magic number */
+	char		fs_fname[6];    /* file system name */
+	char		fs_fpack[6];    /* file system pack name */
+	__be32		fs_bmsize;      /* size of bitmap in bytes */
+	__be32		fs_tfree;       /* total free data blocks */
+	__be32		fs_tinode;      /* total free inodes */
+	__be32		fs_bmblock;     /* bitmap location. */
+	__be32		fs_replsb;      /* Location of replicated superblock. */
+	__be32		fs_lastialloc;  /* last allocated inode */
+	char		fs_spare[20];   /* space for expansion - MUST BE ZERO */
+	__be32		fs_checksum;    /* checksum of volume portion of fs */
+};
+
+/* efs superblock information in memory */
+struct efs_sb_info {
+	__u32	fs_magic;	/* superblock magic number */
+	__u32	fs_start;	/* first block of filesystem */
+	__u32	first_block;	/* first data block in filesystem */
+	__u32	total_blocks;	/* total number of blocks in filesystem */
+	__u32	group_size;	/* # of blocks a group consists of */ 
+	__u32	data_free;	/* # of free data blocks */
+	__u32	inode_free;	/* # of free inodes */
+	__u16	inode_blocks;	/* # of blocks used for inodes in every grp */
+	__u16	total_groups;	/* # of groups */
+};
+
+#endif /* __EFS_FS_SB_H__ */
+
diff -uNr linux-2.6.32/usr/include/linux/elfcore.h clean_modified/linux-2.6.32/usr/include/linux/elfcore.h
--- linux-2.6.32/usr/include/linux/elfcore.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/elfcore.h	2019-04-14 13:24:02.956885163 -0500
@@ -0,0 +1,95 @@
+#ifndef _LINUX_ELFCORE_H
+#define _LINUX_ELFCORE_H
+
+#include <linux/types.h>
+#include <linux/signal.h>
+#include <linux/time.h>
+#include <linux/ptrace.h>
+
+struct elf_siginfo
+{
+	int	si_signo;			/* signal number */
+	int	si_code;			/* extra code */
+	int	si_errno;			/* errno */
+};
+
+
+typedef elf_greg_t greg_t;
+typedef elf_gregset_t gregset_t;
+typedef elf_fpregset_t fpregset_t;
+typedef elf_fpxregset_t fpxregset_t;
+#define NGREG ELF_NGREG
+
+/*
+ * Definitions to generate Intel SVR4-like core files.
+ * These mostly have the same names as the SVR4 types with "elf_"
+ * tacked on the front to prevent clashes with linux definitions,
+ * and the typedef forms have been avoided.  This is mostly like
+ * the SVR4 structure, but more Linuxy, with things that Linux does
+ * not support and which gdb doesn't really use excluded.
+ * Fields present but not used are marked with "XXX".
+ */
+struct elf_prstatus
+{
+#if 0
+	long	pr_flags;	/* XXX Process flags */
+	short	pr_why;		/* XXX Reason for process halt */
+	short	pr_what;	/* XXX More detailed reason */
+#endif
+	struct elf_siginfo pr_info;	/* Info associated with signal */
+	short	pr_cursig;		/* Current signal */
+	unsigned long pr_sigpend;	/* Set of pending signals */
+	unsigned long pr_sighold;	/* Set of held signals */
+#if 0
+	struct sigaltstack pr_altstack;	/* Alternate stack info */
+	struct sigaction pr_action;	/* Signal action for current sig */
+#endif
+	pid_t	pr_pid;
+	pid_t	pr_ppid;
+	pid_t	pr_pgrp;
+	pid_t	pr_sid;
+	struct timeval pr_utime;	/* User time */
+	struct timeval pr_stime;	/* System time */
+	struct timeval pr_cutime;	/* Cumulative user time */
+	struct timeval pr_cstime;	/* Cumulative system time */
+#if 0
+	long	pr_instr;		/* Current instruction */
+#endif
+	elf_gregset_t pr_reg;	/* GP registers */
+#ifdef CONFIG_BINFMT_ELF_FDPIC
+	/* When using FDPIC, the loadmap addresses need to be communicated
+	 * to GDB in order for GDB to do the necessary relocations.  The
+	 * fields (below) used to communicate this information are placed
+	 * immediately after ``pr_reg'', so that the loadmap addresses may
+	 * be viewed as part of the register set if so desired.
+	 */
+	unsigned long pr_exec_fdpic_loadmap;
+	unsigned long pr_interp_fdpic_loadmap;
+#endif
+	int pr_fpvalid;		/* True if math co-processor being used.  */
+};
+
+#define ELF_PRARGSZ	(80)	/* Number of chars for args */
+
+struct elf_prpsinfo
+{
+	char	pr_state;	/* numeric process state */
+	char	pr_sname;	/* char for pr_state */
+	char	pr_zomb;	/* zombie */
+	char	pr_nice;	/* nice val */
+	unsigned long pr_flag;	/* flags */
+	__kernel_uid_t	pr_uid;
+	__kernel_gid_t	pr_gid;
+	pid_t	pr_pid, pr_ppid, pr_pgrp, pr_sid;
+	/* Lots missing */
+	char	pr_fname[16];	/* filename of executable */
+	char	pr_psargs[ELF_PRARGSZ];	/* initial part of arg list */
+};
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+#define PRARGSZ ELF_PRARGSZ 
+
+
+
+#endif /* _LINUX_ELFCORE_H */
diff -uNr linux-2.6.32/usr/include/linux/elf-em.h clean_modified/linux-2.6.32/usr/include/linux/elf-em.h
--- linux-2.6.32/usr/include/linux/elf-em.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/elf-em.h	2019-04-14 13:24:02.956885163 -0500
@@ -0,0 +1,55 @@
+#ifndef _LINUX_ELF_EM_H
+#define _LINUX_ELF_EM_H
+
+/* These constants define the various ELF target machines */
+#define EM_NONE		0
+#define EM_M32		1
+#define EM_SPARC	2
+#define EM_386		3
+#define EM_68K		4
+#define EM_88K		5
+#define EM_486		6	/* Perhaps disused */
+#define EM_860		7
+#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
+				/* Next two are historical and binaries and
+				   modules of these types will be rejected by
+				   Linux.  */
+#define EM_MIPS_RS3_LE	10	/* MIPS R3000 little-endian */
+#define EM_MIPS_RS4_BE	10	/* MIPS R4000 big-endian */
+
+#define EM_PARISC	15	/* HPPA */
+#define EM_SPARC32PLUS	18	/* Sun's "v8plus" */
+#define EM_PPC		20	/* PowerPC */
+#define EM_PPC64	21	 /* PowerPC64 */
+#define EM_SPU		23	/* Cell BE SPU */
+#define EM_SH		42	/* SuperH */
+#define EM_SPARCV9	43	/* SPARC v9 64-bit */
+#define EM_IA_64	50	/* HP/Intel IA-64 */
+#define EM_X86_64	62	/* AMD x86-64 */
+#define EM_S390		22	/* IBM S/390 */
+#define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
+#define EM_V850		87	/* NEC v850 */
+#define EM_M32R		88	/* Renesas M32R */
+#define EM_H8_300	46	/* Renesas H8/300,300H,H8S */
+#define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
+#define EM_BLACKFIN     106     /* ADI Blackfin Processor */
+#define EM_FRV		0x5441	/* Fujitsu FR-V */
+#define EM_AVR32	0x18ad	/* Atmel AVR32 */
+
+/*
+ * This is an interim value that we will use until the committee comes
+ * up with a final number.
+ */
+#define EM_ALPHA	0x9026
+
+/* Bogus old v850 magic number, used by old tools. */
+#define EM_CYGNUS_V850	0x9080
+/* Bogus old m32r magic number, used by old tools. */
+#define EM_CYGNUS_M32R	0x9041
+/* This is the old interim value for S/390 architecture */
+#define EM_S390_OLD	0xA390
+/* Also Panasonic/MEI MN10300, AM33 */
+#define EM_CYGNUS_MN10300 0xbeef
+
+
+#endif /* _LINUX_ELF_EM_H */
diff -uNr linux-2.6.32/usr/include/linux/elf-fdpic.h clean_modified/linux-2.6.32/usr/include/linux/elf-fdpic.h
--- linux-2.6.32/usr/include/linux/elf-fdpic.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/elf-fdpic.h	2019-04-14 13:24:02.957868696 -0500
@@ -0,0 +1,62 @@
+/* elf-fdpic.h: FDPIC ELF load map
+ *
+ * Copyright (C) 2003 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_ELF_FDPIC_H
+#define _LINUX_ELF_FDPIC_H
+
+#include <linux/elf.h>
+
+#define PT_GNU_STACK    (PT_LOOS + 0x474e551)
+
+/* segment mappings for ELF FDPIC libraries/executables/interpreters */
+struct elf32_fdpic_loadseg {
+	Elf32_Addr	addr;		/* core address to which mapped */
+	Elf32_Addr	p_vaddr;	/* VMA recorded in file */
+	Elf32_Word	p_memsz;	/* allocation size recorded in file */
+};
+
+struct elf32_fdpic_loadmap {
+	Elf32_Half	version;	/* version of these structures, just in case... */
+	Elf32_Half	nsegs;		/* number of segments */
+	struct elf32_fdpic_loadseg segs[];
+};
+
+#define ELF32_FDPIC_LOADMAP_VERSION	0x0000
+
+/*
+ * binfmt binary parameters structure
+ */
+struct elf_fdpic_params {
+	struct elfhdr			hdr;		/* ref copy of ELF header */
+	struct elf_phdr			*phdrs;		/* ref copy of PT_PHDR table */
+	struct elf32_fdpic_loadmap	*loadmap;	/* loadmap to be passed to userspace */
+	unsigned long			elfhdr_addr;	/* mapped ELF header user address */
+	unsigned long			ph_addr;	/* mapped PT_PHDR user address */
+	unsigned long			map_addr;	/* mapped loadmap user address */
+	unsigned long			entry_addr;	/* mapped entry user address */
+	unsigned long			stack_size;	/* stack size requested (PT_GNU_STACK) */
+	unsigned long			dynamic_addr;	/* mapped PT_DYNAMIC user address */
+	unsigned long			load_addr;	/* user address at which to map binary */
+	unsigned long			flags;
+#define ELF_FDPIC_FLAG_ARRANGEMENT	0x0000000f	/* PT_LOAD arrangement flags */
+#define ELF_FDPIC_FLAG_INDEPENDENT	0x00000000	/* PT_LOADs can be put anywhere */
+#define ELF_FDPIC_FLAG_HONOURVADDR	0x00000001	/* PT_LOAD.vaddr must be honoured */
+#define ELF_FDPIC_FLAG_CONSTDISP	0x00000002	/* PT_LOADs require constant
+							 * displacement */
+#define ELF_FDPIC_FLAG_CONTIGUOUS	0x00000003	/* PT_LOADs should be contiguous */
+#define ELF_FDPIC_FLAG_EXEC_STACK	0x00000010	/* T if stack to be executable */
+#define ELF_FDPIC_FLAG_NOEXEC_STACK	0x00000020	/* T if stack not to be executable */
+#define ELF_FDPIC_FLAG_EXECUTABLE	0x00000040	/* T if this object is the executable */
+#define ELF_FDPIC_FLAG_PRESENT		0x80000000	/* T if this object is present */
+};
+
+
+#endif /* _LINUX_ELF_FDPIC_H */
diff -uNr linux-2.6.32/usr/include/linux/elf.h clean_modified/linux-2.6.32/usr/include/linux/elf.h
--- linux-2.6.32/usr/include/linux/elf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/elf.h	2019-04-14 13:24:02.957868696 -0500
@@ -0,0 +1,378 @@
+#ifndef _LINUX_ELF_H
+#define _LINUX_ELF_H
+
+#include <linux/types.h>
+#include <linux/elf-em.h>
+
+struct file;
+
+#ifndef elf_read_implies_exec
+  /* Executables for which elf_read_implies_exec() returns TRUE will
+     have the READ_IMPLIES_EXEC personality flag set automatically.
+     Override in asm/elf.h as needed.  */
+# define elf_read_implies_exec(ex, have_pt_gnu_stack)	0
+#endif
+
+/* 32-bit ELF base types. */
+typedef __u32	Elf32_Addr;
+typedef __u16	Elf32_Half;
+typedef __u32	Elf32_Off;
+typedef __s32	Elf32_Sword;
+typedef __u32	Elf32_Word;
+
+/* 64-bit ELF base types. */
+typedef __u64	Elf64_Addr;
+typedef __u16	Elf64_Half;
+typedef __s16	Elf64_SHalf;
+typedef __u64	Elf64_Off;
+typedef __s32	Elf64_Sword;
+typedef __u32	Elf64_Word;
+typedef __u64	Elf64_Xword;
+typedef __s64	Elf64_Sxword;
+
+/* These constants are for the segment types stored in the image headers */
+#define PT_NULL    0
+#define PT_LOAD    1
+#define PT_DYNAMIC 2
+#define PT_INTERP  3
+#define PT_NOTE    4
+#define PT_SHLIB   5
+#define PT_PHDR    6
+#define PT_TLS     7               /* Thread local storage segment */
+#define PT_LOOS    0x60000000      /* OS-specific */
+#define PT_HIOS    0x6fffffff      /* OS-specific */
+#define PT_LOPROC  0x70000000
+#define PT_HIPROC  0x7fffffff
+#define PT_GNU_EH_FRAME		0x6474e550
+
+#define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+
+/* These constants define the different elf file types */
+#define ET_NONE   0
+#define ET_REL    1
+#define ET_EXEC   2
+#define ET_DYN    3
+#define ET_CORE   4
+#define ET_LOPROC 0xff00
+#define ET_HIPROC 0xffff
+
+/* This is the info that is needed to parse the dynamic section of the file */
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH 	15
+#define DT_SYMBOLIC	16
+#define DT_REL	        17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+#define DT_ENCODING	32
+#define OLD_DT_LOOS	0x60000000
+#define DT_LOOS		0x6000000d
+#define DT_HIOS		0x6ffff000
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_VERSYM	0x6ffffff0
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+#define DT_FLAGS_1	0x6ffffffb
+#define DT_VERDEF	0x6ffffffc
+#define	DT_VERDEFNUM	0x6ffffffd
+#define DT_VERNEED	0x6ffffffe
+#define	DT_VERNEEDNUM	0x6fffffff
+#define OLD_DT_HIOS     0x6fffffff
+#define DT_LOPROC	0x70000000
+#define DT_HIPROC	0x7fffffff
+
+/* This info is needed when parsing the symbol table */
+#define STB_LOCAL  0
+#define STB_GLOBAL 1
+#define STB_WEAK   2
+
+#define STT_NOTYPE  0
+#define STT_OBJECT  1
+#define STT_FUNC    2
+#define STT_SECTION 3
+#define STT_FILE    4
+#define STT_COMMON  5
+#define STT_TLS     6
+
+#define ELF_ST_BIND(x)		((x) >> 4)
+#define ELF_ST_TYPE(x)		(((unsigned int) x) & 0xf)
+#define ELF32_ST_BIND(x)	ELF_ST_BIND(x)
+#define ELF32_ST_TYPE(x)	ELF_ST_TYPE(x)
+#define ELF64_ST_BIND(x)	ELF_ST_BIND(x)
+#define ELF64_ST_TYPE(x)	ELF_ST_TYPE(x)
+
+typedef struct dynamic{
+  Elf32_Sword d_tag;
+  union{
+    Elf32_Sword	d_val;
+    Elf32_Addr	d_ptr;
+  } d_un;
+} Elf32_Dyn;
+
+typedef struct {
+  Elf64_Sxword d_tag;		/* entry tag value */
+  union {
+    Elf64_Xword d_val;
+    Elf64_Addr d_ptr;
+  } d_un;
+} Elf64_Dyn;
+
+/* The following are used with relocations */
+#define ELF32_R_SYM(x) ((x) >> 8)
+#define ELF32_R_TYPE(x) ((x) & 0xff)
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+
+typedef struct elf32_rel {
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+} Elf32_Rel;
+
+typedef struct elf64_rel {
+  Elf64_Addr r_offset;	/* Location at which to apply the action */
+  Elf64_Xword r_info;	/* index and type of relocation */
+} Elf64_Rel;
+
+typedef struct elf32_rela{
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+  Elf32_Sword	r_addend;
+} Elf32_Rela;
+
+typedef struct elf64_rela {
+  Elf64_Addr r_offset;	/* Location at which to apply the action */
+  Elf64_Xword r_info;	/* index and type of relocation */
+  Elf64_Sxword r_addend;	/* Constant addend used to compute value */
+} Elf64_Rela;
+
+typedef struct elf32_sym{
+  Elf32_Word	st_name;
+  Elf32_Addr	st_value;
+  Elf32_Word	st_size;
+  unsigned char	st_info;
+  unsigned char	st_other;
+  Elf32_Half	st_shndx;
+} Elf32_Sym;
+
+typedef struct elf64_sym {
+  Elf64_Word st_name;		/* Symbol name, index in string tbl */
+  unsigned char	st_info;	/* Type and binding attributes */
+  unsigned char	st_other;	/* No defined meaning, 0 */
+  Elf64_Half st_shndx;		/* Associated section index */
+  Elf64_Addr st_value;		/* Value of the symbol */
+  Elf64_Xword st_size;		/* Associated symbol size */
+} Elf64_Sym;
+
+
+#define EI_NIDENT	16
+
+typedef struct elf32_hdr{
+  unsigned char	e_ident[EI_NIDENT];
+  Elf32_Half	e_type;
+  Elf32_Half	e_machine;
+  Elf32_Word	e_version;
+  Elf32_Addr	e_entry;  /* Entry point */
+  Elf32_Off	e_phoff;
+  Elf32_Off	e_shoff;
+  Elf32_Word	e_flags;
+  Elf32_Half	e_ehsize;
+  Elf32_Half	e_phentsize;
+  Elf32_Half	e_phnum;
+  Elf32_Half	e_shentsize;
+  Elf32_Half	e_shnum;
+  Elf32_Half	e_shstrndx;
+} Elf32_Ehdr;
+
+typedef struct elf64_hdr {
+  unsigned char	e_ident[EI_NIDENT];	/* ELF "magic number" */
+  Elf64_Half e_type;
+  Elf64_Half e_machine;
+  Elf64_Word e_version;
+  Elf64_Addr e_entry;		/* Entry point virtual address */
+  Elf64_Off e_phoff;		/* Program header table file offset */
+  Elf64_Off e_shoff;		/* Section header table file offset */
+  Elf64_Word e_flags;
+  Elf64_Half e_ehsize;
+  Elf64_Half e_phentsize;
+  Elf64_Half e_phnum;
+  Elf64_Half e_shentsize;
+  Elf64_Half e_shnum;
+  Elf64_Half e_shstrndx;
+} Elf64_Ehdr;
+
+/* These constants define the permissions on sections in the program
+   header, p_flags. */
+#define PF_R		0x4
+#define PF_W		0x2
+#define PF_X		0x1
+
+typedef struct elf32_phdr{
+  Elf32_Word	p_type;
+  Elf32_Off	p_offset;
+  Elf32_Addr	p_vaddr;
+  Elf32_Addr	p_paddr;
+  Elf32_Word	p_filesz;
+  Elf32_Word	p_memsz;
+  Elf32_Word	p_flags;
+  Elf32_Word	p_align;
+} Elf32_Phdr;
+
+typedef struct elf64_phdr {
+  Elf64_Word p_type;
+  Elf64_Word p_flags;
+  Elf64_Off p_offset;		/* Segment file offset */
+  Elf64_Addr p_vaddr;		/* Segment virtual address */
+  Elf64_Addr p_paddr;		/* Segment physical address */
+  Elf64_Xword p_filesz;		/* Segment size in file */
+  Elf64_Xword p_memsz;		/* Segment size in memory */
+  Elf64_Xword p_align;		/* Segment alignment, file & memory */
+} Elf64_Phdr;
+
+/* sh_type */
+#define SHT_NULL	0
+#define SHT_PROGBITS	1
+#define SHT_SYMTAB	2
+#define SHT_STRTAB	3
+#define SHT_RELA	4
+#define SHT_HASH	5
+#define SHT_DYNAMIC	6
+#define SHT_NOTE	7
+#define SHT_NOBITS	8
+#define SHT_REL		9
+#define SHT_SHLIB	10
+#define SHT_DYNSYM	11
+#define SHT_NUM		12
+#define SHT_LOPROC	0x70000000
+#define SHT_HIPROC	0x7fffffff
+#define SHT_LOUSER	0x80000000
+#define SHT_HIUSER	0xffffffff
+
+/* sh_flags */
+#define SHF_WRITE	0x1
+#define SHF_ALLOC	0x2
+#define SHF_EXECINSTR	0x4
+#define SHF_MASKPROC	0xf0000000
+
+/* special section indexes */
+#define SHN_UNDEF	0
+#define SHN_LORESERVE	0xff00
+#define SHN_LOPROC	0xff00
+#define SHN_HIPROC	0xff1f
+#define SHN_ABS		0xfff1
+#define SHN_COMMON	0xfff2
+#define SHN_HIRESERVE	0xffff
+ 
+typedef struct {
+  Elf32_Word	sh_name;
+  Elf32_Word	sh_type;
+  Elf32_Word	sh_flags;
+  Elf32_Addr	sh_addr;
+  Elf32_Off	sh_offset;
+  Elf32_Word	sh_size;
+  Elf32_Word	sh_link;
+  Elf32_Word	sh_info;
+  Elf32_Word	sh_addralign;
+  Elf32_Word	sh_entsize;
+} Elf32_Shdr;
+
+typedef struct elf64_shdr {
+  Elf64_Word sh_name;		/* Section name, index in string tbl */
+  Elf64_Word sh_type;		/* Type of section */
+  Elf64_Xword sh_flags;		/* Miscellaneous section attributes */
+  Elf64_Addr sh_addr;		/* Section virtual addr at execution */
+  Elf64_Off sh_offset;		/* Section file offset */
+  Elf64_Xword sh_size;		/* Size of section in bytes */
+  Elf64_Word sh_link;		/* Index of another section */
+  Elf64_Word sh_info;		/* Additional section information */
+  Elf64_Xword sh_addralign;	/* Section alignment */
+  Elf64_Xword sh_entsize;	/* Entry size if section holds table */
+} Elf64_Shdr;
+
+#define	EI_MAG0		0		/* e_ident[] indexes */
+#define	EI_MAG1		1
+#define	EI_MAG2		2
+#define	EI_MAG3		3
+#define	EI_CLASS	4
+#define	EI_DATA		5
+#define	EI_VERSION	6
+#define	EI_OSABI	7
+#define	EI_PAD		8
+
+#define	ELFMAG0		0x7f		/* EI_MAG */
+#define	ELFMAG1		'E'
+#define	ELFMAG2		'L'
+#define	ELFMAG3		'F'
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define	ELFCLASSNONE	0		/* EI_CLASS */
+#define	ELFCLASS32	1
+#define	ELFCLASS64	2
+#define	ELFCLASSNUM	3
+
+#define ELFDATANONE	0		/* e_ident[EI_DATA] */
+#define ELFDATA2LSB	1
+#define ELFDATA2MSB	2
+
+#define EV_NONE		0		/* e_version, EI_VERSION */
+#define EV_CURRENT	1
+#define EV_NUM		2
+
+#define ELFOSABI_NONE	0
+#define ELFOSABI_LINUX	3
+
+#ifndef ELF_OSABI
+#define ELF_OSABI ELFOSABI_NONE
+#endif
+
+/* Notes used in ET_CORE */
+#define NT_PRSTATUS	1
+#define NT_PRFPREG	2
+#define NT_PRPSINFO	3
+#define NT_TASKSTRUCT	4
+#define NT_AUXV		6
+#define NT_PRXFPREG     0x46e62b7f      /* copied from gdb5.1/include/elf/common.h */
+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
+#define NT_PRXSTATUS	0x300		/* s390 upper register halves */
+
+
+/* Note header in a PT_NOTE section */
+typedef struct elf32_note {
+  Elf32_Word	n_namesz;	/* Name size */
+  Elf32_Word	n_descsz;	/* Content size */
+  Elf32_Word	n_type;		/* Content type */
+} Elf32_Nhdr;
+
+/* Note header in a PT_NOTE section */
+typedef struct elf64_note {
+  Elf64_Word n_namesz;	/* Name size */
+  Elf64_Word n_descsz;	/* Content size */
+  Elf64_Word n_type;	/* Content type */
+} Elf64_Nhdr;
+
+#endif /* _LINUX_ELF_H */
diff -uNr linux-2.6.32/usr/include/linux/errno.h clean_modified/linux-2.6.32/usr/include/linux/errno.h
--- linux-2.6.32/usr/include/linux/errno.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/errno.h	2019-04-14 13:24:02.958829750 -0500
@@ -0,0 +1,7 @@
+#ifndef _LINUX_ERRNO_H
+#define _LINUX_ERRNO_H
+
+#include <asm/errno.h>
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/errqueue.h clean_modified/linux-2.6.32/usr/include/linux/errqueue.h
--- linux-2.6.32/usr/include/linux/errqueue.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/errqueue.h	2019-04-14 13:24:02.958829750 -0500
@@ -0,0 +1,26 @@
+#ifndef _LINUX_ERRQUEUE_H
+#define _LINUX_ERRQUEUE_H 1
+
+#include <linux/types.h>
+
+struct sock_extended_err
+{
+	__u32	ee_errno;	
+	__u8	ee_origin;
+	__u8	ee_type;
+	__u8	ee_code;
+	__u8	ee_pad;
+	__u32   ee_info;
+	__u32   ee_data;
+};
+
+#define SO_EE_ORIGIN_NONE	0
+#define SO_EE_ORIGIN_LOCAL	1
+#define SO_EE_ORIGIN_ICMP	2
+#define SO_EE_ORIGIN_ICMP6	3
+#define SO_EE_ORIGIN_TIMESTAMPING 4
+
+#define SO_EE_OFFENDER(ee)	((struct sockaddr*)((ee)+1))
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ethtool.h clean_modified/linux-2.6.32/usr/include/linux/ethtool.h
--- linux-2.6.32/usr/include/linux/ethtool.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ethtool.h	2019-04-14 13:24:02.959803308 -0500
@@ -0,0 +1,562 @@
+/*
+ * ethtool.h: Defines for Linux ethtool.
+ *
+ * Copyright (C) 1998 David S. Miller (davem@redhat.com)
+ * Copyright 2001 Jeff Garzik <jgarzik@pobox.com>
+ * Portions Copyright 2001 Sun Microsystems (thockin@sun.com)
+ * Portions Copyright 2002 Intel (eli.kupermann@intel.com,
+ *                                christopher.leech@intel.com,
+ *                                scott.feldman@intel.com)
+ * Portions Copyright (C) Sun Microsystems 2008
+ */
+
+#ifndef _LINUX_ETHTOOL_H
+#define _LINUX_ETHTOOL_H
+
+#include <linux/types.h>
+
+/* This should work for both 32 and 64 bit userland. */
+struct ethtool_cmd {
+	__u32	cmd;
+	__u32	supported;	/* Features this interface supports */
+	__u32	advertising;	/* Features this interface advertises */
+	__u16	speed;		/* The forced speed, 10Mb, 100Mb, gigabit */
+	__u8	duplex;		/* Duplex, half or full */
+	__u8	port;		/* Which connector port */
+	__u8	phy_address;
+	__u8	transceiver;	/* Which transceiver to use */
+	__u8	autoneg;	/* Enable or disable autonegotiation */
+	__u8	mdio_support;
+	__u32	maxtxpkt;	/* Tx pkts before generating tx int */
+	__u32	maxrxpkt;	/* Rx pkts before generating rx int */
+	__u16	speed_hi;
+	__u8	eth_tp_mdix;
+	__u8	reserved2;
+	__u32	lp_advertising;	/* Features the link partner advertises */
+	__u32	reserved[2];
+};
+
+static __inline__ void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
+						__u32 speed)
+{
+
+	ep->speed = (__u16)speed;
+	ep->speed_hi = (__u16)(speed >> 16);
+}
+
+static __inline__ __u32 ethtool_cmd_speed(struct ethtool_cmd *ep)
+{
+	return (ep->speed_hi << 16) | ep->speed;
+}
+
+#define ETHTOOL_BUSINFO_LEN	32
+/* these strings are set to whatever the driver author decides... */
+struct ethtool_drvinfo {
+	__u32	cmd;
+	char	driver[32];	/* driver short name, "tulip", "eepro100" */
+	char	version[32];	/* driver version string */
+	char	fw_version[32];	/* firmware version string, if applicable */
+	char	bus_info[ETHTOOL_BUSINFO_LEN];	/* Bus info for this IF. */
+				/* For PCI devices, use pci_name(pci_dev). */
+	char	reserved1[32];
+	char	reserved2[12];
+	__u32	n_priv_flags;	/* number of flags valid in ETHTOOL_GPFLAGS */
+	__u32	n_stats;	/* number of u64's from ETHTOOL_GSTATS */
+	__u32	testinfo_len;
+	__u32	eedump_len;	/* Size of data from ETHTOOL_GEEPROM (bytes) */
+	__u32	regdump_len;	/* Size of data from ETHTOOL_GREGS (bytes) */
+};
+
+#define SOPASS_MAX	6
+/* wake-on-lan settings */
+struct ethtool_wolinfo {
+	__u32	cmd;
+	__u32	supported;
+	__u32	wolopts;
+	__u8	sopass[SOPASS_MAX]; /* SecureOn(tm) password */
+};
+
+/* for passing single values */
+struct ethtool_value {
+	__u32	cmd;
+	__u32	data;
+};
+
+/* for passing big chunks of data */
+struct ethtool_regs {
+	__u32	cmd;
+	__u32	version; /* driver-specific, indicates different chips/revs */
+	__u32	len; /* bytes */
+	__u8	data[0];
+};
+
+/* for passing EEPROM chunks */
+struct ethtool_eeprom {
+	__u32	cmd;
+	__u32	magic;
+	__u32	offset; /* in bytes */
+	__u32	len; /* in bytes */
+	__u8	data[0];
+};
+
+/* for configuring coalescing parameters of chip */
+struct ethtool_coalesce {
+	__u32	cmd;	/* ETHTOOL_{G,S}COALESCE */
+
+	/* How many usecs to delay an RX interrupt after
+	 * a packet arrives.  If 0, only rx_max_coalesced_frames
+	 * is used.
+	 */
+	__u32	rx_coalesce_usecs;
+
+	/* How many packets to delay an RX interrupt after
+	 * a packet arrives.  If 0, only rx_coalesce_usecs is
+	 * used.  It is illegal to set both usecs and max frames
+	 * to zero as this would cause RX interrupts to never be
+	 * generated.
+	 */
+	__u32	rx_max_coalesced_frames;
+
+	/* Same as above two parameters, except that these values
+	 * apply while an IRQ is being serviced by the host.  Not
+	 * all cards support this feature and the values are ignored
+	 * in that case.
+	 */
+	__u32	rx_coalesce_usecs_irq;
+	__u32	rx_max_coalesced_frames_irq;
+
+	/* How many usecs to delay a TX interrupt after
+	 * a packet is sent.  If 0, only tx_max_coalesced_frames
+	 * is used.
+	 */
+	__u32	tx_coalesce_usecs;
+
+	/* How many packets to delay a TX interrupt after
+	 * a packet is sent.  If 0, only tx_coalesce_usecs is
+	 * used.  It is illegal to set both usecs and max frames
+	 * to zero as this would cause TX interrupts to never be
+	 * generated.
+	 */
+	__u32	tx_max_coalesced_frames;
+
+	/* Same as above two parameters, except that these values
+	 * apply while an IRQ is being serviced by the host.  Not
+	 * all cards support this feature and the values are ignored
+	 * in that case.
+	 */
+	__u32	tx_coalesce_usecs_irq;
+	__u32	tx_max_coalesced_frames_irq;
+
+	/* How many usecs to delay in-memory statistics
+	 * block updates.  Some drivers do not have an in-memory
+	 * statistic block, and in such cases this value is ignored.
+	 * This value must not be zero.
+	 */
+	__u32	stats_block_coalesce_usecs;
+
+	/* Adaptive RX/TX coalescing is an algorithm implemented by
+	 * some drivers to improve latency under low packet rates and
+	 * improve throughput under high packet rates.  Some drivers
+	 * only implement one of RX or TX adaptive coalescing.  Anything
+	 * not implemented by the driver causes these values to be
+	 * silently ignored.
+	 */
+	__u32	use_adaptive_rx_coalesce;
+	__u32	use_adaptive_tx_coalesce;
+
+	/* When the packet rate (measured in packets per second)
+	 * is below pkt_rate_low, the {rx,tx}_*_low parameters are
+	 * used.
+	 */
+	__u32	pkt_rate_low;
+	__u32	rx_coalesce_usecs_low;
+	__u32	rx_max_coalesced_frames_low;
+	__u32	tx_coalesce_usecs_low;
+	__u32	tx_max_coalesced_frames_low;
+
+	/* When the packet rate is below pkt_rate_high but above
+	 * pkt_rate_low (both measured in packets per second) the
+	 * normal {rx,tx}_* coalescing parameters are used.
+	 */
+
+	/* When the packet rate is (measured in packets per second)
+	 * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+	 * used.
+	 */
+	__u32	pkt_rate_high;
+	__u32	rx_coalesce_usecs_high;
+	__u32	rx_max_coalesced_frames_high;
+	__u32	tx_coalesce_usecs_high;
+	__u32	tx_max_coalesced_frames_high;
+
+	/* How often to do adaptive coalescing packet rate sampling,
+	 * measured in seconds.  Must not be zero.
+	 */
+	__u32	rate_sample_interval;
+};
+
+/* for configuring RX/TX ring parameters */
+struct ethtool_ringparam {
+	__u32	cmd;	/* ETHTOOL_{G,S}RINGPARAM */
+
+	/* Read only attributes.  These indicate the maximum number
+	 * of pending RX/TX ring entries the driver will allow the
+	 * user to set.
+	 */
+	__u32	rx_max_pending;
+	__u32	rx_mini_max_pending;
+	__u32	rx_jumbo_max_pending;
+	__u32	tx_max_pending;
+
+	/* Values changeable by the user.  The valid values are
+	 * in the range 1 to the "*_max_pending" counterpart above.
+	 */
+	__u32	rx_pending;
+	__u32	rx_mini_pending;
+	__u32	rx_jumbo_pending;
+	__u32	tx_pending;
+};
+
+/* for configuring link flow control parameters */
+struct ethtool_pauseparam {
+	__u32	cmd;	/* ETHTOOL_{G,S}PAUSEPARAM */
+
+	/* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+	 * being true) the user may set 'autonet' here non-zero to have the
+	 * pause parameters be auto-negotiated too.  In such a case, the
+	 * {rx,tx}_pause values below determine what capabilities are
+	 * advertised.
+	 *
+	 * If 'autoneg' is zero or the link is not being auto-negotiated,
+	 * then {rx,tx}_pause force the driver to use/not-use pause
+	 * flow control.
+	 */
+	__u32	autoneg;
+	__u32	rx_pause;
+	__u32	tx_pause;
+};
+
+#define ETH_GSTRING_LEN		32
+enum ethtool_stringset {
+	ETH_SS_TEST		= 0,
+	ETH_SS_STATS,
+	ETH_SS_PRIV_FLAGS,
+};
+
+/* for passing string sets for data tagging */
+struct ethtool_gstrings {
+	__u32	cmd;		/* ETHTOOL_GSTRINGS */
+	__u32	string_set;	/* string set id e.c. ETH_SS_TEST, etc*/
+	__u32	len;		/* number of strings in the string set */
+	__u8	data[0];
+};
+
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE	= (1 << 0),	/* online / offline */
+	ETH_TEST_FL_FAILED	= (1 << 1),	/* test passed / failed */
+};
+
+/* for requesting NIC test and getting results*/
+struct ethtool_test {
+	__u32	cmd;		/* ETHTOOL_TEST */
+	__u32	flags;		/* ETH_TEST_FL_xxx */
+	__u32	reserved;
+	__u32	len;		/* result length, in number of u64 elements */
+	__u64	data[0];
+};
+
+/* for dumping NIC-specific statistics */
+struct ethtool_stats {
+	__u32	cmd;		/* ETHTOOL_GSTATS */
+	__u32	n_stats;	/* number of u64's being returned */
+	__u64	data[0];
+};
+
+struct ethtool_perm_addr {
+	__u32	cmd;		/* ETHTOOL_GPERMADDR */
+	__u32	size;
+	__u8	data[0];
+};
+
+/* boolean flags controlling per-interface behavior characteristics.
+ * When reading, the flag indicates whether or not a certain behavior
+ * is enabled/present.  When writing, the flag indicates whether
+ * or not the driver should turn on (set) or off (clear) a behavior.
+ *
+ * Some behaviors may read-only (unconditionally absent or present).
+ * If such is the case, return EINVAL in the set-flags operation if the
+ * flag differs from the read-only value.
+ */
+enum ethtool_flags {
+	ETH_FLAG_LRO		= (1 << 15),	/* LRO is enabled */
+};
+
+/* The following structures are for supporting RX network flow
+ * classification configuration. Note, all multibyte fields, e.g.,
+ * ip4src, ip4dst, psrc, pdst, spi, etc. are expected to be in network
+ * byte order.
+ */
+struct ethtool_tcpip4_spec {
+	__be32	ip4src;
+	__be32	ip4dst;
+	__be16	psrc;
+	__be16	pdst;
+	__u8    tos;
+};
+
+struct ethtool_ah_espip4_spec {
+	__be32	ip4src;
+	__be32	ip4dst;
+	__be32	spi;
+	__u8    tos;
+};
+
+struct ethtool_rawip4_spec {
+	__be32	ip4src;
+	__be32	ip4dst;
+	__u8	hdata[64];
+};
+
+struct ethtool_ether_spec {
+	__be16	ether_type;
+	__u8	frame_size;
+	__u8	eframe[16];
+};
+
+#define	ETH_RX_NFC_IP4	1
+#define	ETH_RX_NFC_IP6	2
+
+struct ethtool_usrip4_spec {
+	__be32	ip4src;
+	__be32	ip4dst;
+	__be32	l4_4_bytes;
+	__u8    tos;
+	__u8    ip_ver;
+	__u8    proto;
+};
+
+struct ethtool_rx_flow_spec {
+	__u32		flow_type;
+	union {
+		struct ethtool_tcpip4_spec		tcp_ip4_spec;
+		struct ethtool_tcpip4_spec		udp_ip4_spec;
+		struct ethtool_tcpip4_spec		sctp_ip4_spec;
+		struct ethtool_ah_espip4_spec		ah_ip4_spec;
+		struct ethtool_ah_espip4_spec		esp_ip4_spec;
+		struct ethtool_rawip4_spec		raw_ip4_spec;
+		struct ethtool_ether_spec		ether_spec;
+		struct ethtool_usrip4_spec		usr_ip4_spec;
+		__u8					hdata[64];
+	} h_u, m_u; /* entry, mask */
+	__u64		ring_cookie;
+	__u32		location;
+};
+
+struct ethtool_rxnfc {
+	__u32				cmd;
+	__u32				flow_type;
+	/* The rx flow hash value or the rule DB size */
+	__u64				data;
+	struct ethtool_rx_flow_spec	fs;
+	__u32				rule_cnt;
+	__u32				rule_locs[0];
+};
+
+#define ETHTOOL_FLASH_MAX_FILENAME	128
+enum ethtool_flash_op_type {
+	ETHTOOL_FLASH_ALL_REGIONS	= 0,
+};
+
+/* for passing firmware flashing related parameters */
+struct ethtool_flash {
+	__u32	cmd;
+	__u32	region;
+	char	data[ETHTOOL_FLASH_MAX_FILENAME];
+};
+
+
+/* CMDs currently supported */
+#define ETHTOOL_GSET		0x00000001 /* Get settings. */
+#define ETHTOOL_SSET		0x00000002 /* Set settings. */
+#define ETHTOOL_GDRVINFO	0x00000003 /* Get driver info. */
+#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers. */
+#define ETHTOOL_GWOL		0x00000005 /* Get wake-on-lan options. */
+#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options. */
+#define ETHTOOL_GMSGLVL		0x00000007 /* Get driver message level */
+#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level. */
+#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation. */
+#define ETHTOOL_GLINK		0x0000000a /* Get link status (ethtool_value) */
+#define ETHTOOL_GEEPROM		0x0000000b /* Get EEPROM data */
+#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data. */
+#define ETHTOOL_GCOALESCE	0x0000000e /* Get coalesce config */
+#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config. */
+#define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
+#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters. */
+#define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
+#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters. */
+#define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#define ETHTOOL_STXCSUM		0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
+					    * (ethtool_value) */
+#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
+					    * (ethtool_value). */
+#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test. */
+#define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
+#define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
+#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
+#define ETHTOOL_GTSO		0x0000001e /* Get TSO enable (ethtool_value) */
+#define ETHTOOL_STSO		0x0000001f /* Set TSO enable (ethtool_value) */
+#define ETHTOOL_GPERMADDR	0x00000020 /* Get permanent hardware address */
+#define ETHTOOL_GUFO		0x00000021 /* Get UFO enable (ethtool_value) */
+#define ETHTOOL_SUFO		0x00000022 /* Set UFO enable (ethtool_value) */
+#define ETHTOOL_GGSO		0x00000023 /* Get GSO enable (ethtool_value) */
+#define ETHTOOL_SGSO		0x00000024 /* Set GSO enable (ethtool_value) */
+#define ETHTOOL_GFLAGS		0x00000025 /* Get flags bitmap(ethtool_value) */
+#define ETHTOOL_SFLAGS		0x00000026 /* Set flags bitmap(ethtool_value) */
+#define ETHTOOL_GPFLAGS		0x00000027 /* Get driver-private flags bitmap */
+#define ETHTOOL_SPFLAGS		0x00000028 /* Set driver-private flags bitmap */
+
+#define	ETHTOOL_GRXFH		0x00000029 /* Get RX flow hash configuration */
+#define	ETHTOOL_SRXFH		0x0000002a /* Set RX flow hash configuration */
+#define ETHTOOL_GGRO		0x0000002b /* Get GRO enable (ethtool_value) */
+#define ETHTOOL_SGRO		0x0000002c /* Set GRO enable (ethtool_value) */
+#define	ETHTOOL_GRXRINGS	0x0000002d /* Get RX rings available for LB */
+#define	ETHTOOL_GRXCLSRLCNT	0x0000002e /* Get RX class rule count */
+#define	ETHTOOL_GRXCLSRULE	0x0000002f /* Get RX classification rule */
+#define	ETHTOOL_GRXCLSRLALL	0x00000030 /* Get all RX classification rule */
+#define	ETHTOOL_SRXCLSRLDEL	0x00000031 /* Delete RX classification rule */
+#define	ETHTOOL_SRXCLSRLINS	0x00000032 /* Insert RX classification rule */
+#define	ETHTOOL_FLASHDEV	0x00000033 /* Flash firmware to device */
+
+/* compatibility with older code */
+#define SPARC_ETH_GSET		ETHTOOL_GSET
+#define SPARC_ETH_SSET		ETHTOOL_SSET
+
+/* Indicates what features are supported by the interface. */
+#define SUPPORTED_10baseT_Half		(1 << 0)
+#define SUPPORTED_10baseT_Full		(1 << 1)
+#define SUPPORTED_100baseT_Half		(1 << 2)
+#define SUPPORTED_100baseT_Full		(1 << 3)
+#define SUPPORTED_1000baseT_Half	(1 << 4)
+#define SUPPORTED_1000baseT_Full	(1 << 5)
+#define SUPPORTED_Autoneg		(1 << 6)
+#define SUPPORTED_TP			(1 << 7)
+#define SUPPORTED_AUI			(1 << 8)
+#define SUPPORTED_MII			(1 << 9)
+#define SUPPORTED_FIBRE			(1 << 10)
+#define SUPPORTED_BNC			(1 << 11)
+#define SUPPORTED_10000baseT_Full	(1 << 12)
+#define SUPPORTED_Pause			(1 << 13)
+#define SUPPORTED_Asym_Pause		(1 << 14)
+#define SUPPORTED_2500baseX_Full	(1 << 15)
+#define SUPPORTED_Backplane		(1 << 16)
+#define SUPPORTED_1000baseKX_Full	(1 << 17)
+#define SUPPORTED_10000baseKX4_Full	(1 << 18)
+#define SUPPORTED_10000baseKR_Full	(1 << 19)
+#define SUPPORTED_10000baseR_FEC	(1 << 20)
+
+/* Indicates what features are advertised by the interface. */
+#define ADVERTISED_10baseT_Half		(1 << 0)
+#define ADVERTISED_10baseT_Full		(1 << 1)
+#define ADVERTISED_100baseT_Half	(1 << 2)
+#define ADVERTISED_100baseT_Full	(1 << 3)
+#define ADVERTISED_1000baseT_Half	(1 << 4)
+#define ADVERTISED_1000baseT_Full	(1 << 5)
+#define ADVERTISED_Autoneg		(1 << 6)
+#define ADVERTISED_TP			(1 << 7)
+#define ADVERTISED_AUI			(1 << 8)
+#define ADVERTISED_MII			(1 << 9)
+#define ADVERTISED_FIBRE		(1 << 10)
+#define ADVERTISED_BNC			(1 << 11)
+#define ADVERTISED_10000baseT_Full	(1 << 12)
+#define ADVERTISED_Pause		(1 << 13)
+#define ADVERTISED_Asym_Pause		(1 << 14)
+#define ADVERTISED_2500baseX_Full	(1 << 15)
+#define ADVERTISED_Backplane		(1 << 16)
+#define ADVERTISED_1000baseKX_Full	(1 << 17)
+#define ADVERTISED_10000baseKX4_Full	(1 << 18)
+#define ADVERTISED_10000baseKR_Full	(1 << 19)
+#define ADVERTISED_10000baseR_FEC	(1 << 20)
+
+/* The following are all involved in forcing a particular link
+ * mode for the device for setting things.  When getting the
+ * devices settings, these indicate the current mode and whether
+ * it was foced up into this mode or autonegotiated.
+ */
+
+/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */
+#define SPEED_10		10
+#define SPEED_100		100
+#define SPEED_1000		1000
+#define SPEED_2500		2500
+#define SPEED_10000		10000
+
+/* Duplex, half or full. */
+#define DUPLEX_HALF		0x00
+#define DUPLEX_FULL		0x01
+
+/* Which connector port. */
+#define PORT_TP			0x00
+#define PORT_AUI		0x01
+#define PORT_MII		0x02
+#define PORT_FIBRE		0x03
+#define PORT_BNC		0x04
+#define PORT_OTHER		0xff
+
+/* Which transceiver to use. */
+#define XCVR_INTERNAL		0x00
+#define XCVR_EXTERNAL		0x01
+#define XCVR_DUMMY1		0x02
+#define XCVR_DUMMY2		0x03
+#define XCVR_DUMMY3		0x04
+
+/* Enable or disable autonegotiation.  If this is set to enable,
+ * the forced link modes above are completely ignored.
+ */
+#define AUTONEG_DISABLE		0x00
+#define AUTONEG_ENABLE		0x01
+
+/* Mode MDI or MDI-X */
+#define ETH_TP_MDI_INVALID	0x00
+#define ETH_TP_MDI		0x01
+#define ETH_TP_MDI_X		0x02
+
+/* Wake-On-Lan options. */
+#define WAKE_PHY		(1 << 0)
+#define WAKE_UCAST		(1 << 1)
+#define WAKE_MCAST		(1 << 2)
+#define WAKE_BCAST		(1 << 3)
+#define WAKE_ARP		(1 << 4)
+#define WAKE_MAGIC		(1 << 5)
+#define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */
+
+/* L3-L4 network traffic flow types */
+#define	TCP_V4_FLOW	0x01
+#define	UDP_V4_FLOW	0x02
+#define	SCTP_V4_FLOW	0x03
+#define	AH_ESP_V4_FLOW	0x04
+#define	TCP_V6_FLOW	0x05
+#define	UDP_V6_FLOW	0x06
+#define	SCTP_V6_FLOW	0x07
+#define	AH_ESP_V6_FLOW	0x08
+#define	AH_V4_FLOW	0x09
+#define	ESP_V4_FLOW	0x0a
+#define	AH_V6_FLOW	0x0b
+#define	ESP_V6_FLOW	0x0c
+#define	IP_USER_FLOW	0x0d
+
+/* L3-L4 network traffic flow hash options */
+#define	RXH_L2DA	(1 << 1)
+#define	RXH_VLAN	(1 << 2)
+#define	RXH_L3_PROTO	(1 << 3)
+#define	RXH_IP_SRC	(1 << 4)
+#define	RXH_IP_DST	(1 << 5)
+#define	RXH_L4_B_0_1	(1 << 6) /* src port in case of TCP/UDP/SCTP */
+#define	RXH_L4_B_2_3	(1 << 7) /* dst port in case of TCP/UDP/SCTP */
+#define	RXH_DISCARD	(1 << 31)
+
+#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL
+
+#endif /* _LINUX_ETHTOOL_H */
diff -uNr linux-2.6.32/usr/include/linux/eventpoll.h clean_modified/linux-2.6.32/usr/include/linux/eventpoll.h
--- linux-2.6.32/usr/include/linux/eventpoll.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/eventpoll.h	2019-04-14 13:24:02.959803308 -0500
@@ -0,0 +1,54 @@
+/*
+ *  include/linux/eventpoll.h ( Efficent event polling implementation )
+ *  Copyright (C) 2001,...,2006	 Davide Libenzi
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  Davide Libenzi <davidel@xmailserver.org>
+ *
+ */
+
+#ifndef _LINUX_EVENTPOLL_H
+#define _LINUX_EVENTPOLL_H
+
+/* For O_CLOEXEC */
+#include <linux/fcntl.h>
+#include <linux/types.h>
+
+/* Flags for epoll_create1.  */
+#define EPOLL_CLOEXEC O_CLOEXEC
+
+/* Valid opcodes to issue to sys_epoll_ctl() */
+#define EPOLL_CTL_ADD 1
+#define EPOLL_CTL_DEL 2
+#define EPOLL_CTL_MOD 3
+
+/* Set the One Shot behaviour for the target file descriptor */
+#define EPOLLONESHOT (1 << 30)
+
+/* Set the Edge Triggered behaviour for the target file descriptor */
+#define EPOLLET (1 << 31)
+
+/* 
+ * On x86-64 make the 64bit structure have the same alignment as the
+ * 32bit structure. This makes 32bit emulation easier.
+ *
+ * UML/x86_64 needs the same packing as x86_64
+ */
+#ifdef __x86_64__
+#define EPOLL_PACKED __attribute__((packed))
+#else
+#define EPOLL_PACKED
+#endif
+
+struct epoll_event {
+	__u32 events;
+	__u64 data;
+} EPOLL_PACKED;
+
+
+#endif /* #ifndef _LINUX_EVENTPOLL_H */
+
diff -uNr linux-2.6.32/usr/include/linux/ext2_fs.h clean_modified/linux-2.6.32/usr/include/linux/ext2_fs.h
--- linux-2.6.32/usr/include/linux/ext2_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ext2_fs.h	2019-04-14 13:24:02.960835686 -0500
@@ -0,0 +1,556 @@
+/*
+ *  linux/include/linux/ext2_fs.h
+ *
+ * Copyright (C) 1992, 1993, 1994, 1995
+ * Remy Card (card@masi.ibp.fr)
+ * Laboratoire MASI - Institut Blaise Pascal
+ * Universite Pierre et Marie Curie (Paris VI)
+ *
+ *  from
+ *
+ *  linux/include/linux/minix_fs.h
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#ifndef _LINUX_EXT2_FS_H
+#define _LINUX_EXT2_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/*
+ * The second extended filesystem constants/structures
+ */
+
+/*
+ * Define EXT2FS_DEBUG to produce debug messages
+ */
+#undef EXT2FS_DEBUG
+
+/*
+ * Define EXT2_RESERVATION to reserve data blocks for expanding files
+ */
+#define EXT2_DEFAULT_RESERVE_BLOCKS     8
+/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */
+#define EXT2_MAX_RESERVE_BLOCKS         1027
+#define EXT2_RESERVE_WINDOW_NOT_ALLOCATED 0
+/*
+ * The second extended file system version
+ */
+#define EXT2FS_DATE		"95/08/09"
+#define EXT2FS_VERSION		"0.5b"
+
+/*
+ * Debug code
+ */
+#ifdef EXT2FS_DEBUG
+#	define ext2_debug(f, a...)	{ \
+					printk ("EXT2-fs DEBUG (%s, %d): %s:", \
+						__FILE__, __LINE__, __func__); \
+				  	printk (f, ## a); \
+					}
+#else
+#	define ext2_debug(f, a...)	/**/
+#endif
+
+/*
+ * Special inode numbers
+ */
+#define	EXT2_BAD_INO		 1	/* Bad blocks inode */
+#define EXT2_ROOT_INO		 2	/* Root inode */
+#define EXT2_BOOT_LOADER_INO	 5	/* Boot loader inode */
+#define EXT2_UNDEL_DIR_INO	 6	/* Undelete directory inode */
+
+/* First non-reserved inode for old ext2 filesystems */
+#define EXT2_GOOD_OLD_FIRST_INO	11
+
+/* Assume that user mode programs are passing in an ext2fs superblock, not
+ * a kernel struct super_block.  This will allow us to call the feature-test
+ * macros from user land. */
+#define EXT2_SB(sb)	(sb)
+
+/*
+ * Maximal count of links to a file
+ */
+#define EXT2_LINK_MAX		32000
+
+/*
+ * Macro-instructions used to manage several block sizes
+ */
+#define EXT2_MIN_BLOCK_SIZE		1024
+#define	EXT2_MAX_BLOCK_SIZE		4096
+#define EXT2_MIN_BLOCK_LOG_SIZE		  10
+# define EXT2_BLOCK_SIZE(s)		(EXT2_MIN_BLOCK_SIZE << (s)->s_log_block_size)
+#define	EXT2_ADDR_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (__u32))
+# define EXT2_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
+#define EXT2_INODE_SIZE(s)	(((s)->s_rev_level == EXT2_GOOD_OLD_REV) ? \
+				 EXT2_GOOD_OLD_INODE_SIZE : \
+				 (s)->s_inode_size)
+#define EXT2_FIRST_INO(s)	(((s)->s_rev_level == EXT2_GOOD_OLD_REV) ? \
+				 EXT2_GOOD_OLD_FIRST_INO : \
+				 (s)->s_first_ino)
+
+/*
+ * Macro-instructions used to manage fragments
+ */
+#define EXT2_MIN_FRAG_SIZE		1024
+#define	EXT2_MAX_FRAG_SIZE		4096
+#define EXT2_MIN_FRAG_LOG_SIZE		  10
+# define EXT2_FRAG_SIZE(s)		(EXT2_MIN_FRAG_SIZE << (s)->s_log_frag_size)
+# define EXT2_FRAGS_PER_BLOCK(s)	(EXT2_BLOCK_SIZE(s) / EXT2_FRAG_SIZE(s))
+
+/*
+ * Structure of a blocks group descriptor
+ */
+struct ext2_group_desc
+{
+	__le32	bg_block_bitmap;		/* Blocks bitmap block */
+	__le32	bg_inode_bitmap;		/* Inodes bitmap block */
+	__le32	bg_inode_table;		/* Inodes table block */
+	__le16	bg_free_blocks_count;	/* Free blocks count */
+	__le16	bg_free_inodes_count;	/* Free inodes count */
+	__le16	bg_used_dirs_count;	/* Directories count */
+	__le16	bg_pad;
+	__le32	bg_reserved[3];
+};
+
+/*
+ * Macro-instructions used to manage group descriptors
+ */
+# define EXT2_BLOCKS_PER_GROUP(s)	((s)->s_blocks_per_group)
+# define EXT2_DESC_PER_BLOCK(s)		(EXT2_BLOCK_SIZE(s) / sizeof (struct ext2_group_desc))
+# define EXT2_INODES_PER_GROUP(s)	((s)->s_inodes_per_group)
+
+/*
+ * Constants relative to the data blocks
+ */
+#define	EXT2_NDIR_BLOCKS		12
+#define	EXT2_IND_BLOCK			EXT2_NDIR_BLOCKS
+#define	EXT2_DIND_BLOCK			(EXT2_IND_BLOCK + 1)
+#define	EXT2_TIND_BLOCK			(EXT2_DIND_BLOCK + 1)
+#define	EXT2_N_BLOCKS			(EXT2_TIND_BLOCK + 1)
+
+/*
+ * Inode flags (GETFLAGS/SETFLAGS)
+ */
+#define	EXT2_SECRM_FL			FS_SECRM_FL	/* Secure deletion */
+#define	EXT2_UNRM_FL			FS_UNRM_FL	/* Undelete */
+#define	EXT2_COMPR_FL			FS_COMPR_FL	/* Compress file */
+#define EXT2_SYNC_FL			FS_SYNC_FL	/* Synchronous updates */
+#define EXT2_IMMUTABLE_FL		FS_IMMUTABLE_FL	/* Immutable file */
+#define EXT2_APPEND_FL			FS_APPEND_FL	/* writes to file may only append */
+#define EXT2_NODUMP_FL			FS_NODUMP_FL	/* do not dump file */
+#define EXT2_NOATIME_FL			FS_NOATIME_FL	/* do not update atime */
+/* Reserved for compression usage... */
+#define EXT2_DIRTY_FL			FS_DIRTY_FL
+#define EXT2_COMPRBLK_FL		FS_COMPRBLK_FL	/* One or more compressed clusters */
+#define EXT2_NOCOMP_FL			FS_NOCOMP_FL	/* Don't compress */
+#define EXT2_ECOMPR_FL			FS_ECOMPR_FL	/* Compression error */
+/* End compression flags --- maybe not all used */	
+#define EXT2_BTREE_FL			FS_BTREE_FL	/* btree format dir */
+#define EXT2_INDEX_FL			FS_INDEX_FL	/* hash-indexed directory */
+#define EXT2_IMAGIC_FL			FS_IMAGIC_FL	/* AFS directory */
+#define EXT2_JOURNAL_DATA_FL		FS_JOURNAL_DATA_FL /* Reserved for ext3 */
+#define EXT2_NOTAIL_FL			FS_NOTAIL_FL	/* file tail should not be merged */
+#define EXT2_DIRSYNC_FL			FS_DIRSYNC_FL	/* dirsync behaviour (directories only) */
+#define EXT2_TOPDIR_FL			FS_TOPDIR_FL	/* Top of directory hierarchies*/
+#define EXT2_RESERVED_FL		FS_RESERVED_FL	/* reserved for ext2 lib */
+
+#define EXT2_FL_USER_VISIBLE		FS_FL_USER_VISIBLE	/* User visible flags */
+#define EXT2_FL_USER_MODIFIABLE		FS_FL_USER_MODIFIABLE	/* User modifiable flags */
+
+/* Flags that should be inherited by new inodes from their parent. */
+#define EXT2_FL_INHERITED (EXT2_SECRM_FL | EXT2_UNRM_FL | EXT2_COMPR_FL |\
+			   EXT2_SYNC_FL | EXT2_IMMUTABLE_FL | EXT2_APPEND_FL |\
+			   EXT2_NODUMP_FL | EXT2_NOATIME_FL | EXT2_COMPRBLK_FL|\
+			   EXT2_NOCOMP_FL | EXT2_JOURNAL_DATA_FL |\
+			   EXT2_NOTAIL_FL | EXT2_DIRSYNC_FL)
+
+/* Flags that are appropriate for regular files (all but dir-specific ones). */
+#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))
+
+/* Flags that are appropriate for non-directories/regular files. */
+#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)
+
+/* Mask out flags that are inappropriate for the given type of inode. */
+static __inline__ __u32 ext2_mask_flags(umode_t mode, __u32 flags)
+{
+	if (S_ISDIR(mode))
+		return flags;
+	else if (S_ISREG(mode))
+		return flags & EXT2_REG_FLMASK;
+	else
+		return flags & EXT2_OTHER_FLMASK;
+}
+
+/*
+ * ioctl commands
+ */
+#define	EXT2_IOC_GETFLAGS		FS_IOC_GETFLAGS
+#define	EXT2_IOC_SETFLAGS		FS_IOC_SETFLAGS
+#define	EXT2_IOC_GETVERSION		FS_IOC_GETVERSION
+#define	EXT2_IOC_SETVERSION		FS_IOC_SETVERSION
+#define	EXT2_IOC_GETRSVSZ		_IOR('f', 5, long)
+#define	EXT2_IOC_SETRSVSZ		_IOW('f', 6, long)
+
+/*
+ * ioctl commands in 32 bit emulation
+ */
+#define EXT2_IOC32_GETFLAGS		FS_IOC32_GETFLAGS
+#define EXT2_IOC32_SETFLAGS		FS_IOC32_SETFLAGS
+#define EXT2_IOC32_GETVERSION		FS_IOC32_GETVERSION
+#define EXT2_IOC32_SETVERSION		FS_IOC32_SETVERSION
+
+/*
+ * Structure of an inode on the disk
+ */
+struct ext2_inode {
+	__le16	i_mode;		/* File mode */
+	__le16	i_uid;		/* Low 16 bits of Owner Uid */
+	__le32	i_size;		/* Size in bytes */
+	__le32	i_atime;	/* Access time */
+	__le32	i_ctime;	/* Creation time */
+	__le32	i_mtime;	/* Modification time */
+	__le32	i_dtime;	/* Deletion Time */
+	__le16	i_gid;		/* Low 16 bits of Group Id */
+	__le16	i_links_count;	/* Links count */
+	__le32	i_blocks;	/* Blocks count */
+	__le32	i_flags;	/* File flags */
+	union {
+		struct {
+			__le32  l_i_reserved1;
+		} linux1;
+		struct {
+			__le32  h_i_translator;
+		} hurd1;
+		struct {
+			__le32  m_i_reserved1;
+		} masix1;
+	} osd1;				/* OS dependent 1 */
+	__le32	i_block[EXT2_N_BLOCKS];/* Pointers to blocks */
+	__le32	i_generation;	/* File version (for NFS) */
+	__le32	i_file_acl;	/* File ACL */
+	__le32	i_dir_acl;	/* Directory ACL */
+	__le32	i_faddr;	/* Fragment address */
+	union {
+		struct {
+			__u8	l_i_frag;	/* Fragment number */
+			__u8	l_i_fsize;	/* Fragment size */
+			__u16	i_pad1;
+			__le16	l_i_uid_high;	/* these 2 fields    */
+			__le16	l_i_gid_high;	/* were reserved2[0] */
+			__u32	l_i_reserved2;
+		} linux2;
+		struct {
+			__u8	h_i_frag;	/* Fragment number */
+			__u8	h_i_fsize;	/* Fragment size */
+			__le16	h_i_mode_high;
+			__le16	h_i_uid_high;
+			__le16	h_i_gid_high;
+			__le32	h_i_author;
+		} hurd2;
+		struct {
+			__u8	m_i_frag;	/* Fragment number */
+			__u8	m_i_fsize;	/* Fragment size */
+			__u16	m_pad1;
+			__u32	m_i_reserved2[2];
+		} masix2;
+	} osd2;				/* OS dependent 2 */
+};
+
+#define i_size_high	i_dir_acl
+
+#if defined(__KERNEL__) || defined(__linux__)
+#define i_reserved1	osd1.linux1.l_i_reserved1
+#define i_frag		osd2.linux2.l_i_frag
+#define i_fsize		osd2.linux2.l_i_fsize
+#define i_uid_low	i_uid
+#define i_gid_low	i_gid
+#define i_uid_high	osd2.linux2.l_i_uid_high
+#define i_gid_high	osd2.linux2.l_i_gid_high
+#define i_reserved2	osd2.linux2.l_i_reserved2
+#endif
+
+#ifdef	__hurd__
+#define i_translator	osd1.hurd1.h_i_translator
+#define i_frag		osd2.hurd2.h_i_frag
+#define i_fsize		osd2.hurd2.h_i_fsize
+#define i_uid_high	osd2.hurd2.h_i_uid_high
+#define i_gid_high	osd2.hurd2.h_i_gid_high
+#define i_author	osd2.hurd2.h_i_author
+#endif
+
+#ifdef	__masix__
+#define i_reserved1	osd1.masix1.m_i_reserved1
+#define i_frag		osd2.masix2.m_i_frag
+#define i_fsize		osd2.masix2.m_i_fsize
+#define i_reserved2	osd2.masix2.m_i_reserved2
+#endif
+
+/*
+ * File system states
+ */
+#define	EXT2_VALID_FS			0x0001	/* Unmounted cleanly */
+#define	EXT2_ERROR_FS			0x0002	/* Errors detected */
+
+/*
+ * Mount flags
+ */
+#define EXT2_MOUNT_CHECK		0x000001  /* Do mount-time checks */
+#define EXT2_MOUNT_OLDALLOC		0x000002  /* Don't use the new Orlov allocator */
+#define EXT2_MOUNT_GRPID		0x000004  /* Create files with directory's group */
+#define EXT2_MOUNT_DEBUG		0x000008  /* Some debugging messages */
+#define EXT2_MOUNT_ERRORS_CONT		0x000010  /* Continue on errors */
+#define EXT2_MOUNT_ERRORS_RO		0x000020  /* Remount fs ro on errors */
+#define EXT2_MOUNT_ERRORS_PANIC		0x000040  /* Panic on errors */
+#define EXT2_MOUNT_MINIX_DF		0x000080  /* Mimics the Minix statfs */
+#define EXT2_MOUNT_NOBH			0x000100  /* No buffer_heads */
+#define EXT2_MOUNT_NO_UID32		0x000200  /* Disable 32-bit UIDs */
+#define EXT2_MOUNT_XATTR_USER		0x004000  /* Extended user attributes */
+#define EXT2_MOUNT_POSIX_ACL		0x008000  /* POSIX Access Control Lists */
+#define EXT2_MOUNT_XIP			0x010000  /* Execute in place */
+#define EXT2_MOUNT_USRQUOTA		0x020000  /* user quota */
+#define EXT2_MOUNT_GRPQUOTA		0x040000  /* group quota */
+#define EXT2_MOUNT_RESERVATION		0x080000  /* Preallocation */
+
+
+#define clear_opt(o, opt)		o &= ~EXT2_MOUNT_##opt
+#define set_opt(o, opt)			o |= EXT2_MOUNT_##opt
+#define test_opt(sb, opt)		(EXT2_SB(sb)->s_mount_opt & \
+					 EXT2_MOUNT_##opt)
+/*
+ * Maximal mount counts between two filesystem checks
+ */
+#define EXT2_DFL_MAX_MNT_COUNT		20	/* Allow 20 mounts */
+#define EXT2_DFL_CHECKINTERVAL		0	/* Don't use interval check */
+
+/*
+ * Behaviour when detecting errors
+ */
+#define EXT2_ERRORS_CONTINUE		1	/* Continue execution */
+#define EXT2_ERRORS_RO			2	/* Remount fs read-only */
+#define EXT2_ERRORS_PANIC		3	/* Panic */
+#define EXT2_ERRORS_DEFAULT		EXT2_ERRORS_CONTINUE
+
+/*
+ * Structure of the super block
+ */
+struct ext2_super_block {
+	__le32	s_inodes_count;		/* Inodes count */
+	__le32	s_blocks_count;		/* Blocks count */
+	__le32	s_r_blocks_count;	/* Reserved blocks count */
+	__le32	s_free_blocks_count;	/* Free blocks count */
+	__le32	s_free_inodes_count;	/* Free inodes count */
+	__le32	s_first_data_block;	/* First Data Block */
+	__le32	s_log_block_size;	/* Block size */
+	__le32	s_log_frag_size;	/* Fragment size */
+	__le32	s_blocks_per_group;	/* # Blocks per group */
+	__le32	s_frags_per_group;	/* # Fragments per group */
+	__le32	s_inodes_per_group;	/* # Inodes per group */
+	__le32	s_mtime;		/* Mount time */
+	__le32	s_wtime;		/* Write time */
+	__le16	s_mnt_count;		/* Mount count */
+	__le16	s_max_mnt_count;	/* Maximal mount count */
+	__le16	s_magic;		/* Magic signature */
+	__le16	s_state;		/* File system state */
+	__le16	s_errors;		/* Behaviour when detecting errors */
+	__le16	s_minor_rev_level; 	/* minor revision level */
+	__le32	s_lastcheck;		/* time of last check */
+	__le32	s_checkinterval;	/* max. time between checks */
+	__le32	s_creator_os;		/* OS */
+	__le32	s_rev_level;		/* Revision level */
+	__le16	s_def_resuid;		/* Default uid for reserved blocks */
+	__le16	s_def_resgid;		/* Default gid for reserved blocks */
+	/*
+	 * These fields are for EXT2_DYNAMIC_REV superblocks only.
+	 *
+	 * Note: the difference between the compatible feature set and
+	 * the incompatible feature set is that if there is a bit set
+	 * in the incompatible feature set that the kernel doesn't
+	 * know about, it should refuse to mount the filesystem.
+	 * 
+	 * e2fsck's requirements are more strict; if it doesn't know
+	 * about a feature in either the compatible or incompatible
+	 * feature set, it must abort and not try to meddle with
+	 * things it doesn't understand...
+	 */
+	__le32	s_first_ino; 		/* First non-reserved inode */
+	__le16   s_inode_size; 		/* size of inode structure */
+	__le16	s_block_group_nr; 	/* block group # of this superblock */
+	__le32	s_feature_compat; 	/* compatible feature set */
+	__le32	s_feature_incompat; 	/* incompatible feature set */
+	__le32	s_feature_ro_compat; 	/* readonly-compatible feature set */
+	__u8	s_uuid[16];		/* 128-bit uuid for volume */
+	char	s_volume_name[16]; 	/* volume name */
+	char	s_last_mounted[64]; 	/* directory where last mounted */
+	__le32	s_algorithm_usage_bitmap; /* For compression */
+	/*
+	 * Performance hints.  Directory preallocation should only
+	 * happen if the EXT2_COMPAT_PREALLOC flag is on.
+	 */
+	__u8	s_prealloc_blocks;	/* Nr of blocks to try to preallocate*/
+	__u8	s_prealloc_dir_blocks;	/* Nr to preallocate for dirs */
+	__u16	s_padding1;
+	/*
+	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.
+	 */
+	__u8	s_journal_uuid[16];	/* uuid of journal superblock */
+	__u32	s_journal_inum;		/* inode number of journal file */
+	__u32	s_journal_dev;		/* device number of journal file */
+	__u32	s_last_orphan;		/* start of list of inodes to delete */
+	__u32	s_hash_seed[4];		/* HTREE hash seed */
+	__u8	s_def_hash_version;	/* Default hash version to use */
+	__u8	s_reserved_char_pad;
+	__u16	s_reserved_word_pad;
+	__le32	s_default_mount_opts;
+ 	__le32	s_first_meta_bg; 	/* First metablock block group */
+	__u32	s_reserved[190];	/* Padding to the end of the block */
+};
+
+/*
+ * Codes for operating systems
+ */
+#define EXT2_OS_LINUX		0
+#define EXT2_OS_HURD		1
+#define EXT2_OS_MASIX		2
+#define EXT2_OS_FREEBSD		3
+#define EXT2_OS_LITES		4
+
+/*
+ * Revision levels
+ */
+#define EXT2_GOOD_OLD_REV	0	/* The good old (original) format */
+#define EXT2_DYNAMIC_REV	1 	/* V2 format w/ dynamic inode sizes */
+
+#define EXT2_CURRENT_REV	EXT2_GOOD_OLD_REV
+#define EXT2_MAX_SUPP_REV	EXT2_DYNAMIC_REV
+
+#define EXT2_GOOD_OLD_INODE_SIZE 128
+
+/*
+ * Feature set definitions
+ */
+
+#define EXT2_HAS_COMPAT_FEATURE(sb,mask)			\
+	( EXT2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
+#define EXT2_HAS_RO_COMPAT_FEATURE(sb,mask)			\
+	( EXT2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
+#define EXT2_HAS_INCOMPAT_FEATURE(sb,mask)			\
+	( EXT2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
+#define EXT2_SET_COMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)
+#define EXT2_SET_RO_COMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)
+#define EXT2_SET_INCOMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)
+#define EXT2_CLEAR_COMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)
+#define EXT2_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)
+#define EXT2_CLEAR_INCOMPAT_FEATURE(sb,mask)			\
+	EXT2_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)
+
+#define EXT2_FEATURE_COMPAT_DIR_PREALLOC	0x0001
+#define EXT2_FEATURE_COMPAT_IMAGIC_INODES	0x0002
+#define EXT3_FEATURE_COMPAT_HAS_JOURNAL		0x0004
+#define EXT2_FEATURE_COMPAT_EXT_ATTR		0x0008
+#define EXT2_FEATURE_COMPAT_RESIZE_INO		0x0010
+#define EXT2_FEATURE_COMPAT_DIR_INDEX		0x0020
+#define EXT2_FEATURE_COMPAT_ANY			0xffffffff
+
+#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001
+#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE	0x0002
+#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR	0x0004
+#define EXT2_FEATURE_RO_COMPAT_ANY		0xffffffff
+
+#define EXT2_FEATURE_INCOMPAT_COMPRESSION	0x0001
+#define EXT2_FEATURE_INCOMPAT_FILETYPE		0x0002
+#define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004
+#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008
+#define EXT2_FEATURE_INCOMPAT_META_BG		0x0010
+#define EXT2_FEATURE_INCOMPAT_ANY		0xffffffff
+
+#define EXT2_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR
+#define EXT2_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE| \
+					 EXT2_FEATURE_INCOMPAT_META_BG)
+#define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
+					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
+					 EXT2_FEATURE_RO_COMPAT_BTREE_DIR)
+#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED	~EXT2_FEATURE_RO_COMPAT_SUPP
+#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED	~EXT2_FEATURE_INCOMPAT_SUPP
+
+/*
+ * Default values for user and/or group using reserved blocks
+ */
+#define	EXT2_DEF_RESUID		0
+#define	EXT2_DEF_RESGID		0
+
+/*
+ * Default mount options
+ */
+#define EXT2_DEFM_DEBUG		0x0001
+#define EXT2_DEFM_BSDGROUPS	0x0002
+#define EXT2_DEFM_XATTR_USER	0x0004
+#define EXT2_DEFM_ACL		0x0008
+#define EXT2_DEFM_UID16		0x0010
+    /* Not used by ext2, but reserved for use by ext3 */
+#define EXT3_DEFM_JMODE		0x0060 
+#define EXT3_DEFM_JMODE_DATA	0x0020
+#define EXT3_DEFM_JMODE_ORDERED	0x0040
+#define EXT3_DEFM_JMODE_WBACK	0x0060
+
+/*
+ * Structure of a directory entry
+ */
+#define EXT2_NAME_LEN 255
+
+struct ext2_dir_entry {
+	__le32	inode;			/* Inode number */
+	__le16	rec_len;		/* Directory entry length */
+	__le16	name_len;		/* Name length */
+	char	name[EXT2_NAME_LEN];	/* File name */
+};
+
+/*
+ * The new version of the directory entry.  Since EXT2 structures are
+ * stored in intel byte order, and the name_len field could never be
+ * bigger than 255 chars, it's safe to reclaim the extra byte for the
+ * file_type field.
+ */
+struct ext2_dir_entry_2 {
+	__le32	inode;			/* Inode number */
+	__le16	rec_len;		/* Directory entry length */
+	__u8	name_len;		/* Name length */
+	__u8	file_type;
+	char	name[EXT2_NAME_LEN];	/* File name */
+};
+
+/*
+ * Ext2 directory file types.  Only the low 3 bits are used.  The
+ * other bits are reserved for now.
+ */
+enum {
+	EXT2_FT_UNKNOWN,
+	EXT2_FT_REG_FILE,
+	EXT2_FT_DIR,
+	EXT2_FT_CHRDEV,
+	EXT2_FT_BLKDEV,
+	EXT2_FT_FIFO,
+	EXT2_FT_SOCK,
+	EXT2_FT_SYMLINK,
+	EXT2_FT_MAX
+};
+
+/*
+ * EXT2_DIR_PAD defines the directory entries boundaries
+ *
+ * NOTE: It must be a multiple of 4
+ */
+#define EXT2_DIR_PAD		 	4
+#define EXT2_DIR_ROUND 			(EXT2_DIR_PAD - 1)
+#define EXT2_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT2_DIR_ROUND) & \
+					 ~EXT2_DIR_ROUND)
+#define EXT2_MAX_REC_LEN		((1<<16)-1)
+
+#endif	/* _LINUX_EXT2_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/fadvise.h clean_modified/linux-2.6.32/usr/include/linux/fadvise.h
--- linux-2.6.32/usr/include/linux/fadvise.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fadvise.h	2019-04-14 13:24:02.961851186 -0500
@@ -0,0 +1,21 @@
+#ifndef FADVISE_H_INCLUDED
+#define FADVISE_H_INCLUDED
+
+#define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+#define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+#define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+#define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+
+/*
+ * The advise values for POSIX_FADV_DONTNEED and POSIX_ADV_NOREUSE
+ * for s390-64 differ from the values for the rest of the world.
+ */
+#if defined(__s390x__)
+#define POSIX_FADV_DONTNEED	6 /* Don't need these pages.  */
+#define POSIX_FADV_NOREUSE	7 /* Data will be accessed once.  */
+#else
+#define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+#define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+#endif	/* FADVISE_H_INCLUDED */
diff -uNr linux-2.6.32/usr/include/linux/falloc.h clean_modified/linux-2.6.32/usr/include/linux/falloc.h
--- linux-2.6.32/usr/include/linux/falloc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/falloc.h	2019-04-14 13:24:02.961851186 -0500
@@ -0,0 +1,7 @@
+#ifndef _FALLOC_H_
+#define _FALLOC_H_
+
+#define FALLOC_FL_KEEP_SIZE	0x01 /* default is extend size */
+
+
+#endif /* _FALLOC_H_ */
diff -uNr linux-2.6.32/usr/include/linux/fb.h clean_modified/linux-2.6.32/usr/include/linux/fb.h
--- linux-2.6.32/usr/include/linux/fb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fb.h	2019-04-14 13:24:02.961851186 -0500
@@ -0,0 +1,394 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct dentry;
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 smem_len;			/* Length of frame buffer mem */
+	__u32 type;			/* see FB_TYPE_*		*/
+	__u32 type_aux;			/* Interleave for interleaved Planes */
+	__u32 visual;			/* see FB_VISUAL_*		*/ 
+	__u16 xpanstep;			/* zero if no hardware panning  */
+	__u16 ypanstep;			/* zero if no hardware panning  */
+	__u16 ywrapstep;		/* zero if no hardware ywrap    */
+	__u32 line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	__u32 accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the pallette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	__u32 offset;			/* beginning of bitfield	*/
+	__u32 length;			/* length of bitfield		*/
+	__u32 msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	__u32 xres;			/* visible resolution		*/
+	__u32 yres;
+	__u32 xres_virtual;		/* virtual resolution		*/
+	__u32 yres_virtual;
+	__u32 xoffset;			/* offset from virtual to visible */
+	__u32 yoffset;			/* resolution			*/
+
+	__u32 bits_per_pixel;		/* guess what			*/
+	__u32 grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	__u32 nonstd;			/* != 0 Non standard pixel format */
+
+	__u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	__u32 height;			/* height of picture in mm    */
+	__u32 width;			/* width of picture in mm     */
+
+	__u32 accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	__u32 left_margin;		/* time from sync to picture	*/
+	__u32 right_margin;		/* time from picture to sync	*/
+	__u32 upper_margin;		/* time from sync to picture	*/
+	__u32 lower_margin;
+	__u32 hsync_len;		/* length of horizontal sync	*/
+	__u32 vsync_len;		/* length of vertical sync	*/
+	__u32 sync;			/* see FB_SYNC_*		*/
+	__u32 vmode;			/* see FB_VMODE_*		*/
+	__u32 rotate;			/* angle we rotate counter clockwise */
+	__u32 reserved[5];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 *red;			/* Red values	*/
+	__u16 *green;
+	__u16 *blue;
+	__u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	__u32 console;
+	__u32 framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	__u32 flags;			/* FB_VBLANK flags */
+	__u32 count;			/* counter of retraces since boot */
+	__u32 vcount;			/* current scanline position */
+	__u32 hcount;			/* current scandot position */
+	__u32 reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	__u32 dx;
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 sx;
+	__u32 sy;
+};
+
+struct fb_fillrect {
+	__u32 dx;	/* screen-relative */
+	__u32 dy;
+	__u32 width;
+	__u32 height;
+	__u32 color;
+	__u32 rop;
+};
+
+struct fb_image {
+	__u32 dx;		/* Where to place image */
+	__u32 dy;
+	__u32 width;		/* Size of image */
+	__u32 height;
+	__u32 fg_color;		/* Only used when a mono bitmap */
+	__u32 bg_color;
+	__u8  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	__u16 x, y;
+};
+
+struct fb_cursor {
+	__u16 set;		/* what to set */
+	__u16 enable;		/* cursor on/off */
+	__u16 rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+#ifdef CONFIG_FB_BACKLIGHT
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+#endif
+
+
+#endif /* _LINUX_FB_H */
diff -uNr linux-2.6.32/usr/include/linux/fcntl.h clean_modified/linux-2.6.32/usr/include/linux/fcntl.h
--- linux-2.6.32/usr/include/linux/fcntl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fcntl.h	2019-04-14 13:24:02.961851186 -0500
@@ -0,0 +1,44 @@
+#ifndef _LINUX_FCNTL_H
+#define _LINUX_FCNTL_H
+
+#include <asm/fcntl.h>
+
+#define F_SETLEASE	(F_LINUX_SPECIFIC_BASE + 0)
+#define F_GETLEASE	(F_LINUX_SPECIFIC_BASE + 1)
+
+/*
+ * Cancel a blocking posix lock; internal use only until we expose an
+ * asynchronous lock api to userspace:
+ */
+#define F_CANCELLK	(F_LINUX_SPECIFIC_BASE + 5)
+
+/* Create a file descriptor with FD_CLOEXEC set. */
+#define F_DUPFD_CLOEXEC	(F_LINUX_SPECIFIC_BASE + 6)
+
+/*
+ * Request nofications on a directory.
+ * See below for events that may be notified.
+ */
+#define F_NOTIFY	(F_LINUX_SPECIFIC_BASE+2)
+
+/*
+ * Types of directory notifications that may be requested.
+ */
+#define DN_ACCESS	0x00000001	/* File accessed */
+#define DN_MODIFY	0x00000002	/* File modified */
+#define DN_CREATE	0x00000004	/* File created */
+#define DN_DELETE	0x00000008	/* File removed */
+#define DN_RENAME	0x00000010	/* File renamed */
+#define DN_ATTRIB	0x00000020	/* File changed attibutes */
+#define DN_MULTISHOT	0x80000000	/* Don't remove notifier */
+
+#define AT_FDCWD		-100    /* Special value used to indicate
+                                           openat should use the current
+                                           working directory. */
+#define AT_SYMLINK_NOFOLLOW	0x100   /* Do not follow symbolic links.  */
+#define AT_REMOVEDIR		0x200   /* Remove directory instead of
+                                           unlinking file.  */
+#define AT_SYMLINK_FOLLOW	0x400   /* Follow symbolic links.  */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/fd.h clean_modified/linux-2.6.32/usr/include/linux/fd.h
--- linux-2.6.32/usr/include/linux/fd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fd.h	2019-04-14 13:24:02.963207929 -0500
@@ -0,0 +1,380 @@
+#ifndef _LINUX_FD_H
+#define _LINUX_FD_H
+
+#include <linux/ioctl.h>
+
+
+/* New file layout: Now the ioctl definitions immediately follow the
+ * definitions of the structures that they use */
+
+/*
+ * Geometry
+ */
+struct floppy_struct {
+	unsigned int	size,		/* nr of sectors total */
+			sect,		/* sectors per track */
+			head,		/* nr of heads */
+			track,		/* nr of tracks */
+			stretch;	/* bit 0 !=0 means double track steps */
+					/* bit 1 != 0 means swap sides */
+					/* bits 2..9 give the first sector */
+					/*  number (the LSB is flipped) */
+#define FD_STRETCH 1
+#define FD_SWAPSIDES 2
+#define FD_ZEROBASED 4
+#define FD_SECTBASEMASK 0x3FC
+#define FD_MKSECTBASE(s) (((s) ^ 1) << 2)
+#define FD_SECTBASE(floppy) ((((floppy)->stretch & FD_SECTBASEMASK) >> 2) ^ 1)
+
+	unsigned char	gap,		/* gap1 size */
+
+			rate,		/* data rate. |= 0x40 for perpendicular */
+#define FD_2M 0x4
+#define FD_SIZECODEMASK 0x38
+#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
+#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
+			     512 : 128 << FD_SIZECODE(floppy) )
+#define FD_PERP 0x40
+
+			spec1,		/* stepping rate, head unload time */
+			fmt_gap;	/* gap2 size */
+	const char	* name; /* used only for predefined formats */
+};
+
+
+/* commands needing write access have 0x40 set */
+/* commands needing super user access have 0x80 set */
+
+#define FDCLRPRM _IO(2, 0x41)
+/* clear user-defined parameters */
+
+#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) 
+#define FDSETMEDIAPRM FDSETPRM
+/* set user-defined parameters for current media */
+
+#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) 
+#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
+#define FDDEFMEDIAPRM FDDEFPRM
+#define FDGETMEDIAPRM FDGETPRM
+/* set/get disk parameters */
+
+
+#define	FDMSGON  _IO(2,0x45)
+#define	FDMSGOFF _IO(2,0x46)
+/* issue/don't issue kernel messages on media type change */
+
+
+/* 
+ * Formatting (obsolete)
+ */
+#define FD_FILL_BYTE 0xF6 /* format fill byte. */
+
+struct format_descr {
+	unsigned int device,head,track;
+};
+
+#define FDFMTBEG _IO(2,0x47)
+/* begin formatting a disk */
+#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
+/* format the specified track */
+#define FDFMTEND _IO(2,0x49)
+/* end formatting a disk */
+
+
+/*
+ * Error thresholds
+ */
+struct floppy_max_errors {
+	unsigned int
+	  abort,      /* number of errors to be reached before aborting */
+	  read_track, /* maximal number of errors permitted to read an
+		       * entire track at once */
+	  reset,      /* maximal number of errors before a reset is tried */
+	  recal,      /* maximal number of errors before a recalibrate is
+		       * tried */
+
+	  /*
+	   * Threshold for reporting FDC errors to the console.
+	   * Setting this to zero may flood your screen when using
+	   * ultra cheap floppies ;-)
+	   */
+	  reporting;
+
+};
+
+#define FDSETEMSGTRESH	_IO(2,0x4a)
+/* set fdc error reporting threshold */
+
+#define FDFLUSH  _IO(2,0x4b)
+/* flush buffers for media; either for verifying media, or for
+ * handling a media change without closing the file descriptor */
+
+#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)
+#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)
+/* set/get abortion and read_track threshold. See also floppy_drive_params
+ * structure */
+
+
+typedef char floppy_drive_name[16];
+#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)
+/* get drive type: 5 1/4 or 3 1/2 */
+
+
+/*
+ * Drive parameters (user modifiable)
+ */
+struct floppy_drive_params {
+	signed char cmos;		/* CMOS type */
+	
+	/* Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms 
+	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
+	 */
+	unsigned long max_dtr;		/* Step rate, usec */
+	unsigned long hlt;     		/* Head load/settle time, msec */
+	unsigned long hut;     		/* Head unload time (remnant of 
+					 * 8" drives) */
+	unsigned long srt;     		/* Step rate, usec */
+
+	unsigned long spinup;		/* time needed for spinup (expressed
+					 * in jiffies) */
+	unsigned long spindown;		/* timeout needed for spindown */
+	unsigned char spindown_offset;	/* decides in which position the disk
+					 * will stop */
+	unsigned char select_delay;	/* delay to wait after select */
+	unsigned char rps;		/* rotations per second */
+	unsigned char tracks;		/* maximum number of tracks */
+	unsigned long timeout;		/* timeout for interrupt requests */
+	
+	unsigned char interleave_sect;	/* if there are more sectors, use 
+					 * interleave */
+	
+	struct floppy_max_errors max_errors;
+	
+	char flags;			/* various flags, including ftd_msg */
+/*
+ * Announce successful media type detection and media information loss after
+ * disk changes.
+ * Also used to enable/disable printing of overrun warnings.
+ */
+
+#define FTD_MSG 0x10
+#define FD_BROKEN_DCL 0x20
+#define FD_DEBUG 0x02
+#define FD_SILENT_DCL_CLEAR 0x4
+#define FD_INVERTED_DCL 0x80 /* must be 0x80, because of hardware 
+				considerations */
+
+	char read_track;		/* use readtrack during probing? */
+
+/*
+ * Auto-detection. Each drive type has eight formats which are
+ * used in succession to try to read the disk. If the FDC cannot lock onto
+ * the disk, the next format is tried. This uses the variable 'probing'.
+ */
+	short autodetect[8];		/* autodetected formats */
+	
+	int checkfreq; /* how often should the drive be checked for disk 
+			* changes */
+	int native_format; /* native format of this drive */
+};
+
+enum {
+	FD_NEED_TWADDLE_BIT,	/* more magic */
+	FD_VERIFY_BIT,		/* inquire for write protection */
+	FD_DISK_NEWCHANGE_BIT,	/* change detected, and no action undertaken yet
+				 * to clear media change status */
+	FD_UNUSED_BIT,
+	FD_DISK_CHANGED_BIT,	/* disk has been changed since last i/o */
+	FD_DISK_WRITABLE_BIT	/* disk is writable */
+};
+
+#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)
+#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)
+/* set/get drive parameters */
+
+
+/*
+ * Current drive state (not directly modifiable by user, readonly)
+ */
+struct floppy_drive_struct {
+	unsigned long flags;
+/* values for these flags */
+#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)
+#define FD_VERIFY (1 << FD_VERIFY_BIT)
+#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)
+#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)
+#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)
+
+	unsigned long spinup_date;
+	unsigned long select_date;
+	unsigned long first_read_date;
+	short probed_format;
+	short track; /* current track */
+	short maxblock; /* id of highest block read */
+	short maxtrack; /* id of highest half track read */
+	int generation; /* how many diskchanges? */
+
+/*
+ * (User-provided) media information is _not_ discarded after a media change
+ * if the corresponding keep_data flag is non-zero. Positive values are
+ * decremented after each probe.
+ */
+	int keep_data;
+	
+	/* Prevent "aliased" accesses. */
+	int fd_ref;
+	int fd_device;
+	unsigned long last_checked; /* when was the drive last checked for a disk 
+			   * change? */
+	
+	char *dmabuf;
+	int bufblocks;
+};
+
+#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)
+#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)
+/* get drive state: GET returns the cached state, POLL polls for new state */
+
+
+/*
+ * reset FDC
+ */
+enum reset_mode {
+	FD_RESET_IF_NEEDED,	/* reset only if the reset flags is set */
+	FD_RESET_IF_RAWCMD,	/* obsolete */
+	FD_RESET_ALWAYS		/* reset always */
+};
+#define FDRESET _IO(2, 0x54)
+
+
+/*
+ * FDC state
+ */
+struct floppy_fdc_state {	
+	int spec1;		/* spec1 value last used */
+	int spec2;		/* spec2 value last used */
+	int dtr;
+	unsigned char version;	/* FDC version code */
+	unsigned char dor;
+	unsigned long address;	/* io address */
+	unsigned int rawcmd:2;
+	unsigned int reset:1;
+	unsigned int need_configure:1;
+	unsigned int perp_mode:2;
+	unsigned int has_fifo:1;
+	unsigned int driver_version;	/* version code for floppy driver */
+#define FD_DRIVER_VERSION 0x100
+/* user programs using the floppy API should use floppy_fdc_state to
+ * get the version number of the floppy driver that they are running
+ * on. If this version number is bigger than the one compiled into the
+ * user program (the FD_DRIVER_VERSION define), it should be prepared
+ * to bigger structures
+ */
+
+	unsigned char track[4];
+	/* Position of the heads of the 4 units attached to this FDC,
+	 * as stored on the FDC. In the future, the position as stored
+	 * on the FDC might not agree with the actual physical
+	 * position of these drive heads. By allowing such
+	 * disagreement, it will be possible to reset the FDC without
+	 * incurring the expensive cost of repositioning all heads.
+	 * Right now, these positions are hard wired to 0. */
+
+};
+
+#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)
+
+
+/*
+ * Asynchronous Write error tracking
+ */
+struct floppy_write_errors {
+	/* Write error logging.
+	 *
+	 * These fields can be cleared with the FDWERRORCLR ioctl.
+	 * Only writes that were attempted but failed due to a physical media
+	 * error are logged.  write(2) calls that fail and return an error code
+	 * to the user process are not counted.
+	 */
+
+	unsigned int write_errors;  /* number of physical write errors 
+				     * encountered */
+	
+	/* position of first and last write errors */
+	unsigned long first_error_sector;
+	int           first_error_generation;
+	unsigned long last_error_sector;
+	int           last_error_generation;
+	
+	unsigned int badness; /* highest retry count for a read or write 
+			       * operation */
+};
+
+#define FDWERRORCLR  _IO(2, 0x56)
+/* clear write error and badness information */
+#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)
+/* get write error and badness information */
+
+
+/*
+ * Raw commands
+ */
+/* new interface flag: now we can do them in batches */
+#define FDHAVEBATCHEDRAWCMD
+
+struct floppy_raw_cmd {
+	unsigned int flags;
+#define FD_RAW_READ 1
+#define FD_RAW_WRITE 2
+#define FD_RAW_NO_MOTOR 4
+#define FD_RAW_DISK_CHANGE 4 /* out: disk change flag was set */
+#define FD_RAW_INTR 8    /* wait for an interrupt */
+#define FD_RAW_SPIN 0x10 /* spin up the disk for this command */
+#define FD_RAW_NO_MOTOR_AFTER 0x20 /* switch the motor off after command 
+				    * completion */
+#define FD_RAW_NEED_DISK 0x40  /* this command needs a disk to be present */
+#define FD_RAW_NEED_SEEK 0x80  /* this command uses an implied seek (soft) */
+
+/* more "in" flags */
+#define FD_RAW_MORE 0x100  /* more records follow */
+#define FD_RAW_STOP_IF_FAILURE 0x200 /* stop if we encounter a failure */
+#define FD_RAW_STOP_IF_SUCCESS 0x400 /* stop if command successful */
+#define FD_RAW_SOFTFAILURE 0x800 /* consider the return value for failure
+				  * detection too */
+
+/* more "out" flags */
+#define FD_RAW_FAILURE 0x10000 /* command sent to fdc, fdc returned error */
+#define FD_RAW_HARDFAILURE 0x20000 /* fdc had to be reset, or timed out */
+
+	void *data;
+	char *kernel_data; /* location of data buffer in the kernel */
+	struct floppy_raw_cmd *next; /* used for chaining of raw cmd's 
+				      * within the kernel */
+	long length; /* in: length of dma transfer. out: remaining bytes */
+	long phys_length; /* physical length, if different from dma length */
+	int buffer_length; /* length of allocated buffer */
+
+	unsigned char rate;
+	unsigned char cmd_count;
+	unsigned char cmd[16];
+	unsigned char reply_count;
+	unsigned char reply[16];
+	int track;
+	int resultcode;
+
+	int reserved1;
+	int reserved2;
+};
+
+#define FDRAWCMD _IO(2, 0x58)
+/* send a raw command to the fdc. Structure size not included, because of
+ * batches */
+
+#define FDTWADDLE _IO(2, 0x59)
+/* flicker motor-on bit before reading a sector. Experimental */
+
+
+#define FDEJECT _IO(2, 0x5a)
+/* eject the disk */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/fdreg.h clean_modified/linux-2.6.32/usr/include/linux/fdreg.h
--- linux-2.6.32/usr/include/linux/fdreg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fdreg.h	2019-04-14 13:24:02.964189116 -0500
@@ -0,0 +1,137 @@
+#ifndef _LINUX_FDREG_H
+#define _LINUX_FDREG_H
+/*
+ * This file contains some defines for the floppy disk controller.
+ * Various sources. Mostly "IBM Microcomputers: A Programmers
+ * Handbook", Sanches and Canton.
+ */
+
+#ifdef FDPATCHES
+#define FD_IOPORT fdc_state[fdc].address
+#else
+/* It would be a lot saner just to force fdc_state[fdc].address to always
+   be set ! FIXME */
+#define FD_IOPORT 0x3f0
+#endif
+
+/* Fd controller regs. S&C, about page 340 */
+#define FD_STATUS	(4 + FD_IOPORT )
+#define FD_DATA		(5 + FD_IOPORT )
+
+/* Digital Output Register */
+#define FD_DOR		(2 + FD_IOPORT )
+
+/* Digital Input Register (read) */
+#define FD_DIR		(7 + FD_IOPORT )
+
+/* Diskette Control Register (write)*/
+#define FD_DCR		(7 + FD_IOPORT )
+
+/* Bits of main status register */
+#define STATUS_BUSYMASK	0x0F		/* drive busy mask */
+#define STATUS_BUSY	0x10		/* FDC busy */
+#define STATUS_DMA	0x20		/* 0- DMA mode */
+#define STATUS_DIR	0x40		/* 0- cpu->fdc */
+#define STATUS_READY	0x80		/* Data reg ready */
+
+/* Bits of FD_ST0 */
+#define ST0_DS		0x03		/* drive select mask */
+#define ST0_HA		0x04		/* Head (Address) */
+#define ST0_NR		0x08		/* Not Ready */
+#define ST0_ECE		0x10		/* Equipment check error */
+#define ST0_SE		0x20		/* Seek end */
+#define ST0_INTR	0xC0		/* Interrupt code mask */
+
+/* Bits of FD_ST1 */
+#define ST1_MAM		0x01		/* Missing Address Mark */
+#define ST1_WP		0x02		/* Write Protect */
+#define ST1_ND		0x04		/* No Data - unreadable */
+#define ST1_OR		0x10		/* OverRun */
+#define ST1_CRC		0x20		/* CRC error in data or addr */
+#define ST1_EOC		0x80		/* End Of Cylinder */
+
+/* Bits of FD_ST2 */
+#define ST2_MAM		0x01		/* Missing Address Mark (again) */
+#define ST2_BC		0x02		/* Bad Cylinder */
+#define ST2_SNS		0x04		/* Scan Not Satisfied */
+#define ST2_SEH		0x08		/* Scan Equal Hit */
+#define ST2_WC		0x10		/* Wrong Cylinder */
+#define ST2_CRC		0x20		/* CRC error in data field */
+#define ST2_CM		0x40		/* Control Mark = deleted */
+
+/* Bits of FD_ST3 */
+#define ST3_HA		0x04		/* Head (Address) */
+#define ST3_DS		0x08		/* drive is double-sided */
+#define ST3_TZ		0x10		/* Track Zero signal (1=track 0) */
+#define ST3_RY		0x20		/* drive is ready */
+#define ST3_WP		0x40		/* Write Protect */
+#define ST3_FT		0x80		/* Drive Fault */
+
+/* Values for FD_COMMAND */
+#define FD_RECALIBRATE		0x07	/* move to track 0 */
+#define FD_SEEK			0x0F	/* seek track */
+#define FD_READ			0xE6	/* read with MT, MFM, SKip deleted */
+#define FD_WRITE		0xC5	/* write with MT, MFM */
+#define FD_SENSEI		0x08	/* Sense Interrupt Status */
+#define FD_SPECIFY		0x03	/* specify HUT etc */
+#define FD_FORMAT		0x4D	/* format one track */
+#define FD_VERSION		0x10	/* get version code */
+#define FD_CONFIGURE		0x13	/* configure FIFO operation */
+#define FD_PERPENDICULAR	0x12	/* perpendicular r/w mode */
+#define FD_GETSTATUS		0x04	/* read ST3 */
+#define FD_DUMPREGS		0x0E	/* dump the contents of the fdc regs */
+#define FD_READID		0xEA	/* prints the header of a sector */
+#define FD_UNLOCK		0x14	/* Fifo config unlock */
+#define FD_LOCK			0x94	/* Fifo config lock */
+#define FD_RSEEK_OUT		0x8f	/* seek out (i.e. to lower tracks) */
+#define FD_RSEEK_IN		0xcf	/* seek in (i.e. to higher tracks) */
+
+/* the following commands are new in the 82078. They are not used in the
+ * floppy driver, except the first three. These commands may be useful for apps
+ * which use the FDRAWCMD interface. For doc, get the 82078 spec sheets at
+ * http://www-techdoc.intel.com/docs/periph/fd_contr/datasheets/ */
+
+#define FD_PARTID		0x18	/* part id ("extended" version cmd) */
+#define FD_SAVE			0x2e	/* save fdc regs for later restore */
+#define FD_DRIVESPEC		0x8e	/* drive specification: Access to the
+					 * 2 Mbps data transfer rate for tape
+					 * drives */
+
+#define FD_RESTORE		0x4e    /* later restore */
+#define FD_POWERDOWN		0x27	/* configure FDC's powersave features */
+#define FD_FORMAT_N_WRITE	0xef    /* format and write in one go. */
+#define FD_OPTION		0x33	/* ISO format (which is a clean way to
+					 * pack more sectors on a track) */
+
+/* DMA commands */
+#define DMA_READ	0x46
+#define DMA_WRITE	0x4A
+
+/* FDC version return types */
+#define FDC_NONE	0x00
+#define FDC_UNKNOWN	0x10	/* DO NOT USE THIS TYPE EXCEPT IF IDENTIFICATION
+				   FAILS EARLY */
+#define FDC_8272A	0x20	/* Intel 8272a, NEC 765 */
+#define FDC_765ED	0x30	/* Non-Intel 1MB-compatible FDC, can't detect */
+#define FDC_82072	0x40	/* Intel 82072; 8272a + FIFO + DUMPREGS */
+#define FDC_82072A	0x45	/* 82072A (on Sparcs) */
+#define FDC_82077_ORIG	0x51	/* Original version of 82077AA, sans LOCK */
+#define FDC_82077	0x52	/* 82077AA-1 */
+#define FDC_82078_UNKN	0x5f	/* Unknown 82078 variant */
+#define FDC_82078	0x60	/* 44pin 82078 or 64pin 82078SL */
+#define FDC_82078_1	0x61	/* 82078-1 (2Mbps fdc) */
+#define FDC_S82078B	0x62	/* S82078B (first seen on Adaptec AVA-2825 VLB
+				 * SCSI/EIDE/Floppy controller) */
+#define FDC_87306	0x63	/* National Semiconductor PC 87306 */
+
+/*
+ * Beware: the fdc type list is roughly sorted by increasing features.
+ * Presence of features is tested by comparing the FDC version id with the
+ * "oldest" version that has the needed feature.
+ * If during FDC detection, an obscure test fails late in the sequence, don't
+ * assign FDC_UNKNOWN. Else the FDC will be treated as a dumb 8272a, or worse.
+ * This is especially true if the tests are unneeded.
+ */
+
+#define FD_RESET_DELAY 20
+#endif
diff -uNr linux-2.6.32/usr/include/linux/fib_rules.h clean_modified/linux-2.6.32/usr/include/linux/fib_rules.h
--- linux-2.6.32/usr/include/linux/fib_rules.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fib_rules.h	2019-04-14 13:24:02.964189116 -0500
@@ -0,0 +1,71 @@
+#ifndef __LINUX_FIB_RULES_H
+#define __LINUX_FIB_RULES_H
+
+#include <linux/types.h>
+#include <linux/rtnetlink.h>
+
+/* rule is permanent, and cannot be deleted */
+#define FIB_RULE_PERMANENT	0x00000001
+#define FIB_RULE_INVERT		0x00000002
+#define FIB_RULE_UNRESOLVED	0x00000004
+#define FIB_RULE_DEV_DETACHED	0x00000008
+
+/* try to find source address in routing lookups */
+#define FIB_RULE_FIND_SADDR	0x00010000
+
+struct fib_rule_hdr
+{
+	__u8		family;
+	__u8		dst_len;
+	__u8		src_len;
+	__u8		tos;
+
+	__u8		table;
+	__u8		res1;	/* reserved */
+	__u8		res2;	/* reserved */
+	__u8		action;
+
+	__u32		flags;
+};
+
+enum
+{
+	FRA_UNSPEC,
+	FRA_DST,	/* destination address */
+	FRA_SRC,	/* source address */
+	FRA_IFNAME,	/* interface name */
+	FRA_GOTO,	/* target to jump to (FR_ACT_GOTO) */
+	FRA_UNUSED2,
+	FRA_PRIORITY,	/* priority/preference */
+	FRA_UNUSED3,
+	FRA_UNUSED4,
+	FRA_UNUSED5,
+	FRA_FWMARK,	/* mark */
+	FRA_FLOW,	/* flow/class id */
+	FRA_UNUSED6,
+	FRA_UNUSED7,
+	FRA_UNUSED8,
+	FRA_TABLE,	/* Extended table id */
+	FRA_FWMASK,	/* mask for netfilter mark */
+	__FRA_MAX
+};
+
+#define FRA_MAX (__FRA_MAX - 1)
+
+enum
+{
+	FR_ACT_UNSPEC,
+	FR_ACT_TO_TBL,		/* Pass to fixed table */
+	FR_ACT_GOTO,		/* Jump to another rule */
+	FR_ACT_NOP,		/* No operation */
+	FR_ACT_RES3,
+	FR_ACT_RES4,
+	FR_ACT_BLACKHOLE,	/* Drop without notification */
+	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
+	FR_ACT_PROHIBIT,	/* Drop with EACCES */
+	__FR_ACT_MAX,
+};
+
+#define FR_ACT_MAX (__FR_ACT_MAX - 1)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/fiemap.h clean_modified/linux-2.6.32/usr/include/linux/fiemap.h
--- linux-2.6.32/usr/include/linux/fiemap.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fiemap.h	2019-04-14 13:24:02.964189116 -0500
@@ -0,0 +1,66 @@
+/*
+ * FS_IOC_FIEMAP ioctl infrastructure.
+ *
+ * Some portions copyright (C) 2007 Cluster File Systems, Inc
+ *
+ * Authors: Mark Fasheh <mfasheh@suse.com>
+ *          Kalpak Shah <kalpak.shah@sun.com>
+ *          Andreas Dilger <adilger@sun.com>
+ */
+
+#ifndef _LINUX_FIEMAP_H
+#define _LINUX_FIEMAP_H
+
+#include <linux/types.h>
+
+struct fiemap_extent {
+	__u64 fe_logical;  /* logical offset in bytes for the start of
+			    * the extent from the beginning of the file */
+	__u64 fe_physical; /* physical offset in bytes for the start
+			    * of the extent from the beginning of the disk */
+	__u64 fe_length;   /* length in bytes for this extent */
+	__u64 fe_reserved64[2];
+	__u32 fe_flags;    /* FIEMAP_EXTENT_* flags for this extent */
+	__u32 fe_reserved[3];
+};
+
+struct fiemap {
+	__u64 fm_start;		/* logical offset (inclusive) at
+				 * which to start mapping (in) */
+	__u64 fm_length;	/* logical length of mapping which
+				 * userspace wants (in) */
+	__u32 fm_flags;		/* FIEMAP_FLAG_* flags for request (in/out) */
+	__u32 fm_mapped_extents;/* number of extents that were mapped (out) */
+	__u32 fm_extent_count;  /* size of fm_extents array (in) */
+	__u32 fm_reserved;
+	struct fiemap_extent fm_extents[0]; /* array of mapped extents (out) */
+};
+
+#define FIEMAP_MAX_OFFSET	(~0ULL)
+
+#define FIEMAP_FLAG_SYNC	0x00000001 /* sync file data before map */
+#define FIEMAP_FLAG_XATTR	0x00000002 /* map extended attribute tree */
+
+#define FIEMAP_FLAGS_COMPAT	(FIEMAP_FLAG_SYNC | FIEMAP_FLAG_XATTR)
+
+#define FIEMAP_EXTENT_LAST		0x00000001 /* Last extent in file. */
+#define FIEMAP_EXTENT_UNKNOWN		0x00000002 /* Data location unknown. */
+#define FIEMAP_EXTENT_DELALLOC		0x00000004 /* Location still pending.
+						    * Sets EXTENT_UNKNOWN. */
+#define FIEMAP_EXTENT_ENCODED		0x00000008 /* Data can not be read
+						    * while fs is unmounted */
+#define FIEMAP_EXTENT_DATA_ENCRYPTED	0x00000080 /* Data is encrypted by fs.
+						    * Sets EXTENT_NO_BYPASS. */
+#define FIEMAP_EXTENT_NOT_ALIGNED	0x00000100 /* Extent offsets may not be
+						    * block aligned. */
+#define FIEMAP_EXTENT_DATA_INLINE	0x00000200 /* Data mixed with metadata.
+						    * Sets EXTENT_NOT_ALIGNED.*/
+#define FIEMAP_EXTENT_DATA_TAIL		0x00000400 /* Multiple files in block.
+						    * Sets EXTENT_NOT_ALIGNED.*/
+#define FIEMAP_EXTENT_UNWRITTEN		0x00000800 /* Space allocated, but
+						    * no data (i.e. zero). */
+#define FIEMAP_EXTENT_MERGED		0x00001000 /* File does not natively
+						    * support extents. Result
+						    * merged for efficiency. */
+
+#endif /* _LINUX_FIEMAP_H */
diff -uNr linux-2.6.32/usr/include/linux/filter.h clean_modified/linux-2.6.32/usr/include/linux/filter.h
--- linux-2.6.32/usr/include/linux/filter.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/filter.h	2019-04-14 13:24:02.964189116 -0500
@@ -0,0 +1,128 @@
+/*
+ * Linux Socket Filter Data Structures
+ */
+
+#ifndef __LINUX_FILTER_H__
+#define __LINUX_FILTER_H__
+
+
+#include <linux/types.h>
+
+
+/*
+ * Current version of the filter code architecture.
+ */
+#define BPF_MAJOR_VERSION 1
+#define BPF_MINOR_VERSION 1
+
+/*
+ *	Try and keep these values and structures similar to BSD, especially
+ *	the BPF code definitions which need to match so you can share filters
+ */
+ 
+struct sock_filter	/* Filter block */
+{
+	__u16	code;   /* Actual filter code */
+	__u8	jt;	/* Jump true */
+	__u8	jf;	/* Jump false */
+	__u32	k;      /* Generic multiuse field */
+};
+
+struct sock_fprog	/* Required for SO_ATTACH_FILTER. */
+{
+	unsigned short		len;	/* Number of filter blocks */
+	struct sock_filter *filter;
+};
+
+/*
+ * Instruction classes
+ */
+
+#define BPF_CLASS(code) ((code) & 0x07)
+#define         BPF_LD          0x00
+#define         BPF_LDX         0x01
+#define         BPF_ST          0x02
+#define         BPF_STX         0x03
+#define         BPF_ALU         0x04
+#define         BPF_JMP         0x05
+#define         BPF_RET         0x06
+#define         BPF_MISC        0x07
+
+/* ld/ldx fields */
+#define BPF_SIZE(code)  ((code) & 0x18)
+#define         BPF_W           0x00
+#define         BPF_H           0x08
+#define         BPF_B           0x10
+#define BPF_MODE(code)  ((code) & 0xe0)
+#define         BPF_IMM         0x00
+#define         BPF_ABS         0x20
+#define         BPF_IND         0x40
+#define         BPF_MEM         0x60
+#define         BPF_LEN         0x80
+#define         BPF_MSH         0xa0
+
+/* alu/jmp fields */
+#define BPF_OP(code)    ((code) & 0xf0)
+#define         BPF_ADD         0x00
+#define         BPF_SUB         0x10
+#define         BPF_MUL         0x20
+#define         BPF_DIV         0x30
+#define         BPF_OR          0x40
+#define         BPF_AND         0x50
+#define         BPF_LSH         0x60
+#define         BPF_RSH         0x70
+#define         BPF_NEG         0x80
+#define         BPF_JA          0x00
+#define         BPF_JEQ         0x10
+#define         BPF_JGT         0x20
+#define         BPF_JGE         0x30
+#define         BPF_JSET        0x40
+#define BPF_SRC(code)   ((code) & 0x08)
+#define         BPF_K           0x00
+#define         BPF_X           0x08
+
+/* ret - BPF_K and BPF_X also apply */
+#define BPF_RVAL(code)  ((code) & 0x18)
+#define         BPF_A           0x10
+
+/* misc */
+#define BPF_MISCOP(code) ((code) & 0xf8)
+#define         BPF_TAX         0x00
+#define         BPF_TXA         0x80
+
+#ifndef BPF_MAXINSNS
+#define BPF_MAXINSNS 4096
+#endif
+
+/*
+ * Macros for filter block array initializers.
+ */
+#ifndef BPF_STMT
+#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
+#endif
+#ifndef BPF_JUMP
+#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
+#endif
+
+/*
+ * Number of scratch memory words for: BPF_ST and BPF_STX
+ */
+#define BPF_MEMWORDS 16
+
+/* RATIONALE. Negative offsets are invalid in BPF.
+   We use them to reference ancillary data.
+   Unlike introduction new instructions, it does not break
+   existing compilers/optimizers.
+ */
+#define SKF_AD_OFF    (-0x1000)
+#define SKF_AD_PROTOCOL 0
+#define SKF_AD_PKTTYPE 	4
+#define SKF_AD_IFINDEX 	8
+#define SKF_AD_NLATTR	12
+#define SKF_AD_NLATTR_NEST	16
+#define SKF_AD_MAX	20
+#define SKF_NET_OFF   (-0x100000)
+#define SKF_LL_OFF    (-0x200000)
+
+
+#endif /* __LINUX_FILTER_H__ */
diff -uNr linux-2.6.32/usr/include/linux/firewire-cdev.h clean_modified/linux-2.6.32/usr/include/linux/firewire-cdev.h
--- linux-2.6.32/usr/include/linux/firewire-cdev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/firewire-cdev.h	2019-04-14 13:24:02.966137008 -0500
@@ -0,0 +1,634 @@
+/*
+ * Char device interface.
+ *
+ * Copyright (C) 2005-2006  Kristian Hoegsberg <krh@bitplanet.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LINUX_FIREWIRE_CDEV_H
+#define _LINUX_FIREWIRE_CDEV_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/firewire-constants.h>
+
+#define FW_CDEV_EVENT_BUS_RESET			0x00
+#define FW_CDEV_EVENT_RESPONSE			0x01
+#define FW_CDEV_EVENT_REQUEST			0x02
+#define FW_CDEV_EVENT_ISO_INTERRUPT		0x03
+#define FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED	0x04
+#define FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED	0x05
+
+/**
+ * struct fw_cdev_event_common - Common part of all fw_cdev_event_ types
+ * @closure:	For arbitrary use by userspace
+ * @type:	Discriminates the fw_cdev_event_ types
+ *
+ * This struct may be used to access generic members of all fw_cdev_event_
+ * types regardless of the specific type.
+ *
+ * Data passed in the @closure field for a request will be returned in the
+ * corresponding event.  It is big enough to hold a pointer on all platforms.
+ * The ioctl used to set @closure depends on the @type of event.
+ */
+struct fw_cdev_event_common {
+	__u64 closure;
+	__u32 type;
+};
+
+/**
+ * struct fw_cdev_event_bus_reset - Sent when a bus reset occurred
+ * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_GET_INFO ioctl
+ * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_BUS_RESET
+ * @node_id:       New node ID of this node
+ * @local_node_id: Node ID of the local node, i.e. of the controller
+ * @bm_node_id:    Node ID of the bus manager
+ * @irm_node_id:   Node ID of the iso resource manager
+ * @root_node_id:  Node ID of the root node
+ * @generation:    New bus generation
+ *
+ * This event is sent when the bus the device belongs to goes through a bus
+ * reset.  It provides information about the new bus configuration, such as
+ * new node ID for this device, new root ID, and others.
+ */
+struct fw_cdev_event_bus_reset {
+	__u64 closure;
+	__u32 type;
+	__u32 node_id;
+	__u32 local_node_id;
+	__u32 bm_node_id;
+	__u32 irm_node_id;
+	__u32 root_node_id;
+	__u32 generation;
+};
+
+/**
+ * struct fw_cdev_event_response - Sent when a response packet was received
+ * @closure:	See &fw_cdev_event_common;
+ *		set by %FW_CDEV_IOC_SEND_REQUEST ioctl
+ * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_RESPONSE
+ * @rcode:	Response code returned by the remote node
+ * @length:	Data length, i.e. the response's payload size in bytes
+ * @data:	Payload data, if any
+ *
+ * This event is sent when the stack receives a response to an outgoing request
+ * sent by %FW_CDEV_IOC_SEND_REQUEST ioctl.  The payload data for responses
+ * carrying data (read and lock responses) follows immediately and can be
+ * accessed through the @data field.
+ */
+struct fw_cdev_event_response {
+	__u64 closure;
+	__u32 type;
+	__u32 rcode;
+	__u32 length;
+	__u32 data[0];
+};
+
+/**
+ * struct fw_cdev_event_request - Sent on incoming request to an address region
+ * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_ALLOCATE ioctl
+ * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST
+ * @tcode:	Transaction code of the incoming request
+ * @offset:	The offset into the 48-bit per-node address space
+ * @handle:	Reference to the kernel-side pending request
+ * @length:	Data length, i.e. the request's payload size in bytes
+ * @data:	Incoming data, if any
+ *
+ * This event is sent when the stack receives an incoming request to an address
+ * region registered using the %FW_CDEV_IOC_ALLOCATE ioctl.  The request is
+ * guaranteed to be completely contained in the specified region.  Userspace is
+ * responsible for sending the response by %FW_CDEV_IOC_SEND_RESPONSE ioctl,
+ * using the same @handle.
+ *
+ * The payload data for requests carrying data (write and lock requests)
+ * follows immediately and can be accessed through the @data field.
+ */
+struct fw_cdev_event_request {
+	__u64 closure;
+	__u32 type;
+	__u32 tcode;
+	__u64 offset;
+	__u32 handle;
+	__u32 length;
+	__u32 data[0];
+};
+
+/**
+ * struct fw_cdev_event_iso_interrupt - Sent when an iso packet was completed
+ * @closure:	See &fw_cdev_event_common;
+ *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl
+ * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_ISO_INTERRUPT
+ * @cycle:	Cycle counter of the interrupt packet
+ * @header_length: Total length of following headers, in bytes
+ * @header:	Stripped headers, if any
+ *
+ * This event is sent when the controller has completed an &fw_cdev_iso_packet
+ * with the %FW_CDEV_ISO_INTERRUPT bit set.  In the receive case, the headers
+ * stripped of all packets up until and including the interrupt packet are
+ * returned in the @header field.  The amount of header data per packet is as
+ * specified at iso context creation by &fw_cdev_create_iso_context.header_size.
+ *
+ * In version 1 of this ABI, header data consisted of the 1394 isochronous
+ * packet header, followed by quadlets from the packet payload if
+ * &fw_cdev_create_iso_context.header_size > 4.
+ *
+ * In version 2 of this ABI, header data consist of the 1394 isochronous
+ * packet header, followed by a timestamp quadlet if
+ * &fw_cdev_create_iso_context.header_size > 4, followed by quadlets from the
+ * packet payload if &fw_cdev_create_iso_context.header_size > 8.
+ *
+ * Behaviour of ver. 1 of this ABI is no longer available since ABI ver. 2.
+ *
+ * Format of 1394 iso packet header: 16 bits len, 2 bits tag, 6 bits channel,
+ * 4 bits tcode, 4 bits sy, in big endian byte order.  Format of timestamp:
+ * 16 bits invalid, 3 bits cycleSeconds, 13 bits cycleCount, in big endian byte
+ * order.
+ */
+struct fw_cdev_event_iso_interrupt {
+	__u64 closure;
+	__u32 type;
+	__u32 cycle;
+	__u32 header_length;
+	__u32 header[0];
+};
+
+/**
+ * struct fw_cdev_event_iso_resource - Iso resources were allocated or freed
+ * @closure:	See &fw_cdev_event_common;
+ *		set by %FW_CDEV_IOC_(DE)ALLOCATE_ISO_RESOURCE(_ONCE) ioctl
+ * @type:	%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or
+ *		%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED
+ * @handle:	Reference by which an allocated resource can be deallocated
+ * @channel:	Isochronous channel which was (de)allocated, if any
+ * @bandwidth:	Bandwidth allocation units which were (de)allocated, if any
+ *
+ * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event is sent after an isochronous
+ * resource was allocated at the IRM.  The client has to check @channel and
+ * @bandwidth for whether the allocation actually succeeded.
+ *
+ * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event is sent after an isochronous
+ * resource was deallocated at the IRM.  It is also sent when automatic
+ * reallocation after a bus reset failed.
+ *
+ * @channel is <0 if no channel was (de)allocated or if reallocation failed.
+ * @bandwidth is 0 if no bandwidth was (de)allocated or if reallocation failed.
+ */
+struct fw_cdev_event_iso_resource {
+	__u64 closure;
+	__u32 type;
+	__u32 handle;
+	__s32 channel;
+	__s32 bandwidth;
+};
+
+/**
+ * union fw_cdev_event - Convenience union of fw_cdev_event_ types
+ * @common:        Valid for all types
+ * @bus_reset:     Valid if @common.type == %FW_CDEV_EVENT_BUS_RESET
+ * @response:      Valid if @common.type == %FW_CDEV_EVENT_RESPONSE
+ * @request:       Valid if @common.type == %FW_CDEV_EVENT_REQUEST
+ * @iso_interrupt: Valid if @common.type == %FW_CDEV_EVENT_ISO_INTERRUPT
+ * @iso_resource:  Valid if @common.type ==
+ *				%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or
+ *				%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED
+ *
+ * Convenience union for userspace use.  Events could be read(2) into an
+ * appropriately aligned char buffer and then cast to this union for further
+ * processing.  Note that for a request, response or iso_interrupt event,
+ * the data[] or header[] may make the size of the full event larger than
+ * sizeof(union fw_cdev_event).  Also note that if you attempt to read(2)
+ * an event into a buffer that is not large enough for it, the data that does
+ * not fit will be discarded so that the next read(2) will return a new event.
+ */
+union fw_cdev_event {
+	struct fw_cdev_event_common		common;
+	struct fw_cdev_event_bus_reset		bus_reset;
+	struct fw_cdev_event_response		response;
+	struct fw_cdev_event_request		request;
+	struct fw_cdev_event_iso_interrupt	iso_interrupt;
+	struct fw_cdev_event_iso_resource	iso_resource;
+};
+
+/* available since kernel version 2.6.22 */
+#define FW_CDEV_IOC_GET_INFO           _IOWR('#', 0x00, struct fw_cdev_get_info)
+#define FW_CDEV_IOC_SEND_REQUEST        _IOW('#', 0x01, struct fw_cdev_send_request)
+#define FW_CDEV_IOC_ALLOCATE           _IOWR('#', 0x02, struct fw_cdev_allocate)
+#define FW_CDEV_IOC_DEALLOCATE          _IOW('#', 0x03, struct fw_cdev_deallocate)
+#define FW_CDEV_IOC_SEND_RESPONSE       _IOW('#', 0x04, struct fw_cdev_send_response)
+#define FW_CDEV_IOC_INITIATE_BUS_RESET  _IOW('#', 0x05, struct fw_cdev_initiate_bus_reset)
+#define FW_CDEV_IOC_ADD_DESCRIPTOR     _IOWR('#', 0x06, struct fw_cdev_add_descriptor)
+#define FW_CDEV_IOC_REMOVE_DESCRIPTOR   _IOW('#', 0x07, struct fw_cdev_remove_descriptor)
+#define FW_CDEV_IOC_CREATE_ISO_CONTEXT _IOWR('#', 0x08, struct fw_cdev_create_iso_context)
+#define FW_CDEV_IOC_QUEUE_ISO          _IOWR('#', 0x09, struct fw_cdev_queue_iso)
+#define FW_CDEV_IOC_START_ISO           _IOW('#', 0x0a, struct fw_cdev_start_iso)
+#define FW_CDEV_IOC_STOP_ISO            _IOW('#', 0x0b, struct fw_cdev_stop_iso)
+
+/* available since kernel version 2.6.24 */
+#define FW_CDEV_IOC_GET_CYCLE_TIMER     _IOR('#', 0x0c, struct fw_cdev_get_cycle_timer)
+
+/* available since kernel version 2.6.30 */
+#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE       _IOWR('#', 0x0d, struct fw_cdev_allocate_iso_resource)
+#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE      _IOW('#', 0x0e, struct fw_cdev_deallocate)
+#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE   _IOW('#', 0x0f, struct fw_cdev_allocate_iso_resource)
+#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE _IOW('#', 0x10, struct fw_cdev_allocate_iso_resource)
+#define FW_CDEV_IOC_GET_SPEED                     _IO('#', 0x11) /* returns speed code */
+#define FW_CDEV_IOC_SEND_BROADCAST_REQUEST       _IOW('#', 0x12, struct fw_cdev_send_request)
+#define FW_CDEV_IOC_SEND_STREAM_PACKET           _IOW('#', 0x13, struct fw_cdev_send_stream_packet)
+
+/*
+ * FW_CDEV_VERSION History
+ *  1  (2.6.22)  - initial version
+ *  2  (2.6.30)  - changed &fw_cdev_event_iso_interrupt.header if
+ *                 &fw_cdev_create_iso_context.header_size is 8 or more
+ */
+#define FW_CDEV_VERSION 2
+
+/**
+ * struct fw_cdev_get_info - General purpose information ioctl
+ * @version:	The version field is just a running serial number.
+ *		We never break backwards compatibility, but may add more
+ *		structs and ioctls in later revisions.
+ * @rom_length:	If @rom is non-zero, at most rom_length bytes of configuration
+ *		ROM will be copied into that user space address.  In either
+ *		case, @rom_length is updated with the actual length of the
+ *		configuration ROM.
+ * @rom:	If non-zero, address of a buffer to be filled by a copy of the
+ *		device's configuration ROM
+ * @bus_reset:	If non-zero, address of a buffer to be filled by a
+ *		&struct fw_cdev_event_bus_reset with the current state
+ *		of the bus.  This does not cause a bus reset to happen.
+ * @bus_reset_closure: Value of &closure in this and subsequent bus reset events
+ * @card:	The index of the card this device belongs to
+ */
+struct fw_cdev_get_info {
+	__u32 version;
+	__u32 rom_length;
+	__u64 rom;
+	__u64 bus_reset;
+	__u64 bus_reset_closure;
+	__u32 card;
+};
+
+/**
+ * struct fw_cdev_send_request - Send an asynchronous request packet
+ * @tcode:	Transaction code of the request
+ * @length:	Length of outgoing payload, in bytes
+ * @offset:	48-bit offset at destination node
+ * @closure:	Passed back to userspace in the response event
+ * @data:	Userspace pointer to payload
+ * @generation:	The bus generation where packet is valid
+ *
+ * Send a request to the device.  This ioctl implements all outgoing requests.
+ * Both quadlet and block request specify the payload as a pointer to the data
+ * in the @data field.  Once the transaction completes, the kernel writes an
+ * &fw_cdev_event_response event back.  The @closure field is passed back to
+ * user space in the response event.
+ */
+struct fw_cdev_send_request {
+	__u32 tcode;
+	__u32 length;
+	__u64 offset;
+	__u64 closure;
+	__u64 data;
+	__u32 generation;
+};
+
+/**
+ * struct fw_cdev_send_response - Send an asynchronous response packet
+ * @rcode:	Response code as determined by the userspace handler
+ * @length:	Length of outgoing payload, in bytes
+ * @data:	Userspace pointer to payload
+ * @handle:	The handle from the &fw_cdev_event_request
+ *
+ * Send a response to an incoming request.  By setting up an address range using
+ * the %FW_CDEV_IOC_ALLOCATE ioctl, userspace can listen for incoming requests.  An
+ * incoming request will generate an %FW_CDEV_EVENT_REQUEST, and userspace must
+ * send a reply using this ioctl.  The event has a handle to the kernel-side
+ * pending transaction, which should be used with this ioctl.
+ */
+struct fw_cdev_send_response {
+	__u32 rcode;
+	__u32 length;
+	__u64 data;
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_allocate - Allocate a CSR address range
+ * @offset:	Start offset of the address range
+ * @closure:	To be passed back to userspace in request events
+ * @length:	Length of the address range, in bytes
+ * @handle:	Handle to the allocation, written by the kernel
+ *
+ * Allocate an address range in the 48-bit address space on the local node
+ * (the controller).  This allows userspace to listen for requests with an
+ * offset within that address range.  When the kernel receives a request
+ * within the range, an &fw_cdev_event_request event will be written back.
+ * The @closure field is passed back to userspace in the response event.
+ * The @handle field is an out parameter, returning a handle to the allocated
+ * range to be used for later deallocation of the range.
+ */
+struct fw_cdev_allocate {
+	__u64 offset;
+	__u64 closure;
+	__u32 length;
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_deallocate - Free a CSR address range or isochronous resource
+ * @handle:	Handle to the address range or iso resource, as returned by the
+ *		kernel when the range or resource was allocated
+ */
+struct fw_cdev_deallocate {
+	__u32 handle;
+};
+
+#define FW_CDEV_LONG_RESET	0
+#define FW_CDEV_SHORT_RESET	1
+
+/**
+ * struct fw_cdev_initiate_bus_reset - Initiate a bus reset
+ * @type:	%FW_CDEV_SHORT_RESET or %FW_CDEV_LONG_RESET
+ *
+ * Initiate a bus reset for the bus this device is on.  The bus reset can be
+ * either the original (long) bus reset or the arbitrated (short) bus reset
+ * introduced in 1394a-2000.
+ */
+struct fw_cdev_initiate_bus_reset {
+	__u32 type;	/* FW_CDEV_SHORT_RESET or FW_CDEV_LONG_RESET */
+};
+
+/**
+ * struct fw_cdev_add_descriptor - Add contents to the local node's config ROM
+ * @immediate:	If non-zero, immediate key to insert before pointer
+ * @key:	Upper 8 bits of root directory pointer
+ * @data:	Userspace pointer to contents of descriptor block
+ * @length:	Length of descriptor block data, in bytes
+ * @handle:	Handle to the descriptor, written by the kernel
+ *
+ * Add a descriptor block and optionally a preceding immediate key to the local
+ * node's configuration ROM.
+ *
+ * The @key field specifies the upper 8 bits of the descriptor root directory
+ * pointer and the @data and @length fields specify the contents. The @key
+ * should be of the form 0xXX000000. The offset part of the root directory entry
+ * will be filled in by the kernel.
+ *
+ * If not 0, the @immediate field specifies an immediate key which will be
+ * inserted before the root directory pointer.
+ *
+ * If successful, the kernel adds the descriptor and writes back a handle to the
+ * kernel-side object to be used for later removal of the descriptor block and
+ * immediate key.
+ *
+ * This ioctl affects the configuration ROMs of all local nodes.
+ * The ioctl only succeeds on device files which represent a local node.
+ */
+struct fw_cdev_add_descriptor {
+	__u32 immediate;
+	__u32 key;
+	__u64 data;
+	__u32 length;
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_remove_descriptor - Remove contents from the configuration ROM
+ * @handle:	Handle to the descriptor, as returned by the kernel when the
+ *		descriptor was added
+ *
+ * Remove a descriptor block and accompanying immediate key from the local
+ * nodes' configuration ROMs.
+ */
+struct fw_cdev_remove_descriptor {
+	__u32 handle;
+};
+
+#define FW_CDEV_ISO_CONTEXT_TRANSMIT	0
+#define FW_CDEV_ISO_CONTEXT_RECEIVE	1
+
+/**
+ * struct fw_cdev_create_iso_context - Create a context for isochronous IO
+ * @type:	%FW_CDEV_ISO_CONTEXT_TRANSMIT or %FW_CDEV_ISO_CONTEXT_RECEIVE
+ * @header_size: Header size to strip for receive contexts
+ * @channel:	Channel to bind to
+ * @speed:	Speed to transmit at
+ * @closure:	To be returned in &fw_cdev_event_iso_interrupt
+ * @handle:	Handle to context, written back by kernel
+ *
+ * Prior to sending or receiving isochronous I/O, a context must be created.
+ * The context records information about the transmit or receive configuration
+ * and typically maps to an underlying hardware resource.  A context is set up
+ * for either sending or receiving.  It is bound to a specific isochronous
+ * channel.
+ *
+ * If a context was successfully created, the kernel writes back a handle to the
+ * context, which must be passed in for subsequent operations on that context.
+ *
+ * Note that the effect of a @header_size > 4 depends on
+ * &fw_cdev_get_info.version, as documented at &fw_cdev_event_iso_interrupt.
+ */
+struct fw_cdev_create_iso_context {
+	__u32 type;
+	__u32 header_size;
+	__u32 channel;
+	__u32 speed;
+	__u64 closure;
+	__u32 handle;
+};
+
+#define FW_CDEV_ISO_PAYLOAD_LENGTH(v)	(v)
+#define FW_CDEV_ISO_INTERRUPT		(1 << 16)
+#define FW_CDEV_ISO_SKIP		(1 << 17)
+#define FW_CDEV_ISO_SYNC		(1 << 17)
+#define FW_CDEV_ISO_TAG(v)		((v) << 18)
+#define FW_CDEV_ISO_SY(v)		((v) << 20)
+#define FW_CDEV_ISO_HEADER_LENGTH(v)	((v) << 24)
+
+/**
+ * struct fw_cdev_iso_packet - Isochronous packet
+ * @control:	Contains the header length (8 uppermost bits), the sy field
+ *		(4 bits), the tag field (2 bits), a sync flag (1 bit),
+ *		a skip flag (1 bit), an interrupt flag (1 bit), and the
+ *		payload length (16 lowermost bits)
+ * @header:	Header and payload
+ *
+ * &struct fw_cdev_iso_packet is used to describe isochronous packet queues.
+ *
+ * Use the FW_CDEV_ISO_ macros to fill in @control.  The sy and tag fields are
+ * specified by IEEE 1394a and IEC 61883.
+ *
+ * FIXME - finish this documentation
+ */
+struct fw_cdev_iso_packet {
+	__u32 control;
+	__u32 header[0];
+};
+
+/**
+ * struct fw_cdev_queue_iso - Queue isochronous packets for I/O
+ * @packets:	Userspace pointer to packet data
+ * @data:	Pointer into mmap()'ed payload buffer
+ * @size:	Size of packet data in bytes
+ * @handle:	Isochronous context handle
+ *
+ * Queue a number of isochronous packets for reception or transmission.
+ * This ioctl takes a pointer to an array of &fw_cdev_iso_packet structs,
+ * which describe how to transmit from or receive into a contiguous region
+ * of a mmap()'ed payload buffer.  As part of the packet descriptors,
+ * a series of headers can be supplied, which will be prepended to the
+ * payload during DMA.
+ *
+ * The kernel may or may not queue all packets, but will write back updated
+ * values of the @packets, @data and @size fields, so the ioctl can be
+ * resubmitted easily.
+ */
+struct fw_cdev_queue_iso {
+	__u64 packets;
+	__u64 data;
+	__u32 size;
+	__u32 handle;
+};
+
+#define FW_CDEV_ISO_CONTEXT_MATCH_TAG0		 1
+#define FW_CDEV_ISO_CONTEXT_MATCH_TAG1		 2
+#define FW_CDEV_ISO_CONTEXT_MATCH_TAG2		 4
+#define FW_CDEV_ISO_CONTEXT_MATCH_TAG3		 8
+#define FW_CDEV_ISO_CONTEXT_MATCH_ALL_TAGS	15
+
+/**
+ * struct fw_cdev_start_iso - Start an isochronous transmission or reception
+ * @cycle:	Cycle in which to start I/O.  If @cycle is greater than or
+ *		equal to 0, the I/O will start on that cycle.
+ * @sync:	Determines the value to wait for for receive packets that have
+ *		the %FW_CDEV_ISO_SYNC bit set
+ * @tags:	Tag filter bit mask.  Only valid for isochronous reception.
+ *		Determines the tag values for which packets will be accepted.
+ *		Use FW_CDEV_ISO_CONTEXT_MATCH_ macros to set @tags.
+ * @handle:	Isochronous context handle within which to transmit or receive
+ */
+struct fw_cdev_start_iso {
+	__s32 cycle;
+	__u32 sync;
+	__u32 tags;
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_stop_iso - Stop an isochronous transmission or reception
+ * @handle:	Handle of isochronous context to stop
+ */
+struct fw_cdev_stop_iso {
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_get_cycle_timer - read cycle timer register
+ * @local_time:   system time, in microseconds since the Epoch
+ * @cycle_timer:  isochronous cycle timer, as per OHCI 1.1 clause 5.13
+ *
+ * The %FW_CDEV_IOC_GET_CYCLE_TIMER ioctl reads the isochronous cycle timer
+ * and also the system clock.  This allows to express the receive time of an
+ * isochronous packet as a system time with microsecond accuracy.
+ *
+ * @cycle_timer consists of 7 bits cycleSeconds, 13 bits cycleCount, and
+ * 12 bits cycleOffset, in host byte order.
+ */
+struct fw_cdev_get_cycle_timer {
+	__u64 local_time;
+	__u32 cycle_timer;
+};
+
+/**
+ * struct fw_cdev_allocate_iso_resource - (De)allocate a channel or bandwidth
+ * @closure:	Passed back to userspace in correponding iso resource events
+ * @channels:	Isochronous channels of which one is to be (de)allocated
+ * @bandwidth:	Isochronous bandwidth units to be (de)allocated
+ * @handle:	Handle to the allocation, written by the kernel (only valid in
+ *		case of %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctls)
+ *
+ * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctl initiates allocation of an
+ * isochronous channel and/or of isochronous bandwidth at the isochronous
+ * resource manager (IRM).  Only one of the channels specified in @channels is
+ * allocated.  An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED is sent after
+ * communication with the IRM, indicating success or failure in the event data.
+ * The kernel will automatically reallocate the resources after bus resets.
+ * Should a reallocation fail, an %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event
+ * will be sent.  The kernel will also automatically deallocate the resources
+ * when the file descriptor is closed.
+ *
+ * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE ioctl can be used to initiate
+ * deallocation of resources which were allocated as described above.
+ * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.
+ *
+ * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE ioctl is a variant of allocation
+ * without automatic re- or deallocation.
+ * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event concludes this operation,
+ * indicating success or failure in its data.
+ *
+ * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE ioctl works like
+ * %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE except that resources are freed
+ * instead of allocated.
+ * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.
+ *
+ * To summarize, %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE allocates iso resources
+ * for the lifetime of the fd or handle.
+ * In contrast, %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE allocates iso resources
+ * for the duration of a bus generation.
+ *
+ * @channels is a host-endian bitfield with the least significant bit
+ * representing channel 0 and the most significant bit representing channel 63:
+ * 1ULL << c for each channel c that is a candidate for (de)allocation.
+ *
+ * @bandwidth is expressed in bandwidth allocation units, i.e. the time to send
+ * one quadlet of data (payload or header data) at speed S1600.
+ */
+struct fw_cdev_allocate_iso_resource {
+	__u64 closure;
+	__u64 channels;
+	__u32 bandwidth;
+	__u32 handle;
+};
+
+/**
+ * struct fw_cdev_send_stream_packet - send an asynchronous stream packet
+ * @length:	Length of outgoing payload, in bytes
+ * @tag:	Data format tag
+ * @channel:	Isochronous channel to transmit to
+ * @sy:		Synchronization code
+ * @closure:	Passed back to userspace in the response event
+ * @data:	Userspace pointer to payload
+ * @generation:	The bus generation where packet is valid
+ * @speed:	Speed to transmit at
+ *
+ * The %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl sends an asynchronous stream packet
+ * to every device which is listening to the specified channel.  The kernel
+ * writes an &fw_cdev_event_response event which indicates success or failure of
+ * the transmission.
+ */
+struct fw_cdev_send_stream_packet {
+	__u32 length;
+	__u32 tag;
+	__u32 channel;
+	__u32 sy;
+	__u64 closure;
+	__u64 data;
+	__u32 generation;
+	__u32 speed;
+};
+
+#endif /* _LINUX_FIREWIRE_CDEV_H */
diff -uNr linux-2.6.32/usr/include/linux/firewire-constants.h clean_modified/linux-2.6.32/usr/include/linux/firewire-constants.h
--- linux-2.6.32/usr/include/linux/firewire-constants.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/firewire-constants.h	2019-04-14 13:24:02.966137008 -0500
@@ -0,0 +1,67 @@
+#ifndef _LINUX_FIREWIRE_CONSTANTS_H
+#define _LINUX_FIREWIRE_CONSTANTS_H
+
+#define TCODE_WRITE_QUADLET_REQUEST	0x0
+#define TCODE_WRITE_BLOCK_REQUEST	0x1
+#define TCODE_WRITE_RESPONSE		0x2
+#define TCODE_READ_QUADLET_REQUEST	0x4
+#define TCODE_READ_BLOCK_REQUEST	0x5
+#define TCODE_READ_QUADLET_RESPONSE	0x6
+#define TCODE_READ_BLOCK_RESPONSE	0x7
+#define TCODE_CYCLE_START		0x8
+#define TCODE_LOCK_REQUEST		0x9
+#define TCODE_STREAM_DATA		0xa
+#define TCODE_LOCK_RESPONSE		0xb
+
+#define EXTCODE_MASK_SWAP		0x1
+#define EXTCODE_COMPARE_SWAP		0x2
+#define EXTCODE_FETCH_ADD		0x3
+#define EXTCODE_LITTLE_ADD		0x4
+#define EXTCODE_BOUNDED_ADD		0x5
+#define EXTCODE_WRAP_ADD		0x6
+#define EXTCODE_VENDOR_DEPENDENT	0x7
+
+/* Juju specific tcodes */
+#define TCODE_LOCK_MASK_SWAP		(0x10 | EXTCODE_MASK_SWAP)
+#define TCODE_LOCK_COMPARE_SWAP		(0x10 | EXTCODE_COMPARE_SWAP)
+#define TCODE_LOCK_FETCH_ADD		(0x10 | EXTCODE_FETCH_ADD)
+#define TCODE_LOCK_LITTLE_ADD		(0x10 | EXTCODE_LITTLE_ADD)
+#define TCODE_LOCK_BOUNDED_ADD		(0x10 | EXTCODE_BOUNDED_ADD)
+#define TCODE_LOCK_WRAP_ADD		(0x10 | EXTCODE_WRAP_ADD)
+#define TCODE_LOCK_VENDOR_DEPENDENT	(0x10 | EXTCODE_VENDOR_DEPENDENT)
+
+#define RCODE_COMPLETE			0x0
+#define RCODE_CONFLICT_ERROR		0x4
+#define RCODE_DATA_ERROR		0x5
+#define RCODE_TYPE_ERROR		0x6
+#define RCODE_ADDRESS_ERROR		0x7
+
+/* Juju specific rcodes */
+#define RCODE_SEND_ERROR		0x10
+#define RCODE_CANCELLED			0x11
+#define RCODE_BUSY			0x12
+#define RCODE_GENERATION		0x13
+#define RCODE_NO_ACK			0x14
+
+#define SCODE_100			0x0
+#define SCODE_200			0x1
+#define SCODE_400			0x2
+#define SCODE_800			0x3
+#define SCODE_1600			0x4
+#define SCODE_3200			0x5
+#define SCODE_BETA			0x3
+
+#define ACK_COMPLETE			0x1
+#define ACK_PENDING			0x2
+#define ACK_BUSY_X			0x4
+#define ACK_BUSY_A			0x5
+#define ACK_BUSY_B			0x6
+#define ACK_DATA_ERROR			0xd
+#define ACK_TYPE_ERROR			0xe
+
+#define RETRY_1				0x00
+#define RETRY_X				0x01
+#define RETRY_A				0x02
+#define RETRY_B				0x03
+
+#endif /* _LINUX_FIREWIRE_CONSTANTS_H */
diff -uNr linux-2.6.32/usr/include/linux/flat.h clean_modified/linux-2.6.32/usr/include/linux/flat.h
--- linux-2.6.32/usr/include/linux/flat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/flat.h	2019-04-14 13:24:02.966137008 -0500
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2002-2003  David McCullough <davidm@snapgear.com>
+ * Copyright (C) 1998       Kenneth Albanowski <kjahds@kjahds.com>
+ *                          The Silver Hammer Group, Ltd.
+ *
+ * This file provides the definitions and structures needed to
+ * support uClinux flat-format executables.
+ */
+
+#ifndef _LINUX_FLAT_H
+#define _LINUX_FLAT_H
+
+
+#define	FLAT_VERSION			0x00000004L
+
+#ifdef CONFIG_BINFMT_SHARED_FLAT
+#define	MAX_SHARED_LIBS			(4)
+#else
+#define	MAX_SHARED_LIBS			(1)
+#endif
+
+/*
+ * To make everything easier to port and manage cross platform
+ * development,  all fields are in network byte order.
+ */
+
+struct flat_hdr {
+	char magic[4];
+	unsigned long rev;          /* version (as above) */
+	unsigned long entry;        /* Offset of first executable instruction
+	                               with text segment from beginning of file */
+	unsigned long data_start;   /* Offset of data segment from beginning of
+	                               file */
+	unsigned long data_end;     /* Offset of end of data segment
+	                               from beginning of file */
+	unsigned long bss_end;      /* Offset of end of bss segment from beginning
+	                               of file */
+
+	/* (It is assumed that data_end through bss_end forms the bss segment.) */
+
+	unsigned long stack_size;   /* Size of stack, in bytes */
+	unsigned long reloc_start;  /* Offset of relocation records from
+	                               beginning of file */
+	unsigned long reloc_count;  /* Number of relocation records */
+	unsigned long flags;       
+	unsigned long build_date;   /* When the program/library was built */
+	unsigned long filler[5];    /* Reservered, set to zero */
+};
+
+#define FLAT_FLAG_RAM    0x0001 /* load program entirely into RAM */
+#define FLAT_FLAG_GOTPIC 0x0002 /* program is PIC with GOT */
+#define FLAT_FLAG_GZIP   0x0004 /* all but the header is compressed */
+#define FLAT_FLAG_GZDATA 0x0008 /* only data/relocs are compressed (for XIP) */
+#define FLAT_FLAG_KTRACE 0x0010 /* output useful kernel trace for debugging */
+
+
+
+#endif /* _LINUX_FLAT_H */
diff -uNr linux-2.6.32/usr/include/linux/fs.h clean_modified/linux-2.6.32/usr/include/linux/fs.h
--- linux-2.6.32/usr/include/linux/fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fs.h	2019-04-14 13:24:02.967128435 -0500
@@ -0,0 +1,360 @@
+#ifndef _LINUX_FS_H
+#define _LINUX_FS_H
+
+/*
+ * This file has definitions for some important file table
+ * structures etc.
+ */
+
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+
+/*
+ * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
+ * the file limit at runtime and only root can increase the per-process
+ * nr_file rlimit, so it's safe to set up a ridiculously high absolute
+ * upper limit on files-per-process.
+ *
+ * Some programs (notably those using select()) may have to be 
+ * recompiled to take full advantage of the new limits..  
+ */
+
+/* Fixed constants first: */
+#undef NR_OPEN
+#define INR_OPEN 1024		/* Initial setting for nfile rlimits */
+
+#define BLOCK_SIZE_BITS 10
+#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
+
+#define SEEK_SET	0	/* seek relative to beginning of file */
+#define SEEK_CUR	1	/* seek relative to current file position */
+#define SEEK_END	2	/* seek relative to end of file */
+#define SEEK_MAX	SEEK_END
+
+/* And dynamically-tunable limits and defaults: */
+struct files_stat_struct {
+	int nr_files;		/* read only */
+	int nr_free_files;	/* read only */
+	int max_files;		/* tunable */
+};
+
+struct inodes_stat_t {
+	int nr_inodes;
+	int nr_unused;
+	int dummy[5];		/* padding for sysctl ABI compatibility */
+};
+
+
+#define NR_FILE  8192	/* this can well be larger on a larger system */
+
+#define MAY_EXEC 1
+#define MAY_WRITE 2
+#define MAY_READ 4
+#define MAY_APPEND 8
+#define MAY_ACCESS 16
+#define MAY_OPEN 32
+
+/*
+ * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
+ * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()
+ */
+
+/* file is open for reading */
+#define FMODE_READ		((fmode_t)1)
+/* file is open for writing */
+#define FMODE_WRITE		((fmode_t)2)
+/* file is seekable */
+#define FMODE_LSEEK		((fmode_t)4)
+/* file can be accessed using pread */
+#define FMODE_PREAD		((fmode_t)8)
+/* file can be accessed using pwrite */
+#define FMODE_PWRITE		((fmode_t)16)
+/* File is opened for execution with sys_execve / sys_uselib */
+#define FMODE_EXEC		((fmode_t)32)
+/* File is opened with O_NDELAY (only set for block devices) */
+#define FMODE_NDELAY		((fmode_t)64)
+/* File is opened with O_EXCL (only set for block devices) */
+#define FMODE_EXCL		((fmode_t)128)
+/* File is opened using open(.., 3, ..) and is writeable only for ioctls
+   (specialy hack for floppy.c) */
+#define FMODE_WRITE_IOCTL	((fmode_t)256)
+
+/*
+ * Don't update ctime and mtime.
+ *
+ * Currently a special hack for the XFS open_by_handle ioctl, but we'll
+ * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
+ */
+#define FMODE_NOCMTIME		((fmode_t)2048)
+
+/*
+ * The below are the various read and write types that we support. Some of
+ * them include behavioral modifiers that send information down to the
+ * block layer and IO scheduler. Terminology:
+ *
+ *	The block layer uses device plugging to defer IO a little bit, in
+ *	the hope that we will see more IO very shortly. This increases
+ *	coalescing of adjacent IO and thus reduces the number of IOs we
+ *	have to send to the device. It also allows for better queuing,
+ *	if the IO isn't mergeable. If the caller is going to be waiting
+ *	for the IO, then he must ensure that the device is unplugged so
+ *	that the IO is dispatched to the driver.
+ *
+ *	All IO is handled async in Linux. This is fine for background
+ *	writes, but for reads or writes that someone waits for completion
+ *	on, we want to notify the block layer and IO scheduler so that they
+ *	know about it. That allows them to make better scheduling
+ *	decisions. So when the below references 'sync' and 'async', it
+ *	is referencing this priority hint.
+ *
+ * With that in mind, the available types are:
+ *
+ * READ			A normal read operation. Device will be plugged.
+ * READ_SYNC		A synchronous read. Device is not plugged, caller can
+ *			immediately wait on this read without caring about
+ *			unplugging.
+ * READA		Used for read-ahead operations. Lower priority, and the
+ *			 block layer could (in theory) choose to ignore this
+ *			request if it runs into resource problems.
+ * WRITE		A normal async write. Device will be plugged.
+ * SWRITE		Like WRITE, but a special case for ll_rw_block() that
+ *			tells it to lock the buffer first. Normally a buffer
+ *			must be locked before doing IO.
+ * WRITE_SYNC_PLUG	Synchronous write. Identical to WRITE, but passes down
+ *			the hint that someone will be waiting on this IO
+ *			shortly. The device must still be unplugged explicitly,
+ *			WRITE_SYNC_PLUG does not do this as we could be
+ *			submitting more writes before we actually wait on any
+ *			of them.
+ * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
+ *			immediately after submission. The write equivalent
+ *			of READ_SYNC.
+ * WRITE_ODIRECT	Special case write for O_DIRECT only.
+ * SWRITE_SYNC
+ * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
+ *			See SWRITE.
+ * WRITE_BARRIER	Like WRITE, but tells the block layer that all
+ *			previously submitted writes must be safely on storage
+ *			before this one is started. Also guarantees that when
+ *			this write is complete, it itself is also safely on
+ *			storage. Prevents reordering of writes on both sides
+ *			of this IO.
+ *
+ */
+#define RW_MASK		1
+#define RWA_MASK	2
+#define READ 0
+#define WRITE 1
+#define READA 2		/* read-ahead  - don't block if no resources */
+#define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
+#define READ_SYNC	(READ | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define READ_META	(READ | (1 << BIO_RW_META))
+#define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
+#define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
+#define WRITE_ODIRECT	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define SWRITE_SYNC_PLUG	\
+			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
+#define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
+#define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
+
+/*
+ * These aren't really reads or writes, they pass down information about
+ * parts of device that are now unused by the file system.
+ */
+#define DISCARD_NOBARRIER (WRITE | (1 << BIO_RW_DISCARD))
+#define DISCARD_BARRIER (DISCARD_NOBARRIER | (1 << BIO_RW_BARRIER))
+
+#define SEL_IN		1
+#define SEL_OUT		2
+#define SEL_EX		4
+
+/* public flags for file_system_type */
+#define FS_REQUIRES_DEV 1 
+#define FS_BINARY_MOUNTDATA 2
+#define FS_HAS_SUBTYPE 4
+#define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
+#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move()
+					 * during rename() internally.
+					 */
+
+/*
+ * These are the fs-independent mount-flags: up to 32 flags are supported
+ */
+#define MS_RDONLY	 1	/* Mount read-only */
+#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
+#define MS_NODEV	 4	/* Disallow access to device special files */
+#define MS_NOEXEC	 8	/* Disallow program execution */
+#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
+#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
+#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
+#define MS_NOATIME	1024	/* Do not update access times. */
+#define MS_NODIRATIME	2048	/* Do not update directory access times */
+#define MS_BIND		4096
+#define MS_MOVE		8192
+#define MS_REC		16384
+#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
+				   MS_VERBOSE is deprecated. */
+#define MS_SILENT	32768
+#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
+#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
+#define MS_PRIVATE	(1<<18)	/* change to private */
+#define MS_SLAVE	(1<<19)	/* change to slave */
+#define MS_SHARED	(1<<20)	/* change to shared */
+#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
+#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
+#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
+#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
+#define MS_ACTIVE	(1<<30)
+#define MS_NOUSER	(1<<31)
+
+/*
+ * Superblock flags that can be altered by MS_REMOUNT
+ */
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
+
+/*
+ * Old magic mount flag and mask
+ */
+#define MS_MGC_VAL 0xC0ED0000
+#define MS_MGC_MSK 0xffff0000
+
+/* Inode flags - they have nothing to superblock flags now */
+
+#define S_SYNC		1	/* Writes are synced at once */
+#define S_NOATIME	2	/* Do not update access times */
+#define S_APPEND	4	/* Append-only file */
+#define S_IMMUTABLE	8	/* Immutable file */
+#define S_DEAD		16	/* removed, but still open directory */
+#define S_NOQUOTA	32	/* Inode is not counted to quota */
+#define S_DIRSYNC	64	/* Directory modifications are synchronous */
+#define S_NOCMTIME	128	/* Do not update file c/mtime */
+#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
+#define S_PRIVATE	512	/* Inode is fs-internal */
+
+/*
+ * Note that nosuid etc flags are inode-specific: setting some file-system
+ * flags just means all the inodes inherit those flags by default. It might be
+ * possible to override it selectively if you really wanted to with some
+ * ioctl() that is not currently implemented.
+ *
+ * Exception: MS_RDONLY is always applied to the entire file system.
+ *
+ * Unfortunately, it is possible to change a filesystems flags with it mounted
+ * with files in use.  This means that all of the inodes will not have their
+ * i_flags updated.  Hence, i_flags no longer inherit the superblock mount
+ * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
+ */
+#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
+
+#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
+#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
+					((inode)->i_flags & S_SYNC))
+#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
+#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+#define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)
+#define IS_I_VERSION(inode)   __IS_FLG(inode, MS_I_VERSION)
+
+#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
+#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
+#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+
+#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
+#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
+#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
+#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
+
+/* the read-only stuff doesn't really belong here, but any other place is
+   probably as bad and I don't want to create yet another include file. */
+
+#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
+#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
+#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
+#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
+#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
+#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
+#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
+#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
+#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
+#define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
+#define BLKSECTGET _IO(0x12,103)/* get max sectors per request (ll_rw_blk.c) */
+#define BLKSSZGET  _IO(0x12,104)/* get block device sector size */
+#if 0
+#define BLKPG      _IO(0x12,105)/* See blkpg.h */
+
+/* Some people are morons.  Do not use sizeof! */
+
+#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */
+#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */
+/* This was here just to show that the number is taken -
+   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
+#endif
+/* A jump here: 108-111 have been used for various private purposes. */
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
+#define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
+#define BLKTRACESTART _IO(0x12,116)
+#define BLKTRACESTOP _IO(0x12,117)
+#define BLKTRACETEARDOWN _IO(0x12,118)
+#define BLKDISCARD _IO(0x12,119)
+#define BLKIOMIN _IO(0x12,120)
+#define BLKIOOPT _IO(0x12,121)
+#define BLKALIGNOFF _IO(0x12,122)
+#define BLKPBSZGET _IO(0x12,123)
+
+#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
+#define FIBMAP	   _IO(0x00,1)	/* bmap access */
+#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
+#define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
+#define FITHAW		_IOWR('X', 120, int)	/* Thaw */
+
+#define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
+#define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
+#define	FS_IOC_GETVERSION		_IOR('v', 1, long)
+#define	FS_IOC_SETVERSION		_IOW('v', 2, long)
+#define FS_IOC_FIEMAP			_IOWR('f', 11, struct fiemap)
+#define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
+#define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
+#define FS_IOC32_GETVERSION		_IOR('v', 1, int)
+#define FS_IOC32_SETVERSION		_IOW('v', 2, int)
+
+/*
+ * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
+ */
+#define	FS_SECRM_FL			0x00000001 /* Secure deletion */
+#define	FS_UNRM_FL			0x00000002 /* Undelete */
+#define	FS_COMPR_FL			0x00000004 /* Compress file */
+#define FS_SYNC_FL			0x00000008 /* Synchronous updates */
+#define FS_IMMUTABLE_FL			0x00000010 /* Immutable file */
+#define FS_APPEND_FL			0x00000020 /* writes to file may only append */
+#define FS_NODUMP_FL			0x00000040 /* do not dump file */
+#define FS_NOATIME_FL			0x00000080 /* do not update atime */
+/* Reserved for compression usage... */
+#define FS_DIRTY_FL			0x00000100
+#define FS_COMPRBLK_FL			0x00000200 /* One or more compressed clusters */
+#define FS_NOCOMP_FL			0x00000400 /* Don't compress */
+#define FS_ECOMPR_FL			0x00000800 /* Compression error */
+/* End compression flags --- maybe not all used */
+#define FS_BTREE_FL			0x00001000 /* btree format dir */
+#define FS_INDEX_FL			0x00001000 /* hash-indexed directory */
+#define FS_IMAGIC_FL			0x00002000 /* AFS directory */
+#define FS_JOURNAL_DATA_FL		0x00004000 /* Reserved for ext3 */
+#define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
+#define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
+#define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
+#define FS_EXTENT_FL			0x00080000 /* Extents */
+#define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
+#define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
+
+#define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
+#define FS_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
+
+
+#define SYNC_FILE_RANGE_WAIT_BEFORE	1
+#define SYNC_FILE_RANGE_WRITE		2
+#define SYNC_FILE_RANGE_WAIT_AFTER	4
+
+#endif /* _LINUX_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/fuse.h clean_modified/linux-2.6.32/usr/include/linux/fuse.h
--- linux-2.6.32/usr/include/linux/fuse.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/fuse.h	2019-04-14 13:24:02.968105640 -0500
@@ -0,0 +1,568 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+/*
+ * This file defines the kernel interface of FUSE
+ *
+ * Protocol changelog:
+ *
+ * 7.9:
+ *  - new fuse_getattr_in input argument of GETATTR
+ *  - add lk_flags in fuse_lk_in
+ *  - add lock_owner field to fuse_setattr_in, fuse_read_in and fuse_write_in
+ *  - add blksize field to fuse_attr
+ *  - add file flags field to fuse_read_in and fuse_write_in
+ *
+ * 7.10
+ *  - add nonseekable open flag
+ *
+ * 7.11
+ *  - add IOCTL message
+ *  - add unsolicited notification support
+ *  - add POLL message and NOTIFY_POLL notification
+ *
+ * 7.12
+ *  - add umask flag to input argument of open, mknod and mkdir
+ *  - add notification messages for invalidation of inodes and
+ *    directory entries
+ *
+ * 7.13
+ *  - make max number of background requests and congestion threshold
+ *    tunables
+ */
+
+#ifndef _LINUX_FUSE_H
+#define _LINUX_FUSE_H
+
+#include <linux/types.h>
+
+/*
+ * Version negotiation:
+ *
+ * Both the kernel and userspace send the version they support in the
+ * INIT request and reply respectively.
+ *
+ * If the major versions match then both shall use the smallest
+ * of the two minor versions for communication.
+ *
+ * If the kernel supports a larger major version, then userspace shall
+ * reply with the major version it supports, ignore the rest of the
+ * INIT message and expect a new INIT message from the kernel with a
+ * matching major version.
+ *
+ * If the library supports a larger major version, then it shall fall
+ * back to the major protocol version sent by the kernel for
+ * communication and reply with that major version (and an arbitrary
+ * supported minor version).
+ */
+
+/** Version number of this interface */
+#define FUSE_KERNEL_VERSION 7
+
+/** Minor version number of this interface */
+#define FUSE_KERNEL_MINOR_VERSION 13
+
+/** The node ID of the root inode */
+#define FUSE_ROOT_ID 1
+
+/* Make sure all structures are padded to 64bit boundary, so 32bit
+   userspace works under 64bit kernels */
+
+struct fuse_attr {
+	__u64	ino;
+	__u64	size;
+	__u64	blocks;
+	__u64	atime;
+	__u64	mtime;
+	__u64	ctime;
+	__u32	atimensec;
+	__u32	mtimensec;
+	__u32	ctimensec;
+	__u32	mode;
+	__u32	nlink;
+	__u32	uid;
+	__u32	gid;
+	__u32	rdev;
+	__u32	blksize;
+	__u32	padding;
+};
+
+struct fuse_kstatfs {
+	__u64	blocks;
+	__u64	bfree;
+	__u64	bavail;
+	__u64	files;
+	__u64	ffree;
+	__u32	bsize;
+	__u32	namelen;
+	__u32	frsize;
+	__u32	padding;
+	__u32	spare[6];
+};
+
+struct fuse_file_lock {
+	__u64	start;
+	__u64	end;
+	__u32	type;
+	__u32	pid; /* tgid */
+};
+
+/**
+ * Bitmasks for fuse_setattr_in.valid
+ */
+#define FATTR_MODE	(1 << 0)
+#define FATTR_UID	(1 << 1)
+#define FATTR_GID	(1 << 2)
+#define FATTR_SIZE	(1 << 3)
+#define FATTR_ATIME	(1 << 4)
+#define FATTR_MTIME	(1 << 5)
+#define FATTR_FH	(1 << 6)
+#define FATTR_ATIME_NOW	(1 << 7)
+#define FATTR_MTIME_NOW	(1 << 8)
+#define FATTR_LOCKOWNER	(1 << 9)
+
+/**
+ * Flags returned by the OPEN request
+ *
+ * FOPEN_DIRECT_IO: bypass page cache for this open file
+ * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
+ * FOPEN_NONSEEKABLE: the file is not seekable
+ */
+#define FOPEN_DIRECT_IO		(1 << 0)
+#define FOPEN_KEEP_CACHE	(1 << 1)
+#define FOPEN_NONSEEKABLE	(1 << 2)
+
+/**
+ * INIT request/reply flags
+ *
+ * FUSE_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
+ * FUSE_DONT_MASK: don't apply umask to file mode on create operations
+ */
+#define FUSE_ASYNC_READ		(1 << 0)
+#define FUSE_POSIX_LOCKS	(1 << 1)
+#define FUSE_FILE_OPS		(1 << 2)
+#define FUSE_ATOMIC_O_TRUNC	(1 << 3)
+#define FUSE_EXPORT_SUPPORT	(1 << 4)
+#define FUSE_BIG_WRITES		(1 << 5)
+#define FUSE_DONT_MASK		(1 << 6)
+
+/**
+ * CUSE INIT request/reply flags
+ *
+ * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl
+ */
+#define CUSE_UNRESTRICTED_IOCTL	(1 << 0)
+
+/**
+ * Release flags
+ */
+#define FUSE_RELEASE_FLUSH	(1 << 0)
+
+/**
+ * Getattr flags
+ */
+#define FUSE_GETATTR_FH		(1 << 0)
+
+/**
+ * Lock flags
+ */
+#define FUSE_LK_FLOCK		(1 << 0)
+
+/**
+ * WRITE flags
+ *
+ * FUSE_WRITE_CACHE: delayed write from page cache, file handle is guessed
+ * FUSE_WRITE_LOCKOWNER: lock_owner field is valid
+ */
+#define FUSE_WRITE_CACHE	(1 << 0)
+#define FUSE_WRITE_LOCKOWNER	(1 << 1)
+
+/**
+ * Read flags
+ */
+#define FUSE_READ_LOCKOWNER	(1 << 1)
+
+/**
+ * Ioctl flags
+ *
+ * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
+ * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
+ * FUSE_IOCTL_RETRY: retry with new iovecs
+ *
+ * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
+ */
+#define FUSE_IOCTL_COMPAT	(1 << 0)
+#define FUSE_IOCTL_UNRESTRICTED	(1 << 1)
+#define FUSE_IOCTL_RETRY	(1 << 2)
+
+#define FUSE_IOCTL_MAX_IOV	256
+
+/**
+ * Poll flags
+ *
+ * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify
+ */
+#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)
+
+enum fuse_opcode {
+	FUSE_LOOKUP	   = 1,
+	FUSE_FORGET	   = 2,  /* no reply */
+	FUSE_GETATTR	   = 3,
+	FUSE_SETATTR	   = 4,
+	FUSE_READLINK	   = 5,
+	FUSE_SYMLINK	   = 6,
+	FUSE_MKNOD	   = 8,
+	FUSE_MKDIR	   = 9,
+	FUSE_UNLINK	   = 10,
+	FUSE_RMDIR	   = 11,
+	FUSE_RENAME	   = 12,
+	FUSE_LINK	   = 13,
+	FUSE_OPEN	   = 14,
+	FUSE_READ	   = 15,
+	FUSE_WRITE	   = 16,
+	FUSE_STATFS	   = 17,
+	FUSE_RELEASE       = 18,
+	FUSE_FSYNC         = 20,
+	FUSE_SETXATTR      = 21,
+	FUSE_GETXATTR      = 22,
+	FUSE_LISTXATTR     = 23,
+	FUSE_REMOVEXATTR   = 24,
+	FUSE_FLUSH         = 25,
+	FUSE_INIT          = 26,
+	FUSE_OPENDIR       = 27,
+	FUSE_READDIR       = 28,
+	FUSE_RELEASEDIR    = 29,
+	FUSE_FSYNCDIR      = 30,
+	FUSE_GETLK         = 31,
+	FUSE_SETLK         = 32,
+	FUSE_SETLKW        = 33,
+	FUSE_ACCESS        = 34,
+	FUSE_CREATE        = 35,
+	FUSE_INTERRUPT     = 36,
+	FUSE_BMAP          = 37,
+	FUSE_DESTROY       = 38,
+	FUSE_IOCTL         = 39,
+	FUSE_POLL          = 40,
+
+	/* CUSE specific operations */
+	CUSE_INIT          = 4096,
+};
+
+enum fuse_notify_code {
+	FUSE_NOTIFY_POLL   = 1,
+	FUSE_NOTIFY_INVAL_INODE = 2,
+	FUSE_NOTIFY_INVAL_ENTRY = 3,
+	FUSE_NOTIFY_CODE_MAX,
+};
+
+/* The read buffer is required to be at least 8k, but may be much larger */
+#define FUSE_MIN_READ_BUFFER 8192
+
+#define FUSE_COMPAT_ENTRY_OUT_SIZE 120
+
+struct fuse_entry_out {
+	__u64	nodeid;		/* Inode ID */
+	__u64	generation;	/* Inode generation: nodeid:gen must
+				   be unique for the fs's lifetime */
+	__u64	entry_valid;	/* Cache timeout for the name */
+	__u64	attr_valid;	/* Cache timeout for the attributes */
+	__u32	entry_valid_nsec;
+	__u32	attr_valid_nsec;
+	struct fuse_attr attr;
+};
+
+struct fuse_forget_in {
+	__u64	nlookup;
+};
+
+struct fuse_getattr_in {
+	__u32	getattr_flags;
+	__u32	dummy;
+	__u64	fh;
+};
+
+#define FUSE_COMPAT_ATTR_OUT_SIZE 96
+
+struct fuse_attr_out {
+	__u64	attr_valid;	/* Cache timeout for the attributes */
+	__u32	attr_valid_nsec;
+	__u32	dummy;
+	struct fuse_attr attr;
+};
+
+#define FUSE_COMPAT_MKNOD_IN_SIZE 8
+
+struct fuse_mknod_in {
+	__u32	mode;
+	__u32	rdev;
+	__u32	umask;
+	__u32	padding;
+};
+
+struct fuse_mkdir_in {
+	__u32	mode;
+	__u32	umask;
+};
+
+struct fuse_rename_in {
+	__u64	newdir;
+};
+
+struct fuse_link_in {
+	__u64	oldnodeid;
+};
+
+struct fuse_setattr_in {
+	__u32	valid;
+	__u32	padding;
+	__u64	fh;
+	__u64	size;
+	__u64	lock_owner;
+	__u64	atime;
+	__u64	mtime;
+	__u64	unused2;
+	__u32	atimensec;
+	__u32	mtimensec;
+	__u32	unused3;
+	__u32	mode;
+	__u32	unused4;
+	__u32	uid;
+	__u32	gid;
+	__u32	unused5;
+};
+
+struct fuse_open_in {
+	__u32	flags;
+	__u32	unused;
+};
+
+struct fuse_create_in {
+	__u32	flags;
+	__u32	mode;
+	__u32	umask;
+	__u32	padding;
+};
+
+struct fuse_open_out {
+	__u64	fh;
+	__u32	open_flags;
+	__u32	padding;
+};
+
+struct fuse_release_in {
+	__u64	fh;
+	__u32	flags;
+	__u32	release_flags;
+	__u64	lock_owner;
+};
+
+struct fuse_flush_in {
+	__u64	fh;
+	__u32	unused;
+	__u32	padding;
+	__u64	lock_owner;
+};
+
+struct fuse_read_in {
+	__u64	fh;
+	__u64	offset;
+	__u32	size;
+	__u32	read_flags;
+	__u64	lock_owner;
+	__u32	flags;
+	__u32	padding;
+};
+
+#define FUSE_COMPAT_WRITE_IN_SIZE 24
+
+struct fuse_write_in {
+	__u64	fh;
+	__u64	offset;
+	__u32	size;
+	__u32	write_flags;
+	__u64	lock_owner;
+	__u32	flags;
+	__u32	padding;
+};
+
+struct fuse_write_out {
+	__u32	size;
+	__u32	padding;
+};
+
+#define FUSE_COMPAT_STATFS_SIZE 48
+
+struct fuse_statfs_out {
+	struct fuse_kstatfs st;
+};
+
+struct fuse_fsync_in {
+	__u64	fh;
+	__u32	fsync_flags;
+	__u32	padding;
+};
+
+struct fuse_setxattr_in {
+	__u32	size;
+	__u32	flags;
+};
+
+struct fuse_getxattr_in {
+	__u32	size;
+	__u32	padding;
+};
+
+struct fuse_getxattr_out {
+	__u32	size;
+	__u32	padding;
+};
+
+struct fuse_lk_in {
+	__u64	fh;
+	__u64	owner;
+	struct fuse_file_lock lk;
+	__u32	lk_flags;
+	__u32	padding;
+};
+
+struct fuse_lk_out {
+	struct fuse_file_lock lk;
+};
+
+struct fuse_access_in {
+	__u32	mask;
+	__u32	padding;
+};
+
+struct fuse_init_in {
+	__u32	major;
+	__u32	minor;
+	__u32	max_readahead;
+	__u32	flags;
+};
+
+struct fuse_init_out {
+	__u32	major;
+	__u32	minor;
+	__u32	max_readahead;
+	__u32	flags;
+	__u16   max_background;
+	__u16   congestion_threshold;
+	__u32	max_write;
+};
+
+#define CUSE_INIT_INFO_MAX 4096
+
+struct cuse_init_in {
+	__u32	major;
+	__u32	minor;
+	__u32	unused;
+	__u32	flags;
+};
+
+struct cuse_init_out {
+	__u32	major;
+	__u32	minor;
+	__u32	unused;
+	__u32	flags;
+	__u32	max_read;
+	__u32	max_write;
+	__u32	dev_major;		/* chardev major */
+	__u32	dev_minor;		/* chardev minor */
+	__u32	spare[10];
+};
+
+struct fuse_interrupt_in {
+	__u64	unique;
+};
+
+struct fuse_bmap_in {
+	__u64	block;
+	__u32	blocksize;
+	__u32	padding;
+};
+
+struct fuse_bmap_out {
+	__u64	block;
+};
+
+struct fuse_ioctl_in {
+	__u64	fh;
+	__u32	flags;
+	__u32	cmd;
+	__u64	arg;
+	__u32	in_size;
+	__u32	out_size;
+};
+
+struct fuse_ioctl_out {
+	__s32	result;
+	__u32	flags;
+	__u32	in_iovs;
+	__u32	out_iovs;
+};
+
+struct fuse_poll_in {
+	__u64	fh;
+	__u64	kh;
+	__u32	flags;
+	__u32   padding;
+};
+
+struct fuse_poll_out {
+	__u32	revents;
+	__u32	padding;
+};
+
+struct fuse_notify_poll_wakeup_out {
+	__u64	kh;
+};
+
+struct fuse_in_header {
+	__u32	len;
+	__u32	opcode;
+	__u64	unique;
+	__u64	nodeid;
+	__u32	uid;
+	__u32	gid;
+	__u32	pid;
+	__u32	padding;
+};
+
+struct fuse_out_header {
+	__u32	len;
+	__s32	error;
+	__u64	unique;
+};
+
+struct fuse_dirent {
+	__u64	ino;
+	__u64	off;
+	__u32	namelen;
+	__u32	type;
+	char name[0];
+};
+
+#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)
+#define FUSE_DIRENT_ALIGN(x) (((x) + sizeof(__u64) - 1) & ~(sizeof(__u64) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+
+struct fuse_notify_inval_inode_out {
+	__u64	ino;
+	__s64	off;
+	__s64	len;
+};
+
+struct fuse_notify_inval_entry_out {
+	__u64	parent;
+	__u32	namelen;
+	__u32	padding;
+};
+
+#endif /* _LINUX_FUSE_H */
diff -uNr linux-2.6.32/usr/include/linux/futex.h clean_modified/linux-2.6.32/usr/include/linux/futex.h
--- linux-2.6.32/usr/include/linux/futex.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/futex.h	2019-04-14 13:24:02.968105640 -0500
@@ -0,0 +1,152 @@
+#ifndef _LINUX_FUTEX_H
+#define _LINUX_FUTEX_H
+
+
+#include <linux/types.h>
+
+/* Second argument to futex syscall */
+
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_FD		2
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_WAIT_REQUEUE_PI	11
+#define FUTEX_CMP_REQUEUE_PI	12
+
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+#define FUTEX_CMD_MASK		~(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME)
+
+#define FUTEX_WAIT_PRIVATE	(FUTEX_WAIT | FUTEX_PRIVATE_FLAG)
+#define FUTEX_WAKE_PRIVATE	(FUTEX_WAKE | FUTEX_PRIVATE_FLAG)
+#define FUTEX_REQUEUE_PRIVATE	(FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)
+#define FUTEX_CMP_REQUEUE_PRIVATE (FUTEX_CMP_REQUEUE | FUTEX_PRIVATE_FLAG)
+#define FUTEX_WAKE_OP_PRIVATE	(FUTEX_WAKE_OP | FUTEX_PRIVATE_FLAG)
+#define FUTEX_LOCK_PI_PRIVATE	(FUTEX_LOCK_PI | FUTEX_PRIVATE_FLAG)
+#define FUTEX_UNLOCK_PI_PRIVATE	(FUTEX_UNLOCK_PI | FUTEX_PRIVATE_FLAG)
+#define FUTEX_TRYLOCK_PI_PRIVATE (FUTEX_TRYLOCK_PI | FUTEX_PRIVATE_FLAG)
+#define FUTEX_WAIT_BITSET_PRIVATE	(FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG)
+#define FUTEX_WAKE_BITSET_PRIVATE	(FUTEX_WAKE_BITSET | FUTEX_PRIVATE_FLAG)
+#define FUTEX_WAIT_REQUEUE_PI_PRIVATE	(FUTEX_WAIT_REQUEUE_PI | \
+					 FUTEX_PRIVATE_FLAG)
+#define FUTEX_CMP_REQUEUE_PI_PRIVATE	(FUTEX_CMP_REQUEUE_PI | \
+					 FUTEX_PRIVATE_FLAG)
+
+/*
+ * Support for robust futexes: the kernel cleans up held futexes at
+ * thread exit time.
+ */
+
+/*
+ * Per-lock list entry - embedded in user-space locks, somewhere close
+ * to the futex field. (Note: user-space uses a double-linked list to
+ * achieve O(1) list add and remove, but the kernel only needs to know
+ * about the forward link)
+ *
+ * NOTE: this structure is part of the syscall ABI, and must not be
+ * changed.
+ */
+struct robust_list {
+	struct robust_list *next;
+};
+
+/*
+ * Per-thread list head:
+ *
+ * NOTE: this structure is part of the syscall ABI, and must only be
+ * changed if the change is first communicated with the glibc folks.
+ * (When an incompatible change is done, we'll increase the structure
+ *  size, which glibc will detect)
+ */
+struct robust_list_head {
+	/*
+	 * The head of the list. Points back to itself if empty:
+	 */
+	struct robust_list list;
+
+	/*
+	 * This relative offset is set by user-space, it gives the kernel
+	 * the relative position of the futex field to examine. This way
+	 * we keep userspace flexible, to freely shape its data-structure,
+	 * without hardcoding any particular offset into the kernel:
+	 */
+	long futex_offset;
+
+	/*
+	 * The death of the thread may race with userspace setting
+	 * up a lock's links. So to handle this race, userspace first
+	 * sets this field to the address of the to-be-taken lock,
+	 * then does the lock acquire, and then adds itself to the
+	 * list, and then clears this field. Hence the kernel will
+	 * always have full knowledge of all locks that the thread
+	 * _might_ have taken. We check the owner TID in any case,
+	 * so only truly owned locks will be handled.
+	 */
+	struct robust_list *list_op_pending;
+};
+
+/*
+ * Are there any waiters for this robust futex:
+ */
+#define FUTEX_WAITERS		0x80000000
+
+/*
+ * The kernel signals via this bit that a thread holding a futex
+ * has exited without unlocking the futex. The kernel also does
+ * a FUTEX_WAKE on such futexes, after setting the bit, to wake
+ * up any possible waiters:
+ */
+#define FUTEX_OWNER_DIED	0x40000000
+
+/*
+ * The rest of the robust-futex field is for the TID:
+ */
+#define FUTEX_TID_MASK		0x3fffffff
+
+/*
+ * This limit protects against a deliberately circular list.
+ * (Not worth introducing an rlimit for it)
+ */
+#define ROBUST_LIST_LIMIT	2048
+
+/*
+ * bitset with all bits set for the FUTEX_xxx_BITSET OPs to request a
+ * match of any bit.
+ */
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+
+#define FUTEX_OP_SET		0	/* *(int *)UADDR2 = OPARG; */
+#define FUTEX_OP_ADD		1	/* *(int *)UADDR2 += OPARG; */
+#define FUTEX_OP_OR		2	/* *(int *)UADDR2 |= OPARG; */
+#define FUTEX_OP_ANDN		3	/* *(int *)UADDR2 &= ~OPARG; */
+#define FUTEX_OP_XOR		4	/* *(int *)UADDR2 ^= OPARG; */
+
+#define FUTEX_OP_OPARG_SHIFT	8	/* Use (1 << OPARG) instead of OPARG.  */
+
+#define FUTEX_OP_CMP_EQ		0	/* if (oldval == CMPARG) wake */
+#define FUTEX_OP_CMP_NE		1	/* if (oldval != CMPARG) wake */
+#define FUTEX_OP_CMP_LT		2	/* if (oldval < CMPARG) wake */
+#define FUTEX_OP_CMP_LE		3	/* if (oldval <= CMPARG) wake */
+#define FUTEX_OP_CMP_GT		4	/* if (oldval > CMPARG) wake */
+#define FUTEX_OP_CMP_GE		5	/* if (oldval >= CMPARG) wake */
+
+/* FUTEX_WAKE_OP will perform atomically
+   int oldval = *(int *)UADDR2;
+   *(int *)UADDR2 = oldval OP OPARG;
+   if (oldval CMP CMPARG)
+     wake UADDR2;  */
+
+#define FUTEX_OP(op, oparg, cmp, cmparg) \
+  (((op & 0xf) << 28) | ((cmp & 0xf) << 24)		\
+   | ((oparg & 0xfff) << 12) | (cmparg & 0xfff))
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/gameport.h clean_modified/linux-2.6.32/usr/include/linux/gameport.h
--- linux-2.6.32/usr/include/linux/gameport.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/gameport.h	2019-04-14 13:24:02.968105640 -0500
@@ -0,0 +1,28 @@
+#ifndef _GAMEPORT_H
+#define _GAMEPORT_H
+
+/*
+ *  Copyright (c) 1999-2002 Vojtech Pavlik
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+
+#define GAMEPORT_MODE_DISABLED		0
+#define GAMEPORT_MODE_RAW		1
+#define GAMEPORT_MODE_COOKED		2
+
+#define GAMEPORT_ID_VENDOR_ANALOG	0x0001
+#define GAMEPORT_ID_VENDOR_MADCATZ	0x0002
+#define GAMEPORT_ID_VENDOR_LOGITECH	0x0003
+#define GAMEPORT_ID_VENDOR_CREATIVE	0x0004
+#define GAMEPORT_ID_VENDOR_GENIUS	0x0005
+#define GAMEPORT_ID_VENDOR_INTERACT	0x0006
+#define GAMEPORT_ID_VENDOR_MICROSOFT	0x0007
+#define GAMEPORT_ID_VENDOR_THRUSTMASTER	0x0008
+#define GAMEPORT_ID_VENDOR_GRAVIS	0x0009
+#define GAMEPORT_ID_VENDOR_GUILLEMOT	0x000a
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/generic_serial.h clean_modified/linux-2.6.32/usr/include/linux/generic_serial.h
--- linux-2.6.32/usr/include/linux/generic_serial.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/generic_serial.h	2019-04-14 13:24:02.969077913 -0500
@@ -0,0 +1,36 @@
+/*
+ *  generic_serial.h
+ *
+ *  Copyright (C) 1998 R.E.Wolff@BitWizard.nl
+ *
+ *  written for the SX serial driver.
+ *     Contains the code that should be shared over all the serial drivers.
+ *
+ *  Version 0.1 -- December, 1998.
+ */
+
+#ifndef GENERIC_SERIAL_H
+#define GENERIC_SERIAL_H
+
+
+/* Flags */
+/* Warning: serial.h defines some ASYNC_ flags, they say they are "only"
+   used in serial.c, but they are also used in all other serial drivers. 
+   Make sure they don't clash with these here... */
+#define GS_TX_INTEN      0x00800000
+#define GS_RX_INTEN      0x00400000
+#define GS_ACTIVE        0x00200000
+
+
+
+#define GS_TYPE_NORMAL   1
+
+#define GS_DEBUG_FLUSH   0x00000001
+#define GS_DEBUG_BTR     0x00000002
+#define GS_DEBUG_TERMIOS 0x00000004
+#define GS_DEBUG_STUFF   0x00000008
+#define GS_DEBUG_CLOSE   0x00000010
+#define GS_DEBUG_FLOW    0x00000020
+#define GS_DEBUG_WRITE   0x00000040
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/genetlink.h clean_modified/linux-2.6.32/usr/include/linux/genetlink.h
--- linux-2.6.32/usr/include/linux/genetlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/genetlink.h	2019-04-14 13:24:02.969897045 -0500
@@ -0,0 +1,83 @@
+#ifndef __LINUX_GENERIC_NETLINK_H
+#define __LINUX_GENERIC_NETLINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+#define GENL_NAMSIZ	16	/* length of family name */
+
+#define GENL_MIN_ID	NLMSG_MIN_TYPE
+#define GENL_MAX_ID	1023
+
+struct genlmsghdr {
+	__u8	cmd;
+	__u8	version;
+	__u16	reserved;
+};
+
+#define GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))
+
+#define GENL_ADMIN_PERM		0x01
+#define GENL_CMD_CAP_DO		0x02
+#define GENL_CMD_CAP_DUMP	0x04
+#define GENL_CMD_CAP_HASPOL	0x08
+
+/*
+ * List of reserved static generic netlink identifiers:
+ */
+#define GENL_ID_GENERATE	0
+#define GENL_ID_CTRL		NLMSG_MIN_TYPE
+
+/**************************************************************************
+ * Controller
+ **************************************************************************/
+
+enum {
+	CTRL_CMD_UNSPEC,
+	CTRL_CMD_NEWFAMILY,
+	CTRL_CMD_DELFAMILY,
+	CTRL_CMD_GETFAMILY,
+	CTRL_CMD_NEWOPS,
+	CTRL_CMD_DELOPS,
+	CTRL_CMD_GETOPS,
+	CTRL_CMD_NEWMCAST_GRP,
+	CTRL_CMD_DELMCAST_GRP,
+	CTRL_CMD_GETMCAST_GRP, /* unused */
+	__CTRL_CMD_MAX,
+};
+
+#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)
+
+enum {
+	CTRL_ATTR_UNSPEC,
+	CTRL_ATTR_FAMILY_ID,
+	CTRL_ATTR_FAMILY_NAME,
+	CTRL_ATTR_VERSION,
+	CTRL_ATTR_HDRSIZE,
+	CTRL_ATTR_MAXATTR,
+	CTRL_ATTR_OPS,
+	CTRL_ATTR_MCAST_GROUPS,
+	__CTRL_ATTR_MAX,
+};
+
+#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)
+
+enum {
+	CTRL_ATTR_OP_UNSPEC,
+	CTRL_ATTR_OP_ID,
+	CTRL_ATTR_OP_FLAGS,
+	__CTRL_ATTR_OP_MAX,
+};
+
+#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)
+
+enum {
+	CTRL_ATTR_MCAST_GRP_UNSPEC,
+	CTRL_ATTR_MCAST_GRP_NAME,
+	CTRL_ATTR_MCAST_GRP_ID,
+	__CTRL_ATTR_MCAST_GRP_MAX,
+};
+
+#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
+
+#endif	/* __LINUX_GENERIC_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/gen_stats.h clean_modified/linux-2.6.32/usr/include/linux/gen_stats.h
--- linux-2.6.32/usr/include/linux/gen_stats.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/gen_stats.h	2019-04-14 13:24:02.970798756 -0500
@@ -0,0 +1,72 @@
+#ifndef __LINUX_GEN_STATS_H
+#define __LINUX_GEN_STATS_H
+
+#include <linux/types.h>
+
+enum {
+	TCA_STATS_UNSPEC,
+	TCA_STATS_BASIC,
+	TCA_STATS_RATE_EST,
+	TCA_STATS_QUEUE,
+	TCA_STATS_APP,
+	__TCA_STATS_MAX,
+};
+#define TCA_STATS_MAX (__TCA_STATS_MAX - 1)
+
+/**
+ * struct gnet_stats_basic - byte/packet throughput statistics
+ * @bytes: number of seen bytes
+ * @packets: number of seen packets
+ */
+struct gnet_stats_basic
+{
+	__u64	bytes;
+	__u32	packets;
+};
+struct gnet_stats_basic_packed
+{
+	__u64	bytes;
+	__u32	packets;
+} __attribute__ ((packed));
+
+/**
+ * struct gnet_stats_rate_est - rate estimator
+ * @bps: current byte rate
+ * @pps: current packet rate
+ */
+struct gnet_stats_rate_est
+{
+	__u32	bps;
+	__u32	pps;
+};
+
+/**
+ * struct gnet_stats_queue - queuing statistics
+ * @qlen: queue length
+ * @backlog: backlog size of queue
+ * @drops: number of dropped packets
+ * @requeues: number of requeues
+ * @overlimits: number of enqueues over the limit
+ */
+struct gnet_stats_queue
+{
+	__u32	qlen;
+	__u32	backlog;
+	__u32	drops;
+	__u32	requeues;
+	__u32	overlimits;
+};
+
+/**
+ * struct gnet_estimator - rate estimator configuration
+ * @interval: sampling period
+ * @ewma_log: the log of measurement window weight
+ */
+struct gnet_estimator
+{
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+
+#endif /* __LINUX_GEN_STATS_H */
diff -uNr linux-2.6.32/usr/include/linux/gfs2_ondisk.h clean_modified/linux-2.6.32/usr/include/linux/gfs2_ondisk.h
--- linux-2.6.32/usr/include/linux/gfs2_ondisk.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/gfs2_ondisk.h	2019-04-14 13:24:02.973979926 -0500
@@ -0,0 +1,473 @@
+/*
+ * Copyright (C) Sistina Software, Inc.  1997-2003 All rights reserved.
+ * Copyright (C) 2004-2006 Red Hat, Inc.  All rights reserved.
+ *
+ * This copyrighted material is made available to anyone wishing to use,
+ * modify, copy, or redistribute it subject to the terms and conditions
+ * of the GNU General Public License v.2.
+ */
+
+#ifndef __GFS2_ONDISK_DOT_H__
+#define __GFS2_ONDISK_DOT_H__
+
+#include <linux/types.h>
+
+#define GFS2_MAGIC		0x01161970
+#define GFS2_BASIC_BLOCK	512
+#define GFS2_BASIC_BLOCK_SHIFT	9
+
+/* Lock numbers of the LM_TYPE_NONDISK type */
+
+#define GFS2_MOUNT_LOCK		0
+#define GFS2_LIVE_LOCK		1
+#define GFS2_TRANS_LOCK		2
+#define GFS2_RENAME_LOCK	3
+
+/* Format numbers for various metadata types */
+
+#define GFS2_FORMAT_NONE	0
+#define GFS2_FORMAT_SB		100
+#define GFS2_FORMAT_RG		200
+#define GFS2_FORMAT_RB		300
+#define GFS2_FORMAT_DI		400
+#define GFS2_FORMAT_IN		500
+#define GFS2_FORMAT_LF		600
+#define GFS2_FORMAT_JD		700
+#define GFS2_FORMAT_LH		800
+#define GFS2_FORMAT_LD		900
+#define GFS2_FORMAT_LB		1000
+#define GFS2_FORMAT_EA		1600
+#define GFS2_FORMAT_ED		1700
+#define GFS2_FORMAT_QC		1400
+/* These are format numbers for entities contained in files */
+#define GFS2_FORMAT_RI		1100
+#define GFS2_FORMAT_DE		1200
+#define GFS2_FORMAT_QU		1500
+/* These are part of the superblock */
+#define GFS2_FORMAT_FS		1801
+#define GFS2_FORMAT_MULTI	1900
+
+/*
+ * An on-disk inode number
+ */
+
+struct gfs2_inum {
+	__be64 no_formal_ino;
+	__be64 no_addr;
+};
+
+/*
+ * Generic metadata head structure
+ * Every inplace buffer logged in the journal must start with this.
+ */
+
+#define GFS2_METATYPE_NONE	0
+#define GFS2_METATYPE_SB	1
+#define GFS2_METATYPE_RG	2
+#define GFS2_METATYPE_RB	3
+#define GFS2_METATYPE_DI	4
+#define GFS2_METATYPE_IN	5
+#define GFS2_METATYPE_LF	6
+#define GFS2_METATYPE_JD	7
+#define GFS2_METATYPE_LH	8
+#define GFS2_METATYPE_LD	9
+#define GFS2_METATYPE_LB	12
+#define GFS2_METATYPE_EA	10
+#define GFS2_METATYPE_ED	11
+#define GFS2_METATYPE_QC	14
+
+struct gfs2_meta_header {
+	__be32 mh_magic;
+	__be32 mh_type;
+	__be64 __pad0;		/* Was generation number in gfs1 */
+	__be32 mh_format;
+	__be32 __pad1;		/* Was incarnation number in gfs1 */
+};
+
+/*
+ * super-block structure
+ *
+ * It's probably good if SIZEOF_SB <= GFS2_BASIC_BLOCK (512 bytes)
+ *
+ * Order is important, need to be able to read old superblocks to do on-disk
+ * version upgrades.
+ */
+
+/* Address of superblock in GFS2 basic blocks */
+#define GFS2_SB_ADDR		128
+
+/* The lock number for the superblock (must be zero) */
+#define GFS2_SB_LOCK		0
+
+/* Requirement:  GFS2_LOCKNAME_LEN % 8 == 0
+   Includes: the fencing zero at the end */
+#define GFS2_LOCKNAME_LEN	64
+
+struct gfs2_sb {
+	struct gfs2_meta_header sb_header;
+
+	__be32 sb_fs_format;
+	__be32 sb_multihost_format;
+	__u32  __pad0;	/* Was superblock flags in gfs1 */
+
+	__be32 sb_bsize;
+	__be32 sb_bsize_shift;
+	__u32 __pad1;	/* Was journal segment size in gfs1 */
+
+	struct gfs2_inum sb_master_dir; /* Was jindex dinode in gfs1 */
+	struct gfs2_inum __pad2; /* Was rindex dinode in gfs1 */
+	struct gfs2_inum sb_root_dir;
+
+	char sb_lockproto[GFS2_LOCKNAME_LEN];
+	char sb_locktable[GFS2_LOCKNAME_LEN];
+
+	struct gfs2_inum __pad3; /* Was quota inode in gfs1 */
+	struct gfs2_inum __pad4; /* Was licence inode in gfs1 */
+#define GFS2_HAS_UUID 1
+	__u8 sb_uuid[16]; /* The UUID, maybe 0 for backwards compat */
+};
+
+/*
+ * resource index structure
+ */
+
+struct gfs2_rindex {
+	__be64 ri_addr;	/* grp block disk address */
+	__be32 ri_length;	/* length of rgrp header in fs blocks */
+	__u32 __pad;
+
+	__be64 ri_data0;	/* first data location */
+	__be32 ri_data;	/* num of data blocks in rgrp */
+
+	__be32 ri_bitbytes;	/* number of bytes in data bitmaps */
+
+	__u8 ri_reserved[64];
+};
+
+/*
+ * resource group header structure
+ */
+
+/* Number of blocks per byte in rgrp */
+#define GFS2_NBBY		4
+#define GFS2_BIT_SIZE		2
+#define GFS2_BIT_MASK		0x00000003
+
+#define GFS2_BLKST_FREE		0
+#define GFS2_BLKST_USED		1
+#define GFS2_BLKST_UNLINKED	2
+#define GFS2_BLKST_DINODE	3
+
+#define GFS2_RGF_JOURNAL	0x00000001
+#define GFS2_RGF_METAONLY	0x00000002
+#define GFS2_RGF_DATAONLY	0x00000004
+#define GFS2_RGF_NOALLOC	0x00000008
+
+struct gfs2_rgrp {
+	struct gfs2_meta_header rg_header;
+
+	__be32 rg_flags;
+	__be32 rg_free;
+	__be32 rg_dinodes;
+	__be32 __pad;
+	__be64 rg_igeneration;
+
+	__u8 rg_reserved[80]; /* Several fields from gfs1 now reserved */
+};
+
+/*
+ * quota linked list: user quotas and group quotas form two separate 
+ * singly linked lists. ll_next stores uids or gids of next quotas in the 
+ * linked list.
+
+Given the uid/gid, how to calculate the quota file offsets for the corresponding
+gfs2_quota structures on disk:
+
+for user quotas, given uid,
+offset = uid * sizeof(struct gfs2_quota);
+
+for group quotas, given gid,
+offset = (gid * sizeof(struct gfs2_quota)) + sizeof(struct gfs2_quota);
+
+
+  uid:0   gid:0       uid:12   gid:12      uid:17   gid:17     uid:5142 gid:5142
++-------+-------+    +-------+-------+    +-------+- - - -+    +- - - -+-------+
+| valid | valid | :: | valid | valid | :: | valid | inval | :: | inval | valid |
++-------+-------+    +-------+-------+    +-------+- - - -+    +- - - -+-------+
+next:12   next:12    next:17 next:5142    next:NULL                    next:NULL
+    |       |            |       |            |<-- user quota list         |
+     \______|___________/ \______|___________/         group quota list -->|
+            |                    |                                         |
+             \__________________/ \_______________________________________/
+
+*/
+
+/*
+ * quota structure
+ */
+
+struct gfs2_quota {
+	__be64 qu_limit;
+	__be64 qu_warn;
+	__be64 qu_value;
+	__be32 qu_ll_next; /* location of next quota in list */
+	__u8 qu_reserved[60];
+};
+
+/*
+ * dinode structure
+ */
+
+#define GFS2_MAX_META_HEIGHT	10
+#define GFS2_DIR_MAX_DEPTH	17
+
+#define DT2IF(dt) (((dt) << 12) & S_IFMT)
+#define IF2DT(sif) (((sif) & S_IFMT) >> 12)
+
+enum {
+	gfs2fl_Jdata		= 0,
+	gfs2fl_ExHash		= 1,
+	gfs2fl_Unused		= 2,
+	gfs2fl_EaIndirect	= 3,
+	gfs2fl_Directio		= 4,
+	gfs2fl_Immutable	= 5,
+	gfs2fl_AppendOnly	= 6,
+	gfs2fl_NoAtime		= 7,
+	gfs2fl_Sync		= 8,
+	gfs2fl_System		= 9,
+	gfs2fl_TruncInProg	= 29,
+	gfs2fl_InheritDirectio	= 30,
+	gfs2fl_InheritJdata	= 31,
+};
+
+/* Dinode flags */
+#define GFS2_DIF_JDATA			0x00000001
+#define GFS2_DIF_EXHASH			0x00000002
+#define GFS2_DIF_UNUSED			0x00000004  /* only in gfs1 */
+#define GFS2_DIF_EA_INDIRECT		0x00000008
+#define GFS2_DIF_DIRECTIO		0x00000010
+#define GFS2_DIF_IMMUTABLE		0x00000020
+#define GFS2_DIF_APPENDONLY		0x00000040
+#define GFS2_DIF_NOATIME		0x00000080
+#define GFS2_DIF_SYNC			0x00000100
+#define GFS2_DIF_SYSTEM			0x00000200 /* New in gfs2 */
+#define GFS2_DIF_TRUNC_IN_PROG		0x20000000 /* New in gfs2 */
+#define GFS2_DIF_INHERIT_DIRECTIO	0x40000000
+#define GFS2_DIF_INHERIT_JDATA		0x80000000
+
+struct gfs2_dinode {
+	struct gfs2_meta_header di_header;
+
+	struct gfs2_inum di_num;
+
+	__be32 di_mode;	/* mode of file */
+	__be32 di_uid;	/* owner's user id */
+	__be32 di_gid;	/* owner's group id */
+	__be32 di_nlink;	/* number of links to this file */
+	__be64 di_size;	/* number of bytes in file */
+	__be64 di_blocks;	/* number of blocks in file */
+	__be64 di_atime;	/* time last accessed */
+	__be64 di_mtime;	/* time last modified */
+	__be64 di_ctime;	/* time last changed */
+	__be32 di_major;	/* device major number */
+	__be32 di_minor;	/* device minor number */
+
+	/* This section varies from gfs1. Padding added to align with
+         * remainder of dinode
+	 */
+	__be64 di_goal_meta;	/* rgrp to alloc from next */
+	__be64 di_goal_data;	/* data block goal */
+	__be64 di_generation;	/* generation number for NFS */
+
+	__be32 di_flags;	/* GFS2_DIF_... */
+	__be32 di_payload_format;  /* GFS2_FORMAT_... */
+	__u16 __pad1;	/* Was ditype in gfs1 */
+	__be16 di_height;	/* height of metadata */
+	__u32 __pad2;	/* Unused incarnation number from gfs1 */
+
+	/* These only apply to directories  */
+	__u16 __pad3;	/* Padding */
+	__be16 di_depth;	/* Number of bits in the table */
+	__be32 di_entries;	/* The number of entries in the directory */
+
+	struct gfs2_inum __pad4; /* Unused even in current gfs1 */
+
+	__be64 di_eattr;	/* extended attribute block number */
+	__be32 di_atime_nsec;   /* nsec portion of atime */
+	__be32 di_mtime_nsec;   /* nsec portion of mtime */
+	__be32 di_ctime_nsec;   /* nsec portion of ctime */
+
+	__u8 di_reserved[44];
+};
+
+/*
+ * directory structure - many of these per directory file
+ */
+
+#define GFS2_FNAMESIZE		255
+#define GFS2_DIRENT_SIZE(name_len) ((sizeof(struct gfs2_dirent) + (name_len) + 7) & ~7)
+
+struct gfs2_dirent {
+	struct gfs2_inum de_inum;
+	__be32 de_hash;
+	__be16 de_rec_len;
+	__be16 de_name_len;
+	__be16 de_type;
+	__u8 __pad[14];
+};
+
+/*
+ * Header of leaf directory nodes
+ */
+
+struct gfs2_leaf {
+	struct gfs2_meta_header lf_header;
+
+	__be16 lf_depth;		/* Depth of leaf */
+	__be16 lf_entries;		/* Number of dirents in leaf */
+	__be32 lf_dirent_format;	/* Format of the dirents */
+	__be64 lf_next;			/* Next leaf, if overflow */
+
+	__u8 lf_reserved[64];
+};
+
+/*
+ * Extended attribute header format
+ *
+ * This works in a similar way to dirents. There is a fixed size header
+ * followed by a variable length section made up of the name and the
+ * associated data. In the case of a "stuffed" entry, the value is
+ * __inline__ directly after the name, the ea_num_ptrs entry will be
+ * zero in that case. For non-"stuffed" entries, there will be
+ * a set of pointers (aligned to 8 byte boundary) to the block(s)
+ * containing the value.
+ *
+ * The blocks containing the values and the blocks containing the
+ * extended attribute headers themselves all start with the common
+ * metadata header. Each inode, if it has extended attributes, will
+ * have either a single block containing the extended attribute headers
+ * or a single indirect block pointing to blocks containing the
+ * extended attribure headers.
+ *
+ * The maximim size of the data part of an extended attribute is 64k
+ * so the number of blocks required depends upon block size. Since the
+ * block size also determines the number of pointers in an indirect
+ * block, its a fairly complicated calculation to work out the maximum
+ * number of blocks that an inode may have relating to extended attributes.
+ *
+ */
+
+#define GFS2_EA_MAX_NAME_LEN	255
+#define GFS2_EA_MAX_DATA_LEN	65536
+
+#define GFS2_EATYPE_UNUSED	0
+#define GFS2_EATYPE_USR		1
+#define GFS2_EATYPE_SYS		2
+#define GFS2_EATYPE_SECURITY	3
+
+#define GFS2_EATYPE_LAST	3
+#define GFS2_EATYPE_VALID(x)	((x) <= GFS2_EATYPE_LAST)
+
+#define GFS2_EAFLAG_LAST	0x01	/* last ea in block */
+
+struct gfs2_ea_header {
+	__be32 ea_rec_len;
+	__be32 ea_data_len;
+	__u8 ea_name_len;	/* no NULL pointer after the string */
+	__u8 ea_type;		/* GFS2_EATYPE_... */
+	__u8 ea_flags;		/* GFS2_EAFLAG_... */
+	__u8 ea_num_ptrs;
+	__u32 __pad;
+};
+
+/*
+ * Log header structure
+ */
+
+#define GFS2_LOG_HEAD_UNMOUNT	0x00000001	/* log is clean */
+
+struct gfs2_log_header {
+	struct gfs2_meta_header lh_header;
+
+	__be64 lh_sequence;	/* Sequence number of this transaction */
+	__be32 lh_flags;	/* GFS2_LOG_HEAD_... */
+	__be32 lh_tail;		/* Block number of log tail */
+	__be32 lh_blkno;
+	__be32 lh_hash;
+};
+
+/*
+ * Log type descriptor
+ */
+
+#define GFS2_LOG_DESC_METADATA	300
+/* ld_data1 is the number of metadata blocks in the descriptor.
+   ld_data2 is unused. */
+
+#define GFS2_LOG_DESC_REVOKE	301
+/* ld_data1 is the number of revoke blocks in the descriptor.
+   ld_data2 is unused. */
+
+#define GFS2_LOG_DESC_JDATA	302
+/* ld_data1 is the number of data blocks in the descriptor.
+   ld_data2 is unused. */
+
+struct gfs2_log_descriptor {
+	struct gfs2_meta_header ld_header;
+
+	__be32 ld_type;		/* GFS2_LOG_DESC_... */
+	__be32 ld_length;	/* Number of buffers in this chunk */
+	__be32 ld_data1;	/* descriptor-specific field */
+	__be32 ld_data2;	/* descriptor-specific field */
+
+	__u8 ld_reserved[32];
+};
+
+/*
+ * Inum Range
+ * Describe a range of formal inode numbers allocated to
+ * one machine to assign to inodes.
+ */
+
+#define GFS2_INUM_QUANTUM	1048576
+
+struct gfs2_inum_range {
+	__be64 ir_start;
+	__be64 ir_length;
+};
+
+/*
+ * Statfs change
+ * Describes an change to the pool of free and allocated
+ * blocks.
+ */
+
+struct gfs2_statfs_change {
+	__be64 sc_total;
+	__be64 sc_free;
+	__be64 sc_dinodes;
+};
+
+/*
+ * Quota change
+ * Describes an allocation change for a particular
+ * user or group.
+ */
+
+#define GFS2_QCF_USER		0x00000001
+
+struct gfs2_quota_change {
+	__be64 qc_change;
+	__be32 qc_flags;	/* GFS2_QCF_... */
+	__be32 qc_id;
+};
+
+struct gfs2_quota_lvb {
+        __be32 qb_magic;
+        __u32 __pad;
+        __be64 qb_limit;      /* Hard limit of # blocks to alloc */
+        __be64 qb_warn;       /* Warn user when alloc is above this # */
+        __be64 qb_value;       /* Current # blocks allocated */
+};
+
+#endif /* __GFS2_ONDISK_DOT_H__ */
diff -uNr linux-2.6.32/usr/include/linux/gigaset_dev.h clean_modified/linux-2.6.32/usr/include/linux/gigaset_dev.h
--- linux-2.6.32/usr/include/linux/gigaset_dev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/gigaset_dev.h	2019-04-14 13:24:02.973979926 -0500
@@ -0,0 +1,30 @@
+/*
+ * interface to user space for the gigaset driver
+ *
+ * Copyright (c) 2004 by Hansjoerg Lipp <hjlipp@web.de>
+ *
+ * =====================================================================
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License as
+ *    published by the Free Software Foundation; either version 2 of
+ *    the License, or (at your option) any later version.
+ * =====================================================================
+ */
+
+#ifndef GIGASET_INTERFACE_H
+#define GIGASET_INTERFACE_H
+
+#include <linux/ioctl.h>
+
+#define GIGASET_IOCTL 0x47
+
+#define GIGVER_DRIVER 0
+#define GIGVER_COMPAT 1
+#define GIGVER_FWBASE 2
+
+#define GIGASET_REDIR    _IOWR (GIGASET_IOCTL, 0, int)
+#define GIGASET_CONFIG   _IOWR (GIGASET_IOCTL, 1, int)
+#define GIGASET_BRKCHARS _IOW  (GIGASET_IOCTL, 2, unsigned char[6]) //FIXME [6] okay?
+#define GIGASET_VERSION  _IOWR (GIGASET_IOCTL, 3, unsigned[4])
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/hayesesp.h clean_modified/linux-2.6.32/usr/include/linux/hayesesp.h
--- linux-2.6.32/usr/include/linux/hayesesp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hayesesp.h	2019-04-14 13:24:02.973979926 -0500
@@ -0,0 +1,17 @@
+#ifndef HAYESESP_H
+#define HAYESESP_H
+
+struct hayes_esp_config {
+	short flow_on;
+	short flow_off;
+	short rx_trigger;
+	short tx_trigger;
+	short pio_threshold;
+	unsigned char rx_timeout;
+	char dma_channel;
+};
+
+
+
+#endif /* ESP_H */
+
diff -uNr linux-2.6.32/usr/include/linux/hdlc/ioctl.h clean_modified/linux-2.6.32/usr/include/linux/hdlc/ioctl.h
--- linux-2.6.32/usr/include/linux/hdlc/ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hdlc/ioctl.h	2019-04-14 13:24:02.974963166 -0500
@@ -0,0 +1,81 @@
+#ifndef __HDLC_IOCTL_H__
+#define __HDLC_IOCTL_H__
+
+
+#define GENERIC_HDLC_VERSION 4	/* For synchronization with sethdlc utility */
+
+#define CLOCK_DEFAULT   0	/* Default setting */
+#define CLOCK_EXT	1	/* External TX and RX clock - DTE */
+#define CLOCK_INT	2	/* Internal TX and RX clock - DCE */
+#define CLOCK_TXINT	3	/* Internal TX and external RX clock */
+#define CLOCK_TXFROMRX	4	/* TX clock derived from external RX clock */
+
+
+#define ENCODING_DEFAULT	0 /* Default setting */
+#define ENCODING_NRZ		1
+#define ENCODING_NRZI		2
+#define ENCODING_FM_MARK	3
+#define ENCODING_FM_SPACE	4
+#define ENCODING_MANCHESTER	5
+
+
+#define PARITY_DEFAULT		0 /* Default setting */
+#define PARITY_NONE		1 /* No parity */
+#define PARITY_CRC16_PR0	2 /* CRC16, initial value 0x0000 */
+#define PARITY_CRC16_PR1	3 /* CRC16, initial value 0xFFFF */
+#define PARITY_CRC16_PR0_CCITT	4 /* CRC16, initial 0x0000, ITU-T version */
+#define PARITY_CRC16_PR1_CCITT	5 /* CRC16, initial 0xFFFF, ITU-T version */
+#define PARITY_CRC32_PR0_CCITT	6 /* CRC32, initial value 0x00000000 */
+#define PARITY_CRC32_PR1_CCITT	7 /* CRC32, initial value 0xFFFFFFFF */
+
+#define LMI_DEFAULT		0 /* Default setting */
+#define LMI_NONE		1 /* No LMI, all PVCs are static */
+#define LMI_ANSI		2 /* ANSI Annex D */
+#define LMI_CCITT		3 /* ITU-T Annex A */
+#define LMI_CISCO		4 /* The "original" LMI, aka Gang of Four */
+
+typedef struct { 
+	unsigned int clock_rate; /* bits per second */
+	unsigned int clock_type; /* internal, external, TX-internal etc. */
+	unsigned short loopback;
+} sync_serial_settings;          /* V.35, V.24, X.21 */
+
+typedef struct { 
+	unsigned int clock_rate; /* bits per second */
+	unsigned int clock_type; /* internal, external, TX-internal etc. */
+	unsigned short loopback;
+	unsigned int slot_map;
+} te1_settings;                  /* T1, E1 */
+
+typedef struct {
+	unsigned short encoding;
+	unsigned short parity;
+} raw_hdlc_proto;
+
+typedef struct {
+	unsigned int t391;
+	unsigned int t392;
+	unsigned int n391;
+	unsigned int n392;
+	unsigned int n393;
+	unsigned short lmi;
+	unsigned short dce; /* 1 for DCE (network side) operation */
+} fr_proto;
+
+typedef struct {
+	unsigned int dlci;
+} fr_proto_pvc;          /* for creating/deleting FR PVCs */
+
+typedef struct {
+	unsigned int dlci;
+	char master[IFNAMSIZ];	/* Name of master FRAD device */
+}fr_proto_pvc_info;		/* for returning PVC information only */
+
+typedef struct {
+    unsigned int interval;
+    unsigned int timeout;
+} cisco_proto;
+
+/* PPP doesn't need any info now - supply length = 0 to ioctl */
+
+#endif /* __HDLC_IOCTL_H__ */
diff -uNr linux-2.6.32/usr/include/linux/hdlcdrv.h clean_modified/linux-2.6.32/usr/include/linux/hdlcdrv.h
--- linux-2.6.32/usr/include/linux/hdlcdrv.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hdlcdrv.h	2019-04-14 13:24:02.975935501 -0500
@@ -0,0 +1,110 @@
+/*
+ * hdlcdrv.h  -- HDLC packet radio network driver.
+ * The Linux soundcard driver for 1200 baud and 9600 baud packet radio
+ * (C) 1996-1998 by Thomas Sailer, HB9JNX/AE4WA
+ */
+
+#ifndef _HDLCDRV_H
+#define _HDLCDRV_H
+
+/* -------------------------------------------------------------------- */
+/*
+ * structs for the IOCTL commands
+ */
+
+struct hdlcdrv_params {
+	int iobase;
+	int irq;
+	int dma;
+	int dma2;
+	int seriobase;
+	int pariobase;
+	int midiiobase;
+};	
+
+struct hdlcdrv_channel_params {
+	int tx_delay;  /* the transmitter keyup delay in 10ms units */
+	int tx_tail;   /* the transmitter keyoff delay in 10ms units */
+	int slottime;  /* the slottime in 10ms; usually 10 = 100ms */
+	int ppersist;  /* the p-persistence 0..255 */
+	int fulldup;   /* some driver do not support full duplex, setting */
+	               /* this just makes them send even if DCD is on */
+};	
+
+struct hdlcdrv_old_channel_state {
+  	int ptt;
+  	int dcd;
+  	int ptt_keyed;
+};
+
+struct hdlcdrv_channel_state {
+ 	int ptt;
+ 	int dcd;
+ 	int ptt_keyed;
+ 	unsigned long tx_packets;
+ 	unsigned long tx_errors;
+ 	unsigned long rx_packets;
+ 	unsigned long rx_errors;
+};
+
+struct hdlcdrv_ioctl {
+	int cmd;
+	union {
+		struct hdlcdrv_params mp;
+		struct hdlcdrv_channel_params cp;
+		struct hdlcdrv_channel_state cs;
+		struct hdlcdrv_old_channel_state ocs;
+		unsigned int calibrate;
+		unsigned char bits;
+		char modename[128];
+		char drivername[32];
+	} data;
+};
+
+/* -------------------------------------------------------------------- */
+
+/*
+ * ioctl values
+ */
+#define HDLCDRVCTL_GETMODEMPAR       0
+#define HDLCDRVCTL_SETMODEMPAR       1
+#define HDLCDRVCTL_MODEMPARMASK      2  /* not handled by hdlcdrv */
+#define HDLCDRVCTL_GETCHANNELPAR    10
+#define HDLCDRVCTL_SETCHANNELPAR    11
+#define HDLCDRVCTL_OLDGETSTAT       20
+#define HDLCDRVCTL_CALIBRATE        21
+#define HDLCDRVCTL_GETSTAT          22
+
+/*
+ * these are mainly for debugging purposes
+ */
+#define HDLCDRVCTL_GETSAMPLES       30
+#define HDLCDRVCTL_GETBITS          31
+
+/*
+ * not handled by hdlcdrv, but by its depending drivers
+ */
+#define HDLCDRVCTL_GETMODE          40
+#define HDLCDRVCTL_SETMODE          41
+#define HDLCDRVCTL_MODELIST         42
+#define HDLCDRVCTL_DRIVERNAME       43
+
+/*
+ * mask of needed modem parameters, returned by HDLCDRVCTL_MODEMPARMASK
+ */
+#define HDLCDRV_PARMASK_IOBASE      (1<<0)
+#define HDLCDRV_PARMASK_IRQ         (1<<1)
+#define HDLCDRV_PARMASK_DMA         (1<<2)
+#define HDLCDRV_PARMASK_DMA2        (1<<3)
+#define HDLCDRV_PARMASK_SERIOBASE   (1<<4)
+#define HDLCDRV_PARMASK_PARIOBASE   (1<<5)
+#define HDLCDRV_PARMASK_MIDIIOBASE  (1<<6)
+
+/* -------------------------------------------------------------------- */
+
+
+/* -------------------------------------------------------------------- */
+
+#endif /* _HDLCDRV_H */
+
+/* -------------------------------------------------------------------- */
diff -uNr linux-2.6.32/usr/include/linux/hdlc.h clean_modified/linux-2.6.32/usr/include/linux/hdlc.h
--- linux-2.6.32/usr/include/linux/hdlc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hdlc.h	2019-04-14 13:24:02.975935501 -0500
@@ -0,0 +1,23 @@
+/*
+ * Generic HDLC support routines for Linux
+ *
+ * Copyright (C) 1999-2005 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#ifndef __HDLC_H
+#define __HDLC_H
+
+
+#define HDLC_MAX_MTU 1500	/* Ethernet 1500 bytes */
+#if 0
+#define HDLC_MAX_MRU (HDLC_MAX_MTU + 10 + 14 + 4) /* for ETH+VLAN over FR */
+#else
+#define HDLC_MAX_MRU 1600 /* as required for FR network */
+#endif
+
+
+#endif /* __HDLC_H */
diff -uNr linux-2.6.32/usr/include/linux/hdreg.h clean_modified/linux-2.6.32/usr/include/linux/hdreg.h
--- linux-2.6.32/usr/include/linux/hdreg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hdreg.h	2019-04-14 13:24:02.976925079 -0500
@@ -0,0 +1,642 @@
+#ifndef _LINUX_HDREG_H
+#define _LINUX_HDREG_H
+
+#include <linux/types.h>
+
+/*
+ * Command Header sizes for IOCTL commands
+ */
+
+#define HDIO_DRIVE_CMD_HDR_SIZE		(4 * sizeof(__u8))
+#define HDIO_DRIVE_HOB_HDR_SIZE		(8 * sizeof(__u8))
+#define HDIO_DRIVE_TASK_HDR_SIZE	(8 * sizeof(__u8))
+
+#define IDE_DRIVE_TASK_NO_DATA		0
+#define IDE_DRIVE_TASK_INVALID		-1
+#define IDE_DRIVE_TASK_SET_XFER		1
+#define IDE_DRIVE_TASK_IN		2
+#define IDE_DRIVE_TASK_OUT		3
+#define IDE_DRIVE_TASK_RAW_WRITE	4
+
+/*
+ * Define standard taskfile in/out register
+ */
+#define IDE_TASKFILE_STD_IN_FLAGS	0xFE
+#define IDE_HOB_STD_IN_FLAGS		0x3C
+#define IDE_TASKFILE_STD_OUT_FLAGS	0xFE
+#define IDE_HOB_STD_OUT_FLAGS		0x3C
+
+typedef unsigned char task_ioreg_t;
+typedef unsigned long sata_ioreg_t;
+
+typedef union ide_reg_valid_s {
+	unsigned all				: 16;
+	struct {
+		unsigned data			: 1;
+		unsigned error_feature		: 1;
+		unsigned sector			: 1;
+		unsigned nsector		: 1;
+		unsigned lcyl			: 1;
+		unsigned hcyl			: 1;
+		unsigned select			: 1;
+		unsigned status_command		: 1;
+
+		unsigned data_hob		: 1;
+		unsigned error_feature_hob	: 1;
+		unsigned sector_hob		: 1;
+		unsigned nsector_hob		: 1;
+		unsigned lcyl_hob		: 1;
+		unsigned hcyl_hob		: 1;
+		unsigned select_hob		: 1;
+		unsigned control_hob		: 1;
+	} b;
+} ide_reg_valid_t;
+
+typedef struct ide_task_request_s {
+	__u8		io_ports[8];
+	__u8		hob_ports[8]; /* bytes 6 and 7 are unused */
+	ide_reg_valid_t	out_flags;
+	ide_reg_valid_t	in_flags;
+	int		data_phase;
+	int		req_cmd;
+	unsigned long	out_size;
+	unsigned long	in_size;
+} ide_task_request_t;
+
+typedef struct ide_ioctl_request_s {
+	ide_task_request_t	*task_request;
+	unsigned char		*out_buffer;
+	unsigned char		*in_buffer;
+} ide_ioctl_request_t;
+
+struct hd_drive_cmd_hdr {
+	__u8 command;
+	__u8 sector_number;
+	__u8 feature;
+	__u8 sector_count;
+};
+
+typedef struct hd_drive_task_hdr {
+	__u8 data;
+	__u8 feature;
+	__u8 sector_count;
+	__u8 sector_number;
+	__u8 low_cylinder;
+	__u8 high_cylinder;
+	__u8 device_head;
+	__u8 command;
+} task_struct_t;
+
+typedef struct hd_drive_hob_hdr {
+	__u8 data;
+	__u8 feature;
+	__u8 sector_count;
+	__u8 sector_number;
+	__u8 low_cylinder;
+	__u8 high_cylinder;
+	__u8 device_head;
+	__u8 control;
+} hob_struct_t;
+
+#define TASKFILE_NO_DATA		0x0000
+
+#define TASKFILE_IN			0x0001
+#define TASKFILE_MULTI_IN		0x0002
+
+#define TASKFILE_OUT			0x0004
+#define TASKFILE_MULTI_OUT		0x0008
+#define TASKFILE_IN_OUT			0x0010
+
+#define TASKFILE_IN_DMA			0x0020
+#define TASKFILE_OUT_DMA		0x0040
+#define TASKFILE_IN_DMAQ		0x0080
+#define TASKFILE_OUT_DMAQ		0x0100
+
+#define TASKFILE_P_IN			0x0200
+#define TASKFILE_P_OUT			0x0400
+#define TASKFILE_P_IN_DMA		0x0800
+#define TASKFILE_P_OUT_DMA		0x1000
+#define TASKFILE_P_IN_DMAQ		0x2000
+#define TASKFILE_P_OUT_DMAQ		0x4000
+#define TASKFILE_48			0x8000
+#define TASKFILE_INVALID		0x7fff
+
+/* ATA/ATAPI Commands pre T13 Spec */
+#define WIN_NOP				0x00
+/*
+ *	0x01->0x02 Reserved
+ */
+#define CFA_REQ_EXT_ERROR_CODE		0x03 /* CFA Request Extended Error Code */
+/*
+ *	0x04->0x07 Reserved
+ */
+#define WIN_SRST			0x08 /* ATAPI soft reset command */
+#define WIN_DEVICE_RESET		0x08
+/*
+ *	0x09->0x0F Reserved
+ */
+#define WIN_RECAL			0x10
+#define WIN_RESTORE			WIN_RECAL
+/*
+ *	0x10->0x1F Reserved
+ */
+#define WIN_READ			0x20 /* 28-Bit */
+#define WIN_READ_ONCE			0x21 /* 28-Bit without retries */
+#define WIN_READ_LONG			0x22 /* 28-Bit */
+#define WIN_READ_LONG_ONCE		0x23 /* 28-Bit without retries */
+#define WIN_READ_EXT			0x24 /* 48-Bit */
+#define WIN_READDMA_EXT			0x25 /* 48-Bit */
+#define WIN_READDMA_QUEUED_EXT		0x26 /* 48-Bit */
+#define WIN_READ_NATIVE_MAX_EXT		0x27 /* 48-Bit */
+/*
+ *	0x28
+ */
+#define WIN_MULTREAD_EXT		0x29 /* 48-Bit */
+/*
+ *	0x2A->0x2F Reserved
+ */
+#define WIN_WRITE			0x30 /* 28-Bit */
+#define WIN_WRITE_ONCE			0x31 /* 28-Bit without retries */
+#define WIN_WRITE_LONG			0x32 /* 28-Bit */
+#define WIN_WRITE_LONG_ONCE		0x33 /* 28-Bit without retries */
+#define WIN_WRITE_EXT			0x34 /* 48-Bit */
+#define WIN_WRITEDMA_EXT		0x35 /* 48-Bit */
+#define WIN_WRITEDMA_QUEUED_EXT		0x36 /* 48-Bit */
+#define WIN_SET_MAX_EXT			0x37 /* 48-Bit */
+#define CFA_WRITE_SECT_WO_ERASE		0x38 /* CFA Write Sectors without erase */
+#define WIN_MULTWRITE_EXT		0x39 /* 48-Bit */
+/*
+ *	0x3A->0x3B Reserved
+ */
+#define WIN_WRITE_VERIFY		0x3C /* 28-Bit */
+/*
+ *	0x3D->0x3F Reserved
+ */
+#define WIN_VERIFY			0x40 /* 28-Bit - Read Verify Sectors */
+#define WIN_VERIFY_ONCE			0x41 /* 28-Bit - without retries */
+#define WIN_VERIFY_EXT			0x42 /* 48-Bit */
+/*
+ *	0x43->0x4F Reserved
+ */
+#define WIN_FORMAT			0x50
+/*
+ *	0x51->0x5F Reserved
+ */
+#define WIN_INIT			0x60
+/*
+ *	0x61->0x5F Reserved
+ */
+#define WIN_SEEK			0x70 /* 0x70-0x7F Reserved */
+
+#define CFA_TRANSLATE_SECTOR		0x87 /* CFA Translate Sector */
+#define WIN_DIAGNOSE			0x90
+#define WIN_SPECIFY			0x91 /* set drive geometry translation */
+#define WIN_DOWNLOAD_MICROCODE		0x92
+#define WIN_STANDBYNOW2			0x94
+#define WIN_STANDBY2			0x96
+#define WIN_SETIDLE2			0x97
+#define WIN_CHECKPOWERMODE2		0x98
+#define WIN_SLEEPNOW2			0x99
+/*
+ *	0x9A VENDOR
+ */
+#define WIN_PACKETCMD			0xA0 /* Send a packet command. */
+#define WIN_PIDENTIFY			0xA1 /* identify ATAPI device	*/
+#define WIN_QUEUED_SERVICE		0xA2
+#define WIN_SMART			0xB0 /* self-monitoring and reporting */
+#define CFA_ERASE_SECTORS		0xC0
+#define WIN_MULTREAD			0xC4 /* read sectors using multiple mode*/
+#define WIN_MULTWRITE			0xC5 /* write sectors using multiple mode */
+#define WIN_SETMULT			0xC6 /* enable/disable multiple mode */
+#define WIN_READDMA_QUEUED		0xC7 /* read sectors using Queued DMA transfers */
+#define WIN_READDMA			0xC8 /* read sectors using DMA transfers */
+#define WIN_READDMA_ONCE		0xC9 /* 28-Bit - without retries */
+#define WIN_WRITEDMA			0xCA /* write sectors using DMA transfers */
+#define WIN_WRITEDMA_ONCE		0xCB /* 28-Bit - without retries */
+#define WIN_WRITEDMA_QUEUED		0xCC /* write sectors using Queued DMA transfers */
+#define CFA_WRITE_MULTI_WO_ERASE	0xCD /* CFA Write multiple without erase */
+#define WIN_GETMEDIASTATUS		0xDA
+#define WIN_ACKMEDIACHANGE		0xDB /* ATA-1, ATA-2 vendor */
+#define WIN_POSTBOOT			0xDC
+#define WIN_PREBOOT 			0xDD
+#define WIN_DOORLOCK			0xDE /* lock door on removable drives */
+#define WIN_DOORUNLOCK			0xDF /* unlock door on removable drives */
+#define WIN_STANDBYNOW1			0xE0
+#define WIN_IDLEIMMEDIATE		0xE1 /* force drive to become "ready" */
+#define WIN_STANDBY			0xE2 /* Set device in Standby Mode */
+#define WIN_SETIDLE1			0xE3
+#define WIN_READ_BUFFER			0xE4 /* force read only 1 sector */
+#define WIN_CHECKPOWERMODE1		0xE5
+#define WIN_SLEEPNOW1			0xE6
+#define WIN_FLUSH_CACHE			0xE7
+#define WIN_WRITE_BUFFER		0xE8 /* force write only 1 sector */
+#define WIN_WRITE_SAME			0xE9 /* read ata-2 to use */
+	/* SET_FEATURES 0x22 or 0xDD */
+#define WIN_FLUSH_CACHE_EXT		0xEA /* 48-Bit */
+#define WIN_IDENTIFY			0xEC /* ask drive to identify itself	*/
+#define WIN_MEDIAEJECT			0xED
+#define WIN_IDENTIFY_DMA		0xEE /* same as WIN_IDENTIFY, but DMA */
+#define WIN_SETFEATURES			0xEF /* set special drive features */
+#define EXABYTE_ENABLE_NEST		0xF0
+#define WIN_SECURITY_SET_PASS		0xF1
+#define WIN_SECURITY_UNLOCK		0xF2
+#define WIN_SECURITY_ERASE_PREPARE	0xF3
+#define WIN_SECURITY_ERASE_UNIT		0xF4
+#define WIN_SECURITY_FREEZE_LOCK	0xF5
+#define WIN_SECURITY_DISABLE		0xF6
+#define WIN_READ_NATIVE_MAX		0xF8 /* return the native maximum address */
+#define WIN_SET_MAX			0xF9
+#define DISABLE_SEAGATE			0xFB
+
+/* WIN_SMART sub-commands */
+
+#define SMART_READ_VALUES		0xD0
+#define SMART_READ_THRESHOLDS		0xD1
+#define SMART_AUTOSAVE			0xD2
+#define SMART_SAVE			0xD3
+#define SMART_IMMEDIATE_OFFLINE		0xD4
+#define SMART_READ_LOG_SECTOR		0xD5
+#define SMART_WRITE_LOG_SECTOR		0xD6
+#define SMART_WRITE_THRESHOLDS		0xD7
+#define SMART_ENABLE			0xD8
+#define SMART_DISABLE			0xD9
+#define SMART_STATUS			0xDA
+#define SMART_AUTO_OFFLINE		0xDB
+
+/* Password used in TF4 & TF5 executing SMART commands */
+
+#define SMART_LCYL_PASS			0x4F
+#define SMART_HCYL_PASS			0xC2
+
+/* WIN_SETFEATURES sub-commands */
+#define SETFEATURES_EN_8BIT	0x01	/* Enable 8-Bit Transfers */
+#define SETFEATURES_EN_WCACHE	0x02	/* Enable write cache */
+#define SETFEATURES_DIS_DEFECT	0x04	/* Disable Defect Management */
+#define SETFEATURES_EN_APM	0x05	/* Enable advanced power management */
+#define SETFEATURES_EN_SAME_R	0x22	/* for a region ATA-1 */
+#define SETFEATURES_DIS_MSN	0x31	/* Disable Media Status Notification */
+#define SETFEATURES_DIS_RETRY	0x33	/* Disable Retry */
+#define SETFEATURES_EN_AAM	0x42	/* Enable Automatic Acoustic Management */
+#define SETFEATURES_RW_LONG	0x44	/* Set Length of VS bytes */
+#define SETFEATURES_SET_CACHE	0x54	/* Set Cache segments to SC Reg. Val */
+#define SETFEATURES_DIS_RLA	0x55	/* Disable read look-ahead feature */
+#define SETFEATURES_EN_RI	0x5D	/* Enable release interrupt */
+#define SETFEATURES_EN_SI	0x5E	/* Enable SERVICE interrupt */
+#define SETFEATURES_DIS_RPOD	0x66	/* Disable reverting to power on defaults */
+#define SETFEATURES_DIS_ECC	0x77	/* Disable ECC byte count */
+#define SETFEATURES_DIS_8BIT	0x81	/* Disable 8-Bit Transfers */
+#define SETFEATURES_DIS_WCACHE	0x82	/* Disable write cache */
+#define SETFEATURES_EN_DEFECT	0x84	/* Enable Defect Management */
+#define SETFEATURES_DIS_APM	0x85	/* Disable advanced power management */
+#define SETFEATURES_EN_ECC	0x88	/* Enable ECC byte count */
+#define SETFEATURES_EN_MSN	0x95	/* Enable Media Status Notification */
+#define SETFEATURES_EN_RETRY	0x99	/* Enable Retry */
+#define SETFEATURES_EN_RLA	0xAA	/* Enable read look-ahead feature */
+#define SETFEATURES_PREFETCH	0xAB	/* Sets drive prefetch value */
+#define SETFEATURES_EN_REST	0xAC	/* ATA-1 */
+#define SETFEATURES_4B_RW_LONG	0xBB	/* Set Length of 4 bytes */
+#define SETFEATURES_DIS_AAM	0xC2	/* Disable Automatic Acoustic Management */
+#define SETFEATURES_EN_RPOD	0xCC	/* Enable reverting to power on defaults */
+#define SETFEATURES_DIS_RI	0xDD	/* Disable release interrupt ATAPI */
+#define SETFEATURES_EN_SAME_M	0xDD	/* for a entire device ATA-1 */
+#define SETFEATURES_DIS_SI	0xDE	/* Disable SERVICE interrupt ATAPI */
+
+/* WIN_SECURITY sub-commands */
+
+#define SECURITY_SET_PASSWORD		0xBA
+#define SECURITY_UNLOCK			0xBB
+#define SECURITY_ERASE_PREPARE		0xBC
+#define SECURITY_ERASE_UNIT		0xBD
+#define SECURITY_FREEZE_LOCK		0xBE
+#define SECURITY_DISABLE_PASSWORD	0xBF
+
+struct hd_geometry {
+      unsigned char heads;
+      unsigned char sectors;
+      unsigned short cylinders;
+      unsigned long start;
+};
+
+/* hd/ide ctl's that pass (arg) ptrs to user space are numbered 0x030n/0x031n */
+#define HDIO_GETGEO		0x0301	/* get device geometry */
+#define HDIO_GET_UNMASKINTR	0x0302	/* get current unmask setting */
+#define HDIO_GET_MULTCOUNT	0x0304	/* get current IDE blockmode setting */
+#define HDIO_GET_QDMA		0x0305	/* get use-qdma flag */
+
+#define HDIO_SET_XFER		0x0306  /* set transfer rate via proc */
+
+#define HDIO_OBSOLETE_IDENTITY	0x0307	/* OBSOLETE, DO NOT USE: returns 142 bytes */
+#define HDIO_GET_KEEPSETTINGS	0x0308	/* get keep-settings-on-reset flag */
+#define HDIO_GET_32BIT		0x0309	/* get current io_32bit setting */
+#define HDIO_GET_NOWERR		0x030a	/* get ignore-write-error flag */
+#define HDIO_GET_DMA		0x030b	/* get use-dma flag */
+#define HDIO_GET_NICE		0x030c	/* get nice flags */
+#define HDIO_GET_IDENTITY	0x030d	/* get IDE identification info */
+#define HDIO_GET_WCACHE		0x030e	/* get write cache mode on|off */
+#define HDIO_GET_ACOUSTIC	0x030f	/* get acoustic value */
+#define	HDIO_GET_ADDRESS	0x0310	/* */
+
+#define HDIO_GET_BUSSTATE	0x031a	/* get the bus state of the hwif */
+#define HDIO_TRISTATE_HWIF	0x031b	/* execute a channel tristate */
+#define HDIO_DRIVE_RESET	0x031c	/* execute a device reset */
+#define HDIO_DRIVE_TASKFILE	0x031d	/* execute raw taskfile */
+#define HDIO_DRIVE_TASK		0x031e	/* execute task and special drive command */
+#define HDIO_DRIVE_CMD		0x031f	/* execute a special drive command */
+#define HDIO_DRIVE_CMD_AEB	HDIO_DRIVE_TASK
+
+/* hd/ide ctl's that pass (arg) non-ptr values are numbered 0x032n/0x033n */
+#define HDIO_SET_MULTCOUNT	0x0321	/* change IDE blockmode */
+#define HDIO_SET_UNMASKINTR	0x0322	/* permit other irqs during I/O */
+#define HDIO_SET_KEEPSETTINGS	0x0323	/* keep ioctl settings on reset */
+#define HDIO_SET_32BIT		0x0324	/* change io_32bit flags */
+#define HDIO_SET_NOWERR		0x0325	/* change ignore-write-error flag */
+#define HDIO_SET_DMA		0x0326	/* change use-dma flag */
+#define HDIO_SET_PIO_MODE	0x0327	/* reconfig interface to new speed */
+#define HDIO_SCAN_HWIF		0x0328	/* register and (re)scan interface */
+#define HDIO_UNREGISTER_HWIF	0x032a  /* unregister interface */
+#define HDIO_SET_NICE		0x0329	/* set nice flags */
+#define HDIO_SET_WCACHE		0x032b	/* change write cache enable-disable */
+#define HDIO_SET_ACOUSTIC	0x032c	/* change acoustic behavior */
+#define HDIO_SET_BUSSTATE	0x032d	/* set the bus state of the hwif */
+#define HDIO_SET_QDMA		0x032e	/* change use-qdma flag */
+#define HDIO_SET_ADDRESS	0x032f	/* change lba addressing modes */
+
+/* bus states */
+enum {
+	BUSSTATE_OFF = 0,
+	BUSSTATE_ON,
+	BUSSTATE_TRISTATE
+};
+
+/* hd/ide ctl's that pass (arg) ptrs to user space are numbered 0x033n/0x033n */
+/* 0x330 is reserved - used to be HDIO_GETGEO_BIG */
+/* 0x331 is reserved - used to be HDIO_GETGEO_BIG_RAW */
+/* 0x338 is reserved - used to be HDIO_SET_IDE_SCSI */
+/* 0x339 is reserved - used to be HDIO_SET_SCSI_IDE */
+
+#define __NEW_HD_DRIVE_ID
+
+/*
+ * Structure returned by HDIO_GET_IDENTITY, as per ANSI NCITS ATA6 rev.1b spec.
+ *
+ * If you change something here, please remember to update fix_driveid() in
+ * ide/probe.c.
+ */
+struct hd_driveid {
+	unsigned short	config;		/* lots of obsolete bit flags */
+	unsigned short	cyls;		/* Obsolete, "physical" cyls */
+	unsigned short	reserved2;	/* reserved (word 2) */
+	unsigned short	heads;		/* Obsolete, "physical" heads */
+	unsigned short	track_bytes;	/* unformatted bytes per track */
+	unsigned short	sector_bytes;	/* unformatted bytes per sector */
+	unsigned short	sectors;	/* Obsolete, "physical" sectors per track */
+	unsigned short	vendor0;	/* vendor unique */
+	unsigned short	vendor1;	/* vendor unique */
+	unsigned short	vendor2;	/* Retired vendor unique */
+	unsigned char	serial_no[20];	/* 0 = not_specified */
+	unsigned short	buf_type;	/* Retired */
+	unsigned short	buf_size;	/* Retired, 512 byte increments
+					 * 0 = not_specified
+					 */
+	unsigned short	ecc_bytes;	/* for r/w long cmds; 0 = not_specified */
+	unsigned char	fw_rev[8];	/* 0 = not_specified */
+	unsigned char	model[40];	/* 0 = not_specified */
+	unsigned char	max_multsect;	/* 0=not_implemented */
+	unsigned char	vendor3;	/* vendor unique */
+	unsigned short	dword_io;	/* 0=not_implemented; 1=implemented */
+	unsigned char	vendor4;	/* vendor unique */
+	unsigned char	capability;	/* (upper byte of word 49)
+					 *  3:	IORDYsup
+					 *  2:	IORDYsw
+					 *  1:	LBA
+					 *  0:	DMA
+					 */
+	unsigned short	reserved50;	/* reserved (word 50) */
+	unsigned char	vendor5;	/* Obsolete, vendor unique */
+	unsigned char	tPIO;		/* Obsolete, 0=slow, 1=medium, 2=fast */
+	unsigned char	vendor6;	/* Obsolete, vendor unique */
+	unsigned char	tDMA;		/* Obsolete, 0=slow, 1=medium, 2=fast */
+	unsigned short	field_valid;	/* (word 53)
+					 *  2:	ultra_ok	word  88
+					 *  1:	eide_ok		words 64-70
+					 *  0:	cur_ok		words 54-58
+					 */
+	unsigned short	cur_cyls;	/* Obsolete, logical cylinders */
+	unsigned short	cur_heads;	/* Obsolete, l heads */
+	unsigned short	cur_sectors;	/* Obsolete, l sectors per track */
+	unsigned short	cur_capacity0;	/* Obsolete, l total sectors on drive */
+	unsigned short	cur_capacity1;	/* Obsolete, (2 words, misaligned int)     */
+	unsigned char	multsect;	/* current multiple sector count */
+	unsigned char	multsect_valid;	/* when (bit0==1) multsect is ok */
+	unsigned int	lba_capacity;	/* Obsolete, total number of sectors */
+	unsigned short	dma_1word;	/* Obsolete, single-word dma info */
+	unsigned short	dma_mword;	/* multiple-word dma info */
+	unsigned short  eide_pio_modes; /* bits 0:mode3 1:mode4 */
+	unsigned short  eide_dma_min;	/* min mword dma cycle time (ns) */
+	unsigned short  eide_dma_time;	/* recommended mword dma cycle time (ns) */
+	unsigned short  eide_pio;       /* min cycle time (ns), no IORDY  */
+	unsigned short  eide_pio_iordy; /* min cycle time (ns), with IORDY */
+	unsigned short	words69_70[2];	/* reserved words 69-70
+					 * future command overlap and queuing
+					 */
+	unsigned short	words71_74[4];	/* reserved words 71-74
+					 * for IDENTIFY PACKET DEVICE command
+					 */
+	unsigned short  queue_depth;	/* (word 75)
+					 * 15:5	reserved
+					 *  4:0	Maximum queue depth -1
+					 */
+	unsigned short  words76_79[4];	/* reserved words 76-79 */
+	unsigned short  major_rev_num;	/* (word 80) */
+	unsigned short  minor_rev_num;	/* (word 81) */
+	unsigned short  command_set_1;	/* (word 82) supported
+					 * 15:	Obsolete
+					 * 14:	NOP command
+					 * 13:	READ_BUFFER
+					 * 12:	WRITE_BUFFER
+					 * 11:	Obsolete
+					 * 10:	Host Protected Area
+					 *  9:	DEVICE Reset
+					 *  8:	SERVICE Interrupt
+					 *  7:	Release Interrupt
+					 *  6:	look-ahead
+					 *  5:	write cache
+					 *  4:	PACKET Command
+					 *  3:	Power Management Feature Set
+					 *  2:	Removable Feature Set
+					 *  1:	Security Feature Set
+					 *  0:	SMART Feature Set
+					 */
+	unsigned short  command_set_2;	/* (word 83)
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:	FLUSH CACHE EXT
+					 * 12:	FLUSH CACHE
+					 * 11:	Device Configuration Overlay
+					 * 10:	48-bit Address Feature Set
+					 *  9:	Automatic Acoustic Management
+					 *  8:	SET MAX security
+					 *  7:	reserved 1407DT PARTIES
+					 *  6:	SetF sub-command Power-Up
+					 *  5:	Power-Up in Standby Feature Set
+					 *  4:	Removable Media Notification
+					 *  3:	APM Feature Set
+					 *  2:	CFA Feature Set
+					 *  1:	READ/WRITE DMA QUEUED
+					 *  0:	Download MicroCode
+					 */
+	unsigned short  cfsse;		/* (word 84)
+					 * cmd set-feature supported extensions
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:6	reserved
+					 *  5:	General Purpose Logging
+					 *  4:	Streaming Feature Set
+					 *  3:	Media Card Pass Through
+					 *  2:	Media Serial Number Valid
+					 *  1:	SMART selt-test supported
+					 *  0:	SMART error logging
+					 */
+	unsigned short  cfs_enable_1;	/* (word 85)
+					 * command set-feature enabled
+					 * 15:	Obsolete
+					 * 14:	NOP command
+					 * 13:	READ_BUFFER
+					 * 12:	WRITE_BUFFER
+					 * 11:	Obsolete
+					 * 10:	Host Protected Area
+					 *  9:	DEVICE Reset
+					 *  8:	SERVICE Interrupt
+					 *  7:	Release Interrupt
+					 *  6:	look-ahead
+					 *  5:	write cache
+					 *  4:	PACKET Command
+					 *  3:	Power Management Feature Set
+					 *  2:	Removable Feature Set
+					 *  1:	Security Feature Set
+					 *  0:	SMART Feature Set
+					 */
+	unsigned short  cfs_enable_2;	/* (word 86)
+					 * command set-feature enabled
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:	FLUSH CACHE EXT
+					 * 12:	FLUSH CACHE
+					 * 11:	Device Configuration Overlay
+					 * 10:	48-bit Address Feature Set
+					 *  9:	Automatic Acoustic Management
+					 *  8:	SET MAX security
+					 *  7:	reserved 1407DT PARTIES
+					 *  6:	SetF sub-command Power-Up
+					 *  5:	Power-Up in Standby Feature Set
+					 *  4:	Removable Media Notification
+					 *  3:	APM Feature Set
+					 *  2:	CFA Feature Set
+					 *  1:	READ/WRITE DMA QUEUED
+					 *  0:	Download MicroCode
+					 */
+	unsigned short  csf_default;	/* (word 87)
+					 * command set-feature default
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:6	reserved
+					 *  5:	General Purpose Logging enabled
+					 *  4:	Valid CONFIGURE STREAM executed
+					 *  3:	Media Card Pass Through enabled
+					 *  2:	Media Serial Number Valid
+					 *  1:	SMART selt-test supported
+					 *  0:	SMART error logging
+					 */
+	unsigned short  dma_ultra;	/* (word 88) */
+	unsigned short	trseuc;		/* time required for security erase */
+	unsigned short	trsEuc;		/* time required for enhanced erase */
+	unsigned short	CurAPMvalues;	/* current APM values */
+	unsigned short	mprc;		/* master password revision code */
+	unsigned short	hw_config;	/* hardware config (word 93)
+					 * 15:	Shall be ZERO
+					 * 14:	Shall be ONE
+					 * 13:
+					 * 12:
+					 * 11:
+					 * 10:
+					 *  9:
+					 *  8:
+					 *  7:
+					 *  6:
+					 *  5:
+					 *  4:
+					 *  3:
+					 *  2:
+					 *  1:
+					 *  0:	Shall be ONE
+					 */
+	unsigned short	acoustic;	/* (word 94)
+					 * 15:8	Vendor's recommended value
+					 *  7:0	current value
+					 */
+	unsigned short	msrqs;		/* min stream request size */
+	unsigned short	sxfert;		/* stream transfer time */
+	unsigned short	sal;		/* stream access latency */
+	unsigned int	spg;		/* stream performance granularity */
+	unsigned long long lba_capacity_2;/* 48-bit total number of sectors */
+	unsigned short	words104_125[22];/* reserved words 104-125 */
+	unsigned short	last_lun;	/* (word 126) */
+	unsigned short	word127;	/* (word 127) Feature Set
+					 * Removable Media Notification
+					 * 15:2	reserved
+					 *  1:0	00 = not supported
+					 *	01 = supported
+					 *	10 = reserved
+					 *	11 = reserved
+					 */
+	unsigned short	dlf;		/* (word 128)
+					 * device lock function
+					 * 15:9	reserved
+					 *  8	security level 1:max 0:high
+					 *  7:6	reserved
+					 *  5	enhanced erase
+					 *  4	expire
+					 *  3	frozen
+					 *  2	locked
+					 *  1	en/disabled
+					 *  0	capability
+					 */
+	unsigned short  csfo;		/*  (word 129)
+					 * current set features options
+					 * 15:4	reserved
+					 *  3:	auto reassign
+					 *  2:	reverting
+					 *  1:	read-look-ahead
+					 *  0:	write cache
+					 */
+	unsigned short	words130_155[26];/* reserved vendor words 130-155 */
+	unsigned short	word156;	/* reserved vendor word 156 */
+	unsigned short	words157_159[3];/* reserved vendor words 157-159 */
+	unsigned short	cfa_power;	/* (word 160) CFA Power Mode
+					 * 15 word 160 supported
+					 * 14 reserved
+					 * 13
+					 * 12
+					 * 11:0
+					 */
+	unsigned short	words161_175[15];/* Reserved for CFA */
+	unsigned short	words176_205[30];/* Current Media Serial Number */
+	unsigned short	words206_254[49];/* reserved words 206-254 */
+	unsigned short	integrity_word;	/* (word 255)
+					 * 15:8 Checksum
+					 *  7:0 Signature
+					 */
+};
+
+/*
+ * IDE "nice" flags. These are used on a per drive basis to determine
+ * when to be nice and give more bandwidth to the other devices which
+ * share the same IDE bus.
+ */
+#define IDE_NICE_DSC_OVERLAP	(0)	/* per the DSC overlap protocol */
+#define IDE_NICE_ATAPI_OVERLAP	(1)	/* not supported yet */
+#define IDE_NICE_1		(3)	/* when probably won't affect us much */
+#define IDE_NICE_0		(2)	/* when sure that it won't affect us */
+#define IDE_NICE_2		(4)	/* when we know it's on our expense */
+
+#endif	/* _LINUX_HDREG_H */
diff -uNr linux-2.6.32/usr/include/linux/hiddev.h clean_modified/linux-2.6.32/usr/include/linux/hiddev.h
--- linux-2.6.32/usr/include/linux/hiddev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hiddev.h	2019-04-14 13:24:02.976925079 -0500
@@ -0,0 +1,212 @@
+#ifndef _HIDDEV_H
+#define _HIDDEV_H
+
+/*
+ *  Copyright (c) 1999-2000 Vojtech Pavlik
+ *
+ *  Sponsored by SuSE
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/types.h>
+
+/*
+ * The event structure itself
+ */
+
+struct hiddev_event {
+	unsigned hid;
+	signed int value;
+};
+
+struct hiddev_devinfo {
+	__u32 bustype;
+	__u32 busnum;
+	__u32 devnum;
+	__u32 ifnum;
+	__s16 vendor;
+	__s16 product;
+	__s16 version;
+	__u32 num_applications;
+};
+
+struct hiddev_collection_info {
+	__u32 index;
+	__u32 type;
+	__u32 usage;
+	__u32 level;
+};
+
+#define HID_STRING_SIZE 256
+struct hiddev_string_descriptor {
+	__s32 index;
+	char value[HID_STRING_SIZE];
+};
+
+struct hiddev_report_info {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 num_fields;
+};
+
+/* To do a GUSAGE/SUSAGE, fill in at least usage_code,  report_type and 
+ * report_id.  Set report_id to REPORT_ID_UNKNOWN if the rest of the fields 
+ * are unknown.  Otherwise use a usage_ref struct filled in from a previous 
+ * successful GUSAGE call to save time.  To actually send a value to the
+ * device, perform a SUSAGE first, followed by a SREPORT.  An INITREPORT or a
+ * GREPORT isn't necessary for a GUSAGE to return valid data.
+ */
+#define HID_REPORT_ID_UNKNOWN 0xffffffff
+#define HID_REPORT_ID_FIRST   0x00000100
+#define HID_REPORT_ID_NEXT    0x00000200
+#define HID_REPORT_ID_MASK    0x000000ff
+#define HID_REPORT_ID_MAX     0x000000ff
+
+#define HID_REPORT_TYPE_INPUT	1
+#define HID_REPORT_TYPE_OUTPUT	2
+#define HID_REPORT_TYPE_FEATURE	3
+#define HID_REPORT_TYPE_MIN     1
+#define HID_REPORT_TYPE_MAX     3
+
+struct hiddev_field_info {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 field_index;
+	__u32 maxusage;
+	__u32 flags;
+	__u32 physical;		/* physical usage for this field */
+	__u32 logical;		/* logical usage for this field */
+	__u32 application;		/* application usage for this field */
+	__s32 logical_minimum;
+	__s32 logical_maximum;
+	__s32 physical_minimum;
+	__s32 physical_maximum;
+	__u32 unit_exponent;
+	__u32 unit;
+};
+
+/* Fill in report_type, report_id and field_index to get the information on a
+ * field.
+ */
+#define HID_FIELD_CONSTANT		0x001
+#define HID_FIELD_VARIABLE		0x002
+#define HID_FIELD_RELATIVE		0x004
+#define HID_FIELD_WRAP			0x008	
+#define HID_FIELD_NONLINEAR		0x010
+#define HID_FIELD_NO_PREFERRED		0x020
+#define HID_FIELD_NULL_STATE		0x040
+#define HID_FIELD_VOLATILE		0x080
+#define HID_FIELD_BUFFERED_BYTE		0x100
+
+struct hiddev_usage_ref {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 field_index;
+	__u32 usage_index;
+	__u32 usage_code;
+	__s32 value;
+};
+
+/* hiddev_usage_ref_multi is used for sending multiple bytes to a control.
+ * It really manifests itself as setting the value of consecutive usages */
+#define HID_MAX_MULTI_USAGES 1024
+struct hiddev_usage_ref_multi {
+	struct hiddev_usage_ref uref;
+	__u32 num_values;
+	__s32 values[HID_MAX_MULTI_USAGES];
+};
+
+/* FIELD_INDEX_NONE is returned in read() data from the kernel when flags
+ * is set to (HIDDEV_FLAG_UREF | HIDDEV_FLAG_REPORT) and a new report has
+ * been sent by the device 
+ */
+#define HID_FIELD_INDEX_NONE 0xffffffff
+
+/*
+ * Protocol version.
+ */
+
+#define HID_VERSION		0x010004
+
+/*
+ * IOCTLs (0x00 - 0x7f)
+ */
+
+#define HIDIOCGVERSION		_IOR('H', 0x01, int)
+#define HIDIOCAPPLICATION	_IO('H', 0x02)
+#define HIDIOCGDEVINFO		_IOR('H', 0x03, struct hiddev_devinfo)
+#define HIDIOCGSTRING		_IOR('H', 0x04, struct hiddev_string_descriptor)
+#define HIDIOCINITREPORT	_IO('H', 0x05)
+#define HIDIOCGNAME(len)	_IOC(_IOC_READ, 'H', 0x06, len)
+#define HIDIOCGREPORT		_IOW('H', 0x07, struct hiddev_report_info)
+#define HIDIOCSREPORT		_IOW('H', 0x08, struct hiddev_report_info)
+#define HIDIOCGREPORTINFO	_IOWR('H', 0x09, struct hiddev_report_info)
+#define HIDIOCGFIELDINFO	_IOWR('H', 0x0A, struct hiddev_field_info)
+#define HIDIOCGUSAGE		_IOWR('H', 0x0B, struct hiddev_usage_ref)
+#define HIDIOCSUSAGE		_IOW('H', 0x0C, struct hiddev_usage_ref)
+#define HIDIOCGUCODE		_IOWR('H', 0x0D, struct hiddev_usage_ref)
+#define HIDIOCGFLAG		_IOR('H', 0x0E, int)
+#define HIDIOCSFLAG		_IOW('H', 0x0F, int)
+#define HIDIOCGCOLLECTIONINDEX	_IOW('H', 0x10, struct hiddev_usage_ref)
+#define HIDIOCGCOLLECTIONINFO	_IOWR('H', 0x11, struct hiddev_collection_info)
+#define HIDIOCGPHYS(len)	_IOC(_IOC_READ, 'H', 0x12, len)
+
+/* For writing/reading to multiple/consecutive usages */
+#define HIDIOCGUSAGES		_IOWR('H', 0x13, struct hiddev_usage_ref_multi)
+#define HIDIOCSUSAGES		_IOW('H', 0x14, struct hiddev_usage_ref_multi)
+
+/* 
+ * Flags to be used in HIDIOCSFLAG
+ */
+#define HIDDEV_FLAG_UREF	0x1
+#define HIDDEV_FLAG_REPORT	0x2
+#define HIDDEV_FLAGS		0x3
+
+/* To traverse the input report descriptor info for a HID device, perform the 
+ * following:
+ *
+ * rinfo.report_type = HID_REPORT_TYPE_INPUT;
+ * rinfo.report_id = HID_REPORT_ID_FIRST;
+ * ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
+ *
+ * while (ret >= 0) {
+ * 	for (i = 0; i < rinfo.num_fields; i++) {
+ * 		finfo.report_type = rinfo.report_type;
+ * 		finfo.report_id = rinfo.report_id;
+ * 		finfo.field_index = i;
+ * 		ioctl(fd, HIDIOCGFIELDINFO, &finfo);
+ * 		for (j = 0; j < finfo.maxusage; j++) {
+ * 			uref.report_type = rinfo.report_type;
+ * 			uref.report_id = rinfo.report_id;
+ * 			uref.field_index = i;
+ * 			uref.usage_index = j;
+ * 			ioctl(fd, HIDIOCGUCODE, &uref);
+ * 			ioctl(fd, HIDIOCGUSAGE, &uref);
+ * 		}
+ * 	}
+ * 	rinfo.report_id |= HID_REPORT_ID_NEXT;
+ * 	ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
+ * }
+ */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/hid.h clean_modified/linux-2.6.32/usr/include/linux/hid.h
--- linux-2.6.32/usr/include/linux/hid.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hid.h	2019-04-14 13:24:02.977881364 -0500
@@ -0,0 +1,67 @@
+#ifndef __HID_H
+#define __HID_H
+
+/*
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2001 Vojtech Pavlik
+ *  Copyright (c) 2006-2007 Jiri Kosina
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+/*
+ * USB HID (Human Interface Device) interface class code
+ */
+
+#define USB_INTERFACE_CLASS_HID		3
+
+/*
+ * USB HID interface subclass and protocol codes
+ */
+
+#define USB_INTERFACE_SUBCLASS_BOOT	1
+#define USB_INTERFACE_PROTOCOL_KEYBOARD	1
+#define USB_INTERFACE_PROTOCOL_MOUSE	2
+
+/*
+ * HID class requests
+ */
+
+#define HID_REQ_GET_REPORT		0x01
+#define HID_REQ_GET_IDLE		0x02
+#define HID_REQ_GET_PROTOCOL		0x03
+#define HID_REQ_SET_REPORT		0x09
+#define HID_REQ_SET_IDLE		0x0A
+#define HID_REQ_SET_PROTOCOL		0x0B
+
+/*
+ * HID class descriptor types
+ */
+
+#define HID_DT_HID			(USB_TYPE_CLASS | 0x01)
+#define HID_DT_REPORT			(USB_TYPE_CLASS | 0x02)
+#define HID_DT_PHYSICAL			(USB_TYPE_CLASS | 0x03)
+
+#define HID_MAX_DESCRIPTOR_SIZE		4096
+
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/hidraw.h clean_modified/linux-2.6.32/usr/include/linux/hidraw.h
--- linux-2.6.32/usr/include/linux/hidraw.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hidraw.h	2019-04-14 13:24:02.977881364 -0500
@@ -0,0 +1,47 @@
+#ifndef _HIDRAW_H
+#define _HIDRAW_H
+
+/*
+ *  Copyright (c) 2007 Jiri Kosina
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/hid.h>
+#include <linux/types.h>
+
+struct hidraw_report_descriptor {
+	__u32 size;
+	__u8 value[HID_MAX_DESCRIPTOR_SIZE];
+};
+
+struct hidraw_devinfo {
+	__u32 bustype;
+	__s16 vendor;
+	__s16 product;
+};
+
+/* ioctl interface */
+#define HIDIOCGRDESCSIZE	_IOR('H', 0x01, int)
+#define HIDIOCGRDESC		_IOR('H', 0x02, struct hidraw_report_descriptor)
+#define HIDIOCGRAWINFO		_IOR('H', 0x03, struct hidraw_devinfo)
+#define HIDIOCGRAWNAME(len)     _IOC(_IOC_READ, 'H', 0x04, len)
+#define HIDIOCGRAWPHYS(len)     _IOC(_IOC_READ, 'H', 0x05, len)
+
+#define HIDRAW_FIRST_MINOR 0
+#define HIDRAW_MAX_DEVICES 64
+/* number of reports to buffer */
+#define HIDRAW_BUFFER_SIZE 64
+
+
+/* kernel-only API declarations */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/hpet.h clean_modified/linux-2.6.32/usr/include/linux/hpet.h
--- linux-2.6.32/usr/include/linux/hpet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hpet.h	2019-04-14 13:24:02.977881364 -0500
@@ -0,0 +1,23 @@
+#ifndef	__HPET__
+#define	__HPET__ 1
+
+
+
+
+struct hpet_info {
+	unsigned long hi_ireqfreq;	/* Hz */
+	unsigned long hi_flags;	/* information */
+	unsigned short hi_hpet;
+	unsigned short hi_timer;
+};
+
+#define HPET_INFO_PERIODIC	0x0010	/* periodic-capable comparator */
+
+#define	HPET_IE_ON	_IO('h', 0x01)	/* interrupt on */
+#define	HPET_IE_OFF	_IO('h', 0x02)	/* interrupt off */
+#define	HPET_INFO	_IOR('h', 0x03, struct hpet_info)
+#define	HPET_EPI	_IO('h', 0x04)	/* enable periodic */
+#define	HPET_DPI	_IO('h', 0x05)	/* disable periodic */
+#define	HPET_IRQFREQ	_IOW('h', 0x6, unsigned long)	/* IRQFREQ usec */
+
+#endif				/* !__HPET__ */
diff -uNr linux-2.6.32/usr/include/linux/hysdn_if.h clean_modified/linux-2.6.32/usr/include/linux/hysdn_if.h
--- linux-2.6.32/usr/include/linux/hysdn_if.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/hysdn_if.h	2019-04-14 13:24:02.977881364 -0500
@@ -0,0 +1,33 @@
+/* $Id: hysdn_if.h,v 1.1.8.3 2001/09/23 22:25:05 kai Exp $
+ *
+ * Linux driver for HYSDN cards
+ * ioctl definitions shared by hynetmgr and driver.
+ *
+ * Author    Werner Cornelius (werner@titro.de) for Hypercope GmbH
+ * Copyright 1999 by Werner Cornelius (werner@titro.de)
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+/****************/
+/* error values */
+/****************/
+#define ERR_NONE             0 /* no error occurred */
+#define ERR_ALREADY_BOOT  1000 /* we are already booting */
+#define EPOF_BAD_MAGIC    1001 /* bad magic in POF header */
+#define ERR_BOARD_DPRAM   1002 /* board DPRAM failed */
+#define EPOF_INTERNAL     1003 /* internal POF handler error */
+#define EPOF_BAD_IMG_SIZE 1004 /* POF boot image size invalid */
+#define ERR_BOOTIMG_FAIL  1005 /* 1. stage boot image did not start */
+#define ERR_BOOTSEQ_FAIL  1006 /* 2. stage boot seq handshake timeout */
+#define ERR_POF_TIMEOUT   1007 /* timeout waiting for card pof ready */
+#define ERR_NOT_BOOTED    1008 /* operation only allowed when booted */
+#define ERR_CONF_LONG     1009 /* conf line is too long */ 
+#define ERR_INV_CHAN      1010 /* invalid channel number */ 
+#define ERR_ASYNC_TIME    1011 /* timeout sending async data */ 
+
+
+
+
diff -uNr linux-2.6.32/usr/include/linux/i2c-dev.h clean_modified/linux-2.6.32/usr/include/linux/i2c-dev.h
--- linux-2.6.32/usr/include/linux/i2c-dev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/i2c-dev.h	2019-04-14 13:24:02.982778286 -0500
@@ -0,0 +1,71 @@
+/*
+    i2c-dev.h - i2c-bus driver, char device interface
+
+    Copyright (C) 1995-97 Simon G. Vogl
+    Copyright (C) 1998-99 Frodo Looijaard <frodol@dds.nl>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _LINUX_I2C_DEV_H
+#define _LINUX_I2C_DEV_H
+
+#include <linux/types.h>
+
+
+/* /dev/i2c-X ioctl commands.  The ioctl's parameter is always an
+ * unsigned long, except for:
+ *	- I2C_FUNCS, takes pointer to an unsigned long
+ *	- I2C_RDWR, takes pointer to struct i2c_rdwr_ioctl_data
+ *	- I2C_SMBUS, takes pointer to struct i2c_smbus_ioctl_data
+ */
+#define I2C_RETRIES	0x0701	/* number of times a device address should
+				   be polled when not acknowledging */
+#define I2C_TIMEOUT	0x0702	/* set timeout in units of 10 ms */
+
+/* NOTE: Slave address is 7 or 10 bits, but 10-bit addresses
+ * are NOT supported! (due to code brokenness)
+ */
+#define I2C_SLAVE	0x0703	/* Use this slave address */
+#define I2C_SLAVE_FORCE	0x0706	/* Use this slave address, even if it
+				   is already in use by a driver! */
+#define I2C_TENBIT	0x0704	/* 0 for 7 bit addrs, != 0 for 10 bit */
+
+#define I2C_FUNCS	0x0705	/* Get the adapter functionality mask */
+
+#define I2C_RDWR	0x0707	/* Combined R/W transfer (one STOP only) */
+
+#define I2C_PEC		0x0708	/* != 0 to use PEC with SMBus */
+#define I2C_SMBUS	0x0720	/* SMBus transfer */
+
+
+/* This is the structure as used in the I2C_SMBUS ioctl call */
+struct i2c_smbus_ioctl_data {
+	__u8 read_write;
+	__u8 command;
+	__u32 size;
+	union i2c_smbus_data *data;
+};
+
+/* This is the structure as used in the I2C_RDWR ioctl call */
+struct i2c_rdwr_ioctl_data {
+	struct i2c_msg *msgs;	/* pointers to i2c_msgs */
+	__u32 nmsgs;			/* number of i2c_msgs */
+};
+
+#define  I2C_RDRW_IOCTL_MAX_MSGS	42
+
+
+#endif /* _LINUX_I2C_DEV_H */
diff -uNr linux-2.6.32/usr/include/linux/i2c.h clean_modified/linux-2.6.32/usr/include/linux/i2c.h
--- linux-2.6.32/usr/include/linux/i2c.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/i2c.h	2019-04-14 13:24:02.982778286 -0500
@@ -0,0 +1,149 @@
+/* ------------------------------------------------------------------------- */
+/*									     */
+/* i2c.h - definitions for the i2c-bus interface			     */
+/*									     */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 1995-2000 Simon G. Vogl
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+/* ------------------------------------------------------------------------- */
+
+/* With some changes from Kyösti Mälkki <kmalkki@cc.hut.fi> and
+   Frodo Looijaard <frodol@dds.nl> */
+
+#ifndef _LINUX_I2C_H
+#define _LINUX_I2C_H
+
+#include <linux/types.h>
+
+/**
+ * struct i2c_msg - an I2C transaction segment beginning with START
+ * @addr: Slave address, either seven or ten bits.  When this is a ten
+ *	bit address, I2C_M_TEN must be set in @flags and the adapter
+ *	must support I2C_FUNC_10BIT_ADDR.
+ * @flags: I2C_M_RD is handled by all adapters.  No other flags may be
+ *	provided unless the adapter exported the relevant I2C_FUNC_*
+ *	flags through i2c_check_functionality().
+ * @len: Number of data bytes in @buf being read from or written to the
+ *	I2C slave address.  For read transactions where I2C_M_RECV_LEN
+ *	is set, the caller guarantees that this buffer can hold up to
+ *	32 bytes in addition to the initial length byte sent by the
+ *	slave (plus, if used, the SMBus PEC); and this value will be
+ *	incremented by the number of block data bytes received.
+ * @buf: The buffer into which data is read, or from which it's written.
+ *
+ * An i2c_msg is the low level representation of one segment of an I2C
+ * transaction.  It is visible to drivers in the @i2c_transfer() procedure,
+ * to userspace from i2c-dev, and to I2C adapter drivers through the
+ * @i2c_adapter.@master_xfer() method.
+ *
+ * Except when I2C "protocol mangling" is used, all I2C adapters implement
+ * the standard rules for I2C transactions.  Each transaction begins with a
+ * START.  That is followed by the slave address, and a bit encoding read
+ * versus write.  Then follow all the data bytes, possibly including a byte
+ * with SMBus PEC.  The transfer terminates with a NAK, or when all those
+ * bytes have been transferred and ACKed.  If this is the last message in a
+ * group, it is followed by a STOP.  Otherwise it is followed by the next
+ * @i2c_msg transaction segment, beginning with a (repeated) START.
+ *
+ * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then
+ * passing certain @flags may have changed those standard protocol behaviors.
+ * Those flags are only for use with broken/nonconforming slaves, and with
+ * adapters which are known to support the specific mangling options they
+ * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).
+ */
+struct i2c_msg {
+	__u16 addr;	/* slave address			*/
+	__u16 flags;
+#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
+#define I2C_M_RD		0x0001	/* read data, from slave to master */
+#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+	__u16 len;		/* msg length				*/
+	__u8 *buf;		/* pointer to msg data			*/
+};
+
+/* To determine what functionality is present */
+
+#define I2C_FUNC_I2C			0x00000001
+#define I2C_FUNC_10BIT_ADDR		0x00000002
+#define I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_NOSTART etc. */
+#define I2C_FUNC_SMBUS_PEC		0x00000008
+#define I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */
+#define I2C_FUNC_SMBUS_QUICK		0x00010000
+#define I2C_FUNC_SMBUS_READ_BYTE	0x00020000
+#define I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000
+#define I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000
+#define I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000
+#define I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000
+#define I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000
+#define I2C_FUNC_SMBUS_PROC_CALL	0x00800000
+#define I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000
+#define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000
+#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */
+#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */
+
+#define I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \
+					 I2C_FUNC_SMBUS_WRITE_BYTE)
+#define I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \
+					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)
+#define I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \
+					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)
+#define I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \
+					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)
+#define I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
+					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)
+
+#define I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \
+					 I2C_FUNC_SMBUS_BYTE | \
+					 I2C_FUNC_SMBUS_BYTE_DATA | \
+					 I2C_FUNC_SMBUS_WORD_DATA | \
+					 I2C_FUNC_SMBUS_PROC_CALL | \
+					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \
+					 I2C_FUNC_SMBUS_I2C_BLOCK | \
+					 I2C_FUNC_SMBUS_PEC)
+
+/*
+ * Data for SMBus Messages
+ */
+#define I2C_SMBUS_BLOCK_MAX	32	/* As specified in SMBus standard */
+union i2c_smbus_data {
+	__u8 byte;
+	__u16 word;
+	__u8 block[I2C_SMBUS_BLOCK_MAX + 2]; /* block[0] is used for length */
+			       /* and one more for user-space compatibility */
+};
+
+/* i2c_smbus_xfer read or write markers */
+#define I2C_SMBUS_READ	1
+#define I2C_SMBUS_WRITE	0
+
+/* SMBus transaction types (size parameter in the above functions)
+   Note: these no longer correspond to the (arbitrary) PIIX4 internal codes! */
+#define I2C_SMBUS_QUICK		    0
+#define I2C_SMBUS_BYTE		    1
+#define I2C_SMBUS_BYTE_DATA	    2
+#define I2C_SMBUS_WORD_DATA	    3
+#define I2C_SMBUS_PROC_CALL	    4
+#define I2C_SMBUS_BLOCK_DATA	    5
+#define I2C_SMBUS_I2C_BLOCK_BROKEN  6
+#define I2C_SMBUS_BLOCK_PROC_CALL   7		/* SMBus 2.0 */
+#define I2C_SMBUS_I2C_BLOCK_DATA    8
+
+
+#endif /* _LINUX_I2C_H */
diff -uNr linux-2.6.32/usr/include/linux/i2o-dev.h clean_modified/linux-2.6.32/usr/include/linux/i2o-dev.h
--- linux-2.6.32/usr/include/linux/i2o-dev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/i2o-dev.h	2019-04-14 13:24:02.984721413 -0500
@@ -0,0 +1,421 @@
+/*
+ * I2O user space accessible structures/APIs
+ *
+ * (c) Copyright 1999, 2000 Red Hat Software
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ *************************************************************************
+ *
+ * This header file defines the I2O APIs that are available to both
+ * the kernel and user level applications.  Kernel specific structures
+ * are defined in i2o_osm. OSMs should include _only_ i2o_osm.h which
+ * automatically includes this file.
+ *
+ */
+
+#ifndef _I2O_DEV_H
+#define _I2O_DEV_H
+
+/* How many controllers are we allowing */
+#define MAX_I2O_CONTROLLERS	32
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/*
+ * I2O Control IOCTLs and structures
+ */
+#define I2O_MAGIC_NUMBER	'i'
+#define I2OGETIOPS		_IOR(I2O_MAGIC_NUMBER,0,__u8[MAX_I2O_CONTROLLERS])
+#define I2OHRTGET		_IOWR(I2O_MAGIC_NUMBER,1,struct i2o_cmd_hrtlct)
+#define I2OLCTGET		_IOWR(I2O_MAGIC_NUMBER,2,struct i2o_cmd_hrtlct)
+#define I2OPARMSET		_IOWR(I2O_MAGIC_NUMBER,3,struct i2o_cmd_psetget)
+#define I2OPARMGET		_IOWR(I2O_MAGIC_NUMBER,4,struct i2o_cmd_psetget)
+#define I2OSWDL 		_IOWR(I2O_MAGIC_NUMBER,5,struct i2o_sw_xfer)
+#define I2OSWUL 		_IOWR(I2O_MAGIC_NUMBER,6,struct i2o_sw_xfer)
+#define I2OSWDEL		_IOWR(I2O_MAGIC_NUMBER,7,struct i2o_sw_xfer)
+#define I2OVALIDATE		_IOR(I2O_MAGIC_NUMBER,8,__u32)
+#define I2OHTML 		_IOWR(I2O_MAGIC_NUMBER,9,struct i2o_html)
+#define I2OEVTREG		_IOW(I2O_MAGIC_NUMBER,10,struct i2o_evt_id)
+#define I2OEVTGET		_IOR(I2O_MAGIC_NUMBER,11,struct i2o_evt_info)
+#define I2OPASSTHRU		_IOR(I2O_MAGIC_NUMBER,12,struct i2o_cmd_passthru)
+#define I2OPASSTHRU32		_IOR(I2O_MAGIC_NUMBER,12,struct i2o_cmd_passthru32)
+
+struct i2o_cmd_passthru32 {
+	unsigned int iop;	/* IOP unit number */
+	__u32 msg;		/* message */
+};
+
+struct i2o_cmd_passthru {
+	unsigned int iop;	/* IOP unit number */
+	void *msg;	/* message */
+};
+
+struct i2o_cmd_hrtlct {
+	unsigned int iop;	/* IOP unit number */
+	void *resbuf;	/* Buffer for result */
+	unsigned int *reslen;	/* Buffer length in bytes */
+};
+
+struct i2o_cmd_psetget {
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device TID */
+	void *opbuf;	/* Operation List buffer */
+	unsigned int oplen;	/* Operation List buffer length in bytes */
+	void *resbuf;	/* Result List buffer */
+	unsigned int *reslen;	/* Result List buffer length in bytes */
+};
+
+struct i2o_sw_xfer {
+	unsigned int iop;	/* IOP unit number */
+	unsigned char flags;	/* Flags field */
+	unsigned char sw_type;	/* Software type */
+	unsigned int sw_id;	/* Software ID */
+	void *buf;	/* Pointer to software buffer */
+	unsigned int *swlen;	/* Length of software data */
+	unsigned int *maxfrag;	/* Maximum fragment count */
+	unsigned int *curfrag;	/* Current fragment count */
+};
+
+struct i2o_html {
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device ID */
+	unsigned int page;	/* HTML page */
+	void *resbuf;	/* Buffer for reply HTML page */
+	unsigned int *reslen;	/* Length in bytes of reply buffer */
+	void *qbuf;	/* Pointer to HTTP query string */
+	unsigned int qlen;	/* Length in bytes of query string buffer */
+};
+
+#define I2O_EVT_Q_LEN 32
+
+struct i2o_evt_id {
+	unsigned int iop;
+	unsigned int tid;
+	unsigned int evt_mask;
+};
+
+/* Event data size = frame size - message header + evt indicator */
+#define I2O_EVT_DATA_SIZE 88
+
+struct i2o_evt_info {
+	struct i2o_evt_id id;
+	unsigned char evt_data[I2O_EVT_DATA_SIZE];
+	unsigned int data_size;
+};
+
+struct i2o_evt_get {
+	struct i2o_evt_info info;
+	int pending;
+	int lost;
+};
+
+typedef struct i2o_sg_io_hdr {
+	unsigned int flags;	/* see I2O_DPT_SG_IO_FLAGS */
+} i2o_sg_io_hdr_t;
+
+/**************************************************************************
+ * HRT related constants and structures
+ **************************************************************************/
+#define I2O_BUS_LOCAL	0
+#define I2O_BUS_ISA	1
+#define I2O_BUS_EISA	2
+#define I2O_BUS_MCA	3
+#define I2O_BUS_PCI	4
+#define I2O_BUS_PCMCIA	5
+#define I2O_BUS_NUBUS	6
+#define I2O_BUS_CARDBUS 7
+#define I2O_BUS_UNKNOWN 0x80
+
+typedef struct _i2o_pci_bus {
+	__u8 PciFunctionNumber;
+	__u8 PciDeviceNumber;
+	__u8 PciBusNumber;
+	__u8 reserved;
+	__u16 PciVendorID;
+	__u16 PciDeviceID;
+} i2o_pci_bus;
+
+typedef struct _i2o_local_bus {
+	__u16 LbBaseIOPort;
+	__u16 reserved;
+	__u32 LbBaseMemoryAddress;
+} i2o_local_bus;
+
+typedef struct _i2o_isa_bus {
+	__u16 IsaBaseIOPort;
+	__u8 CSN;
+	__u8 reserved;
+	__u32 IsaBaseMemoryAddress;
+} i2o_isa_bus;
+
+typedef struct _i2o_eisa_bus_info {
+	__u16 EisaBaseIOPort;
+	__u8 reserved;
+	__u8 EisaSlotNumber;
+	__u32 EisaBaseMemoryAddress;
+} i2o_eisa_bus;
+
+typedef struct _i2o_mca_bus {
+	__u16 McaBaseIOPort;
+	__u8 reserved;
+	__u8 McaSlotNumber;
+	__u32 McaBaseMemoryAddress;
+} i2o_mca_bus;
+
+typedef struct _i2o_other_bus {
+	__u16 BaseIOPort;
+	__u16 reserved;
+	__u32 BaseMemoryAddress;
+} i2o_other_bus;
+
+typedef struct _i2o_hrt_entry {
+	__u32 adapter_id;
+	__u32 parent_tid:12;
+	__u32 state:4;
+	__u32 bus_num:8;
+	__u32 bus_type:8;
+	union {
+		i2o_pci_bus pci_bus;
+		i2o_local_bus local_bus;
+		i2o_isa_bus isa_bus;
+		i2o_eisa_bus eisa_bus;
+		i2o_mca_bus mca_bus;
+		i2o_other_bus other_bus;
+	} bus;
+} i2o_hrt_entry;
+
+typedef struct _i2o_hrt {
+	__u16 num_entries;
+	__u8 entry_len;
+	__u8 hrt_version;
+	__u32 change_ind;
+	i2o_hrt_entry hrt_entry[1];
+} i2o_hrt;
+
+typedef struct _i2o_lct_entry {
+	__u32 entry_size:16;
+	__u32 tid:12;
+	__u32 reserved:4;
+	__u32 change_ind;
+	__u32 device_flags;
+	__u32 class_id:12;
+	__u32 version:4;
+	__u32 vendor_id:16;
+	__u32 sub_class;
+	__u32 user_tid:12;
+	__u32 parent_tid:12;
+	__u32 bios_info:8;
+	__u8 identity_tag[8];
+	__u32 event_capabilities;
+} i2o_lct_entry;
+
+typedef struct _i2o_lct {
+	__u32 table_size:16;
+	__u32 boot_tid:12;
+	__u32 lct_ver:4;
+	__u32 iop_flags;
+	__u32 change_ind;
+	i2o_lct_entry lct_entry[1];
+} i2o_lct;
+
+typedef struct _i2o_status_block {
+	__u16 org_id;
+	__u16 reserved;
+	__u16 iop_id:12;
+	__u16 reserved1:4;
+	__u16 host_unit_id;
+	__u16 segment_number:12;
+	__u16 i2o_version:4;
+	__u8 iop_state;
+	__u8 msg_type;
+	__u16 inbound_frame_size;
+	__u8 init_code;
+	__u8 reserved2;
+	__u32 max_inbound_frames;
+	__u32 cur_inbound_frames;
+	__u32 max_outbound_frames;
+	char product_id[24];
+	__u32 expected_lct_size;
+	__u32 iop_capabilities;
+	__u32 desired_mem_size;
+	__u32 current_mem_size;
+	__u32 current_mem_base;
+	__u32 desired_io_size;
+	__u32 current_io_size;
+	__u32 current_io_base;
+	__u32 reserved3:24;
+	__u32 cmd_status:8;
+} i2o_status_block;
+
+/* Event indicator mask flags */
+#define I2O_EVT_IND_STATE_CHANGE		0x80000000
+#define I2O_EVT_IND_GENERAL_WARNING		0x40000000
+#define I2O_EVT_IND_CONFIGURATION_FLAG		0x20000000
+#define I2O_EVT_IND_LOCK_RELEASE		0x10000000
+#define I2O_EVT_IND_CAPABILITY_CHANGE		0x08000000
+#define I2O_EVT_IND_DEVICE_RESET		0x04000000
+#define I2O_EVT_IND_EVT_MASK_MODIFIED		0x02000000
+#define I2O_EVT_IND_FIELD_MODIFIED		0x01000000
+#define I2O_EVT_IND_VENDOR_EVT			0x00800000
+#define I2O_EVT_IND_DEVICE_STATE		0x00400000
+
+/* Executive event indicitors */
+#define I2O_EVT_IND_EXEC_RESOURCE_LIMITS	0x00000001
+#define I2O_EVT_IND_EXEC_CONNECTION_FAIL	0x00000002
+#define I2O_EVT_IND_EXEC_ADAPTER_FAULT		0x00000004
+#define I2O_EVT_IND_EXEC_POWER_FAIL		0x00000008
+#define I2O_EVT_IND_EXEC_RESET_PENDING		0x00000010
+#define I2O_EVT_IND_EXEC_RESET_IMMINENT 	0x00000020
+#define I2O_EVT_IND_EXEC_HW_FAIL		0x00000040
+#define I2O_EVT_IND_EXEC_XCT_CHANGE		0x00000080
+#define I2O_EVT_IND_EXEC_NEW_LCT_ENTRY		0x00000100
+#define I2O_EVT_IND_EXEC_MODIFIED_LCT		0x00000200
+#define I2O_EVT_IND_EXEC_DDM_AVAILABILITY	0x00000400
+
+/* Random Block Storage Event Indicators */
+#define I2O_EVT_IND_BSA_VOLUME_LOAD		0x00000001
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD		0x00000002
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ	0x00000004
+#define I2O_EVT_IND_BSA_CAPACITY_CHANGE 	0x00000008
+#define I2O_EVT_IND_BSA_SCSI_SMART		0x00000010
+
+/* Event data for generic events */
+#define I2O_EVT_STATE_CHANGE_NORMAL		0x00
+#define I2O_EVT_STATE_CHANGE_SUSPENDED		0x01
+#define I2O_EVT_STATE_CHANGE_RESTART		0x02
+#define I2O_EVT_STATE_CHANGE_NA_RECOVER 	0x03
+#define I2O_EVT_STATE_CHANGE_NA_NO_RECOVER	0x04
+#define I2O_EVT_STATE_CHANGE_QUIESCE_REQUEST	0x05
+#define I2O_EVT_STATE_CHANGE_FAILED		0x10
+#define I2O_EVT_STATE_CHANGE_FAULTED		0x11
+
+#define I2O_EVT_GEN_WARNING_NORMAL		0x00
+#define I2O_EVT_GEN_WARNING_ERROR_THRESHOLD	0x01
+#define I2O_EVT_GEN_WARNING_MEDIA_FAULT 	0x02
+
+#define I2O_EVT_CAPABILITY_OTHER		0x01
+#define I2O_EVT_CAPABILITY_CHANGED		0x02
+
+#define I2O_EVT_SENSOR_STATE_CHANGED		0x01
+
+/*
+ *	I2O classes / subclasses
+ */
+
+/*  Class ID and Code Assignments
+ *  (LCT.ClassID.Version field)
+ */
+#define I2O_CLASS_VERSION_10			0x00
+#define I2O_CLASS_VERSION_11			0x01
+
+/*  Class code names
+ *  (from v1.5 Table 6-1 Class Code Assignments.)
+ */
+
+#define I2O_CLASS_EXECUTIVE			0x000
+#define I2O_CLASS_DDM				0x001
+#define I2O_CLASS_RANDOM_BLOCK_STORAGE		0x010
+#define I2O_CLASS_SEQUENTIAL_STORAGE		0x011
+#define I2O_CLASS_LAN				0x020
+#define I2O_CLASS_WAN				0x030
+#define I2O_CLASS_FIBRE_CHANNEL_PORT		0x040
+#define I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL	0x041
+#define I2O_CLASS_SCSI_PERIPHERAL		0x051
+#define I2O_CLASS_ATE_PORT			0x060
+#define I2O_CLASS_ATE_PERIPHERAL		0x061
+#define I2O_CLASS_FLOPPY_CONTROLLER		0x070
+#define I2O_CLASS_FLOPPY_DEVICE 		0x071
+#define I2O_CLASS_BUS_ADAPTER			0x080
+#define I2O_CLASS_PEER_TRANSPORT_AGENT		0x090
+#define I2O_CLASS_PEER_TRANSPORT		0x091
+#define	I2O_CLASS_END				0xfff
+
+/*
+ *  Rest of 0x092 - 0x09f reserved for peer-to-peer classes
+ */
+
+#define I2O_CLASS_MATCH_ANYCLASS		0xffffffff
+
+/*
+ *  Subclasses
+ */
+
+#define I2O_SUBCLASS_i960			0x001
+#define I2O_SUBCLASS_HDM			0x020
+#define I2O_SUBCLASS_ISM			0x021
+
+/* Operation functions */
+
+#define I2O_PARAMS_FIELD_GET			0x0001
+#define I2O_PARAMS_LIST_GET			0x0002
+#define I2O_PARAMS_MORE_GET			0x0003
+#define I2O_PARAMS_SIZE_GET			0x0004
+#define I2O_PARAMS_TABLE_GET			0x0005
+#define I2O_PARAMS_FIELD_SET			0x0006
+#define I2O_PARAMS_LIST_SET			0x0007
+#define I2O_PARAMS_ROW_ADD			0x0008
+#define I2O_PARAMS_ROW_DELETE			0x0009
+#define I2O_PARAMS_TABLE_CLEAR			0x000A
+
+/*
+ * I2O serial number conventions / formats
+ * (circa v1.5)
+ */
+
+#define I2O_SNFORMAT_UNKNOWN			0
+#define I2O_SNFORMAT_BINARY			1
+#define I2O_SNFORMAT_ASCII			2
+#define I2O_SNFORMAT_UNICODE			3
+#define I2O_SNFORMAT_LAN48_MAC			4
+#define I2O_SNFORMAT_WAN			5
+
+/*
+ * Plus new in v2.0 (Yellowstone pdf doc)
+ */
+
+#define I2O_SNFORMAT_LAN64_MAC			6
+#define I2O_SNFORMAT_DDM			7
+#define I2O_SNFORMAT_IEEE_REG64 		8
+#define I2O_SNFORMAT_IEEE_REG128		9
+#define I2O_SNFORMAT_UNKNOWN2			0xff
+
+/*
+ *	I2O Get Status State values
+ */
+
+#define ADAPTER_STATE_INITIALIZING		0x01
+#define ADAPTER_STATE_RESET			0x02
+#define ADAPTER_STATE_HOLD			0x04
+#define ADAPTER_STATE_READY			0x05
+#define ADAPTER_STATE_OPERATIONAL		0x08
+#define ADAPTER_STATE_FAILED			0x10
+#define ADAPTER_STATE_FAULTED			0x11
+
+/*
+ *	Software module types
+ */
+#define I2O_SOFTWARE_MODULE_IRTOS		0x11
+#define I2O_SOFTWARE_MODULE_IOP_PRIVATE		0x22
+#define I2O_SOFTWARE_MODULE_IOP_CONFIG		0x23
+
+/*
+ *	Vendors
+ */
+#define I2O_VENDOR_DPT				0x001b
+
+/*
+ * DPT / Adaptec specific values for i2o_sg_io_hdr flags.
+ */
+#define I2O_DPT_SG_FLAG_INTERPRET		0x00010000
+#define I2O_DPT_SG_FLAG_PHYSICAL		0x00020000
+
+#define I2O_DPT_FLASH_FRAG_SIZE			0x10000
+#define I2O_DPT_FLASH_READ			0x0101
+#define I2O_DPT_FLASH_WRITE			0x0102
+
+#endif				/* _I2O_DEV_H */
diff -uNr linux-2.6.32/usr/include/linux/i8k.h clean_modified/linux-2.6.32/usr/include/linux/i8k.h
--- linux-2.6.32/usr/include/linux/i8k.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/i8k.h	2019-04-14 13:24:02.984721413 -0500
@@ -0,0 +1,46 @@
+/*
+ * i8k.h -- Linux driver for accessing the SMM BIOS on Dell laptops
+ *
+ * Copyright (C) 2001  Massimo Dal Zotto <dz@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#ifndef _LINUX_I8K_H
+#define _LINUX_I8K_H
+
+#define I8K_PROC		"/proc/i8k"
+#define I8K_PROC_FMT		"1.0"
+
+#define I8K_BIOS_VERSION	_IOR ('i', 0x80, int)	/* broken: meant 4 bytes */
+#define I8K_MACHINE_ID		_IOR ('i', 0x81, int)	/* broken: meant 16 bytes */
+#define I8K_POWER_STATUS	_IOR ('i', 0x82, size_t)
+#define I8K_FN_STATUS		_IOR ('i', 0x83, size_t)
+#define I8K_GET_TEMP		_IOR ('i', 0x84, size_t)
+#define I8K_GET_SPEED		_IOWR('i', 0x85, size_t)
+#define I8K_GET_FAN		_IOWR('i', 0x86, size_t)
+#define I8K_SET_FAN		_IOWR('i', 0x87, size_t)
+
+#define I8K_FAN_LEFT		1
+#define I8K_FAN_RIGHT		0
+#define I8K_FAN_OFF		0
+#define I8K_FAN_LOW		1
+#define I8K_FAN_HIGH		2
+#define I8K_FAN_MAX		I8K_FAN_HIGH
+
+#define I8K_VOL_UP		1
+#define I8K_VOL_DOWN		2
+#define I8K_VOL_MUTE		4
+
+#define I8K_AC			1
+#define I8K_BATTERY		0
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/icmp.h clean_modified/linux-2.6.32/usr/include/linux/icmp.h
--- linux-2.6.32/usr/include/linux/icmp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/icmp.h	2019-04-14 13:24:02.984721413 -0500
@@ -0,0 +1,97 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the ICMP protocol.
+ *
+ * Version:	@(#)icmp.h	1.0.3	04/28/93
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_ICMP_H
+#define	_LINUX_ICMP_H
+
+#include <linux/types.h>
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+struct icmphdr {
+  __u8		type;
+  __u8		code;
+  __sum16	checksum;
+  union {
+	struct {
+		__be16	id;
+		__be16	sequence;
+	} echo;
+	__be32	gateway;
+	struct {
+		__be16	__unused;
+		__be16	mtu;
+	} frag;
+  } un;
+};
+
+
+/*
+ *	constants for (set|get)sockopt
+ */
+
+#define ICMP_FILTER			1
+
+struct icmp_filter {
+	__u32		data;
+};
+
+
+#endif	/* _LINUX_ICMP_H */
diff -uNr linux-2.6.32/usr/include/linux/icmpv6.h clean_modified/linux-2.6.32/usr/include/linux/icmpv6.h
--- linux-2.6.32/usr/include/linux/icmpv6.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/icmpv6.h	2019-04-14 13:24:02.985931928 -0500
@@ -0,0 +1,164 @@
+#ifndef _LINUX_ICMPV6_H
+#define _LINUX_ICMPV6_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+struct icmp6hdr {
+
+	__u8		icmp6_type;
+	__u8		icmp6_code;
+	__sum16		icmp6_cksum;
+
+
+	union {
+		__be32			un_data32[1];
+		__be16			un_data16[2];
+		__u8			un_data8[4];
+
+		struct icmpv6_echo {
+			__be16		identifier;
+			__be16		sequence;
+		} u_echo;
+
+                struct icmpv6_nd_advt {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+                        __u32		reserved:5,
+                        		override:1,
+                        		solicited:1,
+                        		router:1,
+					reserved2:24;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+                        __u32		router:1,
+					solicited:1,
+                        		override:1,
+                        		reserved:29;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif						
+                } u_nd_advt;
+
+                struct icmpv6_nd_ra {
+			__u8		hop_limit;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			__u8		reserved:3,
+					router_pref:2,
+					home_agent:1,
+					other:1,
+					managed:1;
+
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			__u8		managed:1,
+					other:1,
+					home_agent:1,
+					router_pref:2,
+					reserved:3;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+			__be16		rt_lifetime;
+                } u_nd_ra;
+
+	} icmp6_dataun;
+
+#define icmp6_identifier	icmp6_dataun.u_echo.identifier
+#define icmp6_sequence		icmp6_dataun.u_echo.sequence
+#define icmp6_pointer		icmp6_dataun.un_data32[0]
+#define icmp6_mtu		icmp6_dataun.un_data32[0]
+#define icmp6_unused		icmp6_dataun.un_data32[0]
+#define icmp6_maxdelay		icmp6_dataun.un_data16[0]
+#define icmp6_router		icmp6_dataun.u_nd_advt.router
+#define icmp6_solicited		icmp6_dataun.u_nd_advt.solicited
+#define icmp6_override		icmp6_dataun.u_nd_advt.override
+#define icmp6_ndiscreserved	icmp6_dataun.u_nd_advt.reserved
+#define icmp6_hop_limit		icmp6_dataun.u_nd_ra.hop_limit
+#define icmp6_addrconf_managed	icmp6_dataun.u_nd_ra.managed
+#define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
+#define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
+#define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
+};
+
+
+#define ICMPV6_ROUTER_PREF_LOW		0x3
+#define ICMPV6_ROUTER_PREF_MEDIUM	0x0
+#define ICMPV6_ROUTER_PREF_HIGH		0x1
+#define ICMPV6_ROUTER_PREF_INVALID	0x2
+
+#define ICMPV6_DEST_UNREACH		1
+#define ICMPV6_PKT_TOOBIG		2
+#define ICMPV6_TIME_EXCEED		3
+#define ICMPV6_PARAMPROB		4
+
+#define ICMPV6_INFOMSG_MASK		0x80
+
+#define ICMPV6_ECHO_REQUEST		128
+#define ICMPV6_ECHO_REPLY		129
+#define ICMPV6_MGM_QUERY		130
+#define ICMPV6_MGM_REPORT       	131
+#define ICMPV6_MGM_REDUCTION    	132
+
+#define ICMPV6_NI_QUERY			139
+#define ICMPV6_NI_REPLY			140
+
+#define ICMPV6_MLD2_REPORT		143
+
+#define ICMPV6_DHAAD_REQUEST		144
+#define ICMPV6_DHAAD_REPLY		145
+#define ICMPV6_MOBILE_PREFIX_SOL	146
+#define ICMPV6_MOBILE_PREFIX_ADV	147
+
+/*
+ *	Codes for Destination Unreachable
+ */
+#define ICMPV6_NOROUTE			0
+#define ICMPV6_ADM_PROHIBITED		1
+#define ICMPV6_NOT_NEIGHBOUR		2
+#define ICMPV6_ADDR_UNREACH		3
+#define ICMPV6_PORT_UNREACH		4
+
+/*
+ *	Codes for Time Exceeded
+ */
+#define ICMPV6_EXC_HOPLIMIT		0
+#define ICMPV6_EXC_FRAGTIME		1
+
+/*
+ *	Codes for Parameter Problem
+ */
+#define ICMPV6_HDR_FIELD		0
+#define ICMPV6_UNK_NEXTHDR		1
+#define ICMPV6_UNK_OPTION		2
+
+/*
+ *	constants for (set|get)sockopt
+ */
+
+#define ICMPV6_FILTER			1
+
+/*
+ *	ICMPV6 filter
+ */
+
+#define ICMPV6_FILTER_BLOCK		1
+#define ICMPV6_FILTER_PASS		2
+#define ICMPV6_FILTER_BLOCKOTHERS	3
+#define ICMPV6_FILTER_PASSONLY		4
+
+struct icmp6_filter {
+	__u32		data[8];
+};
+
+/*
+ *	Definitions for MLDv2
+ */
+#define MLD2_MODE_IS_INCLUDE	1
+#define MLD2_MODE_IS_EXCLUDE	2
+#define MLD2_CHANGE_TO_INCLUDE	3
+#define MLD2_CHANGE_TO_EXCLUDE	4
+#define MLD2_ALLOW_NEW_SOURCES	5
+#define MLD2_BLOCK_OLD_SOURCES	6
+
+#define MLD2_ALL_MCR_INIT { { { 0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0,0x16 } } }
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_addr.h clean_modified/linux-2.6.32/usr/include/linux/if_addr.h
--- linux-2.6.32/usr/include/linux/if_addr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_addr.h	2019-04-14 13:24:02.987648016 -0500
@@ -0,0 +1,62 @@
+#ifndef __LINUX_IF_ADDR_H
+#define __LINUX_IF_ADDR_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct ifaddrmsg
+{
+	__u8		ifa_family;
+	__u8		ifa_prefixlen;	/* The prefix length		*/
+	__u8		ifa_flags;	/* Flags			*/
+	__u8		ifa_scope;	/* Address scope		*/
+	__u32		ifa_index;	/* Link index			*/
+};
+
+/*
+ * Important comment:
+ * IFA_ADDRESS is prefix address, rather than local interface address.
+ * It makes no difference for normally configured broadcast interfaces,
+ * but for point-to-point IFA_ADDRESS is DESTINATION address,
+ * local address is supplied in IFA_LOCAL attribute.
+ */
+enum
+{
+	IFA_UNSPEC,
+	IFA_ADDRESS,
+	IFA_LOCAL,
+	IFA_LABEL,
+	IFA_BROADCAST,
+	IFA_ANYCAST,
+	IFA_CACHEINFO,
+	IFA_MULTICAST,
+	__IFA_MAX,
+};
+
+#define IFA_MAX (__IFA_MAX - 1)
+
+/* ifa_flags */
+#define IFA_F_SECONDARY		0x01
+#define IFA_F_TEMPORARY		IFA_F_SECONDARY
+
+#define	IFA_F_NODAD		0x02
+#define IFA_F_OPTIMISTIC	0x04
+#define IFA_F_DADFAILED		0x08
+#define	IFA_F_HOMEADDRESS	0x10
+#define IFA_F_DEPRECATED	0x20
+#define IFA_F_TENTATIVE		0x40
+#define IFA_F_PERMANENT		0x80
+
+struct ifa_cacheinfo
+{
+	__u32	ifa_prefered;
+	__u32	ifa_valid;
+	__u32	cstamp; /* created timestamp, hundredths of seconds */
+	__u32	tstamp; /* updated timestamp, hundredths of seconds */
+};
+
+/* backwards compatibility for userspace */
+#define IFA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
+#define IFA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifaddrmsg))
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_addrlabel.h clean_modified/linux-2.6.32/usr/include/linux/if_addrlabel.h
--- linux-2.6.32/usr/include/linux/if_addrlabel.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_addrlabel.h	2019-04-14 13:24:02.987648016 -0500
@@ -0,0 +1,34 @@
+/*
+ * if_addrlabel.h - netlink interface for address labels
+ *
+ * Copyright (C)2007 USAGI/WIDE Project,  All Rights Reserved.
+ *
+ * Authors:
+ *	YOSHIFUJI Hideaki @ USAGI/WIDE <yoshfuji@linux-ipv6.org>
+ */
+
+#ifndef __LINUX_IF_ADDRLABEL_H
+#define __LINUX_IF_ADDRLABEL_H
+
+#include <linux/types.h>
+
+struct ifaddrlblmsg
+{
+	__u8		ifal_family;		/* Address family */
+	__u8		__ifal_reserved;	/* Reserved */
+	__u8		ifal_prefixlen;		/* Prefix length */
+	__u8		ifal_flags;		/* Flags */
+	__u32		ifal_index;		/* Link index */
+	__u32		ifal_seq;		/* sequence number */
+};
+
+enum
+{
+	IFAL_ADDRESS = 1,
+	IFAL_LABEL = 2,
+	__IFAL_MAX
+};
+
+#define IFAL_MAX	(__IFAL_MAX - 1)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_arcnet.h clean_modified/linux-2.6.32/usr/include/linux/if_arcnet.h
--- linux-2.6.32/usr/include/linux/if_arcnet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_arcnet.h	2019-04-14 13:24:02.988813183 -0500
@@ -0,0 +1,138 @@
+/*
+ * INET         An implementation of the TCP/IP protocol suite for the LINUX
+ *              operating system.  INET is implemented using the  BSD Socket
+ *              interface as the means of communication with the user level.
+ *
+ *              Global definitions for the ARCnet interface.
+ *
+ * Authors:     David Woodhouse and Avery Pennarun
+ *
+ *              This program is free software; you can redistribute it and/or
+ *              modify it under the terms of the GNU General Public License
+ *              as published by the Free Software Foundation; either version
+ *              2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_ARCNET_H
+#define _LINUX_IF_ARCNET_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+
+
+/*
+ *    These are the defined ARCnet Protocol ID's.
+ */
+
+/* CAP mode */
+/* No macro but uses 1-8 */
+
+/* RFC1201 Protocol ID's */
+#define ARC_P_IP		212	/* 0xD4 */
+#define ARC_P_IPV6		196	/* 0xC4: RFC2497 */
+#define ARC_P_ARP		213	/* 0xD5 */
+#define ARC_P_RARP		214	/* 0xD6 */
+#define ARC_P_IPX		250	/* 0xFA */
+#define ARC_P_NOVELL_EC		236	/* 0xEC */
+
+/* Old RFC1051 Protocol ID's */
+#define ARC_P_IP_RFC1051	240	/* 0xF0 */
+#define ARC_P_ARP_RFC1051	241	/* 0xF1 */
+
+/* MS LanMan/WfWg "NDIS" encapsulation */
+#define ARC_P_ETHER		232	/* 0xE8 */
+
+/* Unsupported/indirectly supported protocols */
+#define ARC_P_DATAPOINT_BOOT	0	/* very old Datapoint equipment */
+#define ARC_P_DATAPOINT_MOUNT	1
+#define ARC_P_POWERLAN_BEACON	8	/* Probably ATA-Netbios related */
+#define ARC_P_POWERLAN_BEACON2	243	/* 0xF3 */
+#define ARC_P_LANSOFT		251	/* 0xFB - what is this? */
+#define ARC_P_ATALK		0xDD
+
+/* Hardware address length */
+#define ARCNET_ALEN	1
+
+/*
+ * The RFC1201-specific components of an arcnet packet header.
+ */
+struct arc_rfc1201
+{
+    __u8  proto;		/* protocol ID field - varies		*/
+    __u8  split_flag;	/* for use with split packets		*/
+    __be16   sequence;		/* sequence number			*/
+    __u8  payload[0];	/* space remaining in packet (504 bytes)*/
+};
+#define RFC1201_HDR_SIZE 4
+
+
+/*
+ * The RFC1051-specific components.
+ */
+struct arc_rfc1051
+{
+    __u8 proto;		/* ARC_P_RFC1051_ARP/RFC1051_IP	*/
+    __u8 payload[0];		/* 507 bytes			*/
+};
+#define RFC1051_HDR_SIZE 1
+
+
+/*
+ * The ethernet-encap-specific components.  We have a real ethernet header
+ * and some data.
+ */
+struct arc_eth_encap
+{
+    __u8 proto;		/* Always ARC_P_ETHER			*/
+    struct ethhdr eth;		/* standard ethernet header (yuck!)	*/
+    __u8 payload[0];		/* 493 bytes				*/
+};
+#define ETH_ENCAP_HDR_SIZE 14
+
+
+struct arc_cap
+{
+	__u8 proto;
+	__u8 cookie[sizeof(int)];   /* Actually NOT sent over the network */
+	union {
+		__u8 ack;
+		__u8 raw[0];		/* 507 bytes */
+	} mes;
+};
+
+/*
+ * The data needed by the actual arcnet hardware.
+ *
+ * Now, in the real arcnet hardware, the third and fourth bytes are the
+ * 'offset' specification instead of the length, and the soft data is at
+ * the _end_ of the 512-byte buffer.  We hide this complexity inside the
+ * driver.
+ */
+struct arc_hardware
+{
+    __u8  source,		/* source ARCnet - filled in automagically */
+             dest,		/* destination ARCnet - 0 for broadcast    */
+    	     offset[2];		/* offset bytes (some weird semantics)     */
+};
+#define ARC_HDR_SIZE 4
+
+/*
+ * This is an ARCnet frame header, as seen by the kernel (and userspace,
+ * when you do a raw packet capture).
+ */
+struct archdr
+{
+    /* hardware requirements */
+    struct arc_hardware hard;
+     
+    /* arcnet encapsulation-specific bits */
+    union {
+	struct arc_rfc1201   rfc1201;
+	struct arc_rfc1051   rfc1051;
+	struct arc_eth_encap eth_encap;
+	struct arc_cap       cap;
+	__u8 raw[0];		/* 508 bytes				*/
+    } soft;
+};
+
+#endif				/* _LINUX_IF_ARCNET_H */
diff -uNr linux-2.6.32/usr/include/linux/if_arp.h clean_modified/linux-2.6.32/usr/include/linux/if_arp.h
--- linux-2.6.32/usr/include/linux/if_arp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_arp.h	2019-04-14 13:24:02.988813183 -0500
@@ -0,0 +1,157 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the ARP (RFC 826) protocol.
+ *
+ * Version:	@(#)if_arp.h	1.0.1	04/16/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+ *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Florian La Roche,
+ *		Jonathan Layes <layes@loran.com>
+ *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> ARPHRD_HWX25
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_ARP_H
+#define _LINUX_IF_ARP_H
+
+#include <linux/netdevice.h>
+
+/* ARP protocol HARDWARE identifiers. */
+#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
+#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
+#define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
+#define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
+#define	ARPHRD_PRONET	4		/* PROnet token ring		*/
+#define	ARPHRD_CHAOS	5		/* Chaosnet			*/
+#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB	*/
+#define	ARPHRD_ARCNET	7		/* ARCnet			*/
+#define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
+#define ARPHRD_DLCI	15		/* Frame Relay DLCI		*/
+#define ARPHRD_ATM	19		/* ATM 				*/
+#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id)	*/
+#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
+#define ARPHRD_EUI64	27		/* EUI-64                       */
+#define ARPHRD_INFINIBAND 32		/* InfiniBand			*/
+
+/* Dummy types for non ARP hardware */
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260		/* Notional KISS type 		*/
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271		/* CCITT X.25			*/
+#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CAN	280		/* Controller Area Network      */
+#define ARPHRD_PPP	512
+#define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
+#define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_LAPB	516		/* LAPB				*/
+#define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
+#define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
+
+#define ARPHRD_TUNNEL	768		/* IPIP tunnel			*/
+#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel       		*/
+#define ARPHRD_FRAD	770             /* Frame Relay Access Device    */
+#define ARPHRD_SKIP	771		/* SKIP vif			*/
+#define ARPHRD_LOOPBACK	772		/* Loopback device		*/
+#define ARPHRD_LOCALTLK 773		/* Localtalk device		*/
+#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface */
+#define ARPHRD_BIF      775             /* AP1000 BIF                   */
+#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
+#define ARPHRD_IPDDP	777		/* IP over DDP tunneller	*/
+#define ARPHRD_IPGRE	778		/* GRE over IP			*/
+#define ARPHRD_PIMREG	779		/* PIMSM register interface	*/
+#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
+#define ARPHRD_ASH	781		/* Nexus 64Mbps Ash		*/
+#define ARPHRD_ECONET	782		/* Acorn Econet			*/
+#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
+/* ARP works differently on different FC media .. so  */
+#define ARPHRD_FCPP	784		/* Point to point fibrechannel	*/
+#define ARPHRD_FCAL	785		/* Fibrechannel arbitrated loop */
+#define ARPHRD_FCPL	786		/* Fibrechannel public loop	*/
+#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric		*/
+	/* 787->799 reserved for fibrechannel media types */
+#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR	*/
+#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
+#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
+#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
+#define ARPHRD_IEEE802154	  804
+
+#define ARPHRD_PHONET	820		/* PhoNet media type		*/
+#define ARPHRD_PHONET_PIPE 821		/* PhoNet pipe header		*/
+
+#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
+#define ARPHRD_NONE	  0xFFFE	/* zero header length */
+
+/* ARP protocol opcodes. */
+#define	ARPOP_REQUEST	1		/* ARP request			*/
+#define	ARPOP_REPLY	2		/* ARP reply			*/
+#define	ARPOP_RREQUEST	3		/* RARP request			*/
+#define	ARPOP_RREPLY	4		/* RARP reply			*/
+#define	ARPOP_InREQUEST	8		/* InARP request		*/
+#define	ARPOP_InREPLY	9		/* InARP reply			*/
+#define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
+
+
+/* ARP ioctl request. */
+struct arpreq {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+  char			arp_dev[16];
+};
+
+struct arpreq_old {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+};
+
+/* ARP Flag values. */
+#define ATF_COM		0x02		/* completed entry (ha valid)	*/
+#define	ATF_PERM	0x04		/* permanent entry		*/
+#define	ATF_PUBL	0x08		/* publish entry		*/
+#define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
+#define ATF_NETMASK     0x20            /* want to use a netmask (only
+					   for proxy entries) */
+#define ATF_DONTPUB	0x40		/* don't answer this addresses	*/
+
+/*
+ *	This structure defines an ethernet arp header.
+ */
+
+struct arphdr
+{
+	__be16		ar_hrd;		/* format of hardware address	*/
+	__be16		ar_pro;		/* format of protocol address	*/
+	unsigned char	ar_hln;		/* length of hardware address	*/
+	unsigned char	ar_pln;		/* length of protocol address	*/
+	__be16		ar_op;		/* ARP opcode (command)		*/
+
+#if 0
+	 /*
+	  *	 Ethernet looks like this : This bit is variable sized however...
+	  */
+	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
+	unsigned char		ar_sip[4];		/* sender IP address		*/
+	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
+	unsigned char		ar_tip[4];		/* target IP address		*/
+#endif
+
+};
+
+
+#endif	/* _LINUX_IF_ARP_H */
diff -uNr linux-2.6.32/usr/include/linux/if_bonding.h clean_modified/linux-2.6.32/usr/include/linux/if_bonding.h
--- linux-2.6.32/usr/include/linux/if_bonding.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_bonding.h	2019-04-14 13:24:02.988813183 -0500
@@ -0,0 +1,125 @@
+/*
+ * Bond several ethernet interfaces into a Cisco, running 'Etherchannel'.
+ *
+ *
+ * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
+ * NCM: Network and Communications Management, Inc.
+ *
+ * BUT, I'm the one who modified it for ethernet, so:
+ * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU Public License, incorporated herein by reference.
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
+ *	- Added support for getting slave's speed and duplex via ethtool.
+ *	  Needed for 802.3ad and other future modes.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Enable support of modes that need to use the unique mac address of
+ *	  each slave.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Moved driver's private data types to bonding.h
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
+ *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
+ *
+ * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
+ *	- Added ABI version control to restore compatibility between
+ *	  new/old ifenslave and new/old bonding.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ *
+ * 2005/05/05 - Jason Gabler <jygabler at lbl dot gov>
+ *      - added definitions for various XOR hashing policies
+ */
+
+#ifndef _LINUX_IF_BONDING_H
+#define _LINUX_IF_BONDING_H
+
+#include <linux/if.h>
+#include <linux/types.h>
+#include <linux/if_ether.h>
+
+/* userland - kernel ABI version (2003/05/08) */
+#define BOND_ABI_VERSION 2
+
+/*
+ * We can remove these ioctl definitions in 2.5.  People should use the
+ * SIOC*** versions of them instead
+ */
+#define BOND_ENSLAVE_OLD		(SIOCDEVPRIVATE)
+#define BOND_RELEASE_OLD		(SIOCDEVPRIVATE + 1)
+#define BOND_SETHWADDR_OLD		(SIOCDEVPRIVATE + 2)
+#define BOND_SLAVE_INFO_QUERY_OLD	(SIOCDEVPRIVATE + 11)
+#define BOND_INFO_QUERY_OLD		(SIOCDEVPRIVATE + 12)
+#define BOND_CHANGE_ACTIVE_OLD		(SIOCDEVPRIVATE + 13)
+
+#define BOND_CHECK_MII_STATUS	(SIOCGMIIPHY)
+
+#define BOND_MODE_ROUNDROBIN	0
+#define BOND_MODE_ACTIVEBACKUP	1
+#define BOND_MODE_XOR		2
+#define BOND_MODE_BROADCAST	3
+#define BOND_MODE_8023AD        4
+#define BOND_MODE_TLB           5
+#define BOND_MODE_ALB		6 /* TLB + RLB (receive load balancing) */
+
+/* each slave's link has 4 states */
+#define BOND_LINK_UP    0           /* link is up and running */
+#define BOND_LINK_FAIL  1           /* link has just gone down */
+#define BOND_LINK_DOWN  2           /* link has been down for too long time */
+#define BOND_LINK_BACK  3           /* link is going back */
+
+/* each slave has several states */
+#define BOND_STATE_ACTIVE       0   /* link is active */
+#define BOND_STATE_BACKUP       1   /* link is backup */
+
+#define BOND_DEFAULT_MAX_BONDS  1   /* Default maximum number of devices to support */
+
+/* hashing types */
+#define BOND_XMIT_POLICY_LAYER2		0 /* layer 2 (MAC only), default */
+#define BOND_XMIT_POLICY_LAYER34	1 /* layer 3+4 (IP ^ (TCP || UDP)) */
+#define BOND_XMIT_POLICY_LAYER23	2 /* layer 2+3 (IP ^ MAC) */
+
+typedef struct ifbond {
+	__s32 bond_mode;
+	__s32 num_slaves;
+	__s32 miimon;
+} ifbond;
+
+typedef struct ifslave
+{
+	__s32 slave_id; /* Used as an IN param to the BOND_SLAVE_INFO_QUERY ioctl */
+	char slave_name[IFNAMSIZ];
+	__s8 link;
+	__s8 state;
+	__u32  link_failure_count;
+} ifslave;
+
+struct ad_info {
+	__u16 aggregator_id;
+	__u16 ports;
+	__u16 actor_key;
+	__u16 partner_key;
+	__u8 partner_system[ETH_ALEN];
+};
+
+#endif /* _LINUX_IF_BONDING_H */
+
+/*
+ * Local variables:
+ *  version-control: t
+ *  kept-new-versions: 5
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
+
diff -uNr linux-2.6.32/usr/include/linux/if_bridge.h clean_modified/linux-2.6.32/usr/include/linux/if_bridge.h
--- linux-2.6.32/usr/include/linux/if_bridge.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_bridge.h	2019-04-14 13:24:02.990569485 -0500
@@ -0,0 +1,104 @@
+/*
+ *	Linux ethernet bridge
+ *
+ *	Authors:
+ *	Lennert Buytenhek		<buytenh@gnu.org>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_BRIDGE_H
+#define _LINUX_IF_BRIDGE_H
+
+#include <linux/types.h>
+
+#define SYSFS_BRIDGE_ATTR	"bridge"
+#define SYSFS_BRIDGE_FDB	"brforward"
+#define SYSFS_BRIDGE_PORT_SUBDIR "brif"
+#define SYSFS_BRIDGE_PORT_ATTR	"brport"
+#define SYSFS_BRIDGE_PORT_LINK	"bridge"
+
+#define BRCTL_VERSION 1
+
+#define BRCTL_GET_VERSION 0
+#define BRCTL_GET_BRIDGES 1
+#define BRCTL_ADD_BRIDGE 2
+#define BRCTL_DEL_BRIDGE 3
+#define BRCTL_ADD_IF 4
+#define BRCTL_DEL_IF 5
+#define BRCTL_GET_BRIDGE_INFO 6
+#define BRCTL_GET_PORT_LIST 7
+#define BRCTL_SET_BRIDGE_FORWARD_DELAY 8
+#define BRCTL_SET_BRIDGE_HELLO_TIME 9
+#define BRCTL_SET_BRIDGE_MAX_AGE 10
+#define BRCTL_SET_AGEING_TIME 11
+#define BRCTL_SET_GC_INTERVAL 12
+#define BRCTL_GET_PORT_INFO 13
+#define BRCTL_SET_BRIDGE_STP_STATE 14
+#define BRCTL_SET_BRIDGE_PRIORITY 15
+#define BRCTL_SET_PORT_PRIORITY 16
+#define BRCTL_SET_PATH_COST 17
+#define BRCTL_GET_FDB_ENTRIES 18
+
+#define BR_STATE_DISABLED 0
+#define BR_STATE_LISTENING 1
+#define BR_STATE_LEARNING 2
+#define BR_STATE_FORWARDING 3
+#define BR_STATE_BLOCKING 4
+
+struct __bridge_info
+{
+	__u64 designated_root;
+	__u64 bridge_id;
+	__u32 root_path_cost;
+	__u32 max_age;
+	__u32 hello_time;
+	__u32 forward_delay;
+	__u32 bridge_max_age;
+	__u32 bridge_hello_time;
+	__u32 bridge_forward_delay;
+	__u8 topology_change;
+	__u8 topology_change_detected;
+	__u8 root_port;
+	__u8 stp_enabled;
+	__u32 ageing_time;
+	__u32 gc_interval;
+	__u32 hello_timer_value;
+	__u32 tcn_timer_value;
+	__u32 topology_change_timer_value;
+	__u32 gc_timer_value;
+};
+
+struct __port_info
+{
+	__u64 designated_root;
+	__u64 designated_bridge;
+	__u16 port_id;
+	__u16 designated_port;
+	__u32 path_cost;
+	__u32 designated_cost;
+	__u8 state;
+	__u8 top_change_ack;
+	__u8 config_pending;
+	__u8 unused0;
+	__u32 message_age_timer_value;
+	__u32 forward_delay_timer_value;
+	__u32 hold_timer_value;
+};
+
+struct __fdb_entry
+{
+	__u8 mac_addr[6];
+	__u8 port_no;
+	__u8 is_local;
+	__u32 ageing_timer_value;
+	__u8 port_hi;
+	__u8 pad0;
+	__u16 unused;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_cablemodem.h clean_modified/linux-2.6.32/usr/include/linux/if_cablemodem.h
--- linux-2.6.32/usr/include/linux/if_cablemodem.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_cablemodem.h	2019-04-14 13:24:02.990569485 -0500
@@ -0,0 +1,22 @@
+#ifndef _LINUX_CABLEMODEM_H_
+#define _LINUX_CABLEMODEM_H_
+/*
+ *		Author: Franco Venturi <fventuri@mediaone.net>
+ *		Copyright 1998 Franco Venturi
+ *
+ *		This program is free software; you can redistribute it
+ *		and/or  modify it under  the terms of  the GNU General
+ *		Public  License as  published  by  the  Free  Software
+ *		Foundation;  either  version 2 of the License, or  (at
+ *		your option) any later version.
+ */
+
+/* some useful defines for sb1000.c e cmconfig.c - fv */
+#define SIOCGCMSTATS		SIOCDEVPRIVATE+0	/* get cable modem stats */
+#define SIOCGCMFIRMWARE		SIOCDEVPRIVATE+1	/* get cm firmware version */
+#define SIOCGCMFREQUENCY	SIOCDEVPRIVATE+2	/* get cable modem frequency */
+#define SIOCSCMFREQUENCY	SIOCDEVPRIVATE+3	/* set cable modem frequency */
+#define SIOCGCMPIDS			SIOCDEVPRIVATE+4	/* get cable modem PIDs */
+#define SIOCSCMPIDS			SIOCDEVPRIVATE+5	/* set cable modem PIDs */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_ec.h clean_modified/linux-2.6.32/usr/include/linux/if_ec.h
--- linux-2.6.32/usr/include/linux/if_ec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_ec.h	2019-04-14 13:24:02.990569485 -0500
@@ -0,0 +1,36 @@
+/* Definitions for Econet sockets. */
+
+#ifndef __LINUX_IF_EC
+#define __LINUX_IF_EC
+
+/* User visible stuff. Glibc provides its own but libc5 folk will use these */
+
+struct ec_addr
+{
+  unsigned char station;		/* Station number.  */
+  unsigned char net;			/* Network number.  */
+};
+
+struct sockaddr_ec
+{
+  unsigned short sec_family;
+  unsigned char port;			/* Port number.  */
+  unsigned char cb;			/* Control/flag byte.  */
+  unsigned char type;			/* Type of message.  */
+  struct ec_addr addr;
+  unsigned long cookie;
+};
+
+#define ECTYPE_PACKET_RECEIVED		0	/* Packet received */
+#define ECTYPE_TRANSMIT_STATUS		0x10	/* Transmit completed, 
+						   low nibble holds status */
+
+#define ECTYPE_TRANSMIT_OK		1
+#define ECTYPE_TRANSMIT_NOT_LISTENING	2
+#define ECTYPE_TRANSMIT_NET_ERROR	3
+#define ECTYPE_TRANSMIT_NO_CLOCK	4
+#define ECTYPE_TRANSMIT_LINE_JAMMED	5
+#define ECTYPE_TRANSMIT_NOT_PRESENT	6
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_eql.h clean_modified/linux-2.6.32/usr/include/linux/if_eql.h
--- linux-2.6.32/usr/include/linux/if_eql.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_eql.h	2019-04-14 13:24:02.990569485 -0500
@@ -0,0 +1,54 @@
+/*
+ * Equalizer Load-balancer for serial network interfaces.
+ *
+ * (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
+ * NCM: Network and Communications Management, Inc.
+ *
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU General Public License, incorporated herein by reference.
+ * 
+ * The author may be reached as simon@ncm.com, or C/O
+ *    NCM
+ *    Attn: Simon Janes
+ *    6803 Whittier Ave
+ *    McLean VA 22101
+ *    Phone: 1-703-847-0040 ext 103
+ */
+
+#ifndef _LINUX_IF_EQL_H
+#define _LINUX_IF_EQL_H
+
+#define EQL_DEFAULT_SLAVE_PRIORITY 28800
+#define EQL_DEFAULT_MAX_SLAVES     4
+#define EQL_DEFAULT_MTU            576
+#define EQL_DEFAULT_RESCHED_IVAL   100
+
+#define EQL_ENSLAVE     (SIOCDEVPRIVATE)
+#define EQL_EMANCIPATE  (SIOCDEVPRIVATE + 1)
+
+#define EQL_GETSLAVECFG (SIOCDEVPRIVATE + 2)
+#define EQL_SETSLAVECFG (SIOCDEVPRIVATE + 3)
+
+#define EQL_GETMASTRCFG (SIOCDEVPRIVATE + 4)
+#define EQL_SETMASTRCFG (SIOCDEVPRIVATE + 5)
+
+
+typedef struct master_config {
+	char	master_name[16];
+	int	max_slaves;
+	int	min_slaves;
+} master_config_t;
+
+typedef struct slave_config {
+	char	slave_name[16];
+	long	priority;
+} slave_config_t;
+
+typedef struct slaving_request {
+	char	slave_name[16];
+	long	priority;
+} slaving_request_t;
+
+
+#endif /* _LINUX_EQL_H */
diff -uNr linux-2.6.32/usr/include/linux/if_ether.h clean_modified/linux-2.6.32/usr/include/linux/if_ether.h
--- linux-2.6.32/usr/include/linux/if_ether.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_ether.h	2019-04-14 13:24:02.991548354 -0500
@@ -0,0 +1,124 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+#include <linux/types.h>
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_TEB	0x6558		/* Trans Ether Bridging		*/
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PAUSE	0x8808		/* IEEE Pause frames. See 802.3 31B */
+#define ETH_P_SLOW	0x8809		/* Slow Protocol. See 802.3ad 43B */
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_PAE	0x888E		/* Port Access Entity (IEEE 802.1X) */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+#define ETH_P_TIPC	0x88CA		/* TIPC 			*/
+#define ETH_P_1588	0x88F7		/* IEEE 1588 Timesync */
+#define ETH_P_FCOE	0x8906		/* Fibre Channel over Ethernet  */
+#define ETH_P_FIP	0x8914		/* FCoE Initialization Protocol */
+#define ETH_P_EDSA	0xDADA		/* Ethertype DSA [ NOT AN OFFICIALLY REGISTERED ID ] */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_CAN	0x000C		/* Controller Area Network      */
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+#define ETH_P_DSA	0x001B		/* Distributed Switch Arch.	*/
+#define ETH_P_TRAILER	0x001C		/* Trailer switch tagging	*/
+#define ETH_P_PHONET	0x00F5		/* Nokia Phonet frames          */
+#define ETH_P_IEEE802154 0x00F6		/* IEEE802.15.4 frame		*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+
+#endif	/* _LINUX_IF_ETHER_H */
diff -uNr linux-2.6.32/usr/include/linux/if_fc.h clean_modified/linux-2.6.32/usr/include/linux/if_fc.h
--- linux-2.6.32/usr/include/linux/if_fc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_fc.h	2019-04-14 13:24:02.991548354 -0500
@@ -0,0 +1,51 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for Fibre Channel.
+ *
+ * Version:	@(#)if_fc.h	0.0	11/20/98
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *    Peter De Schrijver, <stud11@cc4.kuleuven.ac.be>
+ *	  Vineet Abraham, <vma@iol.unh.edu>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_FC_H
+#define _LINUX_IF_FC_H
+
+#include <linux/types.h>
+
+#define FC_ALEN	6		/* Octets in one ethernet addr	 */
+#define FC_HLEN   (sizeof(struct fch_hdr)+sizeof(struct fcllc))
+#define FC_ID_LEN 3		/* Octets in a Fibre Channel Address */
+
+/* LLC and SNAP constants */
+#define EXTENDED_SAP 0xAA
+#define UI_CMD       0x03
+
+/* This is NOT the Fibre Channel frame header. The FC frame header is
+ *  constructed in the driver as the Tachyon needs certain fields in
+ *  certains positions. So, it can't be generalized here.*/
+
+struct fch_hdr {
+	__u8  daddr[FC_ALEN];		/* destination address */
+	__u8  saddr[FC_ALEN];		/* source address */
+};
+
+/* This is a Fibre Channel LLC structure */
+struct fcllc {
+	__u8  dsap;			/* destination SAP */
+	__u8  ssap;			/* source SAP */
+	__u8  llc;			/* LLC control field */
+	__u8  protid[3];		/* protocol id */
+	__be16 ethertype;		/* ether type field */
+};
+
+#endif	/* _LINUX_IF_FC_H */
diff -uNr linux-2.6.32/usr/include/linux/if_fddi.h clean_modified/linux-2.6.32/usr/include/linux/if_fddi.h
--- linux-2.6.32/usr/include/linux/if_fddi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_fddi.h	2019-04-14 13:24:02.991548354 -0500
@@ -0,0 +1,108 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the ANSI FDDI interface.
+ *
+ * Version:	@(#)if_fddi.h	1.0.2	Sep 29 2004
+ *
+ * Author:	Lawrence V. Stefani, <stefani@lkg.dec.com>
+ *
+ *		if_fddi.h is based on previous if_ether.h and if_tr.h work by
+ *			Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *			Donald Becker, <becker@super.org>
+ *			Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *			Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *			Peter De Schrijver, <stud11@cc4.kuleuven.ac.be>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_FDDI_H
+#define _LINUX_IF_FDDI_H
+
+#include <linux/types.h>
+
+/*
+ *  Define max and min legal sizes.  The frame sizes do not include
+ *  4 byte FCS/CRC (frame check sequence).
+ */
+#define FDDI_K_ALEN			6		/* Octets in one FDDI address */
+#define FDDI_K_8022_HLEN	16		/* Total octets in 802.2 header */
+#define FDDI_K_SNAP_HLEN	21		/* Total octets in 802.2 SNAP header */
+#define FDDI_K_8022_ZLEN	16		/* Min octets in 802.2 frame sans FCS */
+#define FDDI_K_SNAP_ZLEN	21		/* Min octets in 802.2 SNAP frame sans FCS */
+#define FDDI_K_8022_DLEN	4475	/* Max octets in 802.2 payload */
+#define FDDI_K_SNAP_DLEN	4470	/* Max octets in 802.2 SNAP payload */
+#define FDDI_K_LLC_ZLEN		13		/* Min octets in LLC frame sans FCS */
+#define FDDI_K_LLC_LEN		4491	/* Max octets in LLC frame sans FCS */
+
+/* Define FDDI Frame Control (FC) Byte values */
+#define FDDI_FC_K_VOID					0x00	
+#define FDDI_FC_K_NON_RESTRICTED_TOKEN	0x80	
+#define FDDI_FC_K_RESTRICTED_TOKEN		0xC0	
+#define FDDI_FC_K_SMT_MIN				0x41
+#define FDDI_FC_K_SMT_MAX		   		0x4F
+#define FDDI_FC_K_MAC_MIN				0xC1
+#define FDDI_FC_K_MAC_MAX		  		0xCF	
+#define FDDI_FC_K_ASYNC_LLC_MIN			0x50
+#define FDDI_FC_K_ASYNC_LLC_DEF			0x54
+#define FDDI_FC_K_ASYNC_LLC_MAX			0x5F
+#define FDDI_FC_K_SYNC_LLC_MIN			0xD0
+#define FDDI_FC_K_SYNC_LLC_MAX			0xD7
+#define FDDI_FC_K_IMPLEMENTOR_MIN		0x60
+#define FDDI_FC_K_IMPLEMENTOR_MAX  		0x6F
+#define FDDI_FC_K_RESERVED_MIN			0x70
+#define FDDI_FC_K_RESERVED_MAX			0x7F
+
+/* Define LLC and SNAP constants */
+#define FDDI_EXTENDED_SAP	0xAA
+#define FDDI_UI_CMD			0x03
+
+/* Define 802.2 Type 1 header */
+struct fddi_8022_1_hdr
+	{
+	__u8	dsap;					/* destination service access point */
+	__u8	ssap;					/* source service access point */
+	__u8	ctrl;					/* control byte #1 */
+	} __attribute__ ((packed));
+
+/* Define 802.2 Type 2 header */
+struct fddi_8022_2_hdr
+	{
+	__u8	dsap;					/* destination service access point */
+	__u8	ssap;					/* source service access point */
+	__u8	ctrl_1;					/* control byte #1 */
+	__u8	ctrl_2;					/* control byte #2 */
+	} __attribute__ ((packed));
+
+/* Define 802.2 SNAP header */
+#define FDDI_K_OUI_LEN	3
+struct fddi_snap_hdr
+	{
+	__u8	dsap;					/* always 0xAA */
+	__u8	ssap;					/* always 0xAA */
+	__u8	ctrl;					/* always 0x03 */
+	__u8	oui[FDDI_K_OUI_LEN];	/* organizational universal id */
+	__be16	ethertype;				/* packet type ID field */
+	} __attribute__ ((packed));
+
+/* Define FDDI LLC frame header */
+struct fddihdr
+	{
+	__u8	fc;						/* frame control */
+	__u8	daddr[FDDI_K_ALEN];		/* destination address */
+	__u8	saddr[FDDI_K_ALEN];		/* source address */
+	union
+		{
+		struct fddi_8022_1_hdr		llc_8022_1;
+		struct fddi_8022_2_hdr		llc_8022_2;
+		struct fddi_snap_hdr		llc_snap;
+		} hdr;
+	} __attribute__ ((packed));
+
+
+#endif	/* _LINUX_IF_FDDI_H */
diff -uNr linux-2.6.32/usr/include/linux/if_frad.h clean_modified/linux-2.6.32/usr/include/linux/if_frad.h
--- linux-2.6.32/usr/include/linux/if_frad.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_frad.h	2019-04-14 13:24:02.992521695 -0500
@@ -0,0 +1,122 @@
+/*
+ * DLCI/FRAD	Definitions for Frame Relay Access Devices.  DLCI devices are
+ *		created for each DLCI associated with a FRAD.  The FRAD driver
+ *		is not truly a network device, but the lower level device
+ *		handler.  This allows other FRAD manufacturers to use the DLCI
+ *		code, including its RFC1490 encapsulation alongside the current
+ *		implementation for the Sangoma cards.
+ *
+ * Version:	@(#)if_ifrad.h	0.15	31 Mar 96
+ *
+ * Author:	Mike McLagan <mike.mclagan@linux.org>
+ *
+ * Changes:
+ *		0.15	Mike McLagan	changed structure defs (packed)
+ *					re-arranged flags
+ *					added DLCI_RET vars
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _FRAD_H_
+#define _FRAD_H_
+
+#include <linux/if.h>
+
+/* Structures and constants associated with the DLCI device driver */
+
+struct dlci_add
+{
+   char  devname[IFNAMSIZ];
+   short dlci;
+};
+
+#define DLCI_GET_CONF	(SIOCDEVPRIVATE + 2)
+#define DLCI_SET_CONF	(SIOCDEVPRIVATE + 3)
+
+/* 
+ * These are related to the Sangoma SDLA and should remain in order. 
+ * Code within the SDLA module is based on the specifics of this 
+ * structure.  Change at your own peril.
+ */
+struct dlci_conf {
+   short flags;
+   short CIR_fwd;
+   short Bc_fwd;
+   short Be_fwd;
+   short CIR_bwd;
+   short Bc_bwd;
+   short Be_bwd; 
+
+/* these are part of the status read */
+   short Tc_fwd;
+   short Tc_bwd;
+   short Tf_max;
+   short Tb_max;
+
+/* add any new fields here above is a mirror of sdla_dlci_conf */
+};
+
+#define DLCI_GET_SLAVE	(SIOCDEVPRIVATE + 4)
+
+/* configuration flags for DLCI */
+#define DLCI_IGNORE_CIR_OUT	0x0001
+#define DLCI_ACCOUNT_CIR_IN	0x0002
+#define DLCI_BUFFER_IF		0x0008
+
+#define DLCI_VALID_FLAGS	0x000B
+
+/* defines for the actual Frame Relay hardware */
+#define FRAD_GET_CONF	(SIOCDEVPRIVATE)
+#define FRAD_SET_CONF	(SIOCDEVPRIVATE + 1)
+
+#define FRAD_LAST_IOCTL	FRAD_SET_CONF
+
+/*
+ * Based on the setup for the Sangoma SDLA.  If changes are 
+ * necessary to this structure, a routine will need to be 
+ * added to that module to copy fields.
+ */
+struct frad_conf 
+{
+   short station;
+   short flags;
+   short kbaud;
+   short clocking;
+   short mtu;
+   short T391;
+   short T392;
+   short N391;
+   short N392;
+   short N393;
+   short CIR_fwd;
+   short Bc_fwd;
+   short Be_fwd;
+   short CIR_bwd;
+   short Bc_bwd;
+   short Be_bwd;
+
+/* Add new fields here, above is a mirror of the sdla_conf */
+
+};
+
+#define FRAD_STATION_CPE	0x0000
+#define FRAD_STATION_NODE	0x0001
+
+#define FRAD_TX_IGNORE_CIR	0x0001
+#define FRAD_RX_ACCOUNT_CIR	0x0002
+#define FRAD_DROP_ABORTED	0x0004
+#define FRAD_BUFFERIF		0x0008
+#define FRAD_STATS		0x0010
+#define FRAD_MCI		0x0100
+#define FRAD_AUTODLCI		0x8000
+#define FRAD_VALID_FLAGS	0x811F
+
+#define FRAD_CLOCK_INT		0x0001
+#define FRAD_CLOCK_EXT		0x0000
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if.h clean_modified/linux-2.6.32/usr/include/linux/if.h
--- linux-2.6.32/usr/include/linux/if.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if.h	2019-04-14 13:24:02.992859333 -0500
@@ -0,0 +1,226 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the INET interface module.
+ *
+ * Version:	@(#)if.h	1.0.2	04/18/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_H
+#define _LINUX_IF_H
+
+#include <linux/types.h>		/* for "__kernel_caddr_t" et al	*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+		/* for "__user" et al           */
+
+#define	IFNAMSIZ	16
+#define	IFALIASZ	256
+#include <linux/hdlc/ioctl.h>
+
+/* Standard interface flags (netdevice->flags). */
+#define	IFF_UP		0x1		/* interface is up		*/
+#define	IFF_BROADCAST	0x2		/* broadcast address valid	*/
+#define	IFF_DEBUG	0x4		/* turn on debugging		*/
+#define	IFF_LOOPBACK	0x8		/* is a loopback net		*/
+#define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	*/
+#define	IFF_NOTRAILERS	0x20		/* avoid use of trailers	*/
+#define	IFF_RUNNING	0x40		/* interface RFC2863 OPER_UP	*/
+#define	IFF_NOARP	0x80		/* no ARP protocol		*/
+#define	IFF_PROMISC	0x100		/* receive all packets		*/
+#define	IFF_ALLMULTI	0x200		/* receive all multicast packets*/
+
+#define IFF_MASTER	0x400		/* master of a load balancer 	*/
+#define IFF_SLAVE	0x800		/* slave of a load balancer	*/
+
+#define IFF_MULTICAST	0x1000		/* Supports multicast		*/
+
+#define IFF_PORTSEL	0x2000          /* can set media type		*/
+#define IFF_AUTOMEDIA	0x4000		/* auto media select active	*/
+#define IFF_DYNAMIC	0x8000		/* dialup device with changing addresses*/
+
+#define IFF_LOWER_UP	0x10000		/* driver signals L1 up		*/
+#define IFF_DORMANT	0x20000		/* driver signals dormant	*/
+
+#define IFF_ECHO	0x40000		/* echo sent packets		*/
+
+#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
+		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
+
+/* Private (from user) interface flags (netdevice->priv_flags). */
+#define IFF_802_1Q_VLAN 0x1             /* 802.1Q VLAN device.          */
+#define IFF_EBRIDGE	0x2		/* Ethernet bridging device.	*/
+#define IFF_SLAVE_INACTIVE	0x4	/* bonding slave not the curr. active */
+#define IFF_MASTER_8023AD	0x8	/* bonding master, 802.3ad. 	*/
+#define IFF_MASTER_ALB	0x10		/* bonding master, balance-alb.	*/
+#define IFF_BONDING	0x20		/* bonding master or slave	*/
+#define IFF_SLAVE_NEEDARP 0x40		/* need ARPs for validation	*/
+#define IFF_ISATAP	0x80		/* ISATAP interface (RFC4214)	*/
+#define IFF_MASTER_ARPMON 0x100		/* bonding master, ARP mon in use */
+#define IFF_WAN_HDLC	0x200		/* WAN HDLC device		*/
+#define IFF_XMIT_DST_RELEASE 0x400	/* dev_hard_start_xmit() is allowed to
+					 * release skb->dst
+					 */
+
+#define IF_GET_IFACE	0x0001		/* for querying only */
+#define IF_GET_PROTO	0x0002
+
+/* For definitions see hdlc.h */
+#define IF_IFACE_V35	0x1000		/* V.35 serial interface	*/
+#define IF_IFACE_V24	0x1001		/* V.24 serial interface	*/
+#define IF_IFACE_X21	0x1002		/* X.21 serial interface	*/
+#define IF_IFACE_T1	0x1003		/* T1 telco serial interface	*/
+#define IF_IFACE_E1	0x1004		/* E1 telco serial interface	*/
+#define IF_IFACE_SYNC_SERIAL 0x1005	/* can't be set by software	*/
+#define IF_IFACE_X21D   0x1006          /* X.21 Dual Clocking (FarSite) */
+
+/* For definitions see hdlc.h */
+#define IF_PROTO_HDLC	0x2000		/* raw HDLC protocol		*/
+#define IF_PROTO_PPP	0x2001		/* PPP protocol			*/
+#define IF_PROTO_CISCO	0x2002		/* Cisco HDLC protocol		*/
+#define IF_PROTO_FR	0x2003		/* Frame Relay protocol		*/
+#define IF_PROTO_FR_ADD_PVC 0x2004	/*    Create FR PVC		*/
+#define IF_PROTO_FR_DEL_PVC 0x2005	/*    Delete FR PVC		*/
+#define IF_PROTO_X25	0x2006		/* X.25				*/
+#define IF_PROTO_HDLC_ETH 0x2007	/* raw HDLC, Ethernet emulation	*/
+#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_PVC	0x200A		/* for reading PVC status	*/
+#define IF_PROTO_FR_ETH_PVC 0x200B
+#define IF_PROTO_RAW    0x200C          /* RAW Socket                   */
+
+/* RFC 2863 operational status */
+enum {
+	IF_OPER_UNKNOWN,
+	IF_OPER_NOTPRESENT,
+	IF_OPER_DOWN,
+	IF_OPER_LOWERLAYERDOWN,
+	IF_OPER_TESTING,
+	IF_OPER_DORMANT,
+	IF_OPER_UP,
+};
+
+/* link modes */
+enum {
+	IF_LINK_MODE_DEFAULT,
+	IF_LINK_MODE_DORMANT,	/* limit upward transition to dormant */
+};
+
+/*
+ *	Device mapping structure. I'd just gone off and designed a 
+ *	beautiful scheme using only loadable modules with arguments
+ *	for driver options and along come the PCMCIA people 8)
+ *
+ *	Ah well. The get() side of this is good for WDSETUP, and it'll
+ *	be handy for debugging things. The set side is fine for now and
+ *	being very small might be worth keeping for clean configuration.
+ */
+
+struct ifmap 
+{
+	unsigned long mem_start;
+	unsigned long mem_end;
+	unsigned short base_addr; 
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+	/* 3 bytes spare */
+};
+
+struct if_settings
+{
+	unsigned int type;	/* Type of physical device or protocol */
+	unsigned int size;	/* Size of the data allocated by the caller */
+	union {
+		/* {atm/eth/dsl}_settings anyone ? */
+		raw_hdlc_proto		*raw_hdlc;
+		cisco_proto		*cisco;
+		fr_proto		*fr;
+		fr_proto_pvc		*fr_pvc;
+		fr_proto_pvc_info	*fr_pvc_info;
+
+		/* interface settings */
+		sync_serial_settings	*sync;
+		te1_settings		*te1;
+	} ifs_ifsu;
+};
+
+/*
+ * Interface request structure used for socket
+ * ioctl's.  All interface ioctl's must have parameter
+ * definitions which begin with ifr_name.  The
+ * remainder may be interface specific.
+ */
+
+struct ifreq 
+{
+#define IFHWADDRLEN	6
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	} ifr_ifrn;
+	
+	union {
+		struct	sockaddr ifru_addr;
+		struct	sockaddr ifru_dstaddr;
+		struct	sockaddr ifru_broadaddr;
+		struct	sockaddr ifru_netmask;
+		struct  sockaddr ifru_hwaddr;
+		short	ifru_flags;
+		int	ifru_ivalue;
+		int	ifru_mtu;
+		struct  ifmap ifru_map;
+		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
+		char	ifru_newname[IFNAMSIZ];
+		void *	ifru_data;
+		struct	if_settings ifru_settings;
+	} ifr_ifru;
+};
+
+#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
+#define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
+#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
+#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
+#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
+#define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
+#define	ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
+#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
+#define ifr_map		ifr_ifru.ifru_map	/* device map		*/
+#define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index	*/
+#define ifr_bandwidth	ifr_ifru.ifru_ivalue    /* link bandwidth	*/
+#define ifr_qlen	ifr_ifru.ifru_ivalue	/* Queue length 	*/
+#define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
+#define ifr_settings	ifr_ifru.ifru_settings	/* Device/proto settings*/
+
+/*
+ * Structure used in SIOCGIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible).
+ */
+
+struct ifconf 
+{
+	int	ifc_len;			/* size of buffer	*/
+	union 
+	{
+		char *ifcu_buf;
+		struct ifreq *ifcu_req;
+	} ifc_ifcu;
+};
+#define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
+#define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/
+
+#endif /* _LINUX_IF_H */
diff -uNr linux-2.6.32/usr/include/linux/if_hippi.h clean_modified/linux-2.6.32/usr/include/linux/if_hippi.h
--- linux-2.6.32/usr/include/linux/if_hippi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_hippi.h	2019-04-14 13:24:02.992859333 -0500
@@ -0,0 +1,158 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the HIPPI interface.
+ *
+ * Version:	@(#)if_hippi.h	1.0.0	05/26/97
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *		Jes Sorensen, <Jes.Sorensen@cern.ch>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_HIPPI_H
+#define _LINUX_IF_HIPPI_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/*
+ *	HIPPI magic constants.
+ */
+
+#define HIPPI_ALEN	6		/* Bytes in one HIPPI hw-addr	   */
+#define HIPPI_HLEN	sizeof(struct hippi_hdr)
+#define HIPPI_ZLEN	0		/* Min. bytes in frame without FCS */
+#define HIPPI_DATA_LEN	65280		/* Max. bytes in payload	   */
+#define HIPPI_FRAME_LEN	(HIPPI_DATA_LEN + HIPPI_HLEN)
+					/* Max. bytes in frame without FCS */
+
+/*
+ * Define LLC and SNAP constants.
+ */
+#define HIPPI_EXTENDED_SAP	0xAA
+#define HIPPI_UI_CMD		0x03
+
+
+/*
+ *	Do we need to list some sort of ID's here?
+ */
+
+/*
+ *	HIPPI statistics collection data. 
+ */
+ 
+struct hipnet_statistics
+{
+	int	rx_packets;		/* total packets received	*/
+	int	tx_packets;		/* total packets transmitted	*/
+	int	rx_errors;		/* bad packets received		*/
+	int	tx_errors;		/* packet transmit problems	*/
+	int	rx_dropped;		/* no space in linux buffers	*/
+	int	tx_dropped;		/* no space available in linux	*/
+
+	/* detailed rx_errors: */
+	int	rx_length_errors;
+	int	rx_over_errors;		/* receiver ring buff overflow	*/
+	int	rx_crc_errors;		/* recved pkt with crc error	*/
+	int	rx_frame_errors;	/* recv'd frame alignment error */
+	int	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	int	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	int	tx_aborted_errors;
+	int	tx_carrier_errors;
+	int	tx_fifo_errors;
+	int	tx_heartbeat_errors;
+	int	tx_window_errors;
+};
+
+
+struct hippi_fp_hdr
+{
+#if 0
+	__u8		ulp;				/* must contain 4 */
+#if defined (__BIG_ENDIAN_BITFIELD)
+	__u8		d1_data_present:1;		/* must be 1 */
+	__u8		start_d2_burst_boundary:1;	/* must be zero */
+	__u8		reserved:6;			/* must be zero */
+#if 0
+	__u16		reserved1:5;
+	__u16		d1_area_size:8;			/* must be 3 */
+	__u16		d2_offset:3;			/* must be zero */
+#endif
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8		reserved:6;			/* must be zero */
+	__u8	 	start_d2_burst_boundary:1;	/* must be zero */
+	__u8		d1_data_present:1;		/* must be 1 */
+#if 0
+	__u16		d2_offset:3;			/* must be zero */
+	__u16		d1_area_size:8;			/* must be 3 */
+	__u16		reserved1:5;			/* must be zero */
+#endif
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+#else
+	__be32		fixed;
+#endif
+	__be32		d2_size;
+} __attribute__ ((packed));
+
+struct hippi_le_hdr
+{
+#if defined (__BIG_ENDIAN_BITFIELD)
+	__u8		fc:3;
+	__u8		double_wide:1;
+	__u8		message_type:4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8		message_type:4;
+	__u8		double_wide:1;
+	__u8		fc:3;
+#endif
+	__u8		dest_switch_addr[3];
+#if defined (__BIG_ENDIAN_BITFIELD)
+	__u8		dest_addr_type:4,
+			src_addr_type:4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8		src_addr_type:4,
+			dest_addr_type:4;
+#endif
+	__u8		src_switch_addr[3];
+	__u16		reserved;
+	__u8		daddr[HIPPI_ALEN];
+	__u16		locally_administered;
+	__u8		saddr[HIPPI_ALEN];
+} __attribute__ ((packed));
+
+#define HIPPI_OUI_LEN	3
+/*
+ * Looks like the dsap and ssap fields have been swapped by mistake in
+ * RFC 2067 "IP over HIPPI".
+ */
+struct hippi_snap_hdr
+{
+	__u8	dsap;			/* always 0xAA */
+	__u8	ssap;			/* always 0xAA */
+	__u8	ctrl;			/* always 0x03 */
+	__u8	oui[HIPPI_OUI_LEN];	/* organizational universal id (zero)*/
+	__be16	ethertype;		/* packet type ID field */
+} __attribute__ ((packed));
+
+struct hippi_hdr
+{
+	struct hippi_fp_hdr	fp;
+	struct hippi_le_hdr	le;
+	struct hippi_snap_hdr	snap;
+} __attribute__ ((packed));
+
+#endif	/* _LINUX_IF_HIPPI_H */
diff -uNr linux-2.6.32/usr/include/linux/if_infiniband.h clean_modified/linux-2.6.32/usr/include/linux/if_infiniband.h
--- linux-2.6.32/usr/include/linux/if_infiniband.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_infiniband.h	2019-04-14 13:24:02.993966290 -0500
@@ -0,0 +1,29 @@
+/*
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available at
+ * <http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD
+ * license, available in the LICENSE.TXT file accompanying this
+ * software.  These details are also available at
+ * <http://openib.org/license.html>.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ *
+ * $Id$
+ */
+
+#ifndef _LINUX_IF_INFINIBAND_H
+#define _LINUX_IF_INFINIBAND_H
+
+#define INFINIBAND_ALEN		20	/* Octets in IPoIB HW addr	*/
+
+#endif /* _LINUX_IF_INFINIBAND_H */
diff -uNr linux-2.6.32/usr/include/linux/if_link.h clean_modified/linux-2.6.32/usr/include/linux/if_link.h
--- linux-2.6.32/usr/include/linux/if_link.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_link.h	2019-04-14 13:24:02.993966290 -0500
@@ -0,0 +1,191 @@
+#ifndef _LINUX_IF_LINK_H
+#define _LINUX_IF_LINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+/* The struct should be in sync with struct net_device_stats */
+struct rtnl_link_stats
+{
+	__u32	rx_packets;		/* total packets received	*/
+	__u32	tx_packets;		/* total packets transmitted	*/
+	__u32	rx_bytes;		/* total bytes received 	*/
+	__u32	tx_bytes;		/* total bytes transmitted	*/
+	__u32	rx_errors;		/* bad packets received		*/
+	__u32	tx_errors;		/* packet transmit problems	*/
+	__u32	rx_dropped;		/* no space in linux buffers	*/
+	__u32	tx_dropped;		/* no space available in linux	*/
+	__u32	multicast;		/* multicast packets received	*/
+	__u32	collisions;
+
+	/* detailed rx_errors: */
+	__u32	rx_length_errors;
+	__u32	rx_over_errors;		/* receiver ring buff overflow	*/
+	__u32	rx_crc_errors;		/* recved pkt with crc error	*/
+	__u32	rx_frame_errors;	/* recv'd frame alignment error */
+	__u32	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	__u32	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	__u32	tx_aborted_errors;
+	__u32	tx_carrier_errors;
+	__u32	tx_fifo_errors;
+	__u32	tx_heartbeat_errors;
+	__u32	tx_window_errors;
+
+	/* for cslip etc */
+	__u32	rx_compressed;
+	__u32	tx_compressed;
+};
+
+/* The struct should be in sync with struct ifmap */
+struct rtnl_link_ifmap
+{
+	__u64	mem_start;
+	__u64	mem_end;
+	__u64	base_addr;
+	__u16	irq;
+	__u8	dma;
+	__u8	port;
+};
+
+enum
+{
+	IFLA_UNSPEC,
+	IFLA_ADDRESS,
+	IFLA_BROADCAST,
+	IFLA_IFNAME,
+	IFLA_MTU,
+	IFLA_LINK,
+	IFLA_QDISC,
+	IFLA_STATS,
+	IFLA_COST,
+#define IFLA_COST IFLA_COST
+	IFLA_PRIORITY,
+#define IFLA_PRIORITY IFLA_PRIORITY
+	IFLA_MASTER,
+#define IFLA_MASTER IFLA_MASTER
+	IFLA_WIRELESS,		/* Wireless Extension event - see wireless.h */
+#define IFLA_WIRELESS IFLA_WIRELESS
+	IFLA_PROTINFO,		/* Protocol specific information for a link */
+#define IFLA_PROTINFO IFLA_PROTINFO
+	IFLA_TXQLEN,
+#define IFLA_TXQLEN IFLA_TXQLEN
+	IFLA_MAP,
+#define IFLA_MAP IFLA_MAP
+	IFLA_WEIGHT,
+#define IFLA_WEIGHT IFLA_WEIGHT
+	IFLA_OPERSTATE,
+	IFLA_LINKMODE,
+	IFLA_LINKINFO,
+#define IFLA_LINKINFO IFLA_LINKINFO
+	IFLA_NET_NS_PID,
+	IFLA_IFALIAS,
+	__IFLA_MAX
+};
+
+
+#define IFLA_MAX (__IFLA_MAX - 1)
+
+/* backwards compatibility for userspace */
+#define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))
+#define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))
+
+/* ifi_flags.
+
+   IFF_* flags.
+
+   The only change is:
+   IFF_LOOPBACK, IFF_BROADCAST and IFF_POINTOPOINT are
+   more not changeable by user. They describe link media
+   characteristics and set by device driver.
+
+   Comments:
+   - Combination IFF_BROADCAST|IFF_POINTOPOINT is invalid
+   - If neither of these three flags are set;
+     the interface is NBMA.
+
+   - IFF_MULTICAST does not mean anything special:
+   multicasts can be used on all not-NBMA links.
+   IFF_MULTICAST means that this media uses special encapsulation
+   for multicast frames. Apparently, all IFF_POINTOPOINT and
+   IFF_BROADCAST devices are able to use multicasts too.
+ */
+
+/* IFLA_LINK.
+   For usual devices it is equal ifi_index.
+   If it is a "virtual interface" (f.e. tunnel), ifi_link
+   can point to real physical interface (f.e. for bandwidth calculations),
+   or maybe 0, what means, that real media is unknown (usual
+   for IPIP tunnels, when route to endpoint is allowed to change)
+ */
+
+/* Subtype attributes for IFLA_PROTINFO */
+enum
+{
+	IFLA_INET6_UNSPEC,
+	IFLA_INET6_FLAGS,	/* link flags			*/
+	IFLA_INET6_CONF,	/* sysctl parameters		*/
+	IFLA_INET6_STATS,	/* statistics			*/
+	IFLA_INET6_MCAST,	/* MC things. What of them?	*/
+	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
+	IFLA_INET6_ICMP6STATS,	/* statistics (icmpv6)		*/
+	__IFLA_INET6_MAX
+};
+
+#define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
+
+struct ifla_cacheinfo
+{
+	__u32	max_reasm_len;
+	__u32	tstamp;		/* ipv6InterfaceTable updated timestamp */
+	__u32	reachable_time;
+	__u32	retrans_time;
+};
+
+enum
+{
+	IFLA_INFO_UNSPEC,
+	IFLA_INFO_KIND,
+	IFLA_INFO_DATA,
+	IFLA_INFO_XSTATS,
+	__IFLA_INFO_MAX,
+};
+
+#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)
+
+/* VLAN section */
+
+enum
+{
+	IFLA_VLAN_UNSPEC,
+	IFLA_VLAN_ID,
+	IFLA_VLAN_FLAGS,
+	IFLA_VLAN_EGRESS_QOS,
+	IFLA_VLAN_INGRESS_QOS,
+	__IFLA_VLAN_MAX,
+};
+
+#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)
+
+struct ifla_vlan_flags {
+	__u32	flags;
+	__u32	mask;
+};
+
+enum
+{
+	IFLA_VLAN_QOS_UNSPEC,
+	IFLA_VLAN_QOS_MAPPING,
+	__IFLA_VLAN_QOS_MAX
+};
+
+#define IFLA_VLAN_QOS_MAX	(__IFLA_VLAN_QOS_MAX - 1)
+
+struct ifla_vlan_qos_mapping
+{
+	__u32 from;
+	__u32 to;
+};
+
+#endif /* _LINUX_IF_LINK_H */
diff -uNr linux-2.6.32/usr/include/linux/if_ltalk.h clean_modified/linux-2.6.32/usr/include/linux/if_ltalk.h
--- linux-2.6.32/usr/include/linux/if_ltalk.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_ltalk.h	2019-04-14 13:24:02.993966290 -0500
@@ -0,0 +1,9 @@
+#ifndef __LINUX_LTALK_H
+#define __LINUX_LTALK_H
+
+#define LTALK_HLEN		1
+#define LTALK_MTU		600
+#define LTALK_ALEN		1
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_packet.h clean_modified/linux-2.6.32/usr/include/linux/if_packet.h
--- linux-2.6.32/usr/include/linux/if_packet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_packet.h	2019-04-14 13:24:02.993966290 -0500
@@ -0,0 +1,150 @@
+#ifndef __LINUX_IF_PACKET_H
+#define __LINUX_IF_PACKET_H
+
+#include <linux/types.h>
+
+struct sockaddr_pkt
+{
+	unsigned short spkt_family;
+	unsigned char spkt_device[14];
+	__be16 spkt_protocol;
+};
+
+struct sockaddr_ll
+{
+	unsigned short	sll_family;
+	__be16		sll_protocol;
+	int		sll_ifindex;
+	unsigned short	sll_hatype;
+	unsigned char	sll_pkttype;
+	unsigned char	sll_halen;
+	unsigned char	sll_addr[8];
+};
+
+/* Packet types */
+
+#define PACKET_HOST		0		/* To us		*/
+#define PACKET_BROADCAST	1		/* To all		*/
+#define PACKET_MULTICAST	2		/* To group		*/
+#define PACKET_OTHERHOST	3		/* To someone else 	*/
+#define PACKET_OUTGOING		4		/* Outgoing of any type */
+/* These ones are invisible by user level */
+#define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+#define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
+
+/* Packet socket options */
+
+#define PACKET_ADD_MEMBERSHIP		1
+#define PACKET_DROP_MEMBERSHIP		2
+#define PACKET_RECV_OUTPUT		3
+/* Value 4 is still used by obsolete turbo-packet. */
+#define PACKET_RX_RING			5
+#define PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+
+struct tpacket_stats
+{
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+};
+
+struct tpacket_auxdata
+{
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u16		tp_vlan_tci;
+};
+
+/* Rx ring - header status */
+#define TP_STATUS_KERNEL	0x0
+#define TP_STATUS_USER		0x1
+#define TP_STATUS_COPY		0x2
+#define TP_STATUS_LOSING	0x4
+#define TP_STATUS_CSUMNOTREADY	0x8
+
+/* Tx ring - header status */
+#define TP_STATUS_AVAILABLE	0x0
+#define TP_STATUS_SEND_REQUEST	0x1
+#define TP_STATUS_SENDING	0x2
+#define TP_STATUS_WRONG_FORMAT	0x4
+
+struct tpacket_hdr
+{
+	unsigned long	tp_status;
+	unsigned int	tp_len;
+	unsigned int	tp_snaplen;
+	unsigned short	tp_mac;
+	unsigned short	tp_net;
+	unsigned int	tp_sec;
+	unsigned int	tp_usec;
+};
+
+#define TPACKET_ALIGNMENT	16
+#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
+#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
+
+struct tpacket2_hdr
+{
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u16		tp_vlan_tci;
+};
+
+#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
+
+enum tpacket_versions
+{
+	TPACKET_V1,
+	TPACKET_V2,
+};
+
+/*
+   Frame structure:
+
+   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
+   - struct tpacket_hdr
+   - pad to TPACKET_ALIGNMENT=16
+   - struct sockaddr_ll
+   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
+   - Start+tp_mac: [ Optional MAC header ]
+   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
+   - Pad to align to TPACKET_ALIGNMENT=16
+ */
+
+struct tpacket_req
+{
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+};
+
+struct packet_mreq
+{
+	int		mr_ifindex;
+	unsigned short	mr_type;
+	unsigned short	mr_alen;
+	unsigned char	mr_address[8];
+};
+
+#define PACKET_MR_MULTICAST	0
+#define PACKET_MR_PROMISC	1
+#define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_phonet.h clean_modified/linux-2.6.32/usr/include/linux/if_phonet.h
--- linux-2.6.32/usr/include/linux/if_phonet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_phonet.h	2019-04-14 13:24:02.994974383 -0500
@@ -0,0 +1,16 @@
+/*
+ * File: if_phonet.h
+ *
+ * Phonet interface kernel definitions
+ *
+ * Copyright (C) 2008 Nokia Corporation. All rights reserved.
+ */
+#ifndef LINUX_IF_PHONET_H
+#define LINUX_IF_PHONET_H
+
+#define PHONET_MIN_MTU		6	/* pn_length = 0 */
+#define PHONET_MAX_MTU		65541	/* pn_length = 0xffff */
+#define PHONET_DEV_MTU		PHONET_MAX_MTU
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_plip.h clean_modified/linux-2.6.32/usr/include/linux/if_plip.h
--- linux-2.6.32/usr/include/linux/if_plip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_plip.h	2019-04-14 13:24:02.994974383 -0500
@@ -0,0 +1,28 @@
+/*
+ *	NET3	PLIP tuning facilities for the new Niibe PLIP.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+ 
+#ifndef _LINUX_IF_PLIP_H
+#define _LINUX_IF_PLIP_H
+
+#include <linux/sockios.h>
+
+#define	SIOCDEVPLIP	SIOCDEVPRIVATE
+
+struct plipconf
+{
+	unsigned short pcmd;
+	unsigned long  nibble;
+	unsigned long  trigger;
+};
+
+#define PLIP_GET_TIMEOUT	0x1
+#define PLIP_SET_TIMEOUT	0x2
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_ppp.h clean_modified/linux-2.6.32/usr/include/linux/if_ppp.h
--- linux-2.6.32/usr/include/linux/if_ppp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_ppp.h	2019-04-14 13:24:02.994974383 -0500
@@ -0,0 +1,173 @@
+/*
+ * if_ppp.h - Point-to-Point Protocol definitions.
+ *
+ * Copyright (c) 1989 Carnegie Mellon University.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Carnegie Mellon University.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+/*
+ *  ==FILEVERSION 20050812==
+ *
+ *  NOTE TO MAINTAINERS:
+ *     If you modify this file at all, please set the above date.
+ *     if_ppp.h is shipped with a PPP distribution as well as with the kernel;
+ *     if everyone increases the FILEVERSION number above, then scripts
+ *     can do the right thing when deciding whether to install a new if_ppp.h
+ *     file.  Don't change the format of that line otherwise, so the
+ *     installation script can recognize it.
+ */
+
+#ifndef _IF_PPP_H_
+#define _IF_PPP_H_
+
+#include <linux/types.h>
+
+
+/*
+ * Packet sizes
+ */
+
+#define	PPP_MTU		1500	/* Default MTU (size of Info field) */
+#define PPP_MAXMRU	65000	/* Largest MRU we allow */
+#define PROTO_IPX	0x002b	/* protocol numbers */
+#define PROTO_DNA_RT    0x0027  /* DNA Routing */
+
+
+/*
+ * Bit definitions for flags.
+ */
+
+#define SC_COMP_PROT	0x00000001	/* protocol compression (output) */
+#define SC_COMP_AC	0x00000002	/* header compression (output) */
+#define	SC_COMP_TCP	0x00000004	/* TCP (VJ) compression (output) */
+#define SC_NO_TCP_CCID	0x00000008	/* disable VJ connection-id comp. */
+#define SC_REJ_COMP_AC	0x00000010	/* reject adrs/ctrl comp. on input */
+#define SC_REJ_COMP_TCP	0x00000020	/* reject TCP (VJ) comp. on input */
+#define SC_CCP_OPEN	0x00000040	/* Look at CCP packets */
+#define SC_CCP_UP	0x00000080	/* May send/recv compressed packets */
+#define SC_ENABLE_IP	0x00000100	/* IP packets may be exchanged */
+#define SC_LOOP_TRAFFIC	0x00000200	/* send traffic to pppd */
+#define SC_MULTILINK	0x00000400	/* do multilink encapsulation */
+#define SC_MP_SHORTSEQ	0x00000800	/* use short MP sequence numbers */
+#define SC_COMP_RUN	0x00001000	/* compressor has been inited */
+#define SC_DECOMP_RUN	0x00002000	/* decompressor has been inited */
+#define SC_MP_XSHORTSEQ	0x00004000	/* transmit short MP seq numbers */
+#define SC_DEBUG	0x00010000	/* enable debug messages */
+#define SC_LOG_INPKT	0x00020000	/* log contents of good pkts recvd */
+#define SC_LOG_OUTPKT	0x00040000	/* log contents of pkts sent */
+#define SC_LOG_RAWIN	0x00080000	/* log all chars received */
+#define SC_LOG_FLUSH	0x00100000	/* log all chars flushed */
+#define	SC_SYNC		0x00200000	/* synchronous serial mode */
+#define	SC_MUST_COMP    0x00400000	/* no uncompressed packets may be sent or received */
+#define	SC_MASK		0x0f600fff	/* bits that user can change */
+
+/* state bits */
+#define SC_XMIT_BUSY	0x10000000	/* (used by isdn_ppp?) */
+#define SC_RCV_ODDP	0x08000000	/* have rcvd char with odd parity */
+#define SC_RCV_EVNP	0x04000000	/* have rcvd char with even parity */
+#define SC_RCV_B7_1	0x02000000	/* have rcvd char with bit 7 = 1 */
+#define SC_RCV_B7_0	0x01000000	/* have rcvd char with bit 7 = 0 */
+#define SC_DC_FERROR	0x00800000	/* fatal decomp error detected */
+#define SC_DC_ERROR	0x00400000	/* non-fatal decomp error detected */
+
+/*
+ * Ioctl definitions.
+ */
+
+struct npioctl {
+	int		protocol;	/* PPP protocol, e.g. PPP_IP */
+	enum NPmode	mode;
+};
+
+/* Structure describing a CCP configuration option, for PPPIOCSCOMPRESS */
+struct ppp_option_data {
+	__u8	*ptr;
+	__u32	length;
+	int	transmit;
+};
+
+struct ifpppstatsreq {
+	struct ifreq	 b;
+	struct ppp_stats stats;			/* statistic information */
+};
+
+struct ifpppcstatsreq {
+	struct ifreq	      b;
+	struct ppp_comp_stats stats;
+};
+
+/* For PPPIOCGL2TPSTATS */
+struct pppol2tp_ioc_stats {
+	__u16		tunnel_id;	/* redundant */
+	__u16		session_id;	/* if zero, get tunnel stats */
+	__u32		using_ipsec:1;	/* valid only for session_id == 0 */
+	aligned_u64	tx_packets;
+	aligned_u64	tx_bytes;
+	aligned_u64	tx_errors;
+	aligned_u64	rx_packets;
+	aligned_u64	rx_bytes;
+	aligned_u64	rx_seq_discards;
+	aligned_u64	rx_oos_packets;
+	aligned_u64	rx_errors;
+};
+
+#define ifr__name       b.ifr_ifrn.ifrn_name
+#define stats_ptr       b.ifr_ifru.ifru_data
+
+/*
+ * Ioctl definitions.
+ */
+
+#define	PPPIOCGFLAGS	_IOR('t', 90, int)	/* get configuration flags */
+#define	PPPIOCSFLAGS	_IOW('t', 89, int)	/* set configuration flags */
+#define	PPPIOCGASYNCMAP	_IOR('t', 88, int)	/* get async map */
+#define	PPPIOCSASYNCMAP	_IOW('t', 87, int)	/* set async map */
+#define	PPPIOCGUNIT	_IOR('t', 86, int)	/* get ppp unit number */
+#define	PPPIOCGRASYNCMAP _IOR('t', 85, int)	/* get receive async map */
+#define	PPPIOCSRASYNCMAP _IOW('t', 84, int)	/* set receive async map */
+#define	PPPIOCGMRU	_IOR('t', 83, int)	/* get max receive unit */
+#define	PPPIOCSMRU	_IOW('t', 82, int)	/* set max receive unit */
+#define	PPPIOCSMAXCID	_IOW('t', 81, int)	/* set VJ max slot ID */
+#define PPPIOCGXASYNCMAP _IOR('t', 80, ext_accm) /* get extended ACCM */
+#define PPPIOCSXASYNCMAP _IOW('t', 79, ext_accm) /* set extended ACCM */
+#define PPPIOCXFERUNIT	_IO('t', 78)		/* transfer PPP unit */
+#define PPPIOCSCOMPRESS	_IOW('t', 77, struct ppp_option_data)
+#define PPPIOCGNPMODE	_IOWR('t', 76, struct npioctl) /* get NP mode */
+#define PPPIOCSNPMODE	_IOW('t', 75, struct npioctl)  /* set NP mode */
+#define PPPIOCSPASS	_IOW('t', 71, struct sock_fprog) /* set pass filter */
+#define PPPIOCSACTIVE	_IOW('t', 70, struct sock_fprog) /* set active filt */
+#define PPPIOCGDEBUG	_IOR('t', 65, int)	/* Read debug level */
+#define PPPIOCSDEBUG	_IOW('t', 64, int)	/* Set debug level */
+#define PPPIOCGIDLE	_IOR('t', 63, struct ppp_idle) /* get idle time */
+#define PPPIOCNEWUNIT	_IOWR('t', 62, int)	/* create new ppp unit */
+#define PPPIOCATTACH	_IOW('t', 61, int)	/* attach to ppp unit */
+#define PPPIOCDETACH	_IOW('t', 60, int)	/* detach from ppp unit/chan */
+#define PPPIOCSMRRU	_IOW('t', 59, int)	/* set multilink MRU */
+#define PPPIOCCONNECT	_IOW('t', 58, int)	/* connect channel to unit */
+#define PPPIOCDISCONN	_IO('t', 57)		/* disconnect channel */
+#define PPPIOCATTCHAN	_IOW('t', 56, int)	/* attach to ppp channel */
+#define PPPIOCGCHAN	_IOR('t', 55, int)	/* get ppp channel number */
+#define PPPIOCGL2TPSTATS _IOR('t', 54, struct pppol2tp_ioc_stats)
+
+#define SIOCGPPPSTATS   (SIOCDEVPRIVATE + 0)
+#define SIOCGPPPVER     (SIOCDEVPRIVATE + 1)	/* NEVER change this!! */
+#define SIOCGPPPCSTATS  (SIOCDEVPRIVATE + 2)
+
+#if !defined(ifr_mtu)
+#define ifr_mtu	ifr_ifru.ifru_metric
+#endif
+
+#endif /* _IF_PPP_H_ */
diff -uNr linux-2.6.32/usr/include/linux/if_pppol2tp.h clean_modified/linux-2.6.32/usr/include/linux/if_pppol2tp.h
--- linux-2.6.32/usr/include/linux/if_pppol2tp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_pppol2tp.h	2019-04-14 13:24:02.996019644 -0500
@@ -0,0 +1,66 @@
+/***************************************************************************
+ * Linux PPP over L2TP (PPPoL2TP) Socket Implementation (RFC 2661)
+ *
+ * This file supplies definitions required by the PPP over L2TP driver
+ * (pppol2tp.c).  All version information wrt this file is located in pppol2tp.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOL2TP_H
+#define __LINUX_IF_PPPOL2TP_H
+
+#include <linux/types.h>
+
+
+/* Structure used to connect() the socket to a particular tunnel UDP
+ * socket.
+ */
+struct pppol2tp_addr
+{
+	__kernel_pid_t	pid;		/* pid that owns the fd.
+					 * 0 => current */
+	int	fd;			/* FD of UDP socket to use */
+
+	struct sockaddr_in addr;	/* IP address and port to send to */
+
+	__u16 s_tunnel, s_session;	/* For matching incoming packets */
+	__u16 d_tunnel, d_session;	/* For sending outgoing packets */
+};
+
+/* Socket options:
+ * DEBUG	- bitmask of debug message categories
+ * SENDSEQ	- 0 => don't send packets with sequence numbers
+ *		  1 => send packets with sequence numbers
+ * RECVSEQ	- 0 => receive packet sequence numbers are optional
+ *		  1 => drop receive packets without sequence numbers
+ * LNSMODE	- 0 => act as LAC.
+ *		  1 => act as LNS.
+ * REORDERTO	- reorder timeout (in millisecs). If 0, don't try to reorder.
+ */
+enum {
+	PPPOL2TP_SO_DEBUG	= 1,
+	PPPOL2TP_SO_RECVSEQ	= 2,
+	PPPOL2TP_SO_SENDSEQ	= 3,
+	PPPOL2TP_SO_LNSMODE	= 4,
+	PPPOL2TP_SO_REORDERTO	= 5,
+};
+
+/* Debug message categories for the DEBUG socket option */
+enum {
+	PPPOL2TP_MSG_DEBUG	= (1 << 0),	/* verbose debug (if
+						 * compiled in) */
+	PPPOL2TP_MSG_CONTROL	= (1 << 1),	/* userspace - kernel
+						 * interface */
+	PPPOL2TP_MSG_SEQ	= (1 << 2),	/* sequence numbers */
+	PPPOL2TP_MSG_DATA	= (1 << 3),	/* data packets */
+};
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_pppox.h clean_modified/linux-2.6.32/usr/include/linux/if_pppox.h
--- linux-2.6.32/usr/include/linux/if_pppox.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_pppox.h	2019-04-14 13:24:02.996019644 -0500
@@ -0,0 +1,123 @@
+/***************************************************************************
+ * Linux PPP over X - Generic PPP transport layer sockets
+ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516) 
+ *
+ * This file supplies definitions required by the PPP over Ethernet driver
+ * (pppox.c).  All version information wrt this file is located in pppox.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOX_H
+#define __LINUX_IF_PPPOX_H
+
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+#include <linux/if_pppol2tp.h>
+
+/* For user-space programs to pick up these definitions
+ * which they wouldn't get otherwise without defining __KERNEL__
+ */
+#ifndef AF_PPPOX
+#define AF_PPPOX	24
+#define PF_PPPOX	AF_PPPOX
+#endif /* !(AF_PPPOX) */
+
+/************************************************************************ 
+ * PPPoE addressing definition 
+ */ 
+typedef __be16 sid_t;
+struct pppoe_addr{ 
+       sid_t           sid;                    /* Session identifier */ 
+       unsigned char   remote[ETH_ALEN];       /* Remote address */ 
+       char            dev[IFNAMSIZ];          /* Local device to use */ 
+}; 
+ 
+/************************************************************************ 
+ * Protocols supported by AF_PPPOX 
+ */ 
+#define PX_PROTO_OE    0 /* Currently just PPPoE */
+#define PX_PROTO_OL2TP 1 /* Now L2TP also */
+#define PX_MAX_PROTO   2
+
+struct sockaddr_pppox { 
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
+       unsigned int    sa_protocol;          /* protocol identifier */ 
+       union{ 
+               struct pppoe_addr       pppoe; 
+       }sa_addr; 
+}__attribute__ ((packed)); 
+
+/* The use of the above union isn't viable because the size of this
+ * struct must stay fixed over time -- applications use sizeof(struct
+ * sockaddr_pppox) to fill it. We use a protocol specific sockaddr
+ * type instead.
+ */
+struct sockaddr_pppol2tp {
+	sa_family_t     sa_family;      /* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppol2tp_addr pppol2tp;
+}__attribute__ ((packed));
+
+/*********************************************************************
+ *
+ * ioctl interface for defining forwarding of connections
+ *
+ ********************************************************************/
+
+#define PPPOEIOCSFWD	_IOW(0xB1 ,0, size_t)
+#define PPPOEIOCDFWD	_IO(0xB1 ,1)
+/*#define PPPOEIOCGFWD	_IOWR(0xB1,2, size_t)*/
+
+/* Codes to identify message types */
+#define PADI_CODE	0x09
+#define PADO_CODE	0x07
+#define PADR_CODE	0x19
+#define PADS_CODE	0x65
+#define PADT_CODE	0xa7
+struct pppoe_tag {
+	__be16 tag_type;
+	__be16 tag_len;
+	char tag_data[0];
+} __attribute ((packed));
+
+/* Tag identifiers */
+#define PTT_EOL		__cpu_to_be16(0x0000)
+#define PTT_SRV_NAME	__cpu_to_be16(0x0101)
+#define PTT_AC_NAME	__cpu_to_be16(0x0102)
+#define PTT_HOST_UNIQ	__cpu_to_be16(0x0103)
+#define PTT_AC_COOKIE	__cpu_to_be16(0x0104)
+#define PTT_VENDOR 	__cpu_to_be16(0x0105)
+#define PTT_RELAY_SID	__cpu_to_be16(0x0110)
+#define PTT_SRV_ERR     __cpu_to_be16(0x0201)
+#define PTT_SYS_ERR  	__cpu_to_be16(0x0202)
+#define PTT_GEN_ERR  	__cpu_to_be16(0x0203)
+
+struct pppoe_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 ver : 4;
+	__u8 type : 4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 type : 4;
+	__u8 ver : 4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8 code;
+	__be16 sid;
+	__be16 length;
+	struct pppoe_tag tag[0];
+} __attribute__ ((packed));
+
+/* Length of entire PPPoE + PPP header */
+#define PPPOE_SES_HLEN	8
+
+
+#endif /* !(__LINUX_IF_PPPOX_H) */
diff -uNr linux-2.6.32/usr/include/linux/if_slip.h clean_modified/linux-2.6.32/usr/include/linux/if_slip.h
--- linux-2.6.32/usr/include/linux/if_slip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_slip.h	2019-04-14 13:24:02.996019644 -0500
@@ -0,0 +1,30 @@
+/*
+ *	Swansea University Computer Society	NET3
+ *	
+ *	This file declares the constants of special use with the SLIP/CSLIP/
+ *	KISS TNC driver.
+ */
+ 
+#ifndef __LINUX_SLIP_H
+#define __LINUX_SLIP_H
+
+#define		SL_MODE_SLIP		0
+#define		SL_MODE_CSLIP		1
+#define 	SL_MODE_KISS		4
+
+#define		SL_OPT_SIXBIT		2
+#define		SL_OPT_ADAPTIVE		8
+
+/*
+ *	VSV = ioctl for keepalive & outfill in SLIP driver 
+ */
+ 
+#define SIOCSKEEPALIVE	(SIOCDEVPRIVATE)		/* Set keepalive timeout in sec */
+#define SIOCGKEEPALIVE	(SIOCDEVPRIVATE+1)		/* Get keepalive timeout */
+#define SIOCSOUTFILL	(SIOCDEVPRIVATE+2)		/* Set outfill timeout */
+#define	SIOCGOUTFILL	(SIOCDEVPRIVATE+3)		/* Get outfill timeout */
+#define SIOCSLEASE	(SIOCDEVPRIVATE+4)		/* Set "leased" line type */
+#define	SIOCGLEASE	(SIOCDEVPRIVATE+5)		/* Get line type */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_strip.h clean_modified/linux-2.6.32/usr/include/linux/if_strip.h
--- linux-2.6.32/usr/include/linux/if_strip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_strip.h	2019-04-14 13:24:02.996019644 -0500
@@ -0,0 +1,27 @@
+/*
+ * if_strip.h --
+ *
+ *      Definitions for the STRIP interface
+ *
+ * Copyright 1996 The Board of Trustees of The Leland Stanford
+ * Junior University. All Rights Reserved.
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  Stanford University
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without
+ * express or implied warranty.
+ */
+
+#ifndef __LINUX_STRIP_H
+#define __LINUX_STRIP_H
+
+#include <linux/types.h>
+
+typedef struct {
+    __u8 c[6];
+} MetricomAddress;
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/if_tr.h clean_modified/linux-2.6.32/usr/include/linux/if_tr.h
--- linux-2.6.32/usr/include/linux/if_tr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_tr.h	2019-04-14 13:24:02.996019644 -0500
@@ -0,0 +1,95 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Token-Ring IEEE 802.5 interface.
+ *
+ * Version:	@(#)if_tr.h	0.0	07/11/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Peter De Schrijver, <stud11@cc4.kuleuven.ac.be>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_TR_H
+#define _LINUX_IF_TR_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>	/* For __be16 */
+
+/* IEEE 802.5 Token-Ring magic constants.  The frame sizes omit the preamble
+   and FCS/CRC (frame check sequence). */
+#define TR_ALEN		6		/* Octets in one token-ring addr */
+#define TR_HLEN 	(sizeof(struct trh_hdr)+sizeof(struct trllc))
+#define AC		0x10
+#define LLC_FRAME 	0x40
+
+/* LLC and SNAP constants */
+#define EXTENDED_SAP 	0xAA
+#define UI_CMD       	0x03
+
+/* This is an Token-Ring frame header. */
+struct trh_hdr {
+	__u8  ac;			/* access control field */
+	__u8  fc;			/* frame control field */
+	__u8  daddr[TR_ALEN];		/* destination address */
+	__u8  saddr[TR_ALEN];		/* source address */
+	__be16 rcf;			/* route control field */
+	__be16 rseg[8];			/* routing registers */
+};
+
+
+/* This is an Token-Ring LLC structure */
+struct trllc {
+	__u8  dsap;			/* destination SAP */
+	__u8  ssap;			/* source SAP */
+	__u8  llc;			/* LLC control field */
+	__u8  protid[3];		/* protocol id */
+	__be16 ethertype;		/* ether type field */
+};
+
+/* Token-Ring statistics collection data. */
+struct tr_statistics {
+	unsigned long rx_packets;       /* total packets received	*/
+	unsigned long tx_packets;	/* total packets transmitted	*/
+	unsigned long rx_bytes;		/* total bytes received   	*/
+	unsigned long tx_bytes;		/* total bytes transmitted	*/
+	unsigned long rx_errors;	/* bad packets received		*/
+	unsigned long tx_errors;	/* packet transmit problems	*/
+	unsigned long rx_dropped;	/* no space in linux buffers	*/
+	unsigned long tx_dropped;	/* no space available in linux	*/
+	unsigned long multicast;	/* multicast packets received	*/
+	unsigned long transmit_collision;
+
+	/* detailed Token-Ring errors. See IBM Token-Ring Network
+	   Architecture for more info */
+
+	unsigned long line_errors;
+	unsigned long internal_errors;
+	unsigned long burst_errors;
+	unsigned long A_C_errors;
+	unsigned long abort_delimiters;
+	unsigned long lost_frames;
+	unsigned long recv_congest_count;
+	unsigned long frame_copied_errors;
+	unsigned long frequency_errors;
+	unsigned long token_errors;
+	unsigned long dummy1;
+};
+
+/* source routing stuff */
+#define TR_RII 			0x80
+#define TR_RCF_DIR_BIT 		0x80
+#define TR_RCF_LEN_MASK 	0x1f00
+#define TR_RCF_BROADCAST 	0x8000	/* all-routes broadcast */
+#define TR_RCF_LIMITED_BROADCAST 0xC000	/* single-route broadcast */
+#define TR_RCF_FRAME2K 		0x20
+#define TR_RCF_BROADCAST_MASK 	0xC000
+#define TR_MAXRIFLEN 		18
+
+#endif	/* _LINUX_IF_TR_H */
diff -uNr linux-2.6.32/usr/include/linux/if_tun.h clean_modified/linux-2.6.32/usr/include/linux/if_tun.h
--- linux-2.6.32/usr/include/linux/if_tun.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_tun.h	2019-04-14 13:24:02.997472627 -0500
@@ -0,0 +1,89 @@
+/*
+ *  Universal TUN/TAP device driver.
+ *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef __IF_TUN_H
+#define __IF_TUN_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+
+/* Read queue size */
+#define TUN_READQ_SIZE	500
+
+/* TUN device flags */
+#define TUN_TUN_DEV 	0x0001	
+#define TUN_TAP_DEV	0x0002
+#define TUN_TYPE_MASK   0x000f
+
+#define TUN_FASYNC	0x0010
+#define TUN_NOCHECKSUM	0x0020
+#define TUN_NO_PI	0x0040
+#define TUN_ONE_QUEUE	0x0080
+#define TUN_PERSIST 	0x0100	
+#define TUN_VNET_HDR 	0x0200
+
+/* Ioctl defines */
+#define TUNSETNOCSUM  _IOW('T', 200, int) 
+#define TUNSETDEBUG   _IOW('T', 201, int) 
+#define TUNSETIFF     _IOW('T', 202, int) 
+#define TUNSETPERSIST _IOW('T', 203, int) 
+#define TUNSETOWNER   _IOW('T', 204, int)
+#define TUNSETLINK    _IOW('T', 205, int)
+#define TUNSETGROUP   _IOW('T', 206, int)
+#define TUNGETFEATURES _IOR('T', 207, unsigned int)
+#define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
+#define TUNSETTXFILTER _IOW('T', 209, unsigned int)
+#define TUNGETIFF      _IOR('T', 210, unsigned int)
+#define TUNGETSNDBUF   _IOR('T', 211, int)
+#define TUNSETSNDBUF   _IOW('T', 212, int)
+
+/* TUNSETIFF ifr flags */
+#define IFF_TUN		0x0001
+#define IFF_TAP		0x0002
+#define IFF_NO_PI	0x1000
+#define IFF_ONE_QUEUE	0x2000
+#define IFF_VNET_HDR	0x4000
+#define IFF_TUN_EXCL	0x8000
+
+/* Features for GSO (TUNSETOFFLOAD). */
+#define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */
+#define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
+#define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
+#define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
+#define TUN_F_UFO	0x10	/* I can handle UFO packets */
+
+/* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
+#define TUN_PKT_STRIP	0x0001
+struct tun_pi {
+	__u16  flags;
+	__be16 proto;
+};
+
+/*
+ * Filter spec (used for SETXXFILTER ioctls)
+ * This stuff is applicable only to the TAP (Ethernet) devices.
+ * If the count is zero the filter is disabled and the driver accepts
+ * all packets (promisc mode).
+ * If the filter is enabled in order to accept broadcast packets
+ * broadcast addr must be explicitly included in the addr list.
+ */
+#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
+struct tun_filter {
+	__u16  flags; /* TUN_FLT_ flags see above */
+	__u16  count; /* Number of addresses */
+	__u8   addr[0][ETH_ALEN];
+};
+
+#endif /* __IF_TUN_H */
diff -uNr linux-2.6.32/usr/include/linux/if_tunnel.h clean_modified/linux-2.6.32/usr/include/linux/if_tunnel.h
--- linux-2.6.32/usr/include/linux/if_tunnel.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_tunnel.h	2019-04-14 13:24:02.997472627 -0500
@@ -0,0 +1,69 @@
+#ifndef _IF_TUNNEL_H_
+#define _IF_TUNNEL_H_
+
+#include <linux/types.h>
+
+
+#define SIOCGETTUNNEL   (SIOCDEVPRIVATE + 0)
+#define SIOCADDTUNNEL   (SIOCDEVPRIVATE + 1)
+#define SIOCDELTUNNEL   (SIOCDEVPRIVATE + 2)
+#define SIOCCHGTUNNEL   (SIOCDEVPRIVATE + 3)
+#define SIOCGETPRL      (SIOCDEVPRIVATE + 4)
+#define SIOCADDPRL      (SIOCDEVPRIVATE + 5)
+#define SIOCDELPRL      (SIOCDEVPRIVATE + 6)
+#define SIOCCHGPRL      (SIOCDEVPRIVATE + 7)
+
+#define GRE_CSUM	__cpu_to_be16(0x8000)
+#define GRE_ROUTING	__cpu_to_be16(0x4000)
+#define GRE_KEY		__cpu_to_be16(0x2000)
+#define GRE_SEQ		__cpu_to_be16(0x1000)
+#define GRE_STRICT	__cpu_to_be16(0x0800)
+#define GRE_REC		__cpu_to_be16(0x0700)
+#define GRE_FLAGS	__cpu_to_be16(0x00F8)
+#define GRE_VERSION	__cpu_to_be16(0x0007)
+
+struct ip_tunnel_parm
+{
+	char			name[IFNAMSIZ];
+	int			link;
+	__be16			i_flags;
+	__be16			o_flags;
+	__be32			i_key;
+	__be32			o_key;
+	struct iphdr		iph;
+};
+
+/* SIT-mode i_flags */
+#define	SIT_ISATAP	0x0001
+
+struct ip_tunnel_prl {
+	__be32			addr;
+	__u16			flags;
+	__u16			__reserved;
+	__u32			datalen;
+	__u32			__reserved2;
+	/* data follows */
+};
+
+/* PRL flags */
+#define	PRL_DEFAULT		0x0001
+
+enum
+{
+	IFLA_GRE_UNSPEC,
+	IFLA_GRE_LINK,
+	IFLA_GRE_IFLAGS,
+	IFLA_GRE_OFLAGS,
+	IFLA_GRE_IKEY,
+	IFLA_GRE_OKEY,
+	IFLA_GRE_LOCAL,
+	IFLA_GRE_REMOTE,
+	IFLA_GRE_TTL,
+	IFLA_GRE_TOS,
+	IFLA_GRE_PMTUDISC,
+	__IFLA_GRE_MAX,
+};
+
+#define IFLA_GRE_MAX	(__IFLA_GRE_MAX - 1)
+
+#endif /* _IF_TUNNEL_H_ */
diff -uNr linux-2.6.32/usr/include/linux/if_vlan.h clean_modified/linux-2.6.32/usr/include/linux/if_vlan.h
--- linux-2.6.32/usr/include/linux/if_vlan.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/if_vlan.h	2019-04-14 13:24:02.998466233 -0500
@@ -0,0 +1,62 @@
+/*
+ * VLAN		An implementation of 802.1Q VLAN tagging.
+ *
+ * Authors:	Ben Greear <greearb@candelatech.com>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_VLAN_H_
+#define _LINUX_IF_VLAN_H_
+
+
+/* VLAN IOCTLs are found in sockios.h */
+
+/* Passed in vlan_ioctl_args structure to determine behaviour. */
+enum vlan_ioctl_cmds {
+	ADD_VLAN_CMD,
+	DEL_VLAN_CMD,
+	SET_VLAN_INGRESS_PRIORITY_CMD,
+	SET_VLAN_EGRESS_PRIORITY_CMD,
+	GET_VLAN_INGRESS_PRIORITY_CMD,
+	GET_VLAN_EGRESS_PRIORITY_CMD,
+	SET_VLAN_NAME_TYPE_CMD,
+	SET_VLAN_FLAG_CMD,
+	GET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */
+	GET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */
+};
+
+enum vlan_flags {
+	VLAN_FLAG_REORDER_HDR	= 0x1,
+	VLAN_FLAG_GVRP		= 0x2,
+};
+
+enum vlan_name_types {
+	VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */
+	VLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */
+	VLAN_NAME_TYPE_HIGHEST
+};
+
+struct vlan_ioctl_args {
+	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */
+	char device1[24];
+
+        union {
+		char device2[24];
+		int VID;
+		unsigned int skb_priority;
+		unsigned int name_type;
+		unsigned int bind_type;
+		unsigned int flag; /* Matches vlan_dev_info flags */
+        } u;
+
+	short vlan_qos;   
+};
+
+#endif /* !(_LINUX_IF_VLAN_H_) */
diff -uNr linux-2.6.32/usr/include/linux/igmp.h clean_modified/linux-2.6.32/usr/include/linux/igmp.h
--- linux-2.6.32/usr/include/linux/igmp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/igmp.h	2019-04-14 13:24:02.999275569 -0500
@@ -0,0 +1,129 @@
+/*
+ *	Linux NET3:	Internet Group Management Protocol  [IGMP]
+ *
+ *	Authors:
+ *		Alan Cox <alan@lxorguk.ukuu.org.uk>
+ *
+ *	Extended to talk the BSD extended IGMP protocol of mrouted 3.6
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IGMP_H
+#define _LINUX_IGMP_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/*
+ *	IGMP protocol structures
+ */
+
+/*
+ *	Header in on cable format
+ */
+
+struct igmphdr
+{
+	__u8 type;
+	__u8 code;		/* For newer IGMP */
+	__sum16 csum;
+	__be32 group;
+};
+
+/* V3 group record types [grec_type] */
+#define IGMPV3_MODE_IS_INCLUDE		1
+#define IGMPV3_MODE_IS_EXCLUDE		2
+#define IGMPV3_CHANGE_TO_INCLUDE	3
+#define IGMPV3_CHANGE_TO_EXCLUDE	4
+#define IGMPV3_ALLOW_NEW_SOURCES	5
+#define IGMPV3_BLOCK_OLD_SOURCES	6
+
+struct igmpv3_grec {
+	__u8	grec_type;
+	__u8	grec_auxwords;
+	__be16	grec_nsrcs;
+	__be32	grec_mca;
+	__be32	grec_src[0];
+};
+
+struct igmpv3_report {
+	__u8 type;
+	__u8 resv1;
+	__be16 csum;
+	__be16 resv2;
+	__be16 ngrec;
+	struct igmpv3_grec grec[0];
+};
+
+struct igmpv3_query {
+	__u8 type;
+	__u8 code;
+	__be16 csum;
+	__be32 group;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 qrv:3,
+	     suppress:1,
+	     resv:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 resv:4,
+	     suppress:1,
+	     qrv:3;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	__u8 qqic;
+	__be16 nsrcs;
+	__be32 srcs[0];
+};
+
+#define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
+#define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
+#define IGMP_DVMRP			0x13	/* DVMRP routing */
+#define IGMP_PIM			0x14	/* PIM routing */
+#define IGMP_TRACE			0x15
+#define IGMPV2_HOST_MEMBERSHIP_REPORT	0x16	/* V2 version of 0x11 */
+#define IGMP_HOST_LEAVE_MESSAGE 	0x17
+#define IGMPV3_HOST_MEMBERSHIP_REPORT	0x22	/* V3 version of 0x11 */
+
+#define IGMP_MTRACE_RESP		0x1e
+#define IGMP_MTRACE			0x1f
+
+
+/*
+ *	Use the BSD names for these for compatibility
+ */
+
+#define IGMP_DELAYING_MEMBER		0x01
+#define IGMP_IDLE_MEMBER		0x02
+#define IGMP_LAZY_MEMBER		0x03
+#define IGMP_SLEEPING_MEMBER		0x04
+#define IGMP_AWAKENING_MEMBER		0x05
+
+#define IGMP_MINLEN			8
+
+#define IGMP_MAX_HOST_REPORT_DELAY	10	/* max delay for response to */
+						/* query (in seconds)	*/
+
+#define IGMP_TIMER_SCALE		10	/* denotes that the igmphdr->timer field */
+						/* specifies time in 10th of seconds	 */
+
+#define IGMP_AGE_THRESHOLD		400	/* If this host don't hear any IGMP V1	*/
+						/* message in this period of time,	*/
+						/* revert to IGMP v2 router.		*/
+
+#define IGMP_ALL_HOSTS		htonl(0xE0000001L)
+#define IGMP_ALL_ROUTER 	htonl(0xE0000002L)
+#define IGMPV3_ALL_MCR	 	htonl(0xE0000016L)
+#define IGMP_LOCAL_GROUP	htonl(0xE0000000L)
+#define IGMP_LOCAL_GROUP_MASK	htonl(0xFFFFFF00L)
+
+/*
+ * struct for keeping the multicast list in
+ */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/in6.h clean_modified/linux-2.6.32/usr/include/linux/in6.h
--- linux-2.6.32/usr/include/linux/in6.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/in6.h	2019-04-14 13:24:02.999844161 -0500
@@ -0,0 +1,274 @@
+/*
+ *	Types and definitions for AF_INET6 
+ *	Linux INET6 implementation 
+ *
+ *	Authors:
+ *	Pedro Roque		<roque@di.fc.ul.pt>	
+ *
+ *	Sources:
+ *	IPv6 Program Interfaces for BSD Systems
+ *      <draft-ietf-ipngwg-bsd-api-05.txt>
+ *
+ *	Advanced Sockets API for IPv6
+ *	<draft-stevens-advanced-api-00.txt>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IN6_H
+#define _LINUX_IN6_H
+
+#include <linux/types.h>
+
+/*
+ *	IPv6 address structure
+ */
+
+struct in6_addr
+{
+	union 
+	{
+		__u8		u6_addr8[16];
+		__be16		u6_addr16[8];
+		__be32		u6_addr32[4];
+	} in6_u;
+#define s6_addr			in6_u.u6_addr8
+#define s6_addr16		in6_u.u6_addr16
+#define s6_addr32		in6_u.u6_addr32
+};
+
+/* IPv6 Wildcard Address (::) and Loopback Address (::1) defined in RFC2553
+ * NOTE: Be aware the IN6ADDR_* constants and in6addr_* externals are defined
+ * in network byte order, not in host byte order as are the IPv4 equivalents
+ */
+
+struct sockaddr_in6 {
+	unsigned short int	sin6_family;    /* AF_INET6 */
+	__be16			sin6_port;      /* Transport layer port # */
+	__be32			sin6_flowinfo;  /* IPv6 flow information */
+	struct in6_addr		sin6_addr;      /* IPv6 address */
+	__u32			sin6_scope_id;  /* scope id (new in RFC2553) */
+};
+
+struct ipv6_mreq {
+	/* IPv6 multicast address of group */
+	struct in6_addr ipv6mr_multiaddr;
+
+	/* local IPv6 address of interface */
+	int		ipv6mr_ifindex;
+};
+
+#define ipv6mr_acaddr	ipv6mr_multiaddr
+
+struct in6_flowlabel_req
+{
+	struct in6_addr	flr_dst;
+	__be32	flr_label;
+	__u8	flr_action;
+	__u8	flr_share;
+	__u16	flr_flags;
+	__u16 	flr_expires;
+	__u16	flr_linger;
+	__u32	__flr_pad;
+	/* Options in format of IPV6_PKTOPTIONS */
+};
+
+#define IPV6_FL_A_GET	0
+#define IPV6_FL_A_PUT	1
+#define IPV6_FL_A_RENEW	2
+
+#define IPV6_FL_F_CREATE	1
+#define IPV6_FL_F_EXCL		2
+
+#define IPV6_FL_S_NONE		0
+#define IPV6_FL_S_EXCL		1
+#define IPV6_FL_S_PROCESS	2
+#define IPV6_FL_S_USER		3
+#define IPV6_FL_S_ANY		255
+
+
+/*
+ *	Bitmask constant declarations to help applications select out the 
+ *	flow label and priority fields.
+ *
+ *	Note that this are in host byte order while the flowinfo field of
+ *	sockaddr_in6 is in network byte order.
+ */
+
+#define IPV6_FLOWINFO_FLOWLABEL		0x000fffff
+#define IPV6_FLOWINFO_PRIORITY		0x0ff00000
+
+/* These defintions are obsolete */
+#define IPV6_PRIORITY_UNCHARACTERIZED	0x0000
+#define IPV6_PRIORITY_FILLER		0x0100
+#define IPV6_PRIORITY_UNATTENDED	0x0200
+#define IPV6_PRIORITY_RESERVED1		0x0300
+#define IPV6_PRIORITY_BULK		0x0400
+#define IPV6_PRIORITY_RESERVED2		0x0500
+#define IPV6_PRIORITY_INTERACTIVE	0x0600
+#define IPV6_PRIORITY_CONTROL		0x0700
+#define IPV6_PRIORITY_8			0x0800
+#define IPV6_PRIORITY_9			0x0900
+#define IPV6_PRIORITY_10		0x0a00
+#define IPV6_PRIORITY_11		0x0b00
+#define IPV6_PRIORITY_12		0x0c00
+#define IPV6_PRIORITY_13		0x0d00
+#define IPV6_PRIORITY_14		0x0e00
+#define IPV6_PRIORITY_15		0x0f00
+
+/*
+ *	IPV6 extension headers
+ */
+#define IPPROTO_HOPOPTS		0	/* IPv6 hop-by-hop options	*/
+#define IPPROTO_ROUTING		43	/* IPv6 routing header		*/
+#define IPPROTO_FRAGMENT	44	/* IPv6 fragmentation header	*/
+#define IPPROTO_ICMPV6		58	/* ICMPv6			*/
+#define IPPROTO_NONE		59	/* IPv6 no next header		*/
+#define IPPROTO_DSTOPTS		60	/* IPv6 destination options	*/
+#define IPPROTO_MH		135	/* IPv6 mobility header		*/
+
+/*
+ *	IPv6 TLV options.
+ */
+#define IPV6_TLV_PAD0		0
+#define IPV6_TLV_PADN		1
+#define IPV6_TLV_ROUTERALERT	5
+#define IPV6_TLV_JUMBO		194
+#define IPV6_TLV_HAO		201	/* home address option */
+
+/*
+ *	IPV6 socket options
+ */
+
+#define IPV6_ADDRFORM		1
+#define IPV6_2292PKTINFO	2
+#define IPV6_2292HOPOPTS	3
+#define IPV6_2292DSTOPTS	4
+#define IPV6_2292RTHDR		5
+#define IPV6_2292PKTOPTIONS	6
+#define IPV6_CHECKSUM		7
+#define IPV6_2292HOPLIMIT	8
+#define IPV6_NEXTHOP		9
+#define IPV6_AUTHHDR		10	/* obsolete */
+#define IPV6_FLOWINFO		11
+
+#define IPV6_UNICAST_HOPS	16
+#define IPV6_MULTICAST_IF	17
+#define IPV6_MULTICAST_HOPS	18
+#define IPV6_MULTICAST_LOOP	19
+#define IPV6_ADD_MEMBERSHIP	20
+#define IPV6_DROP_MEMBERSHIP	21
+#define IPV6_ROUTER_ALERT	22
+#define IPV6_MTU_DISCOVER	23
+#define IPV6_MTU		24
+#define IPV6_RECVERR		25
+#define IPV6_V6ONLY		26
+#define IPV6_JOIN_ANYCAST	27
+#define IPV6_LEAVE_ANYCAST	28
+
+/* IPV6_MTU_DISCOVER values */
+#define IPV6_PMTUDISC_DONT		0
+#define IPV6_PMTUDISC_WANT		1
+#define IPV6_PMTUDISC_DO		2
+#define IPV6_PMTUDISC_PROBE		3
+
+/* Flowlabel */
+#define IPV6_FLOWLABEL_MGR	32
+#define IPV6_FLOWINFO_SEND	33
+
+#define IPV6_IPSEC_POLICY	34
+#define IPV6_XFRM_POLICY	35
+
+/*
+ * Multicast:
+ * Following socket options are shared between IPv4 and IPv6.
+ *
+ * MCAST_JOIN_GROUP		42
+ * MCAST_BLOCK_SOURCE		43
+ * MCAST_UNBLOCK_SOURCE		44
+ * MCAST_LEAVE_GROUP		45
+ * MCAST_JOIN_SOURCE_GROUP	46
+ * MCAST_LEAVE_SOURCE_GROUP	47
+ * MCAST_MSFILTER		48
+ */
+
+/*
+ * Advanced API (RFC3542) (1)
+ *
+ * Note: IPV6_RECVRTHDRDSTOPTS does not exist. see net/ipv6/datagram.c.
+ */
+
+#define IPV6_RECVPKTINFO	49
+#define IPV6_PKTINFO		50
+#define IPV6_RECVHOPLIMIT	51
+#define IPV6_HOPLIMIT		52
+#define IPV6_RECVHOPOPTS	53
+#define IPV6_HOPOPTS		54
+#define IPV6_RTHDRDSTOPTS	55
+#define IPV6_RECVRTHDR		56
+#define IPV6_RTHDR		57
+#define IPV6_RECVDSTOPTS	58
+#define IPV6_DSTOPTS		59
+#if 0	/* not yet */
+#define IPV6_RECVPATHMTU	60
+#define IPV6_PATHMTU		61
+#define IPV6_DONTFRAG		62
+#define IPV6_USE_MIN_MTU	63
+#endif
+
+/*
+ * Netfilter (1)
+ *
+ * Following socket options are used in ip6_tables;
+ * see include/linux/netfilter_ipv6/ip6_tables.h.
+ *
+ * IP6T_SO_SET_REPLACE / IP6T_SO_GET_INFO		64
+ * IP6T_SO_SET_ADD_COUNTERS / IP6T_SO_GET_ENTRIES	65
+ */
+
+/*
+ * Advanced API (RFC3542) (2)
+ */
+#define IPV6_RECVTCLASS		66
+#define IPV6_TCLASS		67
+
+/*
+ * Netfilter (2)
+ *
+ * Following socket options are used in ip6_tables;
+ * see include/linux/netfilter_ipv6/ip6_tables.h.
+ *
+ * IP6T_SO_GET_REVISION_MATCH	68
+ * IP6T_SO_GET_REVISION_TARGET	69
+ */
+
+/* RFC5014: Source address selection */
+#define IPV6_ADDR_PREFERENCES	72
+
+#define IPV6_PREFER_SRC_TMP		0x0001
+#define IPV6_PREFER_SRC_PUBLIC		0x0002
+#define IPV6_PREFER_SRC_PUBTMP_DEFAULT	0x0100
+#define IPV6_PREFER_SRC_COA		0x0004
+#define IPV6_PREFER_SRC_HOME		0x0400
+#define IPV6_PREFER_SRC_CGA		0x0008
+#define IPV6_PREFER_SRC_NONCGA		0x0800
+
+/*
+ * Multicast Routing:
+ * see include/linux/mroute6.h.
+ *
+ * MRT6_INIT			200
+ * MRT6_DONE			201
+ * MRT6_ADD_MIF			202
+ * MRT6_DEL_MIF			203
+ * MRT6_ADD_MFC			204
+ * MRT6_DEL_MFC			205
+ * MRT6_VERSION			206
+ * MRT6_ASSERT			207
+ * MRT6_PIM			208
+ * (reserved)			209
+ */
+#endif
diff -uNr linux-2.6.32/usr/include/linux/inet_diag.h clean_modified/linux-2.6.32/usr/include/linux/inet_diag.h
--- linux-2.6.32/usr/include/linux/inet_diag.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/inet_diag.h	2019-04-14 13:24:02.999844161 -0500
@@ -0,0 +1,124 @@
+#ifndef _INET_DIAG_H_
+#define _INET_DIAG_H_ 1
+
+#include <linux/types.h>
+
+/* Just some random number */
+#define TCPDIAG_GETSOCK 18
+#define DCCPDIAG_GETSOCK 19
+
+#define INET_DIAG_GETSOCK_MAX 24
+
+/* Socket identity */
+struct inet_diag_sockid {
+	__be16	idiag_sport;
+	__be16	idiag_dport;
+	__be32	idiag_src[4];
+	__be32	idiag_dst[4];
+	__u32	idiag_if;
+	__u32	idiag_cookie[2];
+#define INET_DIAG_NOCOOKIE (~0U)
+};
+
+/* Request structure */
+
+struct inet_diag_req {
+	__u8	idiag_family;		/* Family of addresses. */
+	__u8	idiag_src_len;
+	__u8	idiag_dst_len;
+	__u8	idiag_ext;		/* Query extended information */
+
+	struct inet_diag_sockid id;
+
+	__u32	idiag_states;		/* States to dump */
+	__u32	idiag_dbs;		/* Tables to dump (NI) */
+};
+
+enum {
+	INET_DIAG_REQ_NONE,
+	INET_DIAG_REQ_BYTECODE,
+};
+
+#define INET_DIAG_REQ_MAX INET_DIAG_REQ_BYTECODE
+
+/* Bytecode is sequence of 4 byte commands followed by variable arguments.
+ * All the commands identified by "code" are conditional jumps forward:
+ * to offset cc+"yes" or to offset cc+"no". "yes" is supposed to be
+ * length of the command and its arguments.
+ */
+ 
+struct inet_diag_bc_op {
+	unsigned char	code;
+	unsigned char	yes;
+	unsigned short	no;
+};
+
+enum {
+	INET_DIAG_BC_NOP,
+	INET_DIAG_BC_JMP,
+	INET_DIAG_BC_S_GE,
+	INET_DIAG_BC_S_LE,
+	INET_DIAG_BC_D_GE,
+	INET_DIAG_BC_D_LE,
+	INET_DIAG_BC_AUTO,
+	INET_DIAG_BC_S_COND,
+	INET_DIAG_BC_D_COND,
+};
+
+struct inet_diag_hostcond {
+	__u8	family;
+	__u8	prefix_len;
+	int	port;
+	__be32	addr[0];
+};
+
+/* Base info structure. It contains socket identity (addrs/ports/cookie)
+ * and, alas, the information shown by netstat. */
+struct inet_diag_msg {
+	__u8	idiag_family;
+	__u8	idiag_state;
+	__u8	idiag_timer;
+	__u8	idiag_retrans;
+
+	struct inet_diag_sockid id;
+
+	__u32	idiag_expires;
+	__u32	idiag_rqueue;
+	__u32	idiag_wqueue;
+	__u32	idiag_uid;
+	__u32	idiag_inode;
+};
+
+/* Extensions */
+
+enum {
+	INET_DIAG_NONE,
+	INET_DIAG_MEMINFO,
+	INET_DIAG_INFO,
+	INET_DIAG_VEGASINFO,
+	INET_DIAG_CONG,
+};
+
+#define INET_DIAG_MAX INET_DIAG_CONG
+
+
+/* INET_DIAG_MEM */
+
+struct inet_diag_meminfo {
+	__u32	idiag_rmem;
+	__u32	idiag_wmem;
+	__u32	idiag_fmem;
+	__u32	idiag_tmem;
+};
+
+/* INET_DIAG_VEGASINFO */
+
+struct tcpvegas_info {
+	__u32	tcpv_enabled;
+	__u32	tcpv_rttcnt;
+	__u32	tcpv_rtt;
+	__u32	tcpv_minrtt;
+};
+
+
+#endif /* _INET_DIAG_H_ */
diff -uNr linux-2.6.32/usr/include/linux/in.h clean_modified/linux-2.6.32/usr/include/linux/in.h
--- linux-2.6.32/usr/include/linux/in.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/in.h	2019-04-14 13:24:02.999844161 -0500
@@ -0,0 +1,255 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions of the Internet Protocol.
+ *
+ * Version:	@(#)in.h	1.0.1	04/21/93
+ *
+ * Authors:	Original taken from the GNU Project <netinet/in.h> file.
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IN_H
+#define _LINUX_IN_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* Standard well-defined IP protocols.  */
+enum {
+  IPPROTO_IP = 0,		/* Dummy protocol for TCP		*/
+  IPPROTO_ICMP = 1,		/* Internet Control Message Protocol	*/
+  IPPROTO_IGMP = 2,		/* Internet Group Management Protocol	*/
+  IPPROTO_IPIP = 4,		/* IPIP tunnels (older KA9Q tunnels use 94) */
+  IPPROTO_TCP = 6,		/* Transmission Control Protocol	*/
+  IPPROTO_EGP = 8,		/* Exterior Gateway Protocol		*/
+  IPPROTO_PUP = 12,		/* PUP protocol				*/
+  IPPROTO_UDP = 17,		/* User Datagram Protocol		*/
+  IPPROTO_IDP = 22,		/* XNS IDP protocol			*/
+  IPPROTO_DCCP = 33,		/* Datagram Congestion Control Protocol */
+  IPPROTO_RSVP = 46,		/* RSVP protocol			*/
+  IPPROTO_GRE = 47,		/* Cisco GRE tunnels (rfc 1701,1702)	*/
+
+  IPPROTO_IPV6	 = 41,		/* IPv6-in-IPv4 tunnelling		*/
+
+  IPPROTO_ESP = 50,            /* Encapsulation Security Payload protocol */
+  IPPROTO_AH = 51,             /* Authentication Header protocol       */
+  IPPROTO_BEETPH = 94,	       /* IP option pseudo header for BEET */
+  IPPROTO_PIM    = 103,		/* Protocol Independent Multicast	*/
+
+  IPPROTO_COMP   = 108,                /* Compression Header protocol */
+  IPPROTO_SCTP   = 132,		/* Stream Control Transport Protocol	*/
+  IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
+
+  IPPROTO_RAW	 = 255,		/* Raw IP packets			*/
+  IPPROTO_MAX
+};
+
+
+/* Internet address. */
+struct in_addr {
+	__be32	s_addr;
+};
+
+#define IP_TOS		1
+#define IP_TTL		2
+#define IP_HDRINCL	3
+#define IP_OPTIONS	4
+#define IP_ROUTER_ALERT	5
+#define IP_RECVOPTS	6
+#define IP_RETOPTS	7
+#define IP_PKTINFO	8
+#define IP_PKTOPTIONS	9
+#define IP_MTU_DISCOVER	10
+#define IP_RECVERR	11
+#define IP_RECVTTL	12
+#define	IP_RECVTOS	13
+#define IP_MTU		14
+#define IP_FREEBIND	15
+#define IP_IPSEC_POLICY	16
+#define IP_XFRM_POLICY	17
+#define IP_PASSSEC	18
+#define IP_TRANSPARENT	19
+
+/* BSD compatibility */
+#define IP_RECVRETOPTS	IP_RETOPTS
+
+/* TProxy original addresses */
+#define IP_ORIGDSTADDR       20
+#define IP_RECVORIGDSTADDR   IP_ORIGDSTADDR
+
+/* IP_MTU_DISCOVER values */
+#define IP_PMTUDISC_DONT		0	/* Never send DF frames */
+#define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
+#define IP_PMTUDISC_DO			2	/* Always DF		*/
+#define IP_PMTUDISC_PROBE		3       /* Ignore dst pmtu      */
+
+#define IP_MULTICAST_IF			32
+#define IP_MULTICAST_TTL 		33
+#define IP_MULTICAST_LOOP 		34
+#define IP_ADD_MEMBERSHIP		35
+#define IP_DROP_MEMBERSHIP		36
+#define IP_UNBLOCK_SOURCE		37
+#define IP_BLOCK_SOURCE			38
+#define IP_ADD_SOURCE_MEMBERSHIP	39
+#define IP_DROP_SOURCE_MEMBERSHIP	40
+#define IP_MSFILTER			41
+#define MCAST_JOIN_GROUP		42
+#define MCAST_BLOCK_SOURCE		43
+#define MCAST_UNBLOCK_SOURCE		44
+#define MCAST_LEAVE_GROUP		45
+#define MCAST_JOIN_SOURCE_GROUP		46
+#define MCAST_LEAVE_SOURCE_GROUP	47
+#define MCAST_MSFILTER			48
+#define IP_MULTICAST_ALL		49
+
+#define MCAST_EXCLUDE	0
+#define MCAST_INCLUDE	1
+
+/* These need to appear somewhere around here */
+#define IP_DEFAULT_MULTICAST_TTL        1
+#define IP_DEFAULT_MULTICAST_LOOP       1
+
+/* Request struct for multicast socket ops */
+
+struct ip_mreq 
+{
+	struct in_addr imr_multiaddr;	/* IP multicast address of group */
+	struct in_addr imr_interface;	/* local IP address of interface */
+};
+
+struct ip_mreqn
+{
+	struct in_addr	imr_multiaddr;		/* IP multicast address of group */
+	struct in_addr	imr_address;		/* local IP address of interface */
+	int		imr_ifindex;		/* Interface index */
+};
+
+struct ip_mreq_source {
+	__be32		imr_multiaddr;
+	__be32		imr_interface;
+	__be32		imr_sourceaddr;
+};
+
+struct ip_msfilter {
+	__be32		imsf_multiaddr;
+	__be32		imsf_interface;
+	__u32		imsf_fmode;
+	__u32		imsf_numsrc;
+	__be32		imsf_slist[1];
+};
+
+#define IP_MSFILTER_SIZE(numsrc) \
+	(sizeof(struct ip_msfilter) - sizeof(__u32) \
+	+ (numsrc) * sizeof(__u32))
+
+struct group_req
+{
+	__u32				 gr_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gr_group;	/* group address */
+};
+
+struct group_source_req
+{
+	__u32				 gsr_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gsr_group;	/* group address */
+	struct __kernel_sockaddr_storage gsr_source;	/* source address */
+};
+
+struct group_filter
+{
+	__u32				 gf_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gf_group;	/* multicast address */
+	__u32				 gf_fmode;	/* filter mode */
+	__u32				 gf_numsrc;	/* number of sources */
+	struct __kernel_sockaddr_storage gf_slist[1];	/* interface index */
+};
+
+#define GROUP_FILTER_SIZE(numsrc) \
+	(sizeof(struct group_filter) - sizeof(struct __kernel_sockaddr_storage) \
+	+ (numsrc) * sizeof(struct __kernel_sockaddr_storage))
+
+struct in_pktinfo
+{
+	int		ipi_ifindex;
+	struct in_addr	ipi_spec_dst;
+	struct in_addr	ipi_addr;
+};
+
+/* Structure describing an Internet (IP) socket address. */
+#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
+struct sockaddr_in {
+  sa_family_t		sin_family;	/* Address family		*/
+  __be16		sin_port;	/* Port number			*/
+  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+#define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
+
+
+/*
+ * Definitions of the bits in an Internet address integer.
+ * On subnets, host and network parts are found according
+ * to the subnet mask, not these masks.
+ */
+#define	IN_CLASSA(a)		((((long int) (a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(a)		((((long int) (a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(a)		((((long int) (a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+
+#define	IN_CLASSD(a)		((((long int) (a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+#define IN_MULTICAST_NET	0xF0000000
+
+#define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xf0000000) == 0xf0000000)
+#define	IN_BADCLASS(a)		IN_EXPERIMENTAL((a))
+
+/* Address to accept any incoming messages. */
+#define	INADDR_ANY		((unsigned long int) 0x00000000)
+
+/* Address to send to all hosts. */
+#define	INADDR_BROADCAST	((unsigned long int) 0xffffffff)
+
+/* Address indicating an error return. */
+#define	INADDR_NONE		((unsigned long int) 0xffffffff)
+
+/* Network number for local host loopback. */
+#define	IN_LOOPBACKNET		127
+
+/* Address to loopback in software to local host.  */
+#define	INADDR_LOOPBACK		0x7f000001	/* 127.0.0.1   */
+#define	IN_LOOPBACK(a)		((((long int) (a)) & 0xff000000) == 0x7f000000)
+
+/* Defines for Multicast INADDR */
+#define INADDR_UNSPEC_GROUP   	0xe0000000U	/* 224.0.0.0   */
+#define INADDR_ALLHOSTS_GROUP 	0xe0000001U	/* 224.0.0.1   */
+#define INADDR_ALLRTRS_GROUP    0xe0000002U	/* 224.0.0.2 */
+#define INADDR_MAX_LOCAL_GROUP  0xe00000ffU	/* 224.0.0.255 */
+
+
+/* <asm/byteorder.h> contains the htonl type stuff.. */
+#include <asm/byteorder.h> 
+
+
+#endif	/* _LINUX_IN_H */
diff -uNr linux-2.6.32/usr/include/linux/inotify.h clean_modified/linux-2.6.32/usr/include/linux/inotify.h
--- linux-2.6.32/usr/include/linux/inotify.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/inotify.h	2019-04-14 13:24:03.000830733 -0500
@@ -0,0 +1,73 @@
+/*
+ * Inode based directory notification for Linux
+ *
+ * Copyright (C) 2005 John McCutchan
+ */
+
+#ifndef _LINUX_INOTIFY_H
+#define _LINUX_INOTIFY_H
+
+/* For O_CLOEXEC and O_NONBLOCK */
+#include <linux/fcntl.h>
+#include <linux/types.h>
+
+/*
+ * struct inotify_event - structure read from the inotify device for each event
+ *
+ * When you are watching a directory, you will receive the filename for events
+ * such as IN_CREATE, IN_DELETE, IN_OPEN, IN_CLOSE, ..., relative to the wd.
+ */
+struct inotify_event {
+	__s32		wd;		/* watch descriptor */
+	__u32		mask;		/* watch mask */
+	__u32		cookie;		/* cookie to synchronize two events */
+	__u32		len;		/* length (including nulls) of name */
+	char		name[0];	/* stub for possible name */
+};
+
+/* the following are legal, implemented events that user-space can watch for */
+#define IN_ACCESS		0x00000001	/* File was accessed */
+#define IN_MODIFY		0x00000002	/* File was modified */
+#define IN_ATTRIB		0x00000004	/* Metadata changed */
+#define IN_CLOSE_WRITE		0x00000008	/* Writtable file was closed */
+#define IN_CLOSE_NOWRITE	0x00000010	/* Unwrittable file closed */
+#define IN_OPEN			0x00000020	/* File was opened */
+#define IN_MOVED_FROM		0x00000040	/* File was moved from X */
+#define IN_MOVED_TO		0x00000080	/* File was moved to Y */
+#define IN_CREATE		0x00000100	/* Subfile was created */
+#define IN_DELETE		0x00000200	/* Subfile was deleted */
+#define IN_DELETE_SELF		0x00000400	/* Self was deleted */
+#define IN_MOVE_SELF		0x00000800	/* Self was moved */
+
+/* the following are legal events.  they are sent as needed to any watch */
+#define IN_UNMOUNT		0x00002000	/* Backing fs was unmounted */
+#define IN_Q_OVERFLOW		0x00004000	/* Event queued overflowed */
+#define IN_IGNORED		0x00008000	/* File was ignored */
+
+/* helper events */
+#define IN_CLOSE		(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* close */
+#define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
+
+/* special flags */
+#define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
+#define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
+#define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
+#define IN_ISDIR		0x40000000	/* event occurred against dir */
+#define IN_ONESHOT		0x80000000	/* only send event once */
+
+/*
+ * All of the events - we build the list by hand so that we can add flags in
+ * the future and not break backward compatibility.  Apps will get only the
+ * events that they originally wanted.  Be sure to add new events here!
+ */
+#define IN_ALL_EVENTS	(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
+			 IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
+			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
+			 IN_MOVE_SELF)
+
+/* Flags for sys_inotify_init1.  */
+#define IN_CLOEXEC O_CLOEXEC
+#define IN_NONBLOCK O_NONBLOCK
+
+
+#endif	/* _LINUX_INOTIFY_H */
diff -uNr linux-2.6.32/usr/include/linux/input.h clean_modified/linux-2.6.32/usr/include/linux/input.h
--- linux-2.6.32/usr/include/linux/input.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/input.h	2019-04-14 13:24:03.001804214 -0500
@@ -0,0 +1,983 @@
+#ifndef _INPUT_H
+#define _INPUT_H
+
+/*
+ * Copyright (c) 1999-2002 Vojtech Pavlik
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/types.h>
+
+/*
+ * The event structure itself
+ */
+
+struct input_event {
+	struct timeval time;
+	__u16 type;
+	__u16 code;
+	__s32 value;
+};
+
+/*
+ * Protocol version.
+ */
+
+#define EV_VERSION		0x010000
+
+/*
+ * IOCTLs (0x00 - 0x7f)
+ */
+
+struct input_id {
+	__u16 bustype;
+	__u16 vendor;
+	__u16 product;
+	__u16 version;
+};
+
+struct input_absinfo {
+	__s32 value;
+	__s32 minimum;
+	__s32 maximum;
+	__s32 fuzz;
+	__s32 flat;
+	__s32 resolution;
+};
+
+#define EVIOCGVERSION		_IOR('E', 0x01, int)			/* get driver version */
+#define EVIOCGID		_IOR('E', 0x02, struct input_id)	/* get device ID */
+#define EVIOCGREP		_IOR('E', 0x03, int[2])			/* get repeat settings */
+#define EVIOCSREP		_IOW('E', 0x03, int[2])			/* set repeat settings */
+#define EVIOCGKEYCODE		_IOR('E', 0x04, int[2])			/* get keycode */
+#define EVIOCSKEYCODE		_IOW('E', 0x04, int[2])			/* set keycode */
+
+#define EVIOCGNAME(len)		_IOC(_IOC_READ, 'E', 0x06, len)		/* get device name */
+#define EVIOCGPHYS(len)		_IOC(_IOC_READ, 'E', 0x07, len)		/* get physical location */
+#define EVIOCGUNIQ(len)		_IOC(_IOC_READ, 'E', 0x08, len)		/* get unique identifier */
+
+#define EVIOCGKEY(len)		_IOC(_IOC_READ, 'E', 0x18, len)		/* get global keystate */
+#define EVIOCGLED(len)		_IOC(_IOC_READ, 'E', 0x19, len)		/* get all LEDs */
+#define EVIOCGSND(len)		_IOC(_IOC_READ, 'E', 0x1a, len)		/* get all sounds status */
+#define EVIOCGSW(len)		_IOC(_IOC_READ, 'E', 0x1b, len)		/* get all switch states */
+
+#define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, 'E', 0x20 + ev, len)	/* get event bits */
+#define EVIOCGABS(abs)		_IOR('E', 0x40 + abs, struct input_absinfo)		/* get abs value/limits */
+#define EVIOCSABS(abs)		_IOW('E', 0xc0 + abs, struct input_absinfo)		/* set abs value/limits */
+
+#define EVIOCSFF		_IOC(_IOC_WRITE, 'E', 0x80, sizeof(struct ff_effect))	/* send a force effect to a force feedback device */
+#define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
+#define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
+
+#define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
+
+/*
+ * Event types
+ */
+
+#define EV_SYN			0x00
+#define EV_KEY			0x01
+#define EV_REL			0x02
+#define EV_ABS			0x03
+#define EV_MSC			0x04
+#define EV_SW			0x05
+#define EV_LED			0x11
+#define EV_SND			0x12
+#define EV_REP			0x14
+#define EV_FF			0x15
+#define EV_PWR			0x16
+#define EV_FF_STATUS		0x17
+#define EV_MAX			0x1f
+#define EV_CNT			(EV_MAX+1)
+
+/*
+ * Synchronization events.
+ */
+
+#define SYN_REPORT		0
+#define SYN_CONFIG		1
+#define SYN_MT_REPORT		2
+
+/*
+ * Keys and buttons
+ *
+ * Most of the keys/buttons are modeled after USB HUT 1.12
+ * (see http://www.usb.org/developers/hidpage).
+ * Abbreviations in the comments:
+ * AC - Application Control
+ * AL - Application Launch Button
+ * SC - System Control
+ */
+
+#define KEY_RESERVED		0
+#define KEY_ESC			1
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+#define KEY_MINUS		12
+#define KEY_EQUAL		13
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_LEFTBRACE		26
+#define KEY_RIGHTBRACE		27
+#define KEY_ENTER		28
+#define KEY_LEFTCTRL		29
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_SEMICOLON		39
+#define KEY_APOSTROPHE		40
+#define KEY_GRAVE		41
+#define KEY_LEFTSHIFT		42
+#define KEY_BACKSLASH		43
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_DOT			52
+#define KEY_SLASH		53
+#define KEY_RIGHTSHIFT		54
+#define KEY_KPASTERISK		55
+#define KEY_LEFTALT		56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+#define KEY_NUMLOCK		69
+#define KEY_SCROLLLOCK		70
+#define KEY_KP7			71
+#define KEY_KP8			72
+#define KEY_KP9			73
+#define KEY_KPMINUS		74
+#define KEY_KP4			75
+#define KEY_KP5			76
+#define KEY_KP6			77
+#define KEY_KPPLUS		78
+#define KEY_KP1			79
+#define KEY_KP2			80
+#define KEY_KP3			81
+#define KEY_KP0			82
+#define KEY_KPDOT		83
+
+#define KEY_ZENKAKUHANKAKU	85
+#define KEY_102ND		86
+#define KEY_F11			87
+#define KEY_F12			88
+#define KEY_RO			89
+#define KEY_KATAKANA		90
+#define KEY_HIRAGANA		91
+#define KEY_HENKAN		92
+#define KEY_KATAKANAHIRAGANA	93
+#define KEY_MUHENKAN		94
+#define KEY_KPJPCOMMA		95
+#define KEY_KPENTER		96
+#define KEY_RIGHTCTRL		97
+#define KEY_KPSLASH		98
+#define KEY_SYSRQ		99
+#define KEY_RIGHTALT		100
+#define KEY_LINEFEED		101
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PAGEUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PAGEDOWN		109
+#define KEY_INSERT		110
+#define KEY_DELETE		111
+#define KEY_MACRO		112
+#define KEY_MUTE		113
+#define KEY_VOLUMEDOWN		114
+#define KEY_VOLUMEUP		115
+#define KEY_POWER		116	/* SC System Power Down */
+#define KEY_KPEQUAL		117
+#define KEY_KPPLUSMINUS		118
+#define KEY_PAUSE		119
+#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
+
+#define KEY_KPCOMMA		121
+#define KEY_HANGEUL		122
+#define KEY_HANGUEL		KEY_HANGEUL
+#define KEY_HANJA		123
+#define KEY_YEN			124
+#define KEY_LEFTMETA		125
+#define KEY_RIGHTMETA		126
+#define KEY_COMPOSE		127
+
+#define KEY_STOP		128	/* AC Stop */
+#define KEY_AGAIN		129
+#define KEY_PROPS		130	/* AC Properties */
+#define KEY_UNDO		131	/* AC Undo */
+#define KEY_FRONT		132
+#define KEY_COPY		133	/* AC Copy */
+#define KEY_OPEN		134	/* AC Open */
+#define KEY_PASTE		135	/* AC Paste */
+#define KEY_FIND		136	/* AC Search */
+#define KEY_CUT			137	/* AC Cut */
+#define KEY_HELP		138	/* AL Integrated Help Center */
+#define KEY_MENU		139	/* Menu (show menu) */
+#define KEY_CALC		140	/* AL Calculator */
+#define KEY_SETUP		141
+#define KEY_SLEEP		142	/* SC System Sleep */
+#define KEY_WAKEUP		143	/* System Wake Up */
+#define KEY_FILE		144	/* AL Local Machine Browser */
+#define KEY_SENDFILE		145
+#define KEY_DELETEFILE		146
+#define KEY_XFER		147
+#define KEY_PROG1		148
+#define KEY_PROG2		149
+#define KEY_WWW			150	/* AL Internet Browser */
+#define KEY_MSDOS		151
+#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
+#define KEY_SCREENLOCK		KEY_COFFEE
+#define KEY_DIRECTION		153
+#define KEY_CYCLEWINDOWS	154
+#define KEY_MAIL		155
+#define KEY_BOOKMARKS		156	/* AC Bookmarks */
+#define KEY_COMPUTER		157
+#define KEY_BACK		158	/* AC Back */
+#define KEY_FORWARD		159	/* AC Forward */
+#define KEY_CLOSECD		160
+#define KEY_EJECTCD		161
+#define KEY_EJECTCLOSECD	162
+#define KEY_NEXTSONG		163
+#define KEY_PLAYPAUSE		164
+#define KEY_PREVIOUSSONG	165
+#define KEY_STOPCD		166
+#define KEY_RECORD		167
+#define KEY_REWIND		168
+#define KEY_PHONE		169	/* Media Select Telephone */
+#define KEY_ISO			170
+#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
+#define KEY_HOMEPAGE		172	/* AC Home */
+#define KEY_REFRESH		173	/* AC Refresh */
+#define KEY_EXIT		174	/* AC Exit */
+#define KEY_MOVE		175
+#define KEY_EDIT		176
+#define KEY_SCROLLUP		177
+#define KEY_SCROLLDOWN		178
+#define KEY_KPLEFTPAREN		179
+#define KEY_KPRIGHTPAREN	180
+#define KEY_NEW			181	/* AC New */
+#define KEY_REDO		182	/* AC Redo/Repeat */
+
+#define KEY_F13			183
+#define KEY_F14			184
+#define KEY_F15			185
+#define KEY_F16			186
+#define KEY_F17			187
+#define KEY_F18			188
+#define KEY_F19			189
+#define KEY_F20			190
+#define KEY_F21			191
+#define KEY_F22			192
+#define KEY_F23			193
+#define KEY_F24			194
+
+#define KEY_PLAYCD		200
+#define KEY_PAUSECD		201
+#define KEY_PROG3		202
+#define KEY_PROG4		203
+#define KEY_DASHBOARD		204	/* AL Dashboard */
+#define KEY_SUSPEND		205
+#define KEY_CLOSE		206	/* AC Close */
+#define KEY_PLAY		207
+#define KEY_FASTFORWARD		208
+#define KEY_BASSBOOST		209
+#define KEY_PRINT		210	/* AC Print */
+#define KEY_HP			211
+#define KEY_CAMERA		212
+#define KEY_SOUND		213
+#define KEY_QUESTION		214
+#define KEY_EMAIL		215
+#define KEY_CHAT		216
+#define KEY_SEARCH		217
+#define KEY_CONNECT		218
+#define KEY_FINANCE		219	/* AL Checkbook/Finance */
+#define KEY_SPORT		220
+#define KEY_SHOP		221
+#define KEY_ALTERASE		222
+#define KEY_CANCEL		223	/* AC Cancel */
+#define KEY_BRIGHTNESSDOWN	224
+#define KEY_BRIGHTNESSUP	225
+#define KEY_MEDIA		226
+
+#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
+					   outputs (Monitor/LCD/TV-out/etc) */
+#define KEY_KBDILLUMTOGGLE	228
+#define KEY_KBDILLUMDOWN	229
+#define KEY_KBDILLUMUP		230
+
+#define KEY_SEND		231	/* AC Send */
+#define KEY_REPLY		232	/* AC Reply */
+#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
+#define KEY_SAVE		234	/* AC Save */
+#define KEY_DOCUMENTS		235
+
+#define KEY_BATTERY		236
+
+#define KEY_BLUETOOTH		237
+#define KEY_WLAN		238
+#define KEY_UWB			239
+
+#define KEY_UNKNOWN		240
+
+#define KEY_VIDEO_NEXT		241	/* drive next video source */
+#define KEY_VIDEO_PREV		242	/* drive previous video source */
+#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
+#define KEY_BRIGHTNESS_ZERO	244	/* brightness off, use ambient */
+#define KEY_DISPLAY_OFF		245	/* display device to off state */
+
+#define KEY_WIMAX		246
+
+/* Range 248 - 255 is reserved for special needs of AT keyboard driver */
+
+#define BTN_MISC		0x100
+#define BTN_0			0x100
+#define BTN_1			0x101
+#define BTN_2			0x102
+#define BTN_3			0x103
+#define BTN_4			0x104
+#define BTN_5			0x105
+#define BTN_6			0x106
+#define BTN_7			0x107
+#define BTN_8			0x108
+#define BTN_9			0x109
+
+#define BTN_MOUSE		0x110
+#define BTN_LEFT		0x110
+#define BTN_RIGHT		0x111
+#define BTN_MIDDLE		0x112
+#define BTN_SIDE		0x113
+#define BTN_EXTRA		0x114
+#define BTN_FORWARD		0x115
+#define BTN_BACK		0x116
+#define BTN_TASK		0x117
+
+#define BTN_JOYSTICK		0x120
+#define BTN_TRIGGER		0x120
+#define BTN_THUMB		0x121
+#define BTN_THUMB2		0x122
+#define BTN_TOP			0x123
+#define BTN_TOP2		0x124
+#define BTN_PINKIE		0x125
+#define BTN_BASE		0x126
+#define BTN_BASE2		0x127
+#define BTN_BASE3		0x128
+#define BTN_BASE4		0x129
+#define BTN_BASE5		0x12a
+#define BTN_BASE6		0x12b
+#define BTN_DEAD		0x12f
+
+#define BTN_GAMEPAD		0x130
+#define BTN_A			0x130
+#define BTN_B			0x131
+#define BTN_C			0x132
+#define BTN_X			0x133
+#define BTN_Y			0x134
+#define BTN_Z			0x135
+#define BTN_TL			0x136
+#define BTN_TR			0x137
+#define BTN_TL2			0x138
+#define BTN_TR2			0x139
+#define BTN_SELECT		0x13a
+#define BTN_START		0x13b
+#define BTN_MODE		0x13c
+#define BTN_THUMBL		0x13d
+#define BTN_THUMBR		0x13e
+
+#define BTN_DIGI		0x140
+#define BTN_TOOL_PEN		0x140
+#define BTN_TOOL_RUBBER		0x141
+#define BTN_TOOL_BRUSH		0x142
+#define BTN_TOOL_PENCIL		0x143
+#define BTN_TOOL_AIRBRUSH	0x144
+#define BTN_TOOL_FINGER		0x145
+#define BTN_TOOL_MOUSE		0x146
+#define BTN_TOOL_LENS		0x147
+#define BTN_TOUCH		0x14a
+#define BTN_STYLUS		0x14b
+#define BTN_STYLUS2		0x14c
+#define BTN_TOOL_DOUBLETAP	0x14d
+#define BTN_TOOL_TRIPLETAP	0x14e
+#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
+
+#define BTN_WHEEL		0x150
+#define BTN_GEAR_DOWN		0x150
+#define BTN_GEAR_UP		0x151
+
+#define KEY_OK			0x160
+#define KEY_SELECT		0x161
+#define KEY_GOTO		0x162
+#define KEY_CLEAR		0x163
+#define KEY_POWER2		0x164
+#define KEY_OPTION		0x165
+#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
+#define KEY_TIME		0x167
+#define KEY_VENDOR		0x168
+#define KEY_ARCHIVE		0x169
+#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
+#define KEY_CHANNEL		0x16b
+#define KEY_FAVORITES		0x16c
+#define KEY_EPG			0x16d
+#define KEY_PVR			0x16e	/* Media Select Home */
+#define KEY_MHP			0x16f
+#define KEY_LANGUAGE		0x170
+#define KEY_TITLE		0x171
+#define KEY_SUBTITLE		0x172
+#define KEY_ANGLE		0x173
+#define KEY_ZOOM		0x174
+#define KEY_MODE		0x175
+#define KEY_KEYBOARD		0x176
+#define KEY_SCREEN		0x177
+#define KEY_PC			0x178	/* Media Select Computer */
+#define KEY_TV			0x179	/* Media Select TV */
+#define KEY_TV2			0x17a	/* Media Select Cable */
+#define KEY_VCR			0x17b	/* Media Select VCR */
+#define KEY_VCR2		0x17c	/* VCR Plus */
+#define KEY_SAT			0x17d	/* Media Select Satellite */
+#define KEY_SAT2		0x17e
+#define KEY_CD			0x17f	/* Media Select CD */
+#define KEY_TAPE		0x180	/* Media Select Tape */
+#define KEY_RADIO		0x181
+#define KEY_TUNER		0x182	/* Media Select Tuner */
+#define KEY_PLAYER		0x183
+#define KEY_TEXT		0x184
+#define KEY_DVD			0x185	/* Media Select DVD */
+#define KEY_AUX			0x186
+#define KEY_MP3			0x187
+#define KEY_AUDIO		0x188
+#define KEY_VIDEO		0x189
+#define KEY_DIRECTORY		0x18a
+#define KEY_LIST		0x18b
+#define KEY_MEMO		0x18c	/* Media Select Messages */
+#define KEY_CALENDAR		0x18d
+#define KEY_RED			0x18e
+#define KEY_GREEN		0x18f
+#define KEY_YELLOW		0x190
+#define KEY_BLUE		0x191
+#define KEY_CHANNELUP		0x192	/* Channel Increment */
+#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
+#define KEY_FIRST		0x194
+#define KEY_LAST		0x195	/* Recall Last */
+#define KEY_AB			0x196
+#define KEY_NEXT		0x197
+#define KEY_RESTART		0x198
+#define KEY_SLOW		0x199
+#define KEY_SHUFFLE		0x19a
+#define KEY_BREAK		0x19b
+#define KEY_PREVIOUS		0x19c
+#define KEY_DIGITS		0x19d
+#define KEY_TEEN		0x19e
+#define KEY_TWEN		0x19f
+#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
+#define KEY_GAMES		0x1a1	/* Media Select Games */
+#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
+#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
+#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
+#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
+#define KEY_EDITOR		0x1a6	/* AL Text Editor */
+#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
+#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
+#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
+#define KEY_DATABASE		0x1aa	/* AL Database App */
+#define KEY_NEWS		0x1ab	/* AL Newsreader */
+#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
+#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
+#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
+#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
+#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
+#define KEY_LOGOFF		0x1b1   /* AL Logoff */
+
+#define KEY_DOLLAR		0x1b2
+#define KEY_EURO		0x1b3
+
+#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define KEY_FRAMEFORWARD	0x1b5
+#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
+
+#define KEY_DEL_EOL		0x1c0
+#define KEY_DEL_EOS		0x1c1
+#define KEY_INS_LINE		0x1c2
+#define KEY_DEL_LINE		0x1c3
+
+#define KEY_FN			0x1d0
+#define KEY_FN_ESC		0x1d1
+#define KEY_FN_F1		0x1d2
+#define KEY_FN_F2		0x1d3
+#define KEY_FN_F3		0x1d4
+#define KEY_FN_F4		0x1d5
+#define KEY_FN_F5		0x1d6
+#define KEY_FN_F6		0x1d7
+#define KEY_FN_F7		0x1d8
+#define KEY_FN_F8		0x1d9
+#define KEY_FN_F9		0x1da
+#define KEY_FN_F10		0x1db
+#define KEY_FN_F11		0x1dc
+#define KEY_FN_F12		0x1dd
+#define KEY_FN_1		0x1de
+#define KEY_FN_2		0x1df
+#define KEY_FN_D		0x1e0
+#define KEY_FN_E		0x1e1
+#define KEY_FN_F		0x1e2
+#define KEY_FN_S		0x1e3
+#define KEY_FN_B		0x1e4
+
+#define KEY_BRL_DOT1		0x1f1
+#define KEY_BRL_DOT2		0x1f2
+#define KEY_BRL_DOT3		0x1f3
+#define KEY_BRL_DOT4		0x1f4
+#define KEY_BRL_DOT5		0x1f5
+#define KEY_BRL_DOT6		0x1f6
+#define KEY_BRL_DOT7		0x1f7
+#define KEY_BRL_DOT8		0x1f8
+#define KEY_BRL_DOT9		0x1f9
+#define KEY_BRL_DOT10		0x1fa
+
+#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
+#define KEY_NUMERIC_1		0x201	/* and other keypads */
+#define KEY_NUMERIC_2		0x202
+#define KEY_NUMERIC_3		0x203
+#define KEY_NUMERIC_4		0x204
+#define KEY_NUMERIC_5		0x205
+#define KEY_NUMERIC_6		0x206
+#define KEY_NUMERIC_7		0x207
+#define KEY_NUMERIC_8		0x208
+#define KEY_NUMERIC_9		0x209
+#define KEY_NUMERIC_STAR	0x20a
+#define KEY_NUMERIC_POUND	0x20b
+
+/* We avoid low common keys in module aliases so they don't get huge. */
+#define KEY_MIN_INTERESTING	KEY_MUTE
+#define KEY_MAX			0x2ff
+#define KEY_CNT			(KEY_MAX+1)
+
+/*
+ * Relative axes
+ */
+
+#define REL_X			0x00
+#define REL_Y			0x01
+#define REL_Z			0x02
+#define REL_RX			0x03
+#define REL_RY			0x04
+#define REL_RZ			0x05
+#define REL_HWHEEL		0x06
+#define REL_DIAL		0x07
+#define REL_WHEEL		0x08
+#define REL_MISC		0x09
+#define REL_MAX			0x0f
+#define REL_CNT			(REL_MAX+1)
+
+/*
+ * Absolute axes
+ */
+
+#define ABS_X			0x00
+#define ABS_Y			0x01
+#define ABS_Z			0x02
+#define ABS_RX			0x03
+#define ABS_RY			0x04
+#define ABS_RZ			0x05
+#define ABS_THROTTLE		0x06
+#define ABS_RUDDER		0x07
+#define ABS_WHEEL		0x08
+#define ABS_GAS			0x09
+#define ABS_BRAKE		0x0a
+#define ABS_HAT0X		0x10
+#define ABS_HAT0Y		0x11
+#define ABS_HAT1X		0x12
+#define ABS_HAT1Y		0x13
+#define ABS_HAT2X		0x14
+#define ABS_HAT2Y		0x15
+#define ABS_HAT3X		0x16
+#define ABS_HAT3Y		0x17
+#define ABS_PRESSURE		0x18
+#define ABS_DISTANCE		0x19
+#define ABS_TILT_X		0x1a
+#define ABS_TILT_Y		0x1b
+#define ABS_TOOL_WIDTH		0x1c
+#define ABS_VOLUME		0x20
+#define ABS_MISC		0x28
+
+#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+#define ABS_MT_POSITION_X	0x35	/* Center X ellipse position */
+#define ABS_MT_POSITION_Y	0x36	/* Center Y ellipse position */
+#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
+
+#define ABS_MAX			0x3f
+#define ABS_CNT			(ABS_MAX+1)
+
+/*
+ * Switch events
+ */
+
+#define SW_LID			0x00  /* set = lid shut */
+#define SW_TABLET_MODE		0x01  /* set = tablet mode */
+#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
+#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
+					 set = radio enabled */
+#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
+#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
+#define SW_DOCK			0x05  /* set = plugged into dock */
+#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
+#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
+#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
+#define SW_MAX			0x0f
+#define SW_CNT			(SW_MAX+1)
+
+/*
+ * Misc events
+ */
+
+#define MSC_SERIAL		0x00
+#define MSC_PULSELED		0x01
+#define MSC_GESTURE		0x02
+#define MSC_RAW			0x03
+#define MSC_SCAN		0x04
+#define MSC_MAX			0x07
+#define MSC_CNT			(MSC_MAX+1)
+
+/*
+ * LEDs
+ */
+
+#define LED_NUML		0x00
+#define LED_CAPSL		0x01
+#define LED_SCROLLL		0x02
+#define LED_COMPOSE		0x03
+#define LED_KANA		0x04
+#define LED_SLEEP		0x05
+#define LED_SUSPEND		0x06
+#define LED_MUTE		0x07
+#define LED_MISC		0x08
+#define LED_MAIL		0x09
+#define LED_CHARGING		0x0a
+#define LED_MAX			0x0f
+#define LED_CNT			(LED_MAX+1)
+
+/*
+ * Autorepeat values
+ */
+
+#define REP_DELAY		0x00
+#define REP_PERIOD		0x01
+#define REP_MAX			0x01
+
+/*
+ * Sounds
+ */
+
+#define SND_CLICK		0x00
+#define SND_BELL		0x01
+#define SND_TONE		0x02
+#define SND_MAX			0x07
+#define SND_CNT			(SND_MAX+1)
+
+/*
+ * IDs.
+ */
+
+#define ID_BUS			0
+#define ID_VENDOR		1
+#define ID_PRODUCT		2
+#define ID_VERSION		3
+
+#define BUS_PCI			0x01
+#define BUS_ISAPNP		0x02
+#define BUS_USB			0x03
+#define BUS_HIL			0x04
+#define BUS_BLUETOOTH		0x05
+#define BUS_VIRTUAL		0x06
+
+#define BUS_ISA			0x10
+#define BUS_I8042		0x11
+#define BUS_XTKBD		0x12
+#define BUS_RS232		0x13
+#define BUS_GAMEPORT		0x14
+#define BUS_PARPORT		0x15
+#define BUS_AMIGA		0x16
+#define BUS_ADB			0x17
+#define BUS_I2C			0x18
+#define BUS_HOST		0x19
+#define BUS_GSC			0x1A
+#define BUS_ATARI		0x1B
+
+/*
+ * MT_TOOL types
+ */
+#define MT_TOOL_FINGER		0
+#define MT_TOOL_PEN		1
+
+/*
+ * Values describing the status of a force-feedback effect
+ */
+#define FF_STATUS_STOPPED	0x00
+#define FF_STATUS_PLAYING	0x01
+#define FF_STATUS_MAX		0x01
+
+/*
+ * Structures used in ioctls to upload effects to a device
+ * They are pieces of a bigger structure (called ff_effect)
+ */
+
+/*
+ * All duration values are expressed in ms. Values above 32767 ms (0x7fff)
+ * should not be used and have unspecified results.
+ */
+
+/**
+ * struct ff_replay - defines scheduling of the force-feedback effect
+ * @length: duration of the effect
+ * @delay: delay before effect should start playing
+ */
+struct ff_replay {
+	__u16 length;
+	__u16 delay;
+};
+
+/**
+ * struct ff_trigger - defines what triggers the force-feedback effect
+ * @button: number of the button triggering the effect
+ * @interval: controls how soon the effect can be re-triggered
+ */
+struct ff_trigger {
+	__u16 button;
+	__u16 interval;
+};
+
+/**
+ * struct ff_envelope - generic force-feedback effect envelope
+ * @attack_length: duration of the attack (ms)
+ * @attack_level: level at the beginning of the attack
+ * @fade_length: duration of fade (ms)
+ * @fade_level: level at the end of fade
+ *
+ * The @attack_level and @fade_level are absolute values; when applying
+ * envelope force-feedback core will convert to positive/negative
+ * value based on polarity of the default level of the effect.
+ * Valid range for the attack and fade levels is 0x0000 - 0x7fff
+ */
+struct ff_envelope {
+	__u16 attack_length;
+	__u16 attack_level;
+	__u16 fade_length;
+	__u16 fade_level;
+};
+
+/**
+ * struct ff_constant_effect - defines parameters of a constant force-feedback effect
+ * @level: strength of the effect; may be negative
+ * @envelope: envelope data
+ */
+struct ff_constant_effect {
+	__s16 level;
+	struct ff_envelope envelope;
+};
+
+/**
+ * struct ff_ramp_effect - defines parameters of a ramp force-feedback effect
+ * @start_level: beginning strength of the effect; may be negative
+ * @end_level: final strength of the effect; may be negative
+ * @envelope: envelope data
+ */
+struct ff_ramp_effect {
+	__s16 start_level;
+	__s16 end_level;
+	struct ff_envelope envelope;
+};
+
+/**
+ * struct ff_condition_effect - defines a spring or friction force-feedback effect
+ * @right_saturation: maximum level when joystick moved all way to the right
+ * @left_saturation: same for the left side
+ * @right_coeff: controls how fast the force grows when the joystick moves
+ *	to the right
+ * @left_coeff: same for the left side
+ * @deadband: size of the dead zone, where no force is produced
+ * @center: position of the dead zone
+ */
+struct ff_condition_effect {
+	__u16 right_saturation;
+	__u16 left_saturation;
+
+	__s16 right_coeff;
+	__s16 left_coeff;
+
+	__u16 deadband;
+	__s16 center;
+};
+
+/**
+ * struct ff_periodic_effect - defines parameters of a periodic force-feedback effect
+ * @waveform: kind of the effect (wave)
+ * @period: period of the wave (ms)
+ * @magnitude: peak value
+ * @offset: mean value of the wave (roughly)
+ * @phase: 'horizontal' shift
+ * @envelope: envelope data
+ * @custom_len: number of samples (FF_CUSTOM only)
+ * @custom_data: buffer of samples (FF_CUSTOM only)
+ *
+ * Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,
+ * FF_SAW_DOWN, FF_CUSTOM. The exact syntax FF_CUSTOM is undefined
+ * for the time being as no driver supports it yet.
+ *
+ * Note: the data pointed by custom_data is copied by the driver.
+ * You can therefore dispose of the memory after the upload/update.
+ */
+struct ff_periodic_effect {
+	__u16 waveform;
+	__u16 period;
+	__s16 magnitude;
+	__s16 offset;
+	__u16 phase;
+
+	struct ff_envelope envelope;
+
+	__u32 custom_len;
+	__s16 *custom_data;
+};
+
+/**
+ * struct ff_rumble_effect - defines parameters of a periodic force-feedback effect
+ * @strong_magnitude: magnitude of the heavy motor
+ * @weak_magnitude: magnitude of the light one
+ *
+ * Some rumble pads have two motors of different weight. Strong_magnitude
+ * represents the magnitude of the vibration generated by the heavy one.
+ */
+struct ff_rumble_effect {
+	__u16 strong_magnitude;
+	__u16 weak_magnitude;
+};
+
+/**
+ * struct ff_effect - defines force feedback effect
+ * @type: type of the effect (FF_CONSTANT, FF_PERIODIC, FF_RAMP, FF_SPRING,
+ *	FF_FRICTION, FF_DAMPER, FF_RUMBLE, FF_INERTIA, or FF_CUSTOM)
+ * @id: an unique id assigned to an effect
+ * @direction: direction of the effect
+ * @trigger: trigger conditions (struct ff_trigger)
+ * @replay: scheduling of the effect (struct ff_replay)
+ * @u: effect-specific structure (one of ff_constant_effect, ff_ramp_effect,
+ *	ff_periodic_effect, ff_condition_effect, ff_rumble_effect) further
+ *	defining effect parameters
+ *
+ * This structure is sent through ioctl from the application to the driver.
+ * To create a new effect application should set its @id to -1; the kernel
+ * will return assigned @id which can later be used to update or delete
+ * this effect.
+ *
+ * Direction of the effect is encoded as follows:
+ *	0 deg -> 0x0000 (down)
+ *	90 deg -> 0x4000 (left)
+ *	180 deg -> 0x8000 (up)
+ *	270 deg -> 0xC000 (right)
+ */
+struct ff_effect {
+	__u16 type;
+	__s16 id;
+	__u16 direction;
+	struct ff_trigger trigger;
+	struct ff_replay replay;
+
+	union {
+		struct ff_constant_effect constant;
+		struct ff_ramp_effect ramp;
+		struct ff_periodic_effect periodic;
+		struct ff_condition_effect condition[2]; /* One for each axis */
+		struct ff_rumble_effect rumble;
+	} u;
+};
+
+/*
+ * Force feedback effect types
+ */
+
+#define FF_RUMBLE	0x50
+#define FF_PERIODIC	0x51
+#define FF_CONSTANT	0x52
+#define FF_SPRING	0x53
+#define FF_FRICTION	0x54
+#define FF_DAMPER	0x55
+#define FF_INERTIA	0x56
+#define FF_RAMP		0x57
+
+#define FF_EFFECT_MIN	FF_RUMBLE
+#define FF_EFFECT_MAX	FF_RAMP
+
+/*
+ * Force feedback periodic effect types
+ */
+
+#define FF_SQUARE	0x58
+#define FF_TRIANGLE	0x59
+#define FF_SINE		0x5a
+#define FF_SAW_UP	0x5b
+#define FF_SAW_DOWN	0x5c
+#define FF_CUSTOM	0x5d
+
+#define FF_WAVEFORM_MIN	FF_SQUARE
+#define FF_WAVEFORM_MAX	FF_CUSTOM
+
+/*
+ * Set ff device properties
+ */
+
+#define FF_GAIN		0x60
+#define FF_AUTOCENTER	0x61
+
+#define FF_MAX		0x7f
+#define FF_CNT		(FF_MAX+1)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/in_route.h clean_modified/linux-2.6.32/usr/include/linux/in_route.h
--- linux-2.6.32/usr/include/linux/in_route.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/in_route.h	2019-04-14 13:24:03.001804214 -0500
@@ -0,0 +1,32 @@
+#ifndef _LINUX_IN_ROUTE_H
+#define _LINUX_IN_ROUTE_H
+
+/* IPv4 routing cache flags */
+
+#define RTCF_DEAD	RTNH_F_DEAD
+#define RTCF_ONLINK	RTNH_F_ONLINK
+
+/* Obsolete flag. About to be deleted */
+#define RTCF_NOPMTUDISC RTM_F_NOPMTUDISC
+
+#define RTCF_NOTIFY	0x00010000
+#define RTCF_DIRECTDST	0x00020000 /* unused */
+#define RTCF_REDIRECTED	0x00040000
+#define RTCF_TPROXY	0x00080000 /* unused */
+
+#define RTCF_FAST	0x00200000 /* unused */
+#define RTCF_MASQ	0x00400000 /* unused */
+#define RTCF_SNAT	0x00800000 /* unused */
+#define RTCF_DOREDIRECT 0x01000000
+#define RTCF_DIRECTSRC	0x04000000
+#define RTCF_DNAT	0x08000000
+#define RTCF_BROADCAST	0x10000000
+#define RTCF_MULTICAST	0x20000000
+#define RTCF_REJECT	0x40000000 /* unused */
+#define RTCF_LOCAL	0x80000000
+
+#define RTCF_NAT	(RTCF_DNAT|RTCF_SNAT)
+
+#define RT_TOS(tos)	((tos)&IPTOS_TOS_MASK)
+
+#endif /* _LINUX_IN_ROUTE_H */
diff -uNr linux-2.6.32/usr/include/linux/ioctl.h clean_modified/linux-2.6.32/usr/include/linux/ioctl.h
--- linux-2.6.32/usr/include/linux/ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ioctl.h	2019-04-14 13:24:03.003813427 -0500
@@ -0,0 +1,7 @@
+#ifndef _LINUX_IOCTL_H
+#define _LINUX_IOCTL_H
+
+#include <asm/ioctl.h>
+
+#endif /* _LINUX_IOCTL_H */
+
diff -uNr linux-2.6.32/usr/include/linux/ip6_tunnel.h clean_modified/linux-2.6.32/usr/include/linux/ip6_tunnel.h
--- linux-2.6.32/usr/include/linux/ip6_tunnel.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ip6_tunnel.h	2019-04-14 13:24:03.003813427 -0500
@@ -0,0 +1,32 @@
+#ifndef _IP6_TUNNEL_H
+#define _IP6_TUNNEL_H
+
+#include <linux/types.h>
+
+#define IPV6_TLV_TNL_ENCAP_LIMIT 4
+#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4
+
+/* don't add encapsulation limit if one isn't present in inner packet */
+#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1
+/* copy the traffic class field from the inner packet */
+#define IP6_TNL_F_USE_ORIG_TCLASS 0x2
+/* copy the flowlabel from the inner packet */
+#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4
+/* being used for Mobile IPv6 */
+#define IP6_TNL_F_MIP6_DEV 0x8
+/* copy DSCP from the outer packet */
+#define IP6_TNL_F_RCV_DSCP_COPY 0x10
+
+struct ip6_tnl_parm {
+	char name[IFNAMSIZ];	/* name of tunnel device */
+	int link;		/* ifindex of underlying L2 interface */
+	__u8 proto;		/* tunnel protocol */
+	__u8 encap_limit;	/* encapsulation limit for tunnel */
+	__u8 hop_limit;		/* hop limit for tunnel */
+	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
+	__u32 flags;		/* tunnel flags */
+	struct in6_addr laddr;	/* local tunnel end-point address */
+	struct in6_addr raddr;	/* remote tunnel end-point address */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ipc.h clean_modified/linux-2.6.32/usr/include/linux/ipc.h
--- linux-2.6.32/usr/include/linux/ipc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipc.h	2019-04-14 13:24:03.003813427 -0500
@@ -0,0 +1,81 @@
+#ifndef _LINUX_IPC_H
+#define _LINUX_IPC_H
+
+#include <linux/types.h>
+
+#define IPC_PRIVATE ((__kernel_key_t) 0)  
+
+/* Obsolete, used only for backwards compatibility and libc5 compiles */
+struct ipc_perm
+{
+	__kernel_key_t	key;
+	__kernel_uid_t	uid;
+	__kernel_gid_t	gid;
+	__kernel_uid_t	cuid;
+	__kernel_gid_t	cgid;
+	__kernel_mode_t	mode; 
+	unsigned short	seq;
+};
+
+/* Include the definition of ipc64_perm */
+#include <asm/ipcbuf.h>
+
+/* resource get request flags */
+#define IPC_CREAT  00001000   /* create if key is nonexistent */
+#define IPC_EXCL   00002000   /* fail if key exists */
+#define IPC_NOWAIT 00004000   /* return error on wait */
+
+/* these fields are used by the DIPC package so the kernel as standard
+   should avoid using them if possible */
+   
+#define IPC_DIPC 00010000  /* make it distributed */
+#define IPC_OWN  00020000  /* this machine is the DIPC owner */
+
+/* 
+ * Control commands used with semctl, msgctl and shmctl 
+ * see also specific commands in sem.h, msg.h and shm.h
+ */
+#define IPC_RMID 0     /* remove resource */
+#define IPC_SET  1     /* set ipc_perm options */
+#define IPC_STAT 2     /* get ipc_perm options */
+#define IPC_INFO 3     /* see ipcs */
+
+/*
+ * Version flags for semctl, msgctl, and shmctl commands
+ * These are passed as bitflags or-ed with the actual command
+ */
+#define IPC_OLD 0	/* Old version (no 32-bit UID support on many
+			   architectures) */
+#define IPC_64  0x0100  /* New version (support 32-bit UIDs, bigger
+			   message sizes, etc. */
+
+/*
+ * These are used to wrap system calls.
+ *
+ * See architecture code for ugly details..
+ */
+struct ipc_kludge {
+	struct msgbuf *msgp;
+	long msgtyp;
+};
+
+#define SEMOP		 1
+#define SEMGET		 2
+#define SEMCTL		 3
+#define SEMTIMEDOP	 4
+#define MSGSND		11
+#define MSGRCV		12
+#define MSGGET		13
+#define MSGCTL		14
+#define SHMAT		21
+#define SHMDT		22
+#define SHMGET		23
+#define SHMCTL		24
+
+/* Used by the DIPC package, try and avoid reusing it */
+#define DIPC            25
+
+#define IPCCALL(version,op)	((version)<<16 | (op))
+
+
+#endif /* _LINUX_IPC_H */
diff -uNr linux-2.6.32/usr/include/linux/ip.h clean_modified/linux-2.6.32/usr/include/linux/ip.h
--- linux-2.6.32/usr/include/linux/ip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ip.h	2019-04-14 13:24:03.005352121 -0500
@@ -0,0 +1,136 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_CIPSO	(6 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+#define IPV4_BEET_PHMAXLEN 8
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__be16	tot_len;
+	__be16	id;
+	__be16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__sum16	check;
+	__be32	saddr;
+	__be32	daddr;
+	/*The options start here. */
+};
+
+
+struct ip_auth_hdr {
+	__u8  nexthdr;
+	__u8  hdrlen;		/* This one is measured in 32 bit units! */
+	__be16 reserved;
+	__be32 spi;
+	__be32 seq_no;		/* Sequence number */
+	__u8  auth_data[0];	/* Variable len but >=4. Mind the 64 bit alignment! */
+};
+
+struct ip_esp_hdr {
+	__be32 spi;
+	__be32 seq_no;		/* Sequence number */
+	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
+};
+
+struct ip_comp_hdr {
+	__u8 nexthdr;
+	__u8 flags;
+	__be16 cpi;
+};
+
+struct ip_beet_phdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 padlen;
+	__u8 reserved;
+};
+
+#endif	/* _LINUX_IP_H */
diff -uNr linux-2.6.32/usr/include/linux/ipmi.h clean_modified/linux-2.6.32/usr/include/linux/ipmi.h
--- linux-2.6.32/usr/include/linux/ipmi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipmi.h	2019-04-14 13:24:03.006191385 -0500
@@ -0,0 +1,456 @@
+/*
+ * ipmi.h
+ *
+ * MontaVista IPMI interface
+ *
+ * Author: MontaVista Software, Inc.
+ *         Corey Minyard <minyard@mvista.com>
+ *         source@mvista.com
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_IPMI_H
+#define __LINUX_IPMI_H
+
+#include <linux/ipmi_msgdefs.h>
+
+
+/*
+ * This file describes an interface to an IPMI driver.  You have to
+ * have a fairly good understanding of IPMI to use this, so go read
+ * the specs first before actually trying to do anything.
+ *
+ * With that said, this driver provides a multi-user interface to the
+ * IPMI driver, and it allows multiple IPMI physical interfaces below
+ * the driver.  The physical interfaces bind as a lower layer on the
+ * driver.  They appear as interfaces to the application using this
+ * interface.
+ *
+ * Multi-user means that multiple applications may use the driver,
+ * send commands, receive responses, etc.  The driver keeps track of
+ * commands the user sends and tracks the responses.  The responses
+ * will go back to the application that send the command.  If the
+ * response doesn't come back in time, the driver will return a
+ * timeout error response to the application.  Asynchronous events
+ * from the BMC event queue will go to all users bound to the driver.
+ * The incoming event queue in the BMC will automatically be flushed
+ * if it becomes full and it is queried once a second to see if
+ * anything is in it.  Incoming commands to the driver will get
+ * delivered as commands.
+ *
+ * This driver provides two main interfaces: one for in-kernel
+ * applications and another for userland applications.  The
+ * capabilities are basically the same for both interface, although
+ * the interfaces are somewhat different.  The stuff in the
+ * #ifdef __KERNEL__ below is the in-kernel interface.  The userland
+ * interface is defined later in the file.  */
+
+
+
+/*
+ * This is an overlay for all the address types, so it's easy to
+ * determine the actual address type.  This is kind of like addresses
+ * work for sockets.
+ */
+#define IPMI_MAX_ADDR_SIZE 32
+struct ipmi_addr {
+	 /* Try to take these from the "Channel Medium Type" table
+	    in section 6.5 of the IPMI 1.5 manual. */
+	int   addr_type;
+	short channel;
+	char  data[IPMI_MAX_ADDR_SIZE];
+};
+
+/*
+ * When the address is not used, the type will be set to this value.
+ * The channel is the BMC's channel number for the channel (usually
+ * 0), or IPMC_BMC_CHANNEL if communicating directly with the BMC.
+ */
+#define IPMI_SYSTEM_INTERFACE_ADDR_TYPE	0x0c
+struct ipmi_system_interface_addr {
+	int           addr_type;
+	short         channel;
+	unsigned char lun;
+};
+
+/* An IPMB Address. */
+#define IPMI_IPMB_ADDR_TYPE		0x01
+/* Used for broadcast get device id as described in section 17.9 of the
+   IPMI 1.5 manual. */
+#define IPMI_IPMB_BROADCAST_ADDR_TYPE	0x41
+struct ipmi_ipmb_addr {
+	int           addr_type;
+	short         channel;
+	unsigned char slave_addr;
+	unsigned char lun;
+};
+
+/*
+ * A LAN Address.  This is an address to/from a LAN interface bridged
+ * by the BMC, not an address actually out on the LAN.
+ *
+ * A concious decision was made here to deviate slightly from the IPMI
+ * spec.  We do not use rqSWID and rsSWID like it shows in the
+ * message.  Instead, we use remote_SWID and local_SWID.  This means
+ * that any message (a request or response) from another device will
+ * always have exactly the same address.  If you didn't do this,
+ * requests and responses from the same device would have different
+ * addresses, and that's not too cool.
+ *
+ * In this address, the remote_SWID is always the SWID the remote
+ * message came from, or the SWID we are sending the message to.
+ * local_SWID is always our SWID.  Note that having our SWID in the
+ * message is a little weird, but this is required.
+ */
+#define IPMI_LAN_ADDR_TYPE		0x04
+struct ipmi_lan_addr {
+	int           addr_type;
+	short         channel;
+	unsigned char privilege;
+	unsigned char session_handle;
+	unsigned char remote_SWID;
+	unsigned char local_SWID;
+	unsigned char lun;
+};
+
+
+/*
+ * Channel for talking directly with the BMC.  When using this
+ * channel, This is for the system interface address type only.  FIXME
+ * - is this right, or should we use -1?
+ */
+#define IPMI_BMC_CHANNEL  0xf
+#define IPMI_NUM_CHANNELS 0x10
+
+/*
+ * Used to signify an "all channel" bitmask.  This is more than the
+ * actual number of channels because this is used in userland and
+ * will cover us if the number of channels is extended.
+ */
+#define IPMI_CHAN_ALL     (~0)
+
+
+/*
+ * A raw IPMI message without any addressing.  This covers both
+ * commands and responses.  The completion code is always the first
+ * byte of data in the response (as the spec shows the messages laid
+ * out).
+ */
+struct ipmi_msg {
+	unsigned char  netfn;
+	unsigned char  cmd;
+	unsigned short data_len;
+	unsigned char  *data;
+};
+
+struct kernel_ipmi_msg {
+	unsigned char  netfn;
+	unsigned char  cmd;
+	unsigned short data_len;
+	unsigned char  *data;
+};
+
+/*
+ * Various defines that are useful for IPMI applications.
+ */
+#define IPMI_INVALID_CMD_COMPLETION_CODE	0xC1
+#define IPMI_TIMEOUT_COMPLETION_CODE		0xC3
+#define IPMI_UNKNOWN_ERR_COMPLETION_CODE	0xff
+
+
+/*
+ * Receive types for messages coming from the receive interface.  This
+ * is used for the receive in-kernel interface and in the receive
+ * IOCTL.
+ *
+ * The "IPMI_RESPONSE_RESPNOSE_TYPE" is a little strange sounding, but
+ * it allows you to get the message results when you send a response
+ * message.
+ */
+#define IPMI_RESPONSE_RECV_TYPE		1 /* A response to a command */
+#define IPMI_ASYNC_EVENT_RECV_TYPE	2 /* Something from the event queue */
+#define IPMI_CMD_RECV_TYPE		3 /* A command from somewhere else */
+#define IPMI_RESPONSE_RESPONSE_TYPE	4 /* The response for
+					      a sent response, giving any
+					      error status for sending the
+					      response.  When you send a
+					      response message, this will
+					      be returned. */
+#define IPMI_OEM_RECV_TYPE		5 /* The response for OEM Channels */
+
+/* Note that async events and received commands do not have a completion
+   code as the first byte of the incoming data, unlike a response. */
+
+
+/*
+ * Modes for ipmi_set_maint_mode() and the userland IOCTL.  The AUTO
+ * setting is the default and means it will be set on certain
+ * commands.  Hard setting it on and off will override automatic
+ * operation.
+ */
+#define IPMI_MAINTENANCE_MODE_AUTO	0
+#define IPMI_MAINTENANCE_MODE_OFF	1
+#define IPMI_MAINTENANCE_MODE_ON	2
+
+
+
+/*
+ * The userland interface
+ */
+
+/*
+ * The userland interface for the IPMI driver is a standard character
+ * device, with each instance of an interface registered as a minor
+ * number under the major character device.
+ *
+ * The read and write calls do not work, to get messages in and out
+ * requires ioctl calls because of the complexity of the data.  select
+ * and poll do work, so you can wait for input using the file
+ * descriptor, you just can use read to get it.
+ *
+ * In general, you send a command down to the interface and receive
+ * responses back.  You can use the msgid value to correlate commands
+ * and responses, the driver will take care of figuring out which
+ * incoming messages are for which command and find the proper msgid
+ * value to report.  You will only receive reponses for commands you
+ * send.  Asynchronous events, however, go to all open users, so you
+ * must be ready to handle these (or ignore them if you don't care).
+ *
+ * The address type depends upon the channel type.  When talking
+ * directly to the BMC (IPMC_BMC_CHANNEL), the address is ignored
+ * (IPMI_UNUSED_ADDR_TYPE).  When talking to an IPMB channel, you must
+ * supply a valid IPMB address with the addr_type set properly.
+ *
+ * When talking to normal channels, the driver takes care of the
+ * details of formatting and sending messages on that channel.  You do
+ * not, for instance, have to format a send command, you just send
+ * whatever command you want to the channel, the driver will create
+ * the send command, automatically issue receive command and get even
+ * commands, and pass those up to the proper user.
+ */
+
+
+/* The magic IOCTL value for this interface. */
+#define IPMI_IOC_MAGIC 'i'
+
+
+/* Messages sent to the interface are this format. */
+struct ipmi_req {
+	unsigned char *addr; /* Address to send the message to. */
+	unsigned int  addr_len;
+
+	long    msgid; /* The sequence number for the message.  This
+			  exact value will be reported back in the
+			  response to this request if it is a command.
+			  If it is a response, this will be used as
+			  the sequence value for the response.  */
+
+	struct ipmi_msg msg;
+};
+/*
+ * Send a message to the interfaces.  error values are:
+ *   - EFAULT - an address supplied was invalid.
+ *   - EINVAL - The address supplied was not valid, or the command
+ *              was not allowed.
+ *   - EMSGSIZE - The message to was too large.
+ *   - ENOMEM - Buffers could not be allocated for the command.
+ */
+#define IPMICTL_SEND_COMMAND		_IOR(IPMI_IOC_MAGIC, 13,	\
+					     struct ipmi_req)
+
+/* Messages sent to the interface with timing parameters are this
+   format. */
+struct ipmi_req_settime {
+	struct ipmi_req req;
+
+	/* See ipmi_request_settime() above for details on these
+	   values. */
+	int          retries;
+	unsigned int retry_time_ms;
+};
+/*
+ * Send a message to the interfaces with timing parameters.  error values
+ * are:
+ *   - EFAULT - an address supplied was invalid.
+ *   - EINVAL - The address supplied was not valid, or the command
+ *              was not allowed.
+ *   - EMSGSIZE - The message to was too large.
+ *   - ENOMEM - Buffers could not be allocated for the command.
+ */
+#define IPMICTL_SEND_COMMAND_SETTIME	_IOR(IPMI_IOC_MAGIC, 21,	\
+					     struct ipmi_req_settime)
+
+/* Messages received from the interface are this format. */
+struct ipmi_recv {
+	int     recv_type; /* Is this a command, response or an
+			      asyncronous event. */
+
+	unsigned char *addr;    /* Address the message was from is put
+				   here.  The caller must supply the
+				   memory. */
+	unsigned int  addr_len; /* The size of the address buffer.
+				   The caller supplies the full buffer
+				   length, this value is updated to
+				   the actual message length when the
+				   message is received. */
+
+	long    msgid; /* The sequence number specified in the request
+			  if this is a response.  If this is a command,
+			  this will be the sequence number from the
+			  command. */
+
+	struct ipmi_msg msg; /* The data field must point to a buffer.
+				The data_size field must be set to the
+				size of the message buffer.  The
+				caller supplies the full buffer
+				length, this value is updated to the
+				actual message length when the message
+				is received. */
+};
+
+/*
+ * Receive a message.  error values:
+ *  - EAGAIN - no messages in the queue.
+ *  - EFAULT - an address supplied was invalid.
+ *  - EINVAL - The address supplied was not valid.
+ *  - EMSGSIZE - The message to was too large to fit into the message buffer,
+ *               the message will be left in the buffer. */
+#define IPMICTL_RECEIVE_MSG		_IOWR(IPMI_IOC_MAGIC, 12,	\
+					      struct ipmi_recv)
+
+/*
+ * Like RECEIVE_MSG, but if the message won't fit in the buffer, it
+ * will truncate the contents instead of leaving the data in the
+ * buffer.
+ */
+#define IPMICTL_RECEIVE_MSG_TRUNC	_IOWR(IPMI_IOC_MAGIC, 11,	\
+					      struct ipmi_recv)
+
+/* Register to get commands from other entities on this interface. */
+struct ipmi_cmdspec {
+	unsigned char netfn;
+	unsigned char cmd;
+};
+
+/*
+ * Register to receive a specific command.  error values:
+ *   - EFAULT - an address supplied was invalid.
+ *   - EBUSY - The netfn/cmd supplied was already in use.
+ *   - ENOMEM - could not allocate memory for the entry.
+ */
+#define IPMICTL_REGISTER_FOR_CMD	_IOR(IPMI_IOC_MAGIC, 14,	\
+					     struct ipmi_cmdspec)
+/*
+ * Unregister a regsitered command.  error values:
+ *  - EFAULT - an address supplied was invalid.
+ *  - ENOENT - The netfn/cmd was not found registered for this user.
+ */
+#define IPMICTL_UNREGISTER_FOR_CMD	_IOR(IPMI_IOC_MAGIC, 15,	\
+					     struct ipmi_cmdspec)
+
+/*
+ * Register to get commands from other entities on specific channels.
+ * This way, you can only listen on specific channels, or have messages
+ * from some channels go to one place and other channels to someplace
+ * else.  The chans field is a bitmask, (1 << channel) for each channel.
+ * It may be IPMI_CHAN_ALL for all channels.
+ */
+struct ipmi_cmdspec_chans {
+	unsigned int netfn;
+	unsigned int cmd;
+	unsigned int chans;
+};
+
+/*
+ * Register to receive a specific command on specific channels.  error values:
+ *   - EFAULT - an address supplied was invalid.
+ *   - EBUSY - One of the netfn/cmd/chans supplied was already in use.
+ *   - ENOMEM - could not allocate memory for the entry.
+ */
+#define IPMICTL_REGISTER_FOR_CMD_CHANS	_IOR(IPMI_IOC_MAGIC, 28,	\
+					     struct ipmi_cmdspec_chans)
+/*
+ * Unregister some netfn/cmd/chans.  error values:
+ *  - EFAULT - an address supplied was invalid.
+ *  - ENOENT - None of the netfn/cmd/chans were found registered for this user.
+ */
+#define IPMICTL_UNREGISTER_FOR_CMD_CHANS _IOR(IPMI_IOC_MAGIC, 29,	\
+					     struct ipmi_cmdspec_chans)
+
+/*
+ * Set whether this interface receives events.  Note that the first
+ * user registered for events will get all pending events for the
+ * interface.  error values:
+ *  - EFAULT - an address supplied was invalid.
+ */
+#define IPMICTL_SET_GETS_EVENTS_CMD	_IOR(IPMI_IOC_MAGIC, 16, int)
+
+/*
+ * Set and get the slave address and LUN that we will use for our
+ * source messages.  Note that this affects the interface, not just
+ * this user, so it will affect all users of this interface.  This is
+ * so some initialization code can come in and do the OEM-specific
+ * things it takes to determine your address (if not the BMC) and set
+ * it for everyone else.  You should probably leave the LUN alone.
+ */
+struct ipmi_channel_lun_address_set {
+	unsigned short channel;
+	unsigned char  value;
+};
+#define IPMICTL_SET_MY_CHANNEL_ADDRESS_CMD \
+	_IOR(IPMI_IOC_MAGIC, 24, struct ipmi_channel_lun_address_set)
+#define IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD \
+	_IOR(IPMI_IOC_MAGIC, 25, struct ipmi_channel_lun_address_set)
+#define IPMICTL_SET_MY_CHANNEL_LUN_CMD \
+	_IOR(IPMI_IOC_MAGIC, 26, struct ipmi_channel_lun_address_set)
+#define IPMICTL_GET_MY_CHANNEL_LUN_CMD \
+	_IOR(IPMI_IOC_MAGIC, 27, struct ipmi_channel_lun_address_set)
+/* Legacy interfaces, these only set IPMB 0. */
+#define IPMICTL_SET_MY_ADDRESS_CMD	_IOR(IPMI_IOC_MAGIC, 17, unsigned int)
+#define IPMICTL_GET_MY_ADDRESS_CMD	_IOR(IPMI_IOC_MAGIC, 18, unsigned int)
+#define IPMICTL_SET_MY_LUN_CMD		_IOR(IPMI_IOC_MAGIC, 19, unsigned int)
+#define IPMICTL_GET_MY_LUN_CMD		_IOR(IPMI_IOC_MAGIC, 20, unsigned int)
+
+/*
+ * Get/set the default timing values for an interface.  You shouldn't
+ * generally mess with these.
+ */
+struct ipmi_timing_parms {
+	int          retries;
+	unsigned int retry_time_ms;
+};
+#define IPMICTL_SET_TIMING_PARMS_CMD	_IOR(IPMI_IOC_MAGIC, 22, \
+					     struct ipmi_timing_parms)
+#define IPMICTL_GET_TIMING_PARMS_CMD	_IOR(IPMI_IOC_MAGIC, 23, \
+					     struct ipmi_timing_parms)
+
+/*
+ * Set the maintenance mode.  See ipmi_set_maintenance_mode() above
+ * for a description of what this does.
+ */
+#define IPMICTL_GET_MAINTENANCE_MODE_CMD	_IOR(IPMI_IOC_MAGIC, 30, int)
+#define IPMICTL_SET_MAINTENANCE_MODE_CMD	_IOW(IPMI_IOC_MAGIC, 31, int)
+
+#endif /* __LINUX_IPMI_H */
diff -uNr linux-2.6.32/usr/include/linux/ipmi_msgdefs.h clean_modified/linux-2.6.32/usr/include/linux/ipmi_msgdefs.h
--- linux-2.6.32/usr/include/linux/ipmi_msgdefs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipmi_msgdefs.h	2019-04-14 13:24:03.006938056 -0500
@@ -0,0 +1,121 @@
+/*
+ * ipmi_smi.h
+ *
+ * MontaVista IPMI system management interface
+ *
+ * Author: MontaVista Software, Inc.
+ *         Corey Minyard <minyard@mvista.com>
+ *         source@mvista.com
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __LINUX_IPMI_MSGDEFS_H
+#define __LINUX_IPMI_MSGDEFS_H
+
+/* Various definitions for IPMI messages used by almost everything in
+   the IPMI stack. */
+
+/* NetFNs and commands used inside the IPMI stack. */
+
+#define IPMI_NETFN_SENSOR_EVENT_REQUEST		0x04
+#define IPMI_NETFN_SENSOR_EVENT_RESPONSE	0x05
+#define IPMI_GET_EVENT_RECEIVER_CMD	0x01
+
+#define IPMI_NETFN_APP_REQUEST			0x06
+#define IPMI_NETFN_APP_RESPONSE			0x07
+#define IPMI_GET_DEVICE_ID_CMD		0x01
+#define IPMI_COLD_RESET_CMD		0x02
+#define IPMI_WARM_RESET_CMD		0x03
+#define IPMI_CLEAR_MSG_FLAGS_CMD	0x30
+#define IPMI_GET_DEVICE_GUID_CMD	0x08
+#define IPMI_GET_MSG_FLAGS_CMD		0x31
+#define IPMI_SEND_MSG_CMD		0x34
+#define IPMI_GET_MSG_CMD		0x33
+#define IPMI_SET_BMC_GLOBAL_ENABLES_CMD	0x2e
+#define IPMI_GET_BMC_GLOBAL_ENABLES_CMD	0x2f
+#define IPMI_READ_EVENT_MSG_BUFFER_CMD	0x35
+#define IPMI_GET_CHANNEL_INFO_CMD	0x42
+
+/* Bit for BMC global enables. */
+#define IPMI_BMC_RCV_MSG_INTR     0x01
+#define IPMI_BMC_EVT_MSG_INTR     0x02
+#define IPMI_BMC_EVT_MSG_BUFF     0x04
+#define IPMI_BMC_SYS_LOG          0x08
+
+#define IPMI_NETFN_STORAGE_REQUEST		0x0a
+#define IPMI_NETFN_STORAGE_RESPONSE		0x0b
+#define IPMI_ADD_SEL_ENTRY_CMD		0x44
+
+#define IPMI_NETFN_FIRMWARE_REQUEST		0x08
+#define IPMI_NETFN_FIRMWARE_RESPONSE		0x09
+
+/* The default slave address */
+#define IPMI_BMC_SLAVE_ADDR	0x20
+
+/* The BT interface on high-end HP systems supports up to 255 bytes in
+ * one transfer.  Its "virtual" BMC supports some commands that are longer
+ * than 128 bytes.  Use the full 256, plus NetFn/LUN, Cmd, cCode, plus
+ * some overhead; it's not worth the effort to dynamically size this based
+ * on the results of the "Get BT Capabilities" command. */
+#define IPMI_MAX_MSG_LENGTH	272	/* multiple of 16 */
+
+#define IPMI_CC_NO_ERROR		0x00
+#define IPMI_NODE_BUSY_ERR		0xc0
+#define IPMI_INVALID_COMMAND_ERR	0xc1
+#define IPMI_TIMEOUT_ERR		0xc3
+#define IPMI_ERR_MSG_TRUNCATED		0xc6
+#define IPMI_REQ_LEN_INVALID_ERR	0xc7
+#define IPMI_REQ_LEN_EXCEEDED_ERR	0xc8
+#define IPMI_NOT_IN_MY_STATE_ERR	0xd5	/* IPMI 2.0 */
+#define IPMI_LOST_ARBITRATION_ERR	0x81
+#define IPMI_BUS_ERR			0x82
+#define IPMI_NAK_ON_WRITE_ERR		0x83
+#define IPMI_ERR_UNSPECIFIED		0xff
+
+#define IPMI_CHANNEL_PROTOCOL_IPMB	1
+#define IPMI_CHANNEL_PROTOCOL_ICMB	2
+#define IPMI_CHANNEL_PROTOCOL_SMBUS	4
+#define IPMI_CHANNEL_PROTOCOL_KCS	5
+#define IPMI_CHANNEL_PROTOCOL_SMIC	6
+#define IPMI_CHANNEL_PROTOCOL_BT10	7
+#define IPMI_CHANNEL_PROTOCOL_BT15	8
+#define IPMI_CHANNEL_PROTOCOL_TMODE	9
+
+#define IPMI_CHANNEL_MEDIUM_IPMB	1
+#define IPMI_CHANNEL_MEDIUM_ICMB10	2
+#define IPMI_CHANNEL_MEDIUM_ICMB09	3
+#define IPMI_CHANNEL_MEDIUM_8023LAN	4
+#define IPMI_CHANNEL_MEDIUM_ASYNC	5
+#define IPMI_CHANNEL_MEDIUM_OTHER_LAN	6
+#define IPMI_CHANNEL_MEDIUM_PCI_SMBUS	7
+#define IPMI_CHANNEL_MEDIUM_SMBUS1	8
+#define IPMI_CHANNEL_MEDIUM_SMBUS2	9
+#define IPMI_CHANNEL_MEDIUM_USB1	10
+#define IPMI_CHANNEL_MEDIUM_USB2	11
+#define IPMI_CHANNEL_MEDIUM_SYSINTF	12
+#define IPMI_CHANNEL_MEDIUM_OEM_MIN	0x60
+#define IPMI_CHANNEL_MEDIUM_OEM_MAX	0x7f
+
+#endif /* __LINUX_IPMI_MSGDEFS_H */
diff -uNr linux-2.6.32/usr/include/linux/ipsec.h clean_modified/linux-2.6.32/usr/include/linux/ipsec.h
--- linux-2.6.32/usr/include/linux/ipsec.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipsec.h	2019-04-14 13:24:03.006938056 -0500
@@ -0,0 +1,47 @@
+#ifndef _LINUX_IPSEC_H
+#define _LINUX_IPSEC_H
+
+/* The definitions, required to talk to KAME racoon IKE. */
+
+#include <linux/pfkeyv2.h>
+
+#define IPSEC_PORT_ANY		0
+#define IPSEC_ULPROTO_ANY	255
+#define IPSEC_PROTO_ANY		255
+
+enum {
+	IPSEC_MODE_ANY		= 0,	/* We do not support this for SA */
+	IPSEC_MODE_TRANSPORT	= 1,
+	IPSEC_MODE_TUNNEL	= 2,
+	IPSEC_MODE_BEET         = 3
+};
+
+enum {
+	IPSEC_DIR_ANY		= 0,
+	IPSEC_DIR_INBOUND	= 1,
+	IPSEC_DIR_OUTBOUND	= 2,
+	IPSEC_DIR_FWD		= 3,	/* It is our own */
+	IPSEC_DIR_MAX		= 4,
+	IPSEC_DIR_INVALID	= 5
+};
+
+enum {
+	IPSEC_POLICY_DISCARD	= 0,
+	IPSEC_POLICY_NONE	= 1,
+	IPSEC_POLICY_IPSEC	= 2,
+	IPSEC_POLICY_ENTRUST	= 3,
+	IPSEC_POLICY_BYPASS	= 4
+};
+
+enum {
+	IPSEC_LEVEL_DEFAULT	= 0,
+	IPSEC_LEVEL_USE		= 1,
+	IPSEC_LEVEL_REQUIRE	= 2,
+	IPSEC_LEVEL_UNIQUE	= 3
+};
+
+#define IPSEC_MANUAL_REQID_MAX	0x3fff
+
+#define IPSEC_REPLAYWSIZE  32
+
+#endif	/* _LINUX_IPSEC_H */
diff -uNr linux-2.6.32/usr/include/linux/ipv6.h clean_modified/linux-2.6.32/usr/include/linux/ipv6.h
--- linux-2.6.32/usr/include/linux/ipv6.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipv6.h	2019-04-14 13:24:03.007791095 -0500
@@ -0,0 +1,159 @@
+#ifndef _IPV6_H
+#define _IPV6_H
+
+#include <linux/types.h>
+#include <linux/in6.h>
+#include <asm/byteorder.h>
+
+/* The latest drafts declared increase in minimal mtu up to 1280. */
+
+#define IPV6_MIN_MTU	1280
+
+/*
+ *	Advanced API
+ *	source interface/address selection, source routing, etc...
+ *	*under construction*
+ */
+
+
+struct in6_pktinfo {
+	struct in6_addr	ipi6_addr;
+	int		ipi6_ifindex;
+};
+
+
+struct in6_ifreq {
+	struct in6_addr	ifr6_addr;
+	__u32		ifr6_prefixlen;
+	int		ifr6_ifindex; 
+};
+
+#define IPV6_SRCRT_STRICT	0x01	/* Deprecated; will be removed */
+#define IPV6_SRCRT_TYPE_0	0	/* Deprecated; will be removed */
+#define IPV6_SRCRT_TYPE_2	2	/* IPv6 type 2 Routing Header	*/
+
+/*
+ *	routing header
+ */
+struct ipv6_rt_hdr {
+	__u8		nexthdr;
+	__u8		hdrlen;
+	__u8		type;
+	__u8		segments_left;
+
+	/*
+	 *	type specific data
+	 *	variable length field
+	 */
+};
+
+
+struct ipv6_opt_hdr {
+	__u8 		nexthdr;
+	__u8 		hdrlen;
+	/* 
+	 * TLV encoded option data follows.
+	 */
+} __attribute__ ((packed));	/* required for some archs */
+
+#define ipv6_destopt_hdr ipv6_opt_hdr
+#define ipv6_hopopt_hdr  ipv6_opt_hdr
+
+
+/*
+ *	routing header type 0 (used in cmsghdr struct)
+ */
+
+struct rt0_hdr {
+	struct ipv6_rt_hdr	rt_hdr;
+	__u32			reserved;
+	struct in6_addr		addr[0];
+
+#define rt0_type		rt_hdr.type
+};
+
+/*
+ *	routing header type 2
+ */
+
+struct rt2_hdr {
+	struct ipv6_rt_hdr	rt_hdr;
+	__u32			reserved;
+	struct in6_addr		addr;
+
+#define rt2_type		rt_hdr.type
+};
+
+/*
+ *	home address option in destination options header
+ */
+
+struct ipv6_destopt_hao {
+	__u8			type;
+	__u8			length;
+	struct in6_addr		addr;
+} __attribute__ ((__packed__));
+
+/*
+ *	IPv6 fixed header
+ *
+ *	BEWARE, it is incorrect. The first 4 bits of flow_lbl
+ *	are glued to priority now, forming "class".
+ */
+
+struct ipv6hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8			priority:4,
+				version:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8			version:4,
+				priority:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8			flow_lbl[3];
+
+	__be16			payload_len;
+	__u8			nexthdr;
+	__u8			hop_limit;
+
+	struct	in6_addr	saddr;
+	struct	in6_addr	daddr;
+};
+
+
+/* index values for the variables in ipv6_devconf */
+enum {
+	DEVCONF_FORWARDING = 0,
+	DEVCONF_HOPLIMIT,
+	DEVCONF_MTU6,
+	DEVCONF_ACCEPT_RA,
+	DEVCONF_ACCEPT_REDIRECTS,
+	DEVCONF_AUTOCONF,
+	DEVCONF_DAD_TRANSMITS,
+	DEVCONF_RTR_SOLICITS,
+	DEVCONF_RTR_SOLICIT_INTERVAL,
+	DEVCONF_RTR_SOLICIT_DELAY,
+	DEVCONF_USE_TEMPADDR,
+	DEVCONF_TEMP_VALID_LFT,
+	DEVCONF_TEMP_PREFERED_LFT,
+	DEVCONF_REGEN_MAX_RETRY,
+	DEVCONF_MAX_DESYNC_FACTOR,
+	DEVCONF_MAX_ADDRESSES,
+	DEVCONF_FORCE_MLD_VERSION,
+	DEVCONF_ACCEPT_RA_DEFRTR,
+	DEVCONF_ACCEPT_RA_PINFO,
+	DEVCONF_ACCEPT_RA_RTR_PREF,
+	DEVCONF_RTR_PROBE_INTERVAL,
+	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN,
+	DEVCONF_PROXY_NDP,
+	DEVCONF_OPTIMISTIC_DAD,
+	DEVCONF_ACCEPT_SOURCE_ROUTE,
+	DEVCONF_MC_FORWARDING,
+	DEVCONF_DISABLE_IPV6,
+	DEVCONF_ACCEPT_DAD,
+	DEVCONF_MAX
+};
+
+
+#endif /* _IPV6_H */
diff -uNr linux-2.6.32/usr/include/linux/ipv6_route.h clean_modified/linux-2.6.32/usr/include/linux/ipv6_route.h
--- linux-2.6.32/usr/include/linux/ipv6_route.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipv6_route.h	2019-04-14 13:24:03.007791095 -0500
@@ -0,0 +1,58 @@
+/*
+ *	Linux INET6 implementation 
+ *
+ *	Authors:
+ *	Pedro Roque		<roque@di.fc.ul.pt>	
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IPV6_ROUTE_H
+#define _LINUX_IPV6_ROUTE_H
+
+#include <linux/types.h>
+
+#define RTF_DEFAULT	0x00010000	/* default - learned via ND	*/
+#define RTF_ALLONLINK	0x00020000	/* (deprecated and will be removed)
+					   fallback, no routers on link */
+#define RTF_ADDRCONF	0x00040000	/* addrconf route - RA		*/
+#define RTF_PREFIX_RT	0x00080000	/* A prefix only route - RA	*/
+#define RTF_ANYCAST	0x00100000	/* Anycast			*/
+
+#define RTF_NONEXTHOP	0x00200000	/* route with no nexthop	*/
+#define RTF_EXPIRES	0x00400000
+
+#define RTF_ROUTEINFO	0x00800000	/* route information - RA	*/
+
+#define RTF_CACHE	0x01000000	/* cache entry			*/
+#define RTF_FLOW	0x02000000	/* flow significant route	*/
+#define RTF_POLICY	0x04000000	/* policy route			*/
+
+#define RTF_PREF(pref)	((pref) << 27)
+#define RTF_PREF_MASK	0x18000000
+
+#define RTF_LOCAL	0x80000000
+
+
+struct in6_rtmsg {
+	struct in6_addr		rtmsg_dst;
+	struct in6_addr		rtmsg_src;
+	struct in6_addr		rtmsg_gateway;
+	__u32			rtmsg_type;
+	__u16			rtmsg_dst_len;
+	__u16			rtmsg_src_len;
+	__u32			rtmsg_metric;
+	unsigned long		rtmsg_info;
+        __u32			rtmsg_flags;
+	int			rtmsg_ifindex;
+};
+
+#define RTMSG_NEWDEVICE		0x11
+#define RTMSG_DELDEVICE		0x12
+#define RTMSG_NEWROUTE		0x21
+#define RTMSG_DELROUTE		0x22
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ip_vs.h clean_modified/linux-2.6.32/usr/include/linux/ip_vs.h
--- linux-2.6.32/usr/include/linux/ip_vs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ip_vs.h	2019-04-14 13:24:03.007791095 -0500
@@ -0,0 +1,405 @@
+/*
+ *      IP Virtual Server
+ *      data structure and functionality definitions
+ */
+
+#ifndef _IP_VS_H
+#define _IP_VS_H
+
+#include <linux/types.h>	/* For __beXX types in userland */
+
+#define IP_VS_VERSION_CODE	0x010201
+#define NVERSION(version)			\
+	(version >> 16) & 0xFF,			\
+	(version >> 8) & 0xFF,			\
+	version & 0xFF
+
+/*
+ *      Virtual Service Flags
+ */
+#define IP_VS_SVC_F_PERSISTENT	0x0001		/* persistent port */
+#define IP_VS_SVC_F_HASHED	0x0002		/* hashed entry */
+
+/*
+ *      Destination Server Flags
+ */
+#define IP_VS_DEST_F_AVAILABLE	0x0001		/* server is available */
+#define IP_VS_DEST_F_OVERLOAD	0x0002		/* server is overloaded */
+
+/*
+ *      IPVS sync daemon states
+ */
+#define IP_VS_STATE_NONE	0x0000		/* daemon is stopped */
+#define IP_VS_STATE_MASTER	0x0001		/* started as master */
+#define IP_VS_STATE_BACKUP	0x0002		/* started as backup */
+
+/*
+ *      IPVS socket options
+ */
+#define IP_VS_BASE_CTL		(64+1024+64)		/* base */
+
+#define IP_VS_SO_SET_NONE	IP_VS_BASE_CTL		/* just peek */
+#define IP_VS_SO_SET_INSERT	(IP_VS_BASE_CTL+1)
+#define IP_VS_SO_SET_ADD	(IP_VS_BASE_CTL+2)
+#define IP_VS_SO_SET_EDIT	(IP_VS_BASE_CTL+3)
+#define IP_VS_SO_SET_DEL	(IP_VS_BASE_CTL+4)
+#define IP_VS_SO_SET_FLUSH	(IP_VS_BASE_CTL+5)
+#define IP_VS_SO_SET_LIST	(IP_VS_BASE_CTL+6)
+#define IP_VS_SO_SET_ADDDEST	(IP_VS_BASE_CTL+7)
+#define IP_VS_SO_SET_DELDEST	(IP_VS_BASE_CTL+8)
+#define IP_VS_SO_SET_EDITDEST	(IP_VS_BASE_CTL+9)
+#define IP_VS_SO_SET_TIMEOUT	(IP_VS_BASE_CTL+10)
+#define IP_VS_SO_SET_STARTDAEMON (IP_VS_BASE_CTL+11)
+#define IP_VS_SO_SET_STOPDAEMON (IP_VS_BASE_CTL+12)
+#define IP_VS_SO_SET_RESTORE    (IP_VS_BASE_CTL+13)
+#define IP_VS_SO_SET_SAVE       (IP_VS_BASE_CTL+14)
+#define IP_VS_SO_SET_ZERO	(IP_VS_BASE_CTL+15)
+#define IP_VS_SO_SET_MAX	IP_VS_SO_SET_ZERO
+
+#define IP_VS_SO_GET_VERSION	IP_VS_BASE_CTL
+#define IP_VS_SO_GET_INFO	(IP_VS_BASE_CTL+1)
+#define IP_VS_SO_GET_SERVICES	(IP_VS_BASE_CTL+2)
+#define IP_VS_SO_GET_SERVICE	(IP_VS_BASE_CTL+3)
+#define IP_VS_SO_GET_DESTS	(IP_VS_BASE_CTL+4)
+#define IP_VS_SO_GET_DEST	(IP_VS_BASE_CTL+5)	/* not used now */
+#define IP_VS_SO_GET_TIMEOUT	(IP_VS_BASE_CTL+6)
+#define IP_VS_SO_GET_DAEMON	(IP_VS_BASE_CTL+7)
+#define IP_VS_SO_GET_MAX	IP_VS_SO_GET_DAEMON
+
+
+/*
+ *      IPVS Connection Flags
+ */
+#define IP_VS_CONN_F_FWD_MASK	0x0007		/* mask for the fwd methods */
+#define IP_VS_CONN_F_MASQ	0x0000		/* masquerading/NAT */
+#define IP_VS_CONN_F_LOCALNODE	0x0001		/* local node */
+#define IP_VS_CONN_F_TUNNEL	0x0002		/* tunneling */
+#define IP_VS_CONN_F_DROUTE	0x0003		/* direct routing */
+#define IP_VS_CONN_F_BYPASS	0x0004		/* cache bypass */
+#define IP_VS_CONN_F_SYNC	0x0020		/* entry created by sync */
+#define IP_VS_CONN_F_HASHED	0x0040		/* hashed entry */
+#define IP_VS_CONN_F_NOOUTPUT	0x0080		/* no output packets */
+#define IP_VS_CONN_F_INACTIVE	0x0100		/* not established */
+#define IP_VS_CONN_F_OUT_SEQ	0x0200		/* must do output seq adjust */
+#define IP_VS_CONN_F_IN_SEQ	0x0400		/* must do input seq adjust */
+#define IP_VS_CONN_F_SEQ_MASK	0x0600		/* in/out sequence mask */
+#define IP_VS_CONN_F_NO_CPORT	0x0800		/* no client port set yet */
+#define IP_VS_CONN_F_TEMPLATE	0x1000		/* template, not connection */
+
+#define IP_VS_SCHEDNAME_MAXLEN	16
+#define IP_VS_IFNAME_MAXLEN	16
+
+
+/*
+ *	The struct ip_vs_service_user and struct ip_vs_dest_user are
+ *	used to set IPVS rules through setsockopt.
+ */
+struct ip_vs_service_user {
+	/* virtual service addresses */
+	__u16		protocol;
+	__be32			addr;		/* virtual ip address */
+	__be16			port;
+	__u32		fwmark;		/* firwall mark of service */
+
+	/* virtual service options */
+	char			sched_name[IP_VS_SCHEDNAME_MAXLEN];
+	unsigned		flags;		/* virtual service flags */
+	unsigned		timeout;	/* persistent timeout in sec */
+	__be32			netmask;	/* persistent netmask */
+};
+
+
+struct ip_vs_dest_user {
+	/* destination server address */
+	__be32			addr;
+	__be16			port;
+
+	/* real server options */
+	unsigned		conn_flags;	/* connection flags */
+	int			weight;		/* destination weight */
+
+	/* thresholds for active connections */
+	__u32		u_threshold;	/* upper threshold */
+	__u32		l_threshold;	/* lower threshold */
+};
+
+
+/*
+ *	IPVS statistics object (for user space)
+ */
+struct ip_vs_stats_user
+{
+	__u32                   conns;          /* connections scheduled */
+	__u32                   inpkts;         /* incoming packets */
+	__u32                   outpkts;        /* outgoing packets */
+	__u64                   inbytes;        /* incoming bytes */
+	__u64                   outbytes;       /* outgoing bytes */
+
+	__u32			cps;		/* current connection rate */
+	__u32			inpps;		/* current in packet rate */
+	__u32			outpps;		/* current out packet rate */
+	__u32			inbps;		/* current in byte rate */
+	__u32			outbps;		/* current out byte rate */
+};
+
+
+/* The argument to IP_VS_SO_GET_INFO */
+struct ip_vs_getinfo {
+	/* version number */
+	unsigned int		version;
+
+	/* size of connection hash table */
+	unsigned int		size;
+
+	/* number of virtual services */
+	unsigned int		num_services;
+};
+
+
+/* The argument to IP_VS_SO_GET_SERVICE */
+struct ip_vs_service_entry {
+	/* which service: user fills in these */
+	__u16		protocol;
+	__be32			addr;		/* virtual address */
+	__be16			port;
+	__u32		fwmark;		/* firwall mark of service */
+
+	/* service options */
+	char			sched_name[IP_VS_SCHEDNAME_MAXLEN];
+	unsigned		flags;          /* virtual service flags */
+	unsigned		timeout;	/* persistent timeout */
+	__be32			netmask;	/* persistent netmask */
+
+	/* number of real servers */
+	unsigned int		num_dests;
+
+	/* statistics */
+	struct ip_vs_stats_user stats;
+};
+
+
+struct ip_vs_dest_entry {
+	__be32			addr;		/* destination address */
+	__be16			port;
+	unsigned		conn_flags;	/* connection flags */
+	int			weight;		/* destination weight */
+
+	__u32		u_threshold;	/* upper threshold */
+	__u32		l_threshold;	/* lower threshold */
+
+	__u32		activeconns;	/* active connections */
+	__u32		inactconns;	/* inactive connections */
+	__u32		persistconns;	/* persistent connections */
+
+	/* statistics */
+	struct ip_vs_stats_user stats;
+};
+
+
+/* The argument to IP_VS_SO_GET_DESTS */
+struct ip_vs_get_dests {
+	/* which service: user fills in these */
+	__u16		protocol;
+	__be32			addr;		/* virtual address */
+	__be16			port;
+	__u32		fwmark;		/* firwall mark of service */
+
+	/* number of real servers */
+	unsigned int		num_dests;
+
+	/* the real servers */
+	struct ip_vs_dest_entry	entrytable[0];
+};
+
+
+/* The argument to IP_VS_SO_GET_SERVICES */
+struct ip_vs_get_services {
+	/* number of virtual services */
+	unsigned int		num_services;
+
+	/* service table */
+	struct ip_vs_service_entry entrytable[0];
+};
+
+
+/* The argument to IP_VS_SO_GET_TIMEOUT */
+struct ip_vs_timeout_user {
+	int			tcp_timeout;
+	int			tcp_fin_timeout;
+	int			udp_timeout;
+};
+
+
+/* The argument to IP_VS_SO_GET_DAEMON */
+struct ip_vs_daemon_user {
+	/* sync daemon state (master/backup) */
+	int			state;
+
+	/* multicast interface name */
+	char			mcast_ifn[IP_VS_IFNAME_MAXLEN];
+
+	/* SyncID we belong to */
+	int			syncid;
+};
+
+/*
+ *
+ * IPVS Generic Netlink interface definitions
+ *
+ */
+
+/* Generic Netlink family info */
+
+#define IPVS_GENL_NAME		"IPVS"
+#define IPVS_GENL_VERSION	0x1
+
+struct ip_vs_flags {
+	__be32 flags;
+	__be32 mask;
+};
+
+/* Generic Netlink command attributes */
+enum {
+	IPVS_CMD_UNSPEC = 0,
+
+	IPVS_CMD_NEW_SERVICE,		/* add service */
+	IPVS_CMD_SET_SERVICE,		/* modify service */
+	IPVS_CMD_DEL_SERVICE,		/* delete service */
+	IPVS_CMD_GET_SERVICE,		/* get service info */
+
+	IPVS_CMD_NEW_DEST,		/* add destination */
+	IPVS_CMD_SET_DEST,		/* modify destination */
+	IPVS_CMD_DEL_DEST,		/* delete destination */
+	IPVS_CMD_GET_DEST,		/* get destination info */
+
+	IPVS_CMD_NEW_DAEMON,		/* start sync daemon */
+	IPVS_CMD_DEL_DAEMON,		/* stop sync daemon */
+	IPVS_CMD_GET_DAEMON,		/* get sync daemon status */
+
+	IPVS_CMD_SET_CONFIG,		/* set config settings */
+	IPVS_CMD_GET_CONFIG,		/* get config settings */
+
+	IPVS_CMD_SET_INFO,		/* only used in GET_INFO reply */
+	IPVS_CMD_GET_INFO,		/* get general IPVS info */
+
+	IPVS_CMD_ZERO,			/* zero all counters and stats */
+	IPVS_CMD_FLUSH,			/* flush services and dests */
+
+	__IPVS_CMD_MAX,
+};
+
+#define IPVS_CMD_MAX (__IPVS_CMD_MAX - 1)
+
+/* Attributes used in the first level of commands */
+enum {
+	IPVS_CMD_ATTR_UNSPEC = 0,
+	IPVS_CMD_ATTR_SERVICE,		/* nested service attribute */
+	IPVS_CMD_ATTR_DEST,		/* nested destination attribute */
+	IPVS_CMD_ATTR_DAEMON,		/* nested sync daemon attribute */
+	IPVS_CMD_ATTR_TIMEOUT_TCP,	/* TCP connection timeout */
+	IPVS_CMD_ATTR_TIMEOUT_TCP_FIN,	/* TCP FIN wait timeout */
+	IPVS_CMD_ATTR_TIMEOUT_UDP,	/* UDP timeout */
+	__IPVS_CMD_ATTR_MAX,
+};
+
+#define IPVS_CMD_ATTR_MAX (__IPVS_SVC_ATTR_MAX - 1)
+
+/*
+ * Attributes used to describe a service
+ *
+ * Used inside nested attribute IPVS_CMD_ATTR_SERVICE
+ */
+enum {
+	IPVS_SVC_ATTR_UNSPEC = 0,
+	IPVS_SVC_ATTR_AF,		/* address family */
+	IPVS_SVC_ATTR_PROTOCOL,		/* virtual service protocol */
+	IPVS_SVC_ATTR_ADDR,		/* virtual service address */
+	IPVS_SVC_ATTR_PORT,		/* virtual service port */
+	IPVS_SVC_ATTR_FWMARK,		/* firewall mark of service */
+
+	IPVS_SVC_ATTR_SCHED_NAME,	/* name of scheduler */
+	IPVS_SVC_ATTR_FLAGS,		/* virtual service flags */
+	IPVS_SVC_ATTR_TIMEOUT,		/* persistent timeout */
+	IPVS_SVC_ATTR_NETMASK,		/* persistent netmask */
+
+	IPVS_SVC_ATTR_STATS,		/* nested attribute for service stats */
+	__IPVS_SVC_ATTR_MAX,
+};
+
+#define IPVS_SVC_ATTR_MAX (__IPVS_SVC_ATTR_MAX - 1)
+
+/*
+ * Attributes used to describe a destination (real server)
+ *
+ * Used inside nested attribute IPVS_CMD_ATTR_DEST
+ */
+enum {
+	IPVS_DEST_ATTR_UNSPEC = 0,
+	IPVS_DEST_ATTR_ADDR,		/* real server address */
+	IPVS_DEST_ATTR_PORT,		/* real server port */
+
+	IPVS_DEST_ATTR_FWD_METHOD,	/* forwarding method */
+	IPVS_DEST_ATTR_WEIGHT,		/* destination weight */
+
+	IPVS_DEST_ATTR_U_THRESH,	/* upper threshold */
+	IPVS_DEST_ATTR_L_THRESH,	/* lower threshold */
+
+	IPVS_DEST_ATTR_ACTIVE_CONNS,	/* active connections */
+	IPVS_DEST_ATTR_INACT_CONNS,	/* inactive connections */
+	IPVS_DEST_ATTR_PERSIST_CONNS,	/* persistent connections */
+
+	IPVS_DEST_ATTR_STATS,		/* nested attribute for dest stats */
+	__IPVS_DEST_ATTR_MAX,
+};
+
+#define IPVS_DEST_ATTR_MAX (__IPVS_DEST_ATTR_MAX - 1)
+
+/*
+ * Attributes describing a sync daemon
+ *
+ * Used inside nested attribute IPVS_CMD_ATTR_DAEMON
+ */
+enum {
+	IPVS_DAEMON_ATTR_UNSPEC = 0,
+	IPVS_DAEMON_ATTR_STATE,		/* sync daemon state (master/backup) */
+	IPVS_DAEMON_ATTR_MCAST_IFN,	/* multicast interface name */
+	IPVS_DAEMON_ATTR_SYNC_ID,	/* SyncID we belong to */
+	__IPVS_DAEMON_ATTR_MAX,
+};
+
+#define IPVS_DAEMON_ATTR_MAX (__IPVS_DAEMON_ATTR_MAX - 1)
+
+/*
+ * Attributes used to describe service or destination entry statistics
+ *
+ * Used inside nested attributes IPVS_SVC_ATTR_STATS and IPVS_DEST_ATTR_STATS
+ */
+enum {
+	IPVS_STATS_ATTR_UNSPEC = 0,
+	IPVS_STATS_ATTR_CONNS,		/* connections scheduled */
+	IPVS_STATS_ATTR_INPKTS,		/* incoming packets */
+	IPVS_STATS_ATTR_OUTPKTS,	/* outgoing packets */
+	IPVS_STATS_ATTR_INBYTES,	/* incoming bytes */
+	IPVS_STATS_ATTR_OUTBYTES,	/* outgoing bytes */
+
+	IPVS_STATS_ATTR_CPS,		/* current connection rate */
+	IPVS_STATS_ATTR_INPPS,		/* current in packet rate */
+	IPVS_STATS_ATTR_OUTPPS,		/* current out packet rate */
+	IPVS_STATS_ATTR_INBPS,		/* current in byte rate */
+	IPVS_STATS_ATTR_OUTBPS,		/* current out byte rate */
+	__IPVS_STATS_ATTR_MAX,
+};
+
+#define IPVS_STATS_ATTR_MAX (__IPVS_STATS_ATTR_MAX - 1)
+
+/* Attributes used in response to IPVS_CMD_GET_INFO command */
+enum {
+	IPVS_INFO_ATTR_UNSPEC = 0,
+	IPVS_INFO_ATTR_VERSION,		/* IPVS version number */
+	IPVS_INFO_ATTR_CONN_TAB_SIZE,	/* size of connection hash table */
+	__IPVS_INFO_ATTR_MAX,
+};
+
+#define IPVS_INFO_ATTR_MAX (__IPVS_INFO_ATTR_MAX - 1)
+
+#endif	/* _IP_VS_H */
diff -uNr linux-2.6.32/usr/include/linux/ipx.h clean_modified/linux-2.6.32/usr/include/linux/ipx.h
--- linux-2.6.32/usr/include/linux/ipx.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ipx.h	2019-04-14 13:24:03.013996810 -0500
@@ -0,0 +1,75 @@
+#ifndef _IPX_H_
+#define _IPX_H_
+#include <linux/types.h>
+#include <linux/sockios.h>
+#include <linux/socket.h>
+#define IPX_NODE_LEN	6
+#define IPX_MTU		576
+
+struct sockaddr_ipx {
+	sa_family_t	sipx_family;
+	__be16		sipx_port;
+	__be32		sipx_network;
+	unsigned char 	sipx_node[IPX_NODE_LEN];
+	__u8		sipx_type;
+	unsigned char	sipx_zero;	/* 16 byte fill */
+};
+
+/*
+ * So we can fit the extra info for SIOCSIFADDR into the address nicely
+ */
+#define sipx_special	sipx_port
+#define sipx_action	sipx_zero
+#define IPX_DLTITF	0
+#define IPX_CRTITF	1
+
+struct ipx_route_definition {
+	__be32        ipx_network;
+	__be32        ipx_router_network;
+	unsigned char ipx_router_node[IPX_NODE_LEN];
+};
+
+struct ipx_interface_definition {
+	__be32        ipx_network;
+	unsigned char ipx_device[16];
+	unsigned char ipx_dlink_type;
+#define IPX_FRAME_NONE		0
+#define IPX_FRAME_SNAP		1
+#define IPX_FRAME_8022		2
+#define IPX_FRAME_ETHERII	3
+#define IPX_FRAME_8023		4
+#define IPX_FRAME_TR_8022       5 /* obsolete */
+	unsigned char ipx_special;
+#define IPX_SPECIAL_NONE	0
+#define IPX_PRIMARY		1
+#define IPX_INTERNAL		2
+	unsigned char ipx_node[IPX_NODE_LEN];
+};
+	
+struct ipx_config_data {
+	unsigned char	ipxcfg_auto_select_primary;
+	unsigned char	ipxcfg_auto_create_interfaces;
+};
+
+/*
+ * OLD Route Definition for backward compatibility.
+ */
+
+struct ipx_route_def {
+	__be32		ipx_network;
+	__be32		ipx_router_network;
+#define IPX_ROUTE_NO_ROUTER	0
+	unsigned char	ipx_router_node[IPX_NODE_LEN];
+	unsigned char	ipx_device[16];
+	unsigned short	ipx_flags;
+#define IPX_RT_SNAP		8
+#define IPX_RT_8022		4
+#define IPX_RT_BLUEBOOK		2
+#define IPX_RT_ROUTED		1
+};
+
+#define SIOCAIPXITFCRT		(SIOCPROTOPRIVATE)
+#define SIOCAIPXPRISLT		(SIOCPROTOPRIVATE + 1)
+#define SIOCIPXCFGDATA		(SIOCPROTOPRIVATE + 2)
+#define SIOCIPXNCPCONN		(SIOCPROTOPRIVATE + 3)
+#endif /* _IPX_H_ */
diff -uNr linux-2.6.32/usr/include/linux/irda.h clean_modified/linux-2.6.32/usr/include/linux/irda.h
--- linux-2.6.32/usr/include/linux/irda.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/irda.h	2019-04-14 13:24:03.013996810 -0500
@@ -0,0 +1,254 @@
+/*********************************************************************
+ *                
+ * Filename:      irda.h
+ * Version:       
+ * Description:   
+ * Status:        Experimental.
+ * Author:        Dag Brattli <dagb@cs.uit.no>
+ * Created at:    Mon Mar  8 14:06:12 1999
+ * Modified at:   Sat Dec 25 16:06:42 1999
+ * Modified by:   Dag Brattli <dagb@cs.uit.no>
+ * 
+ *     Copyright (c) 1999 Dag Brattli, All Rights Reserved.
+ *      
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version.
+ *  
+ *     Neither Dag Brattli nor University of Tromsø admit liability nor
+ *     provide warranty for any of this software. This material is 
+ *     provided "AS-IS" and at no charge.
+ *
+ ********************************************************************/
+
+#ifndef KERNEL_IRDA_H
+#define KERNEL_IRDA_H
+
+#include <linux/types.h>
+
+/* Please do *not* add any #include in this file, this file is
+ * included as-is in user space.
+ * Please fix the calling file to properly included needed files before
+ * this one, or preferably to include <net/irda/irda.h> instead.
+ * Jean II */
+
+/* Hint bit positions for first hint byte */
+#define HINT_PNP         0x01
+#define HINT_PDA         0x02
+#define HINT_COMPUTER    0x04
+#define HINT_PRINTER     0x08
+#define HINT_MODEM       0x10
+#define HINT_FAX         0x20
+#define HINT_LAN         0x40
+#define HINT_EXTENSION   0x80
+
+/* Hint bit positions for second hint byte (first extension byte) */
+#define HINT_TELEPHONY   0x01
+#define HINT_FILE_SERVER 0x02
+#define HINT_COMM        0x04
+#define HINT_MESSAGE     0x08
+#define HINT_HTTP        0x10
+#define HINT_OBEX        0x20
+
+/* IrLMP character code values */
+#define CS_ASCII         0x00
+#define	CS_ISO_8859_1    0x01
+#define	CS_ISO_8859_2    0x02
+#define	CS_ISO_8859_3    0x03
+#define	CS_ISO_8859_4    0x04
+#define	CS_ISO_8859_5    0x05
+#define	CS_ISO_8859_6    0x06
+#define	CS_ISO_8859_7    0x07
+#define	CS_ISO_8859_8    0x08
+#define	CS_ISO_8859_9    0x09
+#define CS_UNICODE       0xff
+
+/* These are the currently known dongles */
+typedef enum {
+	IRDA_TEKRAM_DONGLE       = 0,
+	IRDA_ESI_DONGLE          = 1,
+	IRDA_ACTISYS_DONGLE      = 2,
+	IRDA_ACTISYS_PLUS_DONGLE = 3,
+	IRDA_GIRBIL_DONGLE       = 4,
+	IRDA_LITELINK_DONGLE     = 5,
+	IRDA_AIRPORT_DONGLE      = 6,
+	IRDA_OLD_BELKIN_DONGLE   = 7,
+	IRDA_EP7211_IR           = 8,
+	IRDA_MCP2120_DONGLE      = 9,
+	IRDA_ACT200L_DONGLE      = 10,
+	IRDA_MA600_DONGLE        = 11,
+	IRDA_TOIM3232_DONGLE     = 12,
+	IRDA_EP7211_DONGLE       = 13,
+} IRDA_DONGLE;
+
+/* Protocol types to be used for SOCK_DGRAM */
+enum {
+	IRDAPROTO_UNITDATA = 0,
+	IRDAPROTO_ULTRA    = 1,
+	IRDAPROTO_MAX
+};
+
+#define SOL_IRLMP      266 /* Same as SOL_IRDA for now */
+#define SOL_IRTTP      266 /* Same as SOL_IRDA for now */
+
+#define IRLMP_ENUMDEVICES        1	/* Return discovery log */
+#define IRLMP_IAS_SET            2	/* Set an attribute in local IAS */
+#define IRLMP_IAS_QUERY          3	/* Query remote IAS for attribute */
+#define IRLMP_HINTS_SET          4	/* Set hint bits advertised */
+#define IRLMP_QOS_SET            5
+#define IRLMP_QOS_GET            6
+#define IRLMP_MAX_SDU_SIZE       7
+#define IRLMP_IAS_GET            8	/* Get an attribute from local IAS */
+#define IRLMP_IAS_DEL		 9	/* Remove attribute from local IAS */
+#define IRLMP_HINT_MASK_SET	10	/* Set discovery filter */
+#define IRLMP_WAITDEVICE	11	/* Wait for a new discovery */
+
+#define IRTTP_MAX_SDU_SIZE IRLMP_MAX_SDU_SIZE /* Compatibility */
+
+#define IAS_MAX_STRING         256	/* See IrLMP 1.1, 4.3.3.2 */
+#define IAS_MAX_OCTET_STRING  1024	/* See IrLMP 1.1, 4.3.3.2 */
+#define IAS_MAX_CLASSNAME       60	/* See IrLMP 1.1, 4.3.1 */
+#define IAS_MAX_ATTRIBNAME      60	/* See IrLMP 1.1, 4.3.3.1 */
+#define IAS_MAX_ATTRIBNUMBER   256	/* See IrLMP 1.1, 4.3.3.1 */
+/* For user space backward compatibility - may be fixed in kernel 2.5.X
+ * Note : need 60+1 ('\0'), make it 64 for alignement - Jean II */
+#define IAS_EXPORT_CLASSNAME       64
+#define IAS_EXPORT_ATTRIBNAME     256
+
+/* Attribute type needed for struct irda_ias_set */
+#define IAS_MISSING 0
+#define IAS_INTEGER 1
+#define IAS_OCT_SEQ 2
+#define IAS_STRING  3
+
+#define LSAP_ANY              0xff
+
+struct sockaddr_irda {
+	sa_family_t sir_family;   /* AF_IRDA */
+	__u8        sir_lsap_sel; /* LSAP selector */
+	__u32       sir_addr;     /* Device address */
+	char        sir_name[25]; /* Usually <service>:IrDA:TinyTP */
+};
+
+struct irda_device_info {
+	__u32       saddr;    /* Address of local interface */
+	__u32       daddr;    /* Address of remote device */
+	char        info[22]; /* Description */
+	__u8        charset;  /* Charset used for description */
+	__u8        hints[2]; /* Hint bits */
+};
+
+struct irda_device_list {
+       __u32 len;
+       struct irda_device_info dev[1];
+};
+
+struct irda_ias_set {
+	char irda_class_name[IAS_EXPORT_CLASSNAME];
+	char irda_attrib_name[IAS_EXPORT_ATTRIBNAME];
+	unsigned int irda_attrib_type;
+	union {
+		unsigned int irda_attrib_int;
+		struct {
+			unsigned short len;
+			__u8 octet_seq[IAS_MAX_OCTET_STRING];
+		} irda_attrib_octet_seq;
+		struct {
+			__u8 len;
+			__u8 charset;
+			__u8 string[IAS_MAX_STRING];
+		} irda_attrib_string;
+	} attribute;
+	__u32       daddr;    /* Address of device (for some queries only) */
+};
+
+/* Some private IOCTL's (max 16) */
+#define SIOCSDONGLE    (SIOCDEVPRIVATE + 0)
+#define SIOCGDONGLE    (SIOCDEVPRIVATE + 1)
+#define SIOCSBANDWIDTH (SIOCDEVPRIVATE + 2)
+#define SIOCSMEDIABUSY (SIOCDEVPRIVATE + 3)
+#define SIOCGMEDIABUSY (SIOCDEVPRIVATE + 4)
+#define SIOCGRECEIVING (SIOCDEVPRIVATE + 5)
+#define SIOCSMODE      (SIOCDEVPRIVATE + 6)
+#define SIOCGMODE      (SIOCDEVPRIVATE + 7)
+#define SIOCSDTRRTS    (SIOCDEVPRIVATE + 8)
+#define SIOCGQOS       (SIOCDEVPRIVATE + 9)
+
+/* No reason to include <linux/if.h> just because of this one ;-) */
+#define IRNAMSIZ 16 
+
+/* IrDA quality of service information (must not exceed 16 bytes) */
+struct if_irda_qos {
+	unsigned long  baudrate;
+	unsigned short data_size;
+	unsigned short window_size;
+	unsigned short min_turn_time;
+	unsigned short max_turn_time;
+	unsigned char  add_bofs;
+	unsigned char  link_disc;
+};
+
+/* For setting RTS and DTR lines of a dongle */
+struct if_irda_line {
+	__u8 dtr;
+	__u8 rts;
+};
+
+/* IrDA interface configuration (data part must not exceed 16 bytes) */
+struct if_irda_req {
+	union {
+		char ifrn_name[IRNAMSIZ];  /* if name, e.g. "irda0" */
+	} ifr_ifrn;
+	
+	/* Data part */
+	union {
+		struct if_irda_line ifru_line;
+		struct if_irda_qos  ifru_qos;
+		unsigned short      ifru_flags;
+		unsigned int        ifru_receiving;
+		unsigned int        ifru_mode;
+		unsigned int        ifru_dongle;
+	} ifr_ifru;
+};
+
+#define ifr_baudrate  ifr_ifru.ifru_qos.baudrate
+#define ifr_receiving ifr_ifru.ifru_receiving 
+#define ifr_dongle    ifr_ifru.ifru_dongle
+#define ifr_mode      ifr_ifru.ifru_mode
+#define ifr_dtr       ifr_ifru.ifru_line.dtr
+#define ifr_rts       ifr_ifru.ifru_line.rts
+
+
+/* IrDA netlink definitions */
+#define IRDA_NL_NAME "irda"
+#define IRDA_NL_VERSION 1
+
+enum irda_nl_commands {
+	IRDA_NL_CMD_UNSPEC,
+	IRDA_NL_CMD_SET_MODE,
+	IRDA_NL_CMD_GET_MODE,
+
+	__IRDA_NL_CMD_AFTER_LAST
+};
+#define IRDA_NL_CMD_MAX (__IRDA_NL_CMD_AFTER_LAST - 1)
+
+enum nl80211_attrs {
+	IRDA_NL_ATTR_UNSPEC,
+	IRDA_NL_ATTR_IFNAME,
+	IRDA_NL_ATTR_MODE,
+
+	__IRDA_NL_ATTR_AFTER_LAST
+};
+#define IRDA_NL_ATTR_MAX (__IRDA_NL_ATTR_AFTER_LAST - 1)
+
+/* IrDA modes */
+#define IRDA_MODE_PRIMARY   0x1
+#define IRDA_MODE_SECONDARY 0x2
+#define IRDA_MODE_MONITOR   0x4
+
+#endif /* KERNEL_IRDA_H */
+
+
+
+
diff -uNr linux-2.6.32/usr/include/linux/irqnr.h clean_modified/linux-2.6.32/usr/include/linux/irqnr.h
--- linux-2.6.32/usr/include/linux/irqnr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/irqnr.h	2019-04-14 13:24:03.013996810 -0500
@@ -0,0 +1,8 @@
+#ifndef _LINUX_IRQNR_H
+#define _LINUX_IRQNR_H
+
+/*
+ * Generic irq_desc iterators:
+ */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/isdn/capicmd.h clean_modified/linux-2.6.32/usr/include/linux/isdn/capicmd.h
--- linux-2.6.32/usr/include/linux/isdn/capicmd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/isdn/capicmd.h	2019-04-14 13:24:03.014974748 -0500
@@ -0,0 +1,115 @@
+/* $Id: capicmd.h,v 1.2.6.2 2001/09/23 22:24:33 kai Exp $
+ * 
+ * CAPI 2.0 Interface for Linux
+ * 
+ * Copyright 1997 by Carsten Paeth <calle@calle.de>
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef __CAPICMD_H__
+#define __CAPICMD_H__
+
+#define CAPI_MSG_BASELEN		8
+#define CAPI_DATA_B3_REQ_LEN		(CAPI_MSG_BASELEN+4+4+2+2+2)
+#define CAPI_DATA_B3_RESP_LEN		(CAPI_MSG_BASELEN+4+2)
+
+/*----- CAPI commands -----*/
+#define CAPI_ALERT		    0x01
+#define CAPI_CONNECT		    0x02
+#define CAPI_CONNECT_ACTIVE	    0x03
+#define CAPI_CONNECT_B3_ACTIVE	    0x83
+#define CAPI_CONNECT_B3 	    0x82
+#define CAPI_CONNECT_B3_T90_ACTIVE  0x88
+#define CAPI_DATA_B3		    0x86
+#define CAPI_DISCONNECT_B3	    0x84
+#define CAPI_DISCONNECT 	    0x04
+#define CAPI_FACILITY		    0x80
+#define CAPI_INFO		    0x08
+#define CAPI_LISTEN		    0x05
+#define CAPI_MANUFACTURER	    0xff
+#define CAPI_RESET_B3		    0x87
+#define CAPI_SELECT_B_PROTOCOL	    0x41
+
+/*----- CAPI subcommands -----*/
+
+#define CAPI_REQ    0x80
+#define CAPI_CONF   0x81
+#define CAPI_IND    0x82
+#define CAPI_RESP   0x83
+
+/*----- CAPI combined commands -----*/
+
+#define CAPICMD(cmd,subcmd)	(((cmd)<<8)|(subcmd))
+
+#define CAPI_DISCONNECT_REQ		CAPICMD(CAPI_DISCONNECT,CAPI_REQ)
+#define CAPI_DISCONNECT_CONF		CAPICMD(CAPI_DISCONNECT,CAPI_CONF)
+#define CAPI_DISCONNECT_IND		CAPICMD(CAPI_DISCONNECT,CAPI_IND)
+#define CAPI_DISCONNECT_RESP		CAPICMD(CAPI_DISCONNECT,CAPI_RESP)
+
+#define CAPI_ALERT_REQ			CAPICMD(CAPI_ALERT,CAPI_REQ)
+#define CAPI_ALERT_CONF			CAPICMD(CAPI_ALERT,CAPI_CONF)
+
+#define CAPI_CONNECT_REQ		CAPICMD(CAPI_CONNECT,CAPI_REQ)
+#define CAPI_CONNECT_CONF		CAPICMD(CAPI_CONNECT,CAPI_CONF)
+#define CAPI_CONNECT_IND		CAPICMD(CAPI_CONNECT,CAPI_IND)
+#define CAPI_CONNECT_RESP		CAPICMD(CAPI_CONNECT,CAPI_RESP)
+
+#define CAPI_CONNECT_ACTIVE_REQ		CAPICMD(CAPI_CONNECT_ACTIVE,CAPI_REQ)
+#define CAPI_CONNECT_ACTIVE_CONF	CAPICMD(CAPI_CONNECT_ACTIVE,CAPI_CONF)
+#define CAPI_CONNECT_ACTIVE_IND		CAPICMD(CAPI_CONNECT_ACTIVE,CAPI_IND)
+#define CAPI_CONNECT_ACTIVE_RESP	CAPICMD(CAPI_CONNECT_ACTIVE,CAPI_RESP)
+
+#define CAPI_SELECT_B_PROTOCOL_REQ	CAPICMD(CAPI_SELECT_B_PROTOCOL,CAPI_REQ)
+#define CAPI_SELECT_B_PROTOCOL_CONF	CAPICMD(CAPI_SELECT_B_PROTOCOL,CAPI_CONF)
+
+#define CAPI_CONNECT_B3_ACTIVE_REQ	CAPICMD(CAPI_CONNECT_B3_ACTIVE,CAPI_REQ)
+#define CAPI_CONNECT_B3_ACTIVE_CONF	CAPICMD(CAPI_CONNECT_B3_ACTIVE,CAPI_CONF)
+#define CAPI_CONNECT_B3_ACTIVE_IND	CAPICMD(CAPI_CONNECT_B3_ACTIVE,CAPI_IND)
+#define CAPI_CONNECT_B3_ACTIVE_RESP	CAPICMD(CAPI_CONNECT_B3_ACTIVE,CAPI_RESP)
+
+#define CAPI_CONNECT_B3_REQ		CAPICMD(CAPI_CONNECT_B3,CAPI_REQ)
+#define CAPI_CONNECT_B3_CONF		CAPICMD(CAPI_CONNECT_B3,CAPI_CONF)
+#define CAPI_CONNECT_B3_IND		CAPICMD(CAPI_CONNECT_B3,CAPI_IND)
+#define CAPI_CONNECT_B3_RESP		CAPICMD(CAPI_CONNECT_B3,CAPI_RESP)
+
+
+#define CAPI_CONNECT_B3_T90_ACTIVE_IND	CAPICMD(CAPI_CONNECT_B3_T90_ACTIVE,CAPI_IND)
+#define CAPI_CONNECT_B3_T90_ACTIVE_RESP	CAPICMD(CAPI_CONNECT_B3_T90_ACTIVE,CAPI_RESP)
+
+#define CAPI_DATA_B3_REQ		CAPICMD(CAPI_DATA_B3,CAPI_REQ)
+#define CAPI_DATA_B3_CONF		CAPICMD(CAPI_DATA_B3,CAPI_CONF)
+#define CAPI_DATA_B3_IND		CAPICMD(CAPI_DATA_B3,CAPI_IND)
+#define CAPI_DATA_B3_RESP		CAPICMD(CAPI_DATA_B3,CAPI_RESP)
+
+#define CAPI_DISCONNECT_B3_REQ		CAPICMD(CAPI_DISCONNECT_B3,CAPI_REQ)
+#define CAPI_DISCONNECT_B3_CONF		CAPICMD(CAPI_DISCONNECT_B3,CAPI_CONF)
+#define CAPI_DISCONNECT_B3_IND		CAPICMD(CAPI_DISCONNECT_B3,CAPI_IND)
+#define CAPI_DISCONNECT_B3_RESP		CAPICMD(CAPI_DISCONNECT_B3,CAPI_RESP)
+
+#define CAPI_RESET_B3_REQ		CAPICMD(CAPI_RESET_B3,CAPI_REQ)
+#define CAPI_RESET_B3_CONF		CAPICMD(CAPI_RESET_B3,CAPI_CONF)
+#define CAPI_RESET_B3_IND		CAPICMD(CAPI_RESET_B3,CAPI_IND)
+#define CAPI_RESET_B3_RESP		CAPICMD(CAPI_RESET_B3,CAPI_RESP)
+
+#define CAPI_LISTEN_REQ			CAPICMD(CAPI_LISTEN,CAPI_REQ)
+#define CAPI_LISTEN_CONF		CAPICMD(CAPI_LISTEN,CAPI_CONF)
+
+#define CAPI_MANUFACTURER_REQ		CAPICMD(CAPI_MANUFACTURER,CAPI_REQ)
+#define CAPI_MANUFACTURER_CONF		CAPICMD(CAPI_MANUFACTURER,CAPI_CONF)
+#define CAPI_MANUFACTURER_IND		CAPICMD(CAPI_MANUFACTURER,CAPI_IND)
+#define CAPI_MANUFACTURER_RESP		CAPICMD(CAPI_MANUFACTURER,CAPI_RESP)
+
+#define CAPI_FACILITY_REQ		CAPICMD(CAPI_FACILITY,CAPI_REQ)
+#define CAPI_FACILITY_CONF		CAPICMD(CAPI_FACILITY,CAPI_CONF)
+#define CAPI_FACILITY_IND		CAPICMD(CAPI_FACILITY,CAPI_IND)
+#define CAPI_FACILITY_RESP		CAPICMD(CAPI_FACILITY,CAPI_RESP)
+
+#define CAPI_INFO_REQ			CAPICMD(CAPI_INFO,CAPI_REQ)
+#define CAPI_INFO_CONF			CAPICMD(CAPI_INFO,CAPI_CONF)
+#define CAPI_INFO_IND			CAPICMD(CAPI_INFO,CAPI_IND)
+#define CAPI_INFO_RESP			CAPICMD(CAPI_INFO,CAPI_RESP)
+
+#endif				/* __CAPICMD_H__ */
diff -uNr linux-2.6.32/usr/include/linux/isdn_divertif.h clean_modified/linux-2.6.32/usr/include/linux/isdn_divertif.h
--- linux-2.6.32/usr/include/linux/isdn_divertif.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/isdn_divertif.h	2019-04-14 13:24:03.015947093 -0500
@@ -0,0 +1,26 @@
+/* $Id: isdn_divertif.h,v 1.4.6.1 2001/09/23 22:25:05 kai Exp $
+ *
+ * Header for the diversion supplementary interface for i4l.
+ *
+ * Author    Werner Cornelius (werner@titro.de)
+ * Copyright by Werner Cornelius (werner@titro.de)
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+
+/***********************************************************/
+/* magic value is also used to control version information */
+/***********************************************************/
+#define DIVERT_IF_MAGIC 0x25873401
+#define DIVERT_CMD_REG  0x00  /* register command */
+#define DIVERT_CMD_REL  0x01  /* release command */
+#define DIVERT_NO_ERR   0x00  /* return value no error */
+#define DIVERT_CMD_ERR  0x01  /* invalid cmd */
+#define DIVERT_VER_ERR  0x02  /* magic/version invalid */
+#define DIVERT_REG_ERR  0x03  /* module already registered */
+#define DIVERT_REL_ERR  0x04  /* module not registered */
+#define DIVERT_REG_NAME isdn_register_divert
+
diff -uNr linux-2.6.32/usr/include/linux/isdn.h clean_modified/linux-2.6.32/usr/include/linux/isdn.h
--- linux-2.6.32/usr/include/linux/isdn.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/isdn.h	2019-04-14 13:24:03.015947093 -0500
@@ -0,0 +1,142 @@
+/* $Id: isdn.h,v 1.125.2.3 2004/02/10 01:07:14 keil Exp $
+ *
+ * Main header for the Linux ISDN subsystem (linklevel).
+ *
+ * Copyright 1994,95,96 by Fritz Elfert (fritz@isdn4linux.de)
+ * Copyright 1995,96    by Thinking Objects Software GmbH Wuerzburg
+ * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef __ISDN_H__
+#define __ISDN_H__
+
+#include <linux/ioctl.h>
+
+#define ISDN_MAX_DRIVERS    32
+#define ISDN_MAX_CHANNELS   64
+
+/* New ioctl-codes */
+#define IIOCNETAIF  _IO('I',1)
+#define IIOCNETDIF  _IO('I',2)
+#define IIOCNETSCF  _IO('I',3)
+#define IIOCNETGCF  _IO('I',4)
+#define IIOCNETANM  _IO('I',5)
+#define IIOCNETDNM  _IO('I',6)
+#define IIOCNETGNM  _IO('I',7)
+#define IIOCGETSET  _IO('I',8) /* no longer supported */
+#define IIOCSETSET  _IO('I',9) /* no longer supported */
+#define IIOCSETVER  _IO('I',10)
+#define IIOCNETHUP  _IO('I',11)
+#define IIOCSETGST  _IO('I',12)
+#define IIOCSETBRJ  _IO('I',13)
+#define IIOCSIGPRF  _IO('I',14)
+#define IIOCGETPRF  _IO('I',15)
+#define IIOCSETPRF  _IO('I',16)
+#define IIOCGETMAP  _IO('I',17)
+#define IIOCSETMAP  _IO('I',18)
+#define IIOCNETASL  _IO('I',19)
+#define IIOCNETDIL  _IO('I',20)
+#define IIOCGETCPS  _IO('I',21)
+#define IIOCGETDVR  _IO('I',22)
+#define IIOCNETLCR  _IO('I',23) /* dwabc ioctl for LCR from isdnlog */
+#define IIOCNETDWRSET  _IO('I',24) /* dwabc ioctl to reset abc-values to default on a net-interface */
+
+#define IIOCNETALN  _IO('I',32)
+#define IIOCNETDLN  _IO('I',33)
+
+#define IIOCNETGPN  _IO('I',34)
+
+#define IIOCDBGVAR  _IO('I',127)
+
+#define IIOCDRVCTL  _IO('I',128)
+
+/* cisco hdlck device private ioctls */
+#define SIOCGKEEPPERIOD	(SIOCDEVPRIVATE + 0)
+#define SIOCSKEEPPERIOD	(SIOCDEVPRIVATE + 1)
+#define SIOCGDEBSERINT	(SIOCDEVPRIVATE + 2)
+#define SIOCSDEBSERINT	(SIOCDEVPRIVATE + 3)
+
+/* Packet encapsulations for net-interfaces */
+#define ISDN_NET_ENCAP_ETHER      0
+#define ISDN_NET_ENCAP_RAWIP      1
+#define ISDN_NET_ENCAP_IPTYP      2
+#define ISDN_NET_ENCAP_CISCOHDLC  3 /* Without SLARP and keepalive */
+#define ISDN_NET_ENCAP_SYNCPPP    4
+#define ISDN_NET_ENCAP_UIHDLC     5
+#define ISDN_NET_ENCAP_CISCOHDLCK 6 /* With SLARP and keepalive    */
+#define ISDN_NET_ENCAP_X25IFACE   7 /* Documentation/networking/x25-iface.txt*/
+#define ISDN_NET_ENCAP_MAX_ENCAP  ISDN_NET_ENCAP_X25IFACE
+
+/* Facility which currently uses an ISDN-channel */
+#define ISDN_USAGE_NONE       0
+#define ISDN_USAGE_RAW        1
+#define ISDN_USAGE_MODEM      2
+#define ISDN_USAGE_NET        3
+#define ISDN_USAGE_VOICE      4
+#define ISDN_USAGE_FAX        5
+#define ISDN_USAGE_MASK       7 /* Mask to get plain usage */
+#define ISDN_USAGE_DISABLED  32 /* This bit is set, if channel is disabled */
+#define ISDN_USAGE_EXCLUSIVE 64 /* This bit is set, if channel is exclusive */
+#define ISDN_USAGE_OUTGOING 128 /* This bit is set, if channel is outgoing  */
+
+#define ISDN_MODEM_NUMREG    24        /* Number of Modem-Registers        */
+#define ISDN_LMSNLEN         255 /* Length of tty's Listen-MSN string */
+#define ISDN_CMSGLEN	     50	 /* Length of CONNECT-Message to add for Modem */
+
+#define ISDN_MSNLEN          32
+#define NET_DV 0x06  /* Data version for isdn_net_ioctl_cfg   */
+#define TTY_DV 0x06  /* Data version for iprofd etc.          */
+
+#define INF_DV 0x01  /* Data version for /dev/isdninfo        */
+
+typedef struct {
+  char drvid[25];
+  unsigned long arg;
+} isdn_ioctl_struct;
+
+typedef struct {
+  char name[10];
+  char phone[ISDN_MSNLEN];
+  int  outgoing;
+} isdn_net_ioctl_phone;
+
+typedef struct {
+  char name[10];     /* Name of interface                     */
+  char master[10];   /* Name of Master for Bundling           */
+  char slave[10];    /* Name of Slave for Bundling            */
+  char eaz[256];     /* EAZ/MSN                               */
+  char drvid[25];    /* DriverId for Bindings                 */
+  int  onhtime;      /* Hangup-Timeout                        */
+  int  charge;       /* Charge-Units                          */
+  int  l2_proto;     /* Layer-2 protocol                      */
+  int  l3_proto;     /* Layer-3 protocol                      */
+  int  p_encap;      /* Encapsulation                         */
+  int  exclusive;    /* Channel, if bound exclusive           */
+  int  dialmax;      /* Dial Retry-Counter                    */
+  int  slavedelay;   /* Delay until slave starts up           */
+  int  cbdelay;      /* Delay before Callback                 */
+  int  chargehup;    /* Flag: Charge-Hangup                   */
+  int  ihup;         /* Flag: Hangup-Timeout on incoming line */
+  int  secure;       /* Flag: Secure                          */
+  int  callback;     /* Flag: Callback                        */
+  int  cbhup;        /* Flag: Reject Call before Callback     */
+  int  pppbind;      /* ippp device for bindings              */
+  int  chargeint;    /* Use fixed charge interval length      */
+  int  triggercps;   /* BogoCPS needed for triggering slave   */
+  int  dialtimeout;  /* Dial-Timeout                          */
+  int  dialwait;     /* Time to wait after failed dial        */
+  int  dialmode;     /* Flag: off / on / auto                 */
+} isdn_net_ioctl_cfg;
+
+#define ISDN_NET_DIALMODE_MASK  0xC0    /* bits for status                */
+#define ISDN_NET_DM_OFF	        0x00    /* this interface is stopped      */
+#define ISDN_NET_DM_MANUAL	0x40    /* this interface is on (manual)  */
+#define ISDN_NET_DM_AUTO	0x80    /* this interface is autodial     */
+#define ISDN_NET_DIALMODE(x) ((&(x))->flags & ISDN_NET_DIALMODE_MASK)
+
+
+#endif /* __ISDN_H__ */
diff -uNr linux-2.6.32/usr/include/linux/isdnif.h clean_modified/linux-2.6.32/usr/include/linux/isdnif.h
--- linux-2.6.32/usr/include/linux/isdnif.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/isdnif.h	2019-04-14 13:24:03.015947093 -0500
@@ -0,0 +1,56 @@
+/* $Id: isdnif.h,v 1.43.2.2 2004/01/12 23:08:35 keil Exp $
+ *
+ * Linux ISDN subsystem
+ * Definition of the interface between the subsystem and its low-level drivers.
+ *
+ * Copyright 1994,95,96 by Fritz Elfert (fritz@isdn4linux.de)
+ * Copyright 1995,96    Thinking Objects Software GmbH Wuerzburg
+ * 
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef __ISDNIF_H__
+#define __ISDNIF_H__
+
+
+/*
+ * Values for general protocol-selection
+ */
+#define ISDN_PTYPE_UNKNOWN   0   /* Protocol undefined   */
+#define ISDN_PTYPE_1TR6      1   /* german 1TR6-protocol */
+#define ISDN_PTYPE_EURO      2   /* EDSS1-protocol       */
+#define ISDN_PTYPE_LEASED    3   /* for leased lines     */
+#define ISDN_PTYPE_NI1       4   /* US NI-1 protocol     */
+#define ISDN_PTYPE_MAX       7   /* Max. 8 Protocols     */
+
+/*
+ * Values for Layer-2-protocol-selection
+ */
+#define ISDN_PROTO_L2_X75I   0   /* X75/LAPB with I-Frames            */
+#define ISDN_PROTO_L2_X75UI  1   /* X75/LAPB with UI-Frames           */
+#define ISDN_PROTO_L2_X75BUI 2   /* X75/LAPB with UI-Frames           */
+#define ISDN_PROTO_L2_HDLC   3   /* HDLC                              */
+#define ISDN_PROTO_L2_TRANS  4   /* Transparent (Voice)               */
+#define ISDN_PROTO_L2_X25DTE 5   /* X25/LAPB DTE mode                 */
+#define ISDN_PROTO_L2_X25DCE 6   /* X25/LAPB DCE mode                 */
+#define ISDN_PROTO_L2_V11096 7   /* V.110 bitrate adaption 9600 Baud  */
+#define ISDN_PROTO_L2_V11019 8   /* V.110 bitrate adaption 19200 Baud */
+#define ISDN_PROTO_L2_V11038 9   /* V.110 bitrate adaption 38400 Baud */
+#define ISDN_PROTO_L2_MODEM  10  /* Analog Modem on Board */
+#define ISDN_PROTO_L2_FAX    11  /* Fax Group 2/3         */
+#define ISDN_PROTO_L2_HDLC_56K 12   /* HDLC 56k                          */
+#define ISDN_PROTO_L2_MAX    15  /* Max. 16 Protocols                 */
+
+/*
+ * Values for Layer-3-protocol-selection
+ */
+#define ISDN_PROTO_L3_TRANS	0	/* Transparent */
+#define ISDN_PROTO_L3_TRANSDSP	1	/* Transparent with DSP */
+#define ISDN_PROTO_L3_FCLASS2	2	/* Fax Group 2/3 CLASS 2 */
+#define ISDN_PROTO_L3_FCLASS1	3	/* Fax Group 2/3 CLASS 1 */
+#define ISDN_PROTO_L3_MAX	7	/* Max. 8 Protocols */
+
+
+#endif /* __ISDNIF_H__ */
diff -uNr linux-2.6.32/usr/include/linux/isdn_ppp.h clean_modified/linux-2.6.32/usr/include/linux/isdn_ppp.h
--- linux-2.6.32/usr/include/linux/isdn_ppp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/isdn_ppp.h	2019-04-14 13:24:03.017049217 -0500
@@ -0,0 +1,67 @@
+/* Linux ISDN subsystem, sync PPP, interface to ipppd
+ *
+ * Copyright 1994-1999  by Fritz Elfert (fritz@isdn4linux.de)
+ * Copyright 1995,96    Thinking Objects Software GmbH Wuerzburg
+ * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)
+ * Copyright 2000-2002  by Kai Germaschewski (kai@germaschewski.name)
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef _LINUX_ISDN_PPP_H
+#define _LINUX_ISDN_PPP_H
+
+#define CALLTYPE_INCOMING 0x1
+#define CALLTYPE_OUTGOING 0x2
+#define CALLTYPE_CALLBACK 0x4
+
+#define IPPP_VERSION    "2.2.0"
+
+struct pppcallinfo
+{
+  int calltype;
+  unsigned char local_num[64];
+  unsigned char remote_num[64];
+  int charge_units;
+};
+
+#define PPPIOCGCALLINFO _IOWR('t',128,struct pppcallinfo)
+#define PPPIOCBUNDLE   _IOW('t',129,int)
+#define PPPIOCGMPFLAGS _IOR('t',130,int)
+#define PPPIOCSMPFLAGS _IOW('t',131,int)
+#define PPPIOCSMPMTU   _IOW('t',132,int)
+#define PPPIOCSMPMRU   _IOW('t',133,int)
+#define PPPIOCGCOMPRESSORS _IOR('t',134,unsigned long [8])
+#define PPPIOCSCOMPRESSOR _IOW('t',135,int)
+#define PPPIOCGIFNAME      _IOR('t',136, char [IFNAMSIZ] )
+
+
+#define SC_MP_PROT       0x00000200
+#define SC_REJ_MP_PROT   0x00000400
+#define SC_OUT_SHORT_SEQ 0x00000800
+#define SC_IN_SHORT_SEQ  0x00004000
+
+#define SC_DECOMP_ON		0x01
+#define SC_COMP_ON		0x02
+#define SC_DECOMP_DISCARD	0x04
+#define SC_COMP_DISCARD		0x08
+#define SC_LINK_DECOMP_ON	0x10
+#define SC_LINK_COMP_ON		0x20
+#define SC_LINK_DECOMP_DISCARD	0x40
+#define SC_LINK_COMP_DISCARD	0x80
+
+#define ISDN_PPP_COMP_MAX_OPTIONS 16
+
+#define IPPP_COMP_FLAG_XMIT 0x1
+#define IPPP_COMP_FLAG_LINK 0x2
+
+struct isdn_ppp_comp_data {
+  int num;
+  unsigned char options[ISDN_PPP_COMP_MAX_OPTIONS];
+  int optlen;
+  int flags;
+};
+
+#endif /* _LINUX_ISDN_PPP_H */
diff -uNr linux-2.6.32/usr/include/linux/iso_fs.h clean_modified/linux-2.6.32/usr/include/linux/iso_fs.h
--- linux-2.6.32/usr/include/linux/iso_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/iso_fs.h	2019-04-14 13:24:03.017874268 -0500
@@ -0,0 +1,165 @@
+#ifndef _ISOFS_FS_H
+#define _ISOFS_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/*
+ * The isofs filesystem constants/structures
+ */
+
+/* This part borrowed from the bsd386 isofs */
+#define ISODCL(from, to) (to - from + 1)
+
+struct iso_volume_descriptor {
+	char type[ISODCL(1,1)]; /* 711 */
+	char id[ISODCL(2,6)];
+	char version[ISODCL(7,7)];
+	char data[ISODCL(8,2048)];
+};
+
+/* volume descriptor types */
+#define ISO_VD_PRIMARY 1
+#define ISO_VD_SUPPLEMENTARY 2
+#define ISO_VD_END 255
+
+#define ISO_STANDARD_ID "CD001"
+
+struct iso_primary_descriptor {
+	char type			[ISODCL (  1,   1)]; /* 711 */
+	char id				[ISODCL (  2,   6)];
+	char version			[ISODCL (  7,   7)]; /* 711 */
+	char unused1			[ISODCL (  8,   8)];
+	char system_id			[ISODCL (  9,  40)]; /* achars */
+	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
+	char unused2			[ISODCL ( 73,  80)];
+	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	char unused3			[ISODCL ( 89, 120)];
+	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	char path_table_size		[ISODCL (133, 140)]; /* 733 */
+	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
+	char publisher_id		[ISODCL (319, 446)]; /* achars */
+	char preparer_id		[ISODCL (447, 574)]; /* achars */
+	char application_id		[ISODCL (575, 702)]; /* achars */
+	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
+	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
+	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
+	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	char unused4			[ISODCL (883, 883)];
+	char application_data		[ISODCL (884, 1395)];
+	char unused5			[ISODCL (1396, 2048)];
+};
+
+/* Almost the same as the primary descriptor but two fields are specified */
+struct iso_supplementary_descriptor {
+	char type			[ISODCL (  1,   1)]; /* 711 */
+	char id				[ISODCL (  2,   6)];
+	char version			[ISODCL (  7,   7)]; /* 711 */
+	char flags			[ISODCL (  8,   8)]; /* 853 */
+	char system_id			[ISODCL (  9,  40)]; /* achars */
+	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
+	char unused2			[ISODCL ( 73,  80)];
+	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	char escape			[ISODCL ( 89, 120)]; /* 856 */
+	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	char path_table_size		[ISODCL (133, 140)]; /* 733 */
+	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
+	char publisher_id		[ISODCL (319, 446)]; /* achars */
+	char preparer_id		[ISODCL (447, 574)]; /* achars */
+	char application_id		[ISODCL (575, 702)]; /* achars */
+	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
+	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
+	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
+	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	char unused4			[ISODCL (883, 883)];
+	char application_data		[ISODCL (884, 1395)];
+	char unused5			[ISODCL (1396, 2048)];
+};
+
+
+#define HS_STANDARD_ID "CDROM"
+
+struct  hs_volume_descriptor {
+	char foo			[ISODCL (  1,   8)]; /* 733 */
+	char type			[ISODCL (  9,   9)]; /* 711 */
+	char id				[ISODCL ( 10,  14)];
+	char version			[ISODCL ( 15,  15)]; /* 711 */
+	char data[ISODCL(16,2048)];
+};
+
+
+struct hs_primary_descriptor {
+	char foo			[ISODCL (  1,   8)]; /* 733 */
+	char type			[ISODCL (  9,   9)]; /* 711 */
+	char id				[ISODCL ( 10,  14)];
+	char version			[ISODCL ( 15,  15)]; /* 711 */
+	char unused1			[ISODCL ( 16,  16)]; /* 711 */
+	char system_id			[ISODCL ( 17,  48)]; /* achars */
+	char volume_id			[ISODCL ( 49,  80)]; /* dchars */
+	char unused2			[ISODCL ( 81,  88)]; /* 733 */
+	char volume_space_size		[ISODCL ( 89,  96)]; /* 733 */
+	char unused3			[ISODCL ( 97, 128)]; /* 733 */
+	char volume_set_size		[ISODCL (129, 132)]; /* 723 */
+	char volume_sequence_number	[ISODCL (133, 136)]; /* 723 */
+	char logical_block_size		[ISODCL (137, 140)]; /* 723 */
+	char path_table_size		[ISODCL (141, 148)]; /* 733 */
+	char type_l_path_table		[ISODCL (149, 152)]; /* 731 */
+	char unused4			[ISODCL (153, 180)]; /* 733 */
+	char root_directory_record	[ISODCL (181, 214)]; /* 9.1 */
+};
+
+/* We use this to help us look up the parent inode numbers. */
+
+struct iso_path_table{
+	unsigned char  name_len[2];	/* 721 */
+	char extent[4];		/* 731 */
+	char  parent[2];	/* 721 */
+	char name[0];
+} __attribute__((packed));
+
+/* high sierra is identical to iso, except that the date is only 6 bytes, and
+   there is an extra reserved byte after the flags */
+
+struct iso_directory_record {
+	char length			[ISODCL (1, 1)]; /* 711 */
+	char ext_attr_length		[ISODCL (2, 2)]; /* 711 */
+	char extent			[ISODCL (3, 10)]; /* 733 */
+	char size			[ISODCL (11, 18)]; /* 733 */
+	char date			[ISODCL (19, 25)]; /* 7 by 711 */
+	char flags			[ISODCL (26, 26)];
+	char file_unit_size		[ISODCL (27, 27)]; /* 711 */
+	char interleave			[ISODCL (28, 28)]; /* 711 */
+	char volume_sequence_number	[ISODCL (29, 32)]; /* 723 */
+	unsigned char name_len		[ISODCL (33, 33)]; /* 711 */
+	char name			[0];
+} __attribute__((packed));
+
+#define ISOFS_BLOCK_BITS 11
+#define ISOFS_BLOCK_SIZE 2048
+
+#define ISOFS_BUFFER_SIZE(INODE) ((INODE)->i_sb->s_blocksize)
+#define ISOFS_BUFFER_BITS(INODE) ((INODE)->i_sb->s_blocksize_bits)
+
+#endif /* _ISOFS_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/ivtvfb.h clean_modified/linux-2.6.32/usr/include/linux/ivtvfb.h
--- linux-2.6.32/usr/include/linux/ivtvfb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ivtvfb.h	2019-04-14 13:24:03.017874268 -0500
@@ -0,0 +1,38 @@
+/*
+    On Screen Display cx23415 Framebuffer driver
+
+    Copyright (C) 2006, 2007  Ian Armstrong <ian@iarmst.demon.co.uk>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_IVTVFB_H__
+#define __LINUX_IVTVFB_H__
+
+
+#include <linux/types.h>
+
+/* Framebuffer external API */
+
+struct ivtvfb_dma_frame {
+	void *source;
+	unsigned long dest_offset;
+	int count;
+};
+
+#define IVTVFB_IOC_DMA_FRAME 	_IOW('V', BASE_VIDIOC_PRIVATE+0, struct ivtvfb_dma_frame)
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ivtv.h clean_modified/linux-2.6.32/usr/include/linux/ivtv.h
--- linux-2.6.32/usr/include/linux/ivtv.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ivtv.h	2019-04-14 13:24:03.017874268 -0500
@@ -0,0 +1,69 @@
+/*
+    Public ivtv API header
+    Copyright (C) 2003-2004  Kevin Thayer <nufan_wfk at yahoo.com>
+    Copyright (C) 2004-2007  Hans Verkuil <hverkuil@xs4all.nl>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_IVTV_H__
+#define __LINUX_IVTV_H__
+
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+/* ivtv knows several distinct output modes: MPEG streaming,
+   YUV streaming, YUV updates through user DMA and the passthrough
+   mode.
+
+   In order to clearly tell the driver that we are in user DMA
+   YUV mode you need to call IVTV_IOC_DMA_FRAME with y_source == NULL
+   first (althrough if you don't then the first time
+   DMA_FRAME is called the mode switch is done automatically).
+
+   When you close the file handle the user DMA mode is exited again.
+
+   While in one mode, you cannot use another mode (EBUSY is returned).
+
+   All this means that if you want to change the YUV interlacing
+   for the user DMA YUV mode you first need to do call IVTV_IOC_DMA_FRAME
+   with y_source == NULL before you can set the correct format using
+   VIDIOC_S_FMT.
+
+   Eventually all this should be replaced with a proper V4L2 API,
+   but for now we have to do it this way. */
+
+struct ivtv_dma_frame {
+	enum v4l2_buf_type type; /* V4L2_BUF_TYPE_VIDEO_OUTPUT */
+	__u32 pixelformat;	 /* 0 == same as destination */
+	void *y_source;   /* if NULL and type == V4L2_BUF_TYPE_VIDEO_OUTPUT,
+				    then just switch to user DMA YUV output mode */
+	void *uv_source;  /* Unused for RGB pixelformats */
+	struct v4l2_rect src;
+	struct v4l2_rect dst;
+	__u32 src_width;
+	__u32 src_height;
+};
+
+#define IVTV_IOC_DMA_FRAME  _IOW ('V', BASE_VIDIOC_PRIVATE+0, struct ivtv_dma_frame)
+
+/* Deprecated defines: applications should use the defines from videodev2.h */
+#define IVTV_SLICED_TYPE_TELETEXT_B     V4L2_MPEG_VBI_IVTV_TELETEXT_B
+#define IVTV_SLICED_TYPE_CAPTION_525    V4L2_MPEG_VBI_IVTV_CAPTION_525
+#define IVTV_SLICED_TYPE_WSS_625        V4L2_MPEG_VBI_IVTV_WSS_625
+#define IVTV_SLICED_TYPE_VPS            V4L2_MPEG_VBI_IVTV_VPS
+
+#endif /* _LINUX_IVTV_H */
diff -uNr linux-2.6.32/usr/include/linux/ixjuser.h clean_modified/linux-2.6.32/usr/include/linux/ixjuser.h
--- linux-2.6.32/usr/include/linux/ixjuser.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ixjuser.h	2019-04-14 13:24:03.019844075 -0500
@@ -0,0 +1,720 @@
+#ifndef __LINUX_IXJUSER_H
+#define __LINUX_IXJUSER_H
+
+/******************************************************************************
+ *
+ *    ixjuser.h
+ *
+ * Device Driver for Quicknet Technologies, Inc.'s Telephony cards
+ * including the Internet PhoneJACK, Internet PhoneJACK Lite,
+ * Internet PhoneJACK PCI, Internet LineJACK, Internet PhoneCARD and
+ * SmartCABLE
+ *
+ *    (c) Copyright 1999-2001  Quicknet Technologies, Inc.
+ *
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License
+ *    as published by the Free Software Foundation; either version
+ *    2 of the License, or (at your option) any later version.
+ *
+ * Author:          Ed Okerson, <eokerson@quicknet.net>
+ *    
+ * Contributors:    Greg Herlein, <gherlein@quicknet.net>
+ *                  David W. Erhart, <derhart@quicknet.net>
+ *                  John Sellers, <jsellers@quicknet.net>
+ *                  Mike Preston, <mpreston@quicknet.net>
+ *
+ * More information about the hardware related to this driver can be found
+ * at our website:    http://www.quicknet.net
+ *
+ * Fixes:
+ *
+ * IN NO EVENT SHALL QUICKNET TECHNOLOGIES, INC. BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
+ * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF QUICKNET
+ * TECHNOLOGIES, INC.HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * QUICKNET TECHNOLOGIES, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND QUICKNET TECHNOLOGIES, INC. HAS NO OBLIGATION 
+ * TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ *****************************************************************************/
+
+#include <linux/telephony.h>
+
+
+/******************************************************************************
+*
+* IOCTL's used for the Quicknet Telephony Cards
+*
+* If you use the IXJCTL_TESTRAM command, the card must be power cycled to
+* reset the SRAM values before futher use.
+*
+******************************************************************************/
+
+#define IXJCTL_DSP_RESET 		_IO  ('q', 0xC0)
+
+#define IXJCTL_RING                     PHONE_RING
+#define IXJCTL_HOOKSTATE                PHONE_HOOKSTATE
+#define IXJCTL_MAXRINGS			PHONE_MAXRINGS
+#define IXJCTL_RING_CADENCE		PHONE_RING_CADENCE
+#define IXJCTL_RING_START		PHONE_RING_START
+#define IXJCTL_RING_STOP		PHONE_RING_STOP
+
+#define IXJCTL_CARDTYPE			_IOR ('q', 0xC1, int)
+#define IXJCTL_SERIAL			_IOR ('q', 0xC2, int)
+#define IXJCTL_DSP_TYPE                 _IOR ('q', 0xC3, int)
+#define IXJCTL_DSP_VERSION              _IOR ('q', 0xC4, int)
+#define IXJCTL_VERSION              	_IOR ('q', 0xDA, char *)
+#define IXJCTL_DSP_IDLE			_IO  ('q', 0xC5)
+#define IXJCTL_TESTRAM			_IO  ('q', 0xC6)
+
+/******************************************************************************
+*
+* This group of IOCTLs deal with the record settings of the DSP
+*
+* The IXJCTL_REC_DEPTH command sets the internal buffer depth of the DSP.
+* Setting a lower depth reduces latency, but increases the demand of the
+* application to service the driver without frame loss.  The DSP has 480
+* bytes of physical buffer memory for the record channel so the true
+* maximum limit is determined by how many frames will fit in the buffer.
+*
+* 1 uncompressed (480 byte) 16-bit linear frame.
+* 2 uncompressed (240 byte) 8-bit A-law/mu-law frames.
+* 15 TrueSpeech 8.5 frames.
+* 20 TrueSpeech 6.3,5.3,4.8 or 4.1 frames.
+*
+* The default in the driver is currently set to 2 frames.
+*
+* The IXJCTL_REC_VOLUME and IXJCTL_PLAY_VOLUME commands both use a Q8
+* number as a parameter, 0x100 scales the signal by 1.0, 0x200 scales the
+* signal by 2.0, 0x80 scales the signal by 0.5.  No protection is given
+* against over-scaling, if the multiplication factor times the input
+* signal exceeds 16 bits, overflow distortion will occur.  The default
+* setting is 0x100 (1.0).
+*
+* The IXJCTL_REC_LEVEL returns the average signal level (not r.m.s.) on
+* the most recently recorded frame as a 16 bit value.
+******************************************************************************/
+
+#define IXJCTL_REC_CODEC                PHONE_REC_CODEC
+#define IXJCTL_REC_START                PHONE_REC_START
+#define IXJCTL_REC_STOP                 PHONE_REC_STOP
+#define IXJCTL_REC_DEPTH		PHONE_REC_DEPTH
+#define IXJCTL_FRAME			PHONE_FRAME
+#define IXJCTL_REC_VOLUME		PHONE_REC_VOLUME
+#define IXJCTL_REC_LEVEL		PHONE_REC_LEVEL
+
+typedef enum {
+	f300_640 = 4, f300_500, f1100, f350, f400, f480, f440, f620, f20_50,
+	f133_200, f300, f300_420, f330, f300_425, f330_440, f340, f350_400,
+	f350_440, f350_450, f360, f380_420, f392, f400_425, f400_440, f400_450,
+	f420, f425, f425_450, f425_475, f435, f440_450, f440_480, f445, f450,
+	f452, f475, f480_620, f494, f500, f520, f523, f525, f540_660, f587,
+	f590, f600, f660, f700, f740, f750, f750_1450, f770, f800, f816, f850,
+	f857_1645, f900, f900_1300, f935_1215, f941_1477, f942, f950, f950_1400,
+	f975, f1000, f1020, f1050, f1100_1750, f1140, f1200, f1209, f1330, f1336,
+	lf1366, f1380, f1400, f1477, f1600, f1633_1638, f1800, f1860
+} IXJ_FILTER_FREQ;
+
+typedef struct {
+	unsigned int filter;
+	IXJ_FILTER_FREQ freq;
+	char enable;
+} IXJ_FILTER;
+
+typedef struct {
+	char enable;
+	char en_filter;
+	unsigned int filter;
+	unsigned int on1;
+	unsigned int off1;
+	unsigned int on2;
+	unsigned int off2;
+	unsigned int on3;
+	unsigned int off3;
+} IXJ_FILTER_CADENCE;
+
+#define IXJCTL_SET_FILTER		_IOW ('q', 0xC7, IXJ_FILTER *)
+#define IXJCTL_SET_FILTER_RAW		_IOW ('q', 0xDD, IXJ_FILTER_RAW *)
+#define IXJCTL_GET_FILTER_HIST		_IOW ('q', 0xC8, int)
+#define IXJCTL_FILTER_CADENCE		_IOW ('q', 0xD6, IXJ_FILTER_CADENCE *)
+#define IXJCTL_PLAY_CID			_IO  ('q', 0xD7)
+/******************************************************************************
+*
+* This IOCTL allows you to reassign values in the tone index table.  The
+* tone table has 32 entries (0 - 31), but the driver only allows entries
+* 13 - 27 to be modified, entry 0 is reserved for silence and 1 - 12 are
+* the standard DTMF digits and 28 - 31 are the DTMF tones for A, B, C & D.
+* The positions used internally for Call Progress Tones are as follows:
+*    Dial Tone   - 25
+*    Ring Back   - 26
+*    Busy Signal - 27
+*
+* The freq values are calculated as:
+* freq = cos(2 * PI * frequency / 8000)
+*
+* The most commonly needed values are already calculated and listed in the
+* enum IXJ_TONE_FREQ.  Each tone index can have two frequencies with
+* different gains, if you are only using a single frequency set the unused
+* one to 0.
+*
+* The gain values range from 0 to 15 indicating +6dB to -24dB in 2dB
+* increments.
+*
+******************************************************************************/
+
+typedef enum {
+	hz20 = 0x7ffa,
+	hz50 = 0x7fe5,
+	hz133 = 0x7f4c,
+	hz200 = 0x7e6b,
+	hz261 = 0x7d50,		/* .63 C1  */
+	hz277 = 0x7cfa,		/* .18 CS1 */
+	hz293 = 0x7c9f,		/* .66 D1  */
+	hz300 = 0x7c75,
+	hz311 = 0x7c32,		/* .13 DS1 */
+	hz329 = 0x7bbf,		/* .63 E1  */
+	hz330 = 0x7bb8,
+	hz340 = 0x7b75,
+	hz349 = 0x7b37,		/* .23 F1  */
+	hz350 = 0x7b30,
+	hz360 = 0x7ae9,
+	hz369 = 0x7aa8,		/* .99 FS1 */
+	hz380 = 0x7a56,
+	hz392 = 0x79fa,		/* .00 G1  */
+	hz400 = 0x79bb,
+	hz415 = 0x7941,		/* .30 GS1 */
+	hz420 = 0x7918,
+	hz425 = 0x78ee,
+	hz435 = 0x7899,
+	hz440 = 0x786d,		/* .00 A1  */
+	hz445 = 0x7842,
+	hz450 = 0x7815,
+	hz452 = 0x7803,
+	hz466 = 0x7784,		/* .16 AS1 */
+	hz475 = 0x7731,
+	hz480 = 0x7701,
+	hz493 = 0x7685,		/* .88 B1  */
+	hz494 = 0x767b,
+	hz500 = 0x7640,
+	hz520 = 0x7578,
+	hz523 = 0x7559,		/* .25 C2  */
+	hz525 = 0x7544,
+	hz540 = 0x74a7,
+	hz554 = 0x7411,		/* .37 CS2 */
+	hz587 = 0x72a1,		/* .33 D2  */
+	hz590 = 0x727f,
+	hz600 = 0x720b,
+	hz620 = 0x711e,
+	hz622 = 0x7106,		/* .25 DS2 */
+	hz659 = 0x6f3b,		/* .26 E2  */
+	hz660 = 0x6f2e,
+	hz698 = 0x6d3d,		/* .46 F2  */
+	hz700 = 0x6d22,
+	hz739 = 0x6b09,		/* .99 FS2 */
+	hz740 = 0x6afa,
+	hz750 = 0x6a6c,
+	hz770 = 0x694b,
+	hz783 = 0x688b,		/* .99 G2  */
+	hz800 = 0x678d,
+	hz816 = 0x6698,
+	hz830 = 0x65bf,		/* .61 GS2 */
+	hz850 = 0x6484,
+	hz857 = 0x6414,
+	hz880 = 0x629f,		/* .00 A2  */
+	hz900 = 0x6154,
+	hz932 = 0x5f35,		/* .33 AS2 */
+	hz935 = 0x5f01,
+	hz941 = 0x5e9a,
+	hz942 = 0x5e88,
+	hz950 = 0x5dfd,
+	hz975 = 0x5c44,
+	hz1000 = 0x5a81,
+	hz1020 = 0x5912,
+	hz1050 = 0x56e2,
+	hz1100 = 0x5320,
+	hz1140 = 0x5007,
+	hz1200 = 0x4b3b,
+	hz1209 = 0x4a80,
+	hz1215 = 0x4a02,
+	hz1250 = 0x471c,
+	hz1300 = 0x42e0,
+	hz1330 = 0x4049,
+	hz1336 = 0x3fc4,
+	hz1366 = 0x3d22,
+	hz1380 = 0x3be4,
+	hz1400 = 0x3a1b,
+	hz1450 = 0x3596,
+	hz1477 = 0x331c,
+	hz1500 = 0x30fb,
+	hz1600 = 0x278d,
+	hz1633 = 0x2462,
+	hz1638 = 0x23e7,
+	hz1645 = 0x233a,
+	hz1750 = 0x18f8,
+	hz1800 = 0x1405,
+	hz1860 = 0xe0b,
+	hz2100 = 0xf5f6,
+	hz2130 = 0xf2f5,
+	hz2450 = 0xd3b3,
+	hz2750 = 0xb8e4
+} IXJ_FREQ;
+
+typedef enum {
+	C1 = hz261,
+	CS1 = hz277,
+	D1 = hz293,
+	DS1 = hz311,
+	E1 = hz329,
+	F1 = hz349,
+	FS1 = hz369,
+	G1 = hz392,
+	GS1 = hz415,
+	A1 = hz440,
+	AS1 = hz466,
+	B1 = hz493,
+	C2 = hz523,
+	CS2 = hz554,
+	D2 = hz587,
+	DS2 = hz622,
+	E2 = hz659,
+	F2 = hz698,
+	FS2 = hz739,
+	G2 = hz783,
+	GS2 = hz830,
+	A2 = hz880,
+	AS2 = hz932,
+} IXJ_NOTE;
+
+typedef struct {
+	int tone_index;
+	int freq0;
+	int gain0;
+	int freq1;
+	int gain1;
+} IXJ_TONE;
+
+#define IXJCTL_INIT_TONE		_IOW ('q', 0xC9, IXJ_TONE *)
+
+/******************************************************************************
+*
+* The IXJCTL_TONE_CADENCE ioctl defines tone sequences used for various
+* Call Progress Tones (CPT).  This is accomplished by setting up an array of
+* IXJ_CADENCE_ELEMENT structures that sequentially define the states of
+* the tone sequence.  The tone_on_time and tone_off time are in
+* 250 microsecond intervals.  A pointer to this array is passed to the
+* driver as the ce element of an IXJ_CADENCE structure.  The elements_used
+* must be set to the number of IXJ_CADENCE_ELEMENTS in the array.  The
+* termination variable defines what to do at the end of a cadence, the
+* options are to play the cadence once and stop, to repeat the last
+* element of the cadence indefinitely, or to repeat the entire cadence
+* indefinitely.  The ce variable is a pointer to the array of IXJ_TONE
+* structures.  If the freq0 variable is non-zero, the tone table contents
+* for the tone_index are updated to the frequencies and gains defined.  It
+* should be noted that DTMF tones cannot be reassigned, so if DTMF tone
+* table indexes are used in a cadence the frequency and gain variables will
+* be ignored.
+*
+* If the array elements contain frequency parameters the driver will
+* initialize the needed tone table elements and begin playing the tone,
+* there is no preset limit on the number of elements in the cadence.  If
+* there is more than one frequency used in the cadence, sequential elements
+* of different frequencies MUST use different tone table indexes.  Only one
+* cadence can be played at a time.  It is possible to build complex
+* cadences with multiple frequencies using 2 tone table indexes by
+* alternating between them.
+*
+******************************************************************************/
+
+typedef struct {
+	int index;
+	int tone_on_time;
+	int tone_off_time;
+	int freq0;
+	int gain0;
+	int freq1;
+	int gain1;
+} IXJ_CADENCE_ELEMENT;
+
+typedef enum {
+	PLAY_ONCE,
+	REPEAT_LAST_ELEMENT,
+	REPEAT_ALL
+} IXJ_CADENCE_TERM;
+
+typedef struct {
+	int elements_used;
+	IXJ_CADENCE_TERM termination;
+	IXJ_CADENCE_ELEMENT *ce;
+} IXJ_CADENCE;
+
+#define IXJCTL_TONE_CADENCE		_IOW ('q', 0xCA, IXJ_CADENCE *)
+/******************************************************************************
+*
+* This group of IOCTLs deal with the playback settings of the DSP
+*
+******************************************************************************/
+
+#define IXJCTL_PLAY_CODEC               PHONE_PLAY_CODEC
+#define IXJCTL_PLAY_START               PHONE_PLAY_START
+#define IXJCTL_PLAY_STOP                PHONE_PLAY_STOP
+#define IXJCTL_PLAY_DEPTH		PHONE_PLAY_DEPTH
+#define IXJCTL_PLAY_VOLUME		PHONE_PLAY_VOLUME
+#define IXJCTL_PLAY_LEVEL		PHONE_PLAY_LEVEL
+
+/******************************************************************************
+*
+* This group of IOCTLs deal with the Acoustic Echo Cancellation settings
+* of the DSP
+*
+* Issuing the IXJCTL_AEC_START command with a value of AEC_OFF has the
+* same effect as IXJCTL_AEC_STOP.  This is to simplify slider bar
+* controls.  IXJCTL_AEC_GET_LEVEL returns the current setting of the AEC.
+******************************************************************************/
+#define IXJCTL_AEC_START		_IOW ('q', 0xCB, int)
+#define IXJCTL_AEC_STOP			_IO  ('q', 0xCC)
+#define IXJCTL_AEC_GET_LEVEL		_IO  ('q', 0xCD)
+
+#define AEC_OFF   0
+#define AEC_LOW   1
+#define AEC_MED   2
+#define AEC_HIGH  3
+#define AEC_AUTO  4
+#define AEC_AGC   5
+/******************************************************************************
+*
+* Call Progress Tones, DTMF, etc.
+* IXJCTL_DTMF_OOB determines if DTMF signaling is sent as Out-Of-Band
+* only.  If you pass a 1, DTMF is suppressed from the audio stream.
+* Tone on and off times are in 250 microsecond intervals so
+* ioctl(ixj1, IXJCTL_SET_TONE_ON_TIME, 360);
+* will set the tone on time of board ixj1 to 360 * 250us = 90ms
+* the default values of tone on and off times is 840 or 210ms
+******************************************************************************/
+
+#define IXJCTL_DTMF_READY		PHONE_DTMF_READY
+#define IXJCTL_GET_DTMF                 PHONE_GET_DTMF
+#define IXJCTL_GET_DTMF_ASCII           PHONE_GET_DTMF_ASCII
+#define IXJCTL_DTMF_OOB			PHONE_DTMF_OOB
+#define IXJCTL_EXCEPTION		PHONE_EXCEPTION
+#define IXJCTL_PLAY_TONE		PHONE_PLAY_TONE
+#define IXJCTL_SET_TONE_ON_TIME		PHONE_SET_TONE_ON_TIME
+#define IXJCTL_SET_TONE_OFF_TIME	PHONE_SET_TONE_OFF_TIME
+#define IXJCTL_GET_TONE_ON_TIME		PHONE_GET_TONE_ON_TIME
+#define IXJCTL_GET_TONE_OFF_TIME	PHONE_GET_TONE_OFF_TIME
+#define IXJCTL_GET_TONE_STATE		PHONE_GET_TONE_STATE
+#define IXJCTL_BUSY			PHONE_BUSY
+#define IXJCTL_RINGBACK			PHONE_RINGBACK
+#define IXJCTL_DIALTONE			PHONE_DIALTONE
+#define IXJCTL_CPT_STOP			PHONE_CPT_STOP
+
+/******************************************************************************
+* LineJACK specific IOCTLs
+*
+* The lsb 4 bits of the LED argument represent the state of each of the 4
+* LED's on the LineJACK
+******************************************************************************/
+
+#define IXJCTL_SET_LED			_IOW ('q', 0xCE, int)
+#define IXJCTL_MIXER			_IOW ('q', 0xCF, int)
+
+/******************************************************************************
+* 
+* The master volume controls use attenuation with 32 levels from 0 to -62dB
+* with steps of 2dB each, the defines should be OR'ed together then sent
+* as the parameter to the mixer command to change the mixer settings.
+* 
+******************************************************************************/
+#define MIXER_MASTER_L		0x0000
+#define MIXER_MASTER_R		0x0100
+#define ATT00DB			0x00
+#define ATT02DB			0x01
+#define ATT04DB			0x02
+#define ATT06DB			0x03
+#define ATT08DB			0x04
+#define ATT10DB			0x05
+#define ATT12DB			0x06
+#define ATT14DB			0x07
+#define ATT16DB			0x08
+#define ATT18DB			0x09
+#define ATT20DB			0x0A
+#define ATT22DB			0x0B
+#define ATT24DB			0x0C
+#define ATT26DB			0x0D
+#define ATT28DB			0x0E
+#define ATT30DB			0x0F
+#define ATT32DB			0x10
+#define ATT34DB			0x11
+#define ATT36DB			0x12
+#define ATT38DB			0x13
+#define ATT40DB			0x14
+#define ATT42DB			0x15
+#define ATT44DB			0x16
+#define ATT46DB			0x17
+#define ATT48DB			0x18
+#define ATT50DB			0x19
+#define ATT52DB			0x1A
+#define ATT54DB			0x1B
+#define ATT56DB			0x1C
+#define ATT58DB			0x1D
+#define ATT60DB			0x1E
+#define ATT62DB			0x1F
+#define MASTER_MUTE		0x80
+
+/******************************************************************************
+* 
+* The input volume controls use gain with 32 levels from +12dB to -50dB
+* with steps of 2dB each, the defines should be OR'ed together then sent
+* as the parameter to the mixer command to change the mixer settings.
+* 
+******************************************************************************/
+#define MIXER_PORT_CD_L		0x0600
+#define MIXER_PORT_CD_R		0x0700
+#define MIXER_PORT_LINE_IN_L	0x0800
+#define MIXER_PORT_LINE_IN_R	0x0900
+#define MIXER_PORT_POTS_REC	0x0C00
+#define MIXER_PORT_MIC		0x0E00
+
+#define GAIN12DB		0x00
+#define GAIN10DB		0x01
+#define GAIN08DB		0x02
+#define GAIN06DB		0x03
+#define GAIN04DB		0x04
+#define GAIN02DB		0x05
+#define GAIN00DB		0x06
+#define GAIN_02DB		0x07
+#define GAIN_04DB		0x08
+#define GAIN_06DB		0x09
+#define GAIN_08DB		0x0A
+#define GAIN_10DB		0x0B
+#define GAIN_12DB		0x0C
+#define GAIN_14DB		0x0D
+#define GAIN_16DB		0x0E
+#define GAIN_18DB		0x0F
+#define GAIN_20DB		0x10
+#define GAIN_22DB		0x11
+#define GAIN_24DB		0x12
+#define GAIN_26DB		0x13
+#define GAIN_28DB		0x14
+#define GAIN_30DB		0x15
+#define GAIN_32DB		0x16
+#define GAIN_34DB		0x17
+#define GAIN_36DB		0x18
+#define GAIN_38DB		0x19
+#define GAIN_40DB		0x1A
+#define GAIN_42DB		0x1B
+#define GAIN_44DB		0x1C
+#define GAIN_46DB		0x1D
+#define GAIN_48DB		0x1E
+#define GAIN_50DB		0x1F
+#define INPUT_MUTE		0x80
+
+/******************************************************************************
+* 
+* The POTS volume control use attenuation with 8 levels from 0dB to -28dB
+* with steps of 4dB each, the defines should be OR'ed together then sent
+* as the parameter to the mixer command to change the mixer settings.
+* 
+******************************************************************************/
+#define MIXER_PORT_POTS_PLAY	0x0F00
+
+#define POTS_ATT_00DB		0x00
+#define POTS_ATT_04DB		0x01
+#define POTS_ATT_08DB		0x02
+#define POTS_ATT_12DB		0x03
+#define POTS_ATT_16DB		0x04
+#define POTS_ATT_20DB		0x05
+#define POTS_ATT_24DB		0x06
+#define POTS_ATT_28DB		0x07
+#define POTS_MUTE		0x80
+
+/******************************************************************************
+* 
+* The DAA controls the interface to the PSTN port.  The driver loads the
+* US coefficients by default, so if you live in a different country you
+* need to load the set for your countries phone system.
+* 
+******************************************************************************/
+#define IXJCTL_DAA_COEFF_SET		_IOW ('q', 0xD0, int)
+
+#define DAA_US 		1	/*PITA 8kHz */
+#define DAA_UK 		2	/*ISAR34 8kHz */
+#define DAA_FRANCE 	3	/* */
+#define DAA_GERMANY	4
+#define DAA_AUSTRALIA	5
+#define DAA_JAPAN	6
+
+/******************************************************************************
+* 
+* Use IXJCTL_PORT to set or query the port the card is set to.  If the
+* argument is set to PORT_QUERY, the return value of the ioctl will
+* indicate which port is currently in use, otherwise it will change the
+* port.
+* 
+******************************************************************************/
+#define IXJCTL_PORT			_IOW ('q', 0xD1, int)
+
+#define PORT_QUERY	0
+#define PORT_POTS	1
+#define PORT_PSTN	2
+#define PORT_SPEAKER	3
+#define PORT_HANDSET	4
+
+#define IXJCTL_PSTN_SET_STATE		PHONE_PSTN_SET_STATE
+#define IXJCTL_PSTN_GET_STATE		PHONE_PSTN_GET_STATE
+
+#define PSTN_ON_HOOK	0
+#define PSTN_RINGING	1
+#define PSTN_OFF_HOOK	2
+#define PSTN_PULSE_DIAL	3
+
+/******************************************************************************
+* 
+* The DAA Analog GAIN sets 2 parameters at one time, the receive gain (AGRR), 
+* and the transmit gain (AGX).  OR together the components and pass them
+* as the parameter to IXJCTL_DAA_AGAIN.  The default setting is both at 0dB.
+* 
+******************************************************************************/
+#define IXJCTL_DAA_AGAIN		_IOW ('q', 0xD2, int)
+
+#define AGRR00DB	0x00	/* Analog gain in receive direction 0dB */
+#define AGRR3_5DB	0x10	/* Analog gain in receive direction 3.5dB */
+#define AGRR06DB	0x30	/* Analog gain in receive direction 6dB */
+
+#define AGX00DB		0x00	/* Analog gain in transmit direction 0dB */
+#define AGX_6DB		0x04	/* Analog gain in transmit direction -6dB */
+#define AGX3_5DB	0x08	/* Analog gain in transmit direction 3.5dB */
+#define AGX_2_5B	0x0C	/* Analog gain in transmit direction -2.5dB */
+
+#define IXJCTL_PSTN_LINETEST		_IO  ('q', 0xD3)
+
+#define IXJCTL_CID			_IOR ('q', 0xD4, PHONE_CID *)
+#define IXJCTL_VMWI			_IOR ('q', 0xD8, int)
+#define IXJCTL_CIDCW			_IOW ('q', 0xD9, PHONE_CID *)
+/******************************************************************************
+* 
+* The wink duration is tunable with this ioctl.  The default wink duration  
+* is 320ms.  You do not need to use this ioctl if you do not require a
+* different wink duration.
+* 
+******************************************************************************/
+#define IXJCTL_WINK_DURATION		PHONE_WINK_DURATION
+
+/******************************************************************************
+* 
+* This ioctl will connect the POTS port to the PSTN port on the LineJACK
+* In order for this to work properly the port selection should be set to
+* the PSTN port with IXJCTL_PORT prior to calling this ioctl.  This will
+* enable conference calls between PSTN callers and network callers.
+* Passing a 1 to this ioctl enables the POTS<->PSTN connection while
+* passing a 0 turns it back off.
+* 
+******************************************************************************/
+#define IXJCTL_POTS_PSTN		_IOW ('q', 0xD5, int)
+
+/******************************************************************************
+*
+* IOCTLs added by request.
+*
+* IXJCTL_HZ sets the value your Linux kernel uses for HZ as defined in
+*           /usr/include/asm/param.h, this determines the fundamental
+*           frequency of the clock ticks on your Linux system.  The kernel
+*           must be rebuilt if you change this value, also all modules you
+*           use (except this one) must be recompiled.  The default value
+*           is 100, and you only need to use this IOCTL if you use some
+*           other value.
+*
+*
+* IXJCTL_RATE sets the number of times per second that the driver polls
+*             the DSP.  This value cannot be larger than HZ.  By
+*             increasing both of these values, you may be able to reduce
+*             latency because the max hang time that can exist between the
+*             driver and the DSP will be reduced.
+*
+******************************************************************************/
+
+#define IXJCTL_HZ                       _IOW ('q', 0xE0, int)
+#define IXJCTL_RATE                     _IOW ('q', 0xE1, int)
+#define IXJCTL_FRAMES_READ		_IOR ('q', 0xE2, unsigned long)
+#define IXJCTL_FRAMES_WRITTEN		_IOR ('q', 0xE3, unsigned long)
+#define IXJCTL_READ_WAIT		_IOR ('q', 0xE4, unsigned long)
+#define IXJCTL_WRITE_WAIT		_IOR ('q', 0xE5, unsigned long)
+#define IXJCTL_DRYBUFFER_READ		_IOR ('q', 0xE6, unsigned long)
+#define IXJCTL_DRYBUFFER_CLEAR		_IO  ('q', 0xE7)
+#define IXJCTL_DTMF_PRESCALE		_IOW ('q', 0xE8, int)
+
+/******************************************************************************
+*
+* This ioctl allows the user application to control what events the driver
+* will send signals for, and what signals it will send for which event.
+* By default, if signaling is enabled, all events will send SIGIO when
+* they occur.  To disable signals for an event set the signal to 0.
+*
+******************************************************************************/
+typedef enum {
+	SIG_DTMF_READY,
+	SIG_HOOKSTATE,
+	SIG_FLASH,
+	SIG_PSTN_RING,
+	SIG_CALLER_ID,
+	SIG_PSTN_WINK,
+	SIG_F0, SIG_F1, SIG_F2, SIG_F3,
+	SIG_FC0, SIG_FC1, SIG_FC2, SIG_FC3,
+	SIG_READ_READY = 33,
+	SIG_WRITE_READY = 34
+} IXJ_SIGEVENT;
+
+typedef struct {
+	unsigned int event;
+	int signal;
+} IXJ_SIGDEF;
+
+#define IXJCTL_SIGCTL			_IOW ('q', 0xE9, IXJ_SIGDEF *)
+
+/******************************************************************************
+*
+* These ioctls allow the user application to change the gain in the 
+* Smart Cable of the Internet Phone Card.  Sending -1 as a value will cause
+* return value to be the current setting.  Valid values to set are 0x00 - 0x1F
+*
+* 11111 = +12 dB
+* 10111 =   0 dB
+* 00000 = -34.5 dB
+*
+* IXJCTL_SC_RXG sets the Receive gain
+* IXJCTL_SC_TXG sets the Transmit gain
+*
+******************************************************************************/
+#define IXJCTL_SC_RXG			_IOW ('q', 0xEA, int)
+#define IXJCTL_SC_TXG			_IOW ('q', 0xEB, int)
+
+/******************************************************************************
+*
+* The intercom IOCTL's short the output from one card to the input of the
+* other and vice versa (actually done in the DSP read function).  It is only
+* necessary to execute the IOCTL on one card, but it is necessary to have
+* both devices open to be able to detect hook switch changes.  The record
+* codec and rate of each card must match the playback codec and rate of
+* the other card for this to work properly.
+*
+******************************************************************************/
+
+#define IXJCTL_INTERCOM_START 		_IOW ('q', 0xFD, int)
+#define IXJCTL_INTERCOM_STOP  		_IOW ('q', 0xFE, int)
+
+/******************************************************************************
+ *
+ * new structure for accessing raw filter information
+ *
+ ******************************************************************************/
+
+typedef struct {
+	unsigned int filter;
+	char enable;
+	unsigned int coeff[19];
+} IXJ_FILTER_RAW;
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/jffs2.h clean_modified/linux-2.6.32/usr/include/linux/jffs2.h
--- linux-2.6.32/usr/include/linux/jffs2.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/jffs2.h	2019-04-14 13:24:03.021906001 -0500
@@ -0,0 +1,222 @@
+/*
+ * JFFS2 -- Journalling Flash File System, Version 2.
+ *
+ * Copyright (C) 2001-2003 Red Hat, Inc.
+ *
+ * Created by David Woodhouse <dwmw2@infradead.org>
+ *
+ * For licensing information, see the file 'LICENCE' in the
+ * jffs2 directory.
+ */
+
+#ifndef __LINUX_JFFS2_H__
+#define __LINUX_JFFS2_H__
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/* You must include something which defines the C99 uintXX_t types. 
+   We don't do it from here because this file is used in too many
+   different environments. */
+
+/* Values we may expect to find in the 'magic' field */
+#define JFFS2_OLD_MAGIC_BITMASK 0x1984
+#define JFFS2_MAGIC_BITMASK 0x1985
+#define KSAMTIB_CIGAM_2SFFJ 0x8519 /* For detecting wrong-endian fs */
+#define JFFS2_EMPTY_BITMASK 0xffff
+#define JFFS2_DIRTY_BITMASK 0x0000
+
+/* Summary node MAGIC marker */
+#define JFFS2_SUM_MAGIC	0x02851885
+
+/* We only allow a single char for length, and 0xFF is empty flash so
+   we don't want it confused with a real length. Hence max 254.
+*/
+#define JFFS2_MAX_NAME_LEN 254
+
+/* How small can we sensibly write nodes? */
+#define JFFS2_MIN_DATA_LEN 128
+
+#define JFFS2_COMPR_NONE	0x00
+#define JFFS2_COMPR_ZERO	0x01
+#define JFFS2_COMPR_RTIME	0x02
+#define JFFS2_COMPR_RUBINMIPS	0x03
+#define JFFS2_COMPR_COPY	0x04
+#define JFFS2_COMPR_DYNRUBIN	0x05
+#define JFFS2_COMPR_ZLIB	0x06
+#define JFFS2_COMPR_LZO		0x07
+/* Compatibility flags. */
+#define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+#define JFFS2_NODE_ACCURATE 0x2000
+/* INCOMPAT: Fail to mount the filesystem */
+#define JFFS2_FEATURE_INCOMPAT 0xc000
+/* ROCOMPAT: Mount read-only */
+#define JFFS2_FEATURE_ROCOMPAT 0x8000
+/* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_COPY 0x4000
+/* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */
+#define JFFS2_FEATURE_RWCOMPAT_DELETE 0x0000
+
+#define JFFS2_NODETYPE_DIRENT (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1)
+#define JFFS2_NODETYPE_INODE (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2)
+#define JFFS2_NODETYPE_CLEANMARKER (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+#define JFFS2_NODETYPE_PADDING (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4)
+
+#define JFFS2_NODETYPE_SUMMARY (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6)
+
+#define JFFS2_NODETYPE_XATTR (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 8)
+#define JFFS2_NODETYPE_XREF (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 9)
+
+/* XATTR Related */
+#define JFFS2_XPREFIX_USER		1	/* for "user." */
+#define JFFS2_XPREFIX_SECURITY		2	/* for "security." */
+#define JFFS2_XPREFIX_ACL_ACCESS	3	/* for "system.posix_acl_access" */
+#define JFFS2_XPREFIX_ACL_DEFAULT	4	/* for "system.posix_acl_default" */
+#define JFFS2_XPREFIX_TRUSTED		5	/* for "trusted.*" */
+
+#define JFFS2_ACL_VERSION		0x0001
+
+// Maybe later...
+//#define JFFS2_NODETYPE_CHECKPOINT (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)
+//#define JFFS2_NODETYPE_OPTIONS (JFFS2_FEATURE_RWCOMPAT_COPY | JFFS2_NODE_ACCURATE | 4)
+
+
+#define JFFS2_INO_FLAG_PREREAD	  1	/* Do read_inode() for this one at
+					   mount time, don't wait for it to
+					   happen later */
+#define JFFS2_INO_FLAG_USERCOMPR  2	/* User has requested a specific
+					   compression type */
+
+
+/* These can go once we've made sure we've caught all uses without
+   byteswapping */
+
+typedef struct {
+	__u32 v32;
+} __attribute__((packed)) jint32_t;
+
+typedef struct {
+	__u32 m;
+} __attribute__((packed)) jmode_t;
+
+typedef struct {
+	__u16 v16;
+} __attribute__((packed)) jint16_t;
+
+struct jffs2_unknown_node
+{
+	/* All start like this */
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen; /* So we can skip over nodes we don't grok */
+	jint32_t hdr_crc;
+};
+
+struct jffs2_raw_dirent
+{
+	jint16_t magic;
+	jint16_t nodetype;	/* == JFFS2_NODETYPE_DIRENT */
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t pino;
+	jint32_t version;
+	jint32_t ino; /* == zero for unlink */
+	jint32_t mctime;
+	__u8 nsize;
+	__u8 type;
+	__u8 unused[2];
+	jint32_t node_crc;
+	jint32_t name_crc;
+	__u8 name[0];
+};
+
+/* The JFFS2 raw inode structure: Used for storage on physical media.  */
+/* The uid, gid, atime, mtime and ctime members could be longer, but
+   are left like this for space efficiency. If and when people decide
+   they really need them extended, it's simple enough to add support for
+   a new type of raw node.
+*/
+struct jffs2_raw_inode
+{
+	jint16_t magic;      /* A constant magic number.  */
+	jint16_t nodetype;   /* == JFFS2_NODETYPE_INODE */
+	jint32_t totlen;     /* Total length of this node (inc data, etc.) */
+	jint32_t hdr_crc;
+	jint32_t ino;        /* Inode number.  */
+	jint32_t version;    /* Version number.  */
+	jmode_t mode;       /* The file's type or mode.  */
+	jint16_t uid;        /* The file's owner.  */
+	jint16_t gid;        /* The file's group.  */
+	jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */
+	jint32_t atime;      /* Last access time.  */
+	jint32_t mtime;      /* Last modification time.  */
+	jint32_t ctime;      /* Change time.  */
+	jint32_t offset;     /* Where to begin to write.  */
+	jint32_t csize;      /* (Compressed) data size */
+	jint32_t dsize;	     /* Size of the node's data. (after decompression) */
+	__u8 compr;       /* Compression algorithm used */
+	__u8 usercompr;   /* Compression algorithm requested by the user */
+	jint16_t flags;	     /* See JFFS2_INO_FLAG_* */
+	jint32_t data_crc;   /* CRC for the (compressed) data.  */
+	jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */
+	__u8 data[0];
+};
+
+struct jffs2_raw_xattr {
+	jint16_t magic;
+	jint16_t nodetype;	/* = JFFS2_NODETYPE_XATTR */
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t xid;		/* XATTR identifier number */
+	jint32_t version;
+	__u8 xprefix;
+	__u8 name_len;
+	jint16_t value_len;
+	jint32_t data_crc;
+	jint32_t node_crc;
+	__u8 data[0];
+} __attribute__((packed));
+
+struct jffs2_raw_xref
+{
+	jint16_t magic;
+	jint16_t nodetype;	/* = JFFS2_NODETYPE_XREF */
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t ino;		/* inode number */
+	jint32_t xid;		/* XATTR identifier number */
+	jint32_t xseqno;	/* xref sequencial number */
+	jint32_t node_crc;
+} __attribute__((packed));
+
+struct jffs2_raw_summary
+{
+	jint16_t magic;
+	jint16_t nodetype; 	/* = JFFS2_NODETYPE_SUMMARY */
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t sum_num;	/* number of sum entries*/
+	jint32_t cln_mkr;	/* clean marker size, 0 = no cleanmarker */
+	jint32_t padded;	/* sum of the size of padding nodes */
+	jint32_t sum_crc;	/* summary information crc */
+	jint32_t node_crc; 	/* node crc */
+	jint32_t sum[0]; 	/* inode summary info */
+};
+
+union jffs2_node_union
+{
+	struct jffs2_raw_inode i;
+	struct jffs2_raw_dirent d;
+	struct jffs2_raw_xattr x;
+	struct jffs2_raw_xref r;
+	struct jffs2_raw_summary s;
+	struct jffs2_unknown_node u;
+};
+
+/* Data payload for device nodes. */
+union jffs2_device_node {
+	jint16_t old;
+	jint32_t new;
+};
+
+#endif /* __LINUX_JFFS2_H__ */
diff -uNr linux-2.6.32/usr/include/linux/joystick.h clean_modified/linux-2.6.32/usr/include/linux/joystick.h
--- linux-2.6.32/usr/include/linux/joystick.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/joystick.h	2019-04-14 13:24:03.021906001 -0500
@@ -0,0 +1,136 @@
+#ifndef _LINUX_JOYSTICK_H
+#define _LINUX_JOYSTICK_H
+
+/*
+ *  Copyright (C) 1996-2000 Vojtech Pavlik
+ *
+ *  Sponsored by SuSE
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+/*
+ * Version
+ */
+
+#define JS_VERSION		0x020100
+
+/*
+ * Types and constants for reading from /dev/js
+ */
+
+#define JS_EVENT_BUTTON		0x01	/* button pressed/released */
+#define JS_EVENT_AXIS		0x02	/* joystick moved */
+#define JS_EVENT_INIT		0x80	/* initial state of device */
+
+struct js_event {
+	__u32 time;	/* event timestamp in milliseconds */
+	__s16 value;	/* value */
+	__u8 type;	/* event type */
+	__u8 number;	/* axis/button number */
+};
+
+/*
+ * IOCTL commands for joystick driver
+ */
+
+#define JSIOCGVERSION		_IOR('j', 0x01, __u32)				/* get driver version */
+
+#define JSIOCGAXES		_IOR('j', 0x11, __u8)				/* get number of axes */
+#define JSIOCGBUTTONS		_IOR('j', 0x12, __u8)				/* get number of buttons */
+#define JSIOCGNAME(len)		_IOC(_IOC_READ, 'j', 0x13, len)			/* get identifier string */
+
+#define JSIOCSCORR		_IOW('j', 0x21, struct js_corr)			/* set correction values */
+#define JSIOCGCORR		_IOR('j', 0x22, struct js_corr)			/* get correction values */
+
+#define JSIOCSAXMAP		_IOW('j', 0x31, __u8[ABS_MAX + 1])		/* set axis mapping */
+#define JSIOCGAXMAP		_IOR('j', 0x32, __u8[ABS_MAX + 1])		/* get axis mapping */
+#define JSIOCSBTNMAP		_IOW('j', 0x33, __u16[KEY_MAX - BTN_MISC + 1])	/* set button mapping */
+#define JSIOCGBTNMAP		_IOR('j', 0x34, __u16[KEY_MAX - BTN_MISC + 1])	/* get button mapping */
+
+/*
+ * Types and constants for get/set correction
+ */
+
+#define JS_CORR_NONE		0x00	/* returns raw values */
+#define JS_CORR_BROKEN		0x01	/* broken line */
+
+struct js_corr {
+	__s32 coef[8];
+	__s16 prec;
+	__u16 type;
+};
+
+/*
+ * v0.x compatibility definitions
+ */
+
+#define JS_RETURN		sizeof(struct JS_DATA_TYPE)
+#define JS_TRUE			1
+#define JS_FALSE		0
+#define JS_X_0			0x01
+#define JS_Y_0			0x02
+#define JS_X_1			0x04
+#define JS_Y_1			0x08
+#define JS_MAX			2
+
+#define JS_DEF_TIMEOUT		0x1300
+#define JS_DEF_CORR		0
+#define JS_DEF_TIMELIMIT	10L
+
+#define JS_SET_CAL		1
+#define JS_GET_CAL		2
+#define JS_SET_TIMEOUT		3
+#define JS_GET_TIMEOUT		4
+#define JS_SET_TIMELIMIT	5
+#define JS_GET_TIMELIMIT	6
+#define JS_GET_ALL		7
+#define JS_SET_ALL		8
+
+struct JS_DATA_TYPE {
+	__s32 buttons;
+	__s32 x;
+	__s32 y;
+};
+
+struct JS_DATA_SAVE_TYPE_32 {
+	__s32 JS_TIMEOUT;
+	__s32 BUSY;
+	__s32 JS_EXPIRETIME;
+	__s32 JS_TIMELIMIT;
+	struct JS_DATA_TYPE JS_SAVE;
+	struct JS_DATA_TYPE JS_CORR;
+};
+
+struct JS_DATA_SAVE_TYPE_64 {
+	__s32 JS_TIMEOUT;
+	__s32 BUSY;
+	__s64 JS_EXPIRETIME;
+	__s64 JS_TIMELIMIT;
+	struct JS_DATA_TYPE JS_SAVE;
+	struct JS_DATA_TYPE JS_CORR;
+};
+
+
+#endif /* _LINUX_JOYSTICK_H */
diff -uNr linux-2.6.32/usr/include/linux/kdev_t.h clean_modified/linux-2.6.32/usr/include/linux/kdev_t.h
--- linux-2.6.32/usr/include/linux/kdev_t.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kdev_t.h	2019-04-14 13:24:03.021906001 -0500
@@ -0,0 +1,11 @@
+#ifndef _LINUX_KDEV_T_H
+#define _LINUX_KDEV_T_H
+
+/*
+Some programs want their definitions of MAJOR and MINOR and MKDEV
+from the kernel sources. These must be the externally visible ones.
+*/
+#define MAJOR(dev)	((dev)>>8)
+#define MINOR(dev)	((dev) & 0xff)
+#define MKDEV(ma,mi)	((ma)<<8 | (mi))
+#endif
diff -uNr linux-2.6.32/usr/include/linux/kd.h clean_modified/linux-2.6.32/usr/include/linux/kd.h
--- linux-2.6.32/usr/include/linux/kd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kd.h	2019-04-14 13:24:03.021906001 -0500
@@ -0,0 +1,182 @@
+#ifndef _LINUX_KD_H
+#define _LINUX_KD_H
+#include <linux/types.h>
+
+
+/* 0x4B is 'K', to avoid collision with termios and vt */
+
+#define GIO_FONT	0x4B60	/* gets font in expanded form */
+#define PIO_FONT	0x4B61	/* use font in expanded form */
+
+#define GIO_FONTX	0x4B6B	/* get font using struct consolefontdesc */
+#define PIO_FONTX	0x4B6C	/* set font using struct consolefontdesc */
+struct consolefontdesc {
+	unsigned short charcount;	/* characters in font (256 or 512) */
+	unsigned short charheight;	/* scan lines per character (1-32) */
+	char *chardata;		/* font data in expanded form */
+};
+
+#define PIO_FONTRESET   0x4B6D	/* reset to default font */
+
+#define GIO_CMAP	0x4B70	/* gets colour palette on VGA+ */
+#define PIO_CMAP	0x4B71	/* sets colour palette on VGA+ */
+
+#define KIOCSOUND	0x4B2F	/* start sound generation (0 for off) */
+#define KDMKTONE	0x4B30	/* generate tone */
+
+#define KDGETLED	0x4B31	/* return current led state */
+#define KDSETLED	0x4B32	/* set led state [lights, not flags] */
+#define 	LED_SCR		0x01	/* scroll lock led */
+#define 	LED_NUM		0x02	/* num lock led */
+#define 	LED_CAP		0x04	/* caps lock led */
+
+#define KDGKBTYPE	0x4B33	/* get keyboard type */
+#define 	KB_84		0x01
+#define 	KB_101		0x02 	/* this is what we always answer */
+#define 	KB_OTHER	0x03
+
+#define KDADDIO		0x4B34	/* add i/o port as valid */
+#define KDDELIO		0x4B35	/* del i/o port as valid */
+#define KDENABIO	0x4B36	/* enable i/o to video board */
+#define KDDISABIO	0x4B37	/* disable i/o to video board */
+
+#define KDSETMODE	0x4B3A	/* set text/graphics mode */
+#define		KD_TEXT		0x00
+#define		KD_GRAPHICS	0x01
+#define		KD_TEXT0	0x02	/* obsolete */
+#define		KD_TEXT1	0x03	/* obsolete */
+#define KDGETMODE	0x4B3B	/* get current mode */
+
+#define KDMAPDISP	0x4B3C	/* map display into address space */
+#define KDUNMAPDISP	0x4B3D	/* unmap display from address space */
+
+typedef char scrnmap_t;
+#define		E_TABSZ		256
+#define GIO_SCRNMAP	0x4B40	/* get screen mapping from kernel */
+#define PIO_SCRNMAP	0x4B41	/* put screen mapping table in kernel */
+#define GIO_UNISCRNMAP  0x4B69	/* get full Unicode screen mapping */
+#define PIO_UNISCRNMAP  0x4B6A  /* set full Unicode screen mapping */
+
+#define GIO_UNIMAP	0x4B66	/* get unicode-to-font mapping from kernel */
+struct unipair {
+	unsigned short unicode;
+	unsigned short fontpos;
+};
+struct unimapdesc {
+	unsigned short entry_ct;
+	struct unipair *entries;
+};
+#define PIO_UNIMAP	0x4B67	/* put unicode-to-font mapping in kernel */
+#define PIO_UNIMAPCLR	0x4B68	/* clear table, possibly advise hash algorithm */
+struct unimapinit {
+	unsigned short advised_hashsize;  /* 0 if no opinion */
+	unsigned short advised_hashstep;  /* 0 if no opinion */
+	unsigned short advised_hashlevel; /* 0 if no opinion */
+};
+
+#define UNI_DIRECT_BASE 0xF000	/* start of Direct Font Region */
+#define UNI_DIRECT_MASK 0x01FF	/* Direct Font Region bitmask */
+
+#define		K_RAW		0x00
+#define		K_XLATE		0x01
+#define		K_MEDIUMRAW	0x02
+#define		K_UNICODE	0x03
+#define KDGKBMODE	0x4B44	/* gets current keyboard mode */
+#define KDSKBMODE	0x4B45	/* sets current keyboard mode */
+
+#define		K_METABIT	0x03
+#define		K_ESCPREFIX	0x04
+#define KDGKBMETA	0x4B62	/* gets meta key handling mode */
+#define KDSKBMETA	0x4B63	/* sets meta key handling mode */
+
+#define		K_SCROLLLOCK	0x01
+#define		K_NUMLOCK	0x02
+#define		K_CAPSLOCK	0x04
+#define	KDGKBLED	0x4B64	/* get led flags (not lights) */
+#define	KDSKBLED	0x4B65	/* set led flags (not lights) */
+
+struct kbentry {
+	unsigned char kb_table;
+	unsigned char kb_index;
+	unsigned short kb_value;
+};
+#define		K_NORMTAB	0x00
+#define		K_SHIFTTAB	0x01
+#define		K_ALTTAB	0x02
+#define		K_ALTSHIFTTAB	0x03
+
+#define KDGKBENT	0x4B46	/* gets one entry in translation table */
+#define KDSKBENT	0x4B47	/* sets one entry in translation table */
+
+struct kbsentry {
+	unsigned char kb_func;
+	unsigned char kb_string[512];
+};
+#define KDGKBSENT	0x4B48	/* gets one function key string entry */
+#define KDSKBSENT	0x4B49	/* sets one function key string entry */
+
+struct kbdiacr {
+        unsigned char diacr, base, result;
+};
+struct kbdiacrs {
+        unsigned int kb_cnt;    /* number of entries in following array */
+	struct kbdiacr kbdiacr[256];    /* MAX_DIACR from keyboard.h */
+};
+#define KDGKBDIACR      0x4B4A  /* read kernel accent table */
+#define KDSKBDIACR      0x4B4B  /* write kernel accent table */
+
+struct kbdiacruc {
+	unsigned int diacr, base, result;
+};
+struct kbdiacrsuc {
+        unsigned int kb_cnt;    /* number of entries in following array */
+	struct kbdiacruc kbdiacruc[256];    /* MAX_DIACR from keyboard.h */
+};
+#define KDGKBDIACRUC    0x4BFA  /* read kernel accent table - UCS */
+#define KDSKBDIACRUC    0x4BFB  /* write kernel accent table - UCS */
+
+struct kbkeycode {
+	unsigned int scancode, keycode;
+};
+#define KDGETKEYCODE	0x4B4C	/* read kernel keycode table entry */
+#define KDSETKEYCODE	0x4B4D	/* write kernel keycode table entry */
+
+#define KDSIGACCEPT	0x4B4E	/* accept kbd generated signals */
+
+struct kbd_repeat {
+	int delay;	/* in msec; <= 0: don't change */
+	int period;	/* in msec; <= 0: don't change */
+			/* earlier this field was misnamed "rate" */
+};
+
+#define KDKBDREP        0x4B52  /* set keyboard delay/repeat rate;
+				 * actually used values are returned */
+
+#define KDFONTOP	0x4B72	/* font operations */
+
+struct console_font_op {
+	unsigned int op;	/* operation code KD_FONT_OP_* */
+	unsigned int flags;	/* KD_FONT_FLAG_* */
+	unsigned int width, height;	/* font size */
+	unsigned int charcount;
+	unsigned char *data;	/* font data with height fixed to 32 */
+};
+
+struct console_font {
+	unsigned int width, height;	/* font size */
+	unsigned int charcount;
+	unsigned char *data;	/* font data with height fixed to 32 */
+};
+
+#define KD_FONT_OP_SET		0	/* Set font */
+#define KD_FONT_OP_GET		1	/* Get font */
+#define KD_FONT_OP_SET_DEFAULT	2	/* Set font to default, data points to name / NULL */
+#define KD_FONT_OP_COPY		3	/* Copy from another console */
+
+#define KD_FONT_FLAG_DONT_RECALC 	1	/* Don't recalculate hw charcell size [compat] */
+
+/* note: 0x4B00-0x4B4E all have had a value at some time;
+   don't reuse for the time being */
+/* note: 0x4B60-0x4B6D, 0x4B70-0x4B72 used above */
+
+#endif /* _LINUX_KD_H */
diff -uNr linux-2.6.32/usr/include/linux/kernelcapi.h clean_modified/linux-2.6.32/usr/include/linux/kernelcapi.h
--- linux-2.6.32/usr/include/linux/kernelcapi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kernelcapi.h	2019-04-14 13:24:03.023719195 -0500
@@ -0,0 +1,47 @@
+/*
+ * $Id: kernelcapi.h,v 1.8.6.2 2001/02/07 11:31:31 kai Exp $
+ * 
+ * Kernel CAPI 2.0 Interface for Linux
+ * 
+ * (c) Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
+ * 
+ */
+
+#ifndef __KERNELCAPI_H__
+#define __KERNELCAPI_H__
+
+#define CAPI_MAXAPPL	240	/* maximum number of applications  */
+#define CAPI_MAXCONTR	32	/* maximum number of controller    */
+#define CAPI_MAXDATAWINDOW	8
+
+
+typedef struct kcapi_flagdef {
+	int contr;
+	int flag;
+} kcapi_flagdef;
+
+typedef struct kcapi_carddef {
+	char		driver[32];
+	unsigned int	port;
+	unsigned	irq;
+	unsigned int	membase;
+	int		cardnr;
+} kcapi_carddef;
+
+/* new ioctls >= 10 */
+#define KCAPI_CMD_TRACE		10
+#define KCAPI_CMD_ADDCARD	11	/* OBSOLETE */
+
+/* 
+ * flag > 2 => trace also data
+ * flag & 1 => show trace
+ */
+#define KCAPI_TRACE_OFF			0
+#define KCAPI_TRACE_SHORT_NO_DATA	1
+#define KCAPI_TRACE_FULL_NO_DATA	2
+#define KCAPI_TRACE_SHORT		3
+#define KCAPI_TRACE_FULL		4
+
+
+
+#endif				/* __KERNELCAPI_H__ */
diff -uNr linux-2.6.32/usr/include/linux/kernel.h clean_modified/linux-2.6.32/usr/include/linux/kernel.h
--- linux-2.6.32/usr/include/linux/kernel.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kernel.h	2019-04-14 13:24:03.023719195 -0500
@@ -0,0 +1,56 @@
+#ifndef _LINUX_KERNEL_H
+#define _LINUX_KERNEL_H
+
+/*
+ * 'kernel.h' contains some often-used function prototypes etc
+ */
+
+
+
+#define SI_LOAD_SHIFT	16
+struct sysinfo {
+	long uptime;			/* Seconds since boot */
+	unsigned long loads[3];		/* 1, 5, and 15 minute load averages */
+	unsigned long totalram;		/* Total usable main memory size */
+	unsigned long freeram;		/* Available memory size */
+	unsigned long sharedram;	/* Amount of shared memory */
+	unsigned long bufferram;	/* Memory used by buffers */
+	unsigned long totalswap;	/* Total swap space size */
+	unsigned long freeswap;		/* swap space still available */
+	unsigned short procs;		/* Number of current processes */
+	unsigned short pad;		/* explicit padding for m68k */
+	unsigned long totalhigh;	/* Total high memory size */
+	unsigned long freehigh;		/* Available high memory size */
+	unsigned int mem_unit;		/* Memory unit size in bytes */
+	char _f[20-2*sizeof(long)-sizeof(int)];	/* Padding: libc5 uses this.. */
+};
+
+/* Force a compilation error if condition is true */
+#define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))
+
+/* Force a compilation error if condition is constant and true */
+#define MAYBE_BUILD_BUG_ON(cond) ((void)sizeof(char[1 - 2 * !!(cond)]))
+
+/* Force a compilation error if condition is true, but also produce a
+   result (of value 0 and type size_t), so the expression can be used
+   e.g. in a structure initializer (or where-ever else comma expressions
+   aren't permitted). */
+#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
+#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
+
+/* Trap pasters of __FUNCTION__ at compile-time */
+#define __FUNCTION__ (__func__)
+
+/* This helps us to avoid #ifdef CONFIG_NUMA */
+#ifdef CONFIG_NUMA
+#define NUMA_BUILD 1
+#else
+#define NUMA_BUILD 0
+#endif
+
+/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */
+#ifdef CONFIG_FTRACE_MCOUNT_RECORD
+# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD
+#endif
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/keyboard.h clean_modified/linux-2.6.32/usr/include/linux/keyboard.h
--- linux-2.6.32/usr/include/linux/keyboard.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/keyboard.h	2019-04-14 13:24:03.024693392 -0500
@@ -0,0 +1,443 @@
+#ifndef __LINUX_KEYBOARD_H
+#define __LINUX_KEYBOARD_H
+
+#include <linux/wait.h>
+
+#define KG_SHIFT	0
+#define KG_CTRL		2
+#define KG_ALT		3
+#define KG_ALTGR	1
+#define KG_SHIFTL	4
+#define KG_KANASHIFT	4
+#define KG_SHIFTR	5
+#define KG_CTRLL	6
+#define KG_CTRLR	7
+#define KG_CAPSSHIFT	8
+
+#define NR_SHIFT	9
+
+#define NR_KEYS		256
+#define MAX_NR_KEYMAPS	256
+/* This means 128Kb if all keymaps are allocated. Only the superuser
+	may increase the number of keymaps beyond MAX_NR_OF_USER_KEYMAPS. */
+#define MAX_NR_OF_USER_KEYMAPS 256 	/* should be at least 7 */
+
+
+#define MAX_NR_FUNC	256	/* max nr of strings assigned to keys */
+
+#define KT_LATIN	0	/* we depend on this being zero */
+#define KT_LETTER	11	/* symbol that can be acted upon by CapsLock */
+#define KT_FN		1
+#define KT_SPEC		2
+#define KT_PAD		3
+#define KT_DEAD		4
+#define KT_CONS		5
+#define KT_CUR		6
+#define KT_SHIFT	7
+#define KT_META		8
+#define KT_ASCII	9
+#define KT_LOCK		10
+#define KT_SLOCK	12
+#define KT_DEAD2	13
+#define KT_BRL		14
+
+#define K(t,v)		(((t)<<8)|(v))
+#define KTYP(x)		((x) >> 8)
+#define KVAL(x)		((x) & 0xff)
+
+#define K_F1		K(KT_FN,0)
+#define K_F2		K(KT_FN,1)
+#define K_F3		K(KT_FN,2)
+#define K_F4		K(KT_FN,3)
+#define K_F5		K(KT_FN,4)
+#define K_F6		K(KT_FN,5)
+#define K_F7		K(KT_FN,6)
+#define K_F8		K(KT_FN,7)
+#define K_F9		K(KT_FN,8)
+#define K_F10		K(KT_FN,9)
+#define K_F11		K(KT_FN,10)
+#define K_F12		K(KT_FN,11)
+#define K_F13		K(KT_FN,12)
+#define K_F14		K(KT_FN,13)
+#define K_F15		K(KT_FN,14)
+#define K_F16		K(KT_FN,15)
+#define K_F17		K(KT_FN,16)
+#define K_F18		K(KT_FN,17)
+#define K_F19		K(KT_FN,18)
+#define K_F20		K(KT_FN,19)
+#define K_FIND		K(KT_FN,20)
+#define K_INSERT	K(KT_FN,21)
+#define K_REMOVE	K(KT_FN,22)
+#define K_SELECT	K(KT_FN,23)
+#define K_PGUP		K(KT_FN,24) /* PGUP is a synonym for PRIOR */
+#define K_PGDN		K(KT_FN,25) /* PGDN is a synonym for NEXT */
+#define K_MACRO	 	K(KT_FN,26)
+#define K_HELP		K(KT_FN,27)
+#define K_DO		K(KT_FN,28)
+#define K_PAUSE	 	K(KT_FN,29)
+#define K_F21		K(KT_FN,30)
+#define K_F22		K(KT_FN,31)
+#define K_F23		K(KT_FN,32)
+#define K_F24		K(KT_FN,33)
+#define K_F25		K(KT_FN,34)
+#define K_F26		K(KT_FN,35)
+#define K_F27		K(KT_FN,36)
+#define K_F28		K(KT_FN,37)
+#define K_F29		K(KT_FN,38)
+#define K_F30		K(KT_FN,39)
+#define K_F31		K(KT_FN,40)
+#define K_F32		K(KT_FN,41)
+#define K_F33		K(KT_FN,42)
+#define K_F34		K(KT_FN,43)
+#define K_F35		K(KT_FN,44)
+#define K_F36		K(KT_FN,45)
+#define K_F37		K(KT_FN,46)
+#define K_F38		K(KT_FN,47)
+#define K_F39		K(KT_FN,48)
+#define K_F40		K(KT_FN,49)
+#define K_F41		K(KT_FN,50)
+#define K_F42		K(KT_FN,51)
+#define K_F43		K(KT_FN,52)
+#define K_F44		K(KT_FN,53)
+#define K_F45		K(KT_FN,54)
+#define K_F46		K(KT_FN,55)
+#define K_F47		K(KT_FN,56)
+#define K_F48		K(KT_FN,57)
+#define K_F49		K(KT_FN,58)
+#define K_F50		K(KT_FN,59)
+#define K_F51		K(KT_FN,60)
+#define K_F52		K(KT_FN,61)
+#define K_F53		K(KT_FN,62)
+#define K_F54		K(KT_FN,63)
+#define K_F55		K(KT_FN,64)
+#define K_F56		K(KT_FN,65)
+#define K_F57		K(KT_FN,66)
+#define K_F58		K(KT_FN,67)
+#define K_F59		K(KT_FN,68)
+#define K_F60		K(KT_FN,69)
+#define K_F61		K(KT_FN,70)
+#define K_F62		K(KT_FN,71)
+#define K_F63		K(KT_FN,72)
+#define K_F64		K(KT_FN,73)
+#define K_F65		K(KT_FN,74)
+#define K_F66		K(KT_FN,75)
+#define K_F67		K(KT_FN,76)
+#define K_F68		K(KT_FN,77)
+#define K_F69		K(KT_FN,78)
+#define K_F70		K(KT_FN,79)
+#define K_F71		K(KT_FN,80)
+#define K_F72		K(KT_FN,81)
+#define K_F73		K(KT_FN,82)
+#define K_F74		K(KT_FN,83)
+#define K_F75		K(KT_FN,84)
+#define K_F76		K(KT_FN,85)
+#define K_F77		K(KT_FN,86)
+#define K_F78		K(KT_FN,87)
+#define K_F79		K(KT_FN,88)
+#define K_F80		K(KT_FN,89)
+#define K_F81		K(KT_FN,90)
+#define K_F82		K(KT_FN,91)
+#define K_F83		K(KT_FN,92)
+#define K_F84		K(KT_FN,93)
+#define K_F85		K(KT_FN,94)
+#define K_F86		K(KT_FN,95)
+#define K_F87		K(KT_FN,96)
+#define K_F88		K(KT_FN,97)
+#define K_F89		K(KT_FN,98)
+#define K_F90		K(KT_FN,99)
+#define K_F91		K(KT_FN,100)
+#define K_F92		K(KT_FN,101)
+#define K_F93		K(KT_FN,102)
+#define K_F94		K(KT_FN,103)
+#define K_F95		K(KT_FN,104)
+#define K_F96		K(KT_FN,105)
+#define K_F97		K(KT_FN,106)
+#define K_F98		K(KT_FN,107)
+#define K_F99		K(KT_FN,108)
+#define K_F100		K(KT_FN,109)
+#define K_F101		K(KT_FN,110)
+#define K_F102		K(KT_FN,111)
+#define K_F103		K(KT_FN,112)
+#define K_F104		K(KT_FN,113)
+#define K_F105		K(KT_FN,114)
+#define K_F106		K(KT_FN,115)
+#define K_F107		K(KT_FN,116)
+#define K_F108		K(KT_FN,117)
+#define K_F109		K(KT_FN,118)
+#define K_F110		K(KT_FN,119)
+#define K_F111		K(KT_FN,120)
+#define K_F112		K(KT_FN,121)
+#define K_F113		K(KT_FN,122)
+#define K_F114		K(KT_FN,123)
+#define K_F115		K(KT_FN,124)
+#define K_F116		K(KT_FN,125)
+#define K_F117		K(KT_FN,126)
+#define K_F118		K(KT_FN,127)
+#define K_F119		K(KT_FN,128)
+#define K_F120		K(KT_FN,129)
+#define K_F121		K(KT_FN,130)
+#define K_F122		K(KT_FN,131)
+#define K_F123		K(KT_FN,132)
+#define K_F124		K(KT_FN,133)
+#define K_F125		K(KT_FN,134)
+#define K_F126		K(KT_FN,135)
+#define K_F127		K(KT_FN,136)
+#define K_F128		K(KT_FN,137)
+#define K_F129		K(KT_FN,138)
+#define K_F130		K(KT_FN,139)
+#define K_F131		K(KT_FN,140)
+#define K_F132		K(KT_FN,141)
+#define K_F133		K(KT_FN,142)
+#define K_F134		K(KT_FN,143)
+#define K_F135		K(KT_FN,144)
+#define K_F136		K(KT_FN,145)
+#define K_F137		K(KT_FN,146)
+#define K_F138		K(KT_FN,147)
+#define K_F139		K(KT_FN,148)
+#define K_F140		K(KT_FN,149)
+#define K_F141		K(KT_FN,150)
+#define K_F142		K(KT_FN,151)
+#define K_F143		K(KT_FN,152)
+#define K_F144		K(KT_FN,153)
+#define K_F145		K(KT_FN,154)
+#define K_F146		K(KT_FN,155)
+#define K_F147		K(KT_FN,156)
+#define K_F148		K(KT_FN,157)
+#define K_F149		K(KT_FN,158)
+#define K_F150		K(KT_FN,159)
+#define K_F151		K(KT_FN,160)
+#define K_F152		K(KT_FN,161)
+#define K_F153		K(KT_FN,162)
+#define K_F154		K(KT_FN,163)
+#define K_F155		K(KT_FN,164)
+#define K_F156		K(KT_FN,165)
+#define K_F157		K(KT_FN,166)
+#define K_F158		K(KT_FN,167)
+#define K_F159		K(KT_FN,168)
+#define K_F160		K(KT_FN,169)
+#define K_F161		K(KT_FN,170)
+#define K_F162		K(KT_FN,171)
+#define K_F163		K(KT_FN,172)
+#define K_F164		K(KT_FN,173)
+#define K_F165		K(KT_FN,174)
+#define K_F166		K(KT_FN,175)
+#define K_F167		K(KT_FN,176)
+#define K_F168		K(KT_FN,177)
+#define K_F169		K(KT_FN,178)
+#define K_F170		K(KT_FN,179)
+#define K_F171		K(KT_FN,180)
+#define K_F172		K(KT_FN,181)
+#define K_F173		K(KT_FN,182)
+#define K_F174		K(KT_FN,183)
+#define K_F175		K(KT_FN,184)
+#define K_F176		K(KT_FN,185)
+#define K_F177		K(KT_FN,186)
+#define K_F178		K(KT_FN,187)
+#define K_F179		K(KT_FN,188)
+#define K_F180		K(KT_FN,189)
+#define K_F181		K(KT_FN,190)
+#define K_F182		K(KT_FN,191)
+#define K_F183		K(KT_FN,192)
+#define K_F184		K(KT_FN,193)
+#define K_F185		K(KT_FN,194)
+#define K_F186		K(KT_FN,195)
+#define K_F187		K(KT_FN,196)
+#define K_F188		K(KT_FN,197)
+#define K_F189		K(KT_FN,198)
+#define K_F190		K(KT_FN,199)
+#define K_F191		K(KT_FN,200)
+#define K_F192		K(KT_FN,201)
+#define K_F193		K(KT_FN,202)
+#define K_F194		K(KT_FN,203)
+#define K_F195		K(KT_FN,204)
+#define K_F196		K(KT_FN,205)
+#define K_F197		K(KT_FN,206)
+#define K_F198		K(KT_FN,207)
+#define K_F199		K(KT_FN,208)
+#define K_F200		K(KT_FN,209)
+#define K_F201		K(KT_FN,210)
+#define K_F202		K(KT_FN,211)
+#define K_F203		K(KT_FN,212)
+#define K_F204		K(KT_FN,213)
+#define K_F205		K(KT_FN,214)
+#define K_F206		K(KT_FN,215)
+#define K_F207		K(KT_FN,216)
+#define K_F208		K(KT_FN,217)
+#define K_F209		K(KT_FN,218)
+#define K_F210		K(KT_FN,219)
+#define K_F211		K(KT_FN,220)
+#define K_F212		K(KT_FN,221)
+#define K_F213		K(KT_FN,222)
+#define K_F214		K(KT_FN,223)
+#define K_F215		K(KT_FN,224)
+#define K_F216		K(KT_FN,225)
+#define K_F217		K(KT_FN,226)
+#define K_F218		K(KT_FN,227)
+#define K_F219		K(KT_FN,228)
+#define K_F220		K(KT_FN,229)
+#define K_F221		K(KT_FN,230)
+#define K_F222		K(KT_FN,231)
+#define K_F223		K(KT_FN,232)
+#define K_F224		K(KT_FN,233)
+#define K_F225		K(KT_FN,234)
+#define K_F226		K(KT_FN,235)
+#define K_F227		K(KT_FN,236)
+#define K_F228		K(KT_FN,237)
+#define K_F229		K(KT_FN,238)
+#define K_F230		K(KT_FN,239)
+#define K_F231		K(KT_FN,240)
+#define K_F232		K(KT_FN,241)
+#define K_F233		K(KT_FN,242)
+#define K_F234		K(KT_FN,243)
+#define K_F235		K(KT_FN,244)
+#define K_F236		K(KT_FN,245)
+#define K_F237		K(KT_FN,246)
+#define K_F238		K(KT_FN,247)
+#define K_F239		K(KT_FN,248)
+#define K_F240		K(KT_FN,249)
+#define K_F241		K(KT_FN,250)
+#define K_F242		K(KT_FN,251)
+#define K_F243		K(KT_FN,252)
+#define K_F244		K(KT_FN,253)
+#define K_F245		K(KT_FN,254)
+#define K_UNDO		K(KT_FN,255)
+
+
+#define K_HOLE		K(KT_SPEC,0)
+#define K_ENTER		K(KT_SPEC,1)
+#define K_SH_REGS	K(KT_SPEC,2)
+#define K_SH_MEM	K(KT_SPEC,3)
+#define K_SH_STAT	K(KT_SPEC,4)
+#define K_BREAK		K(KT_SPEC,5)
+#define K_CONS		K(KT_SPEC,6)
+#define K_CAPS		K(KT_SPEC,7)
+#define K_NUM		K(KT_SPEC,8)
+#define K_HOLD		K(KT_SPEC,9)
+#define K_SCROLLFORW	K(KT_SPEC,10)
+#define K_SCROLLBACK	K(KT_SPEC,11)
+#define K_BOOT		K(KT_SPEC,12)
+#define K_CAPSON	K(KT_SPEC,13)
+#define K_COMPOSE	K(KT_SPEC,14)
+#define K_SAK		K(KT_SPEC,15)
+#define K_DECRCONSOLE	K(KT_SPEC,16)
+#define K_INCRCONSOLE	K(KT_SPEC,17)
+#define K_SPAWNCONSOLE	K(KT_SPEC,18)
+#define K_BARENUMLOCK	K(KT_SPEC,19)
+
+#define K_ALLOCATED	K(KT_SPEC,126) /* dynamically allocated keymap */
+#define K_NOSUCHMAP	K(KT_SPEC,127) /* returned by KDGKBENT */
+
+#define K_P0		K(KT_PAD,0)
+#define K_P1		K(KT_PAD,1)
+#define K_P2		K(KT_PAD,2)
+#define K_P3		K(KT_PAD,3)
+#define K_P4		K(KT_PAD,4)
+#define K_P5		K(KT_PAD,5)
+#define K_P6		K(KT_PAD,6)
+#define K_P7		K(KT_PAD,7)
+#define K_P8		K(KT_PAD,8)
+#define K_P9		K(KT_PAD,9)
+#define K_PPLUS		K(KT_PAD,10)	/* key-pad plus */
+#define K_PMINUS	K(KT_PAD,11)	/* key-pad minus */
+#define K_PSTAR		K(KT_PAD,12)	/* key-pad asterisk (star) */
+#define K_PSLASH	K(KT_PAD,13)	/* key-pad slash */
+#define K_PENTER	K(KT_PAD,14)	/* key-pad enter */
+#define K_PCOMMA	K(KT_PAD,15)	/* key-pad comma: kludge... */
+#define K_PDOT		K(KT_PAD,16)	/* key-pad dot (period): kludge... */
+#define K_PPLUSMINUS	K(KT_PAD,17)	/* key-pad plus/minus */
+#define K_PPARENL	K(KT_PAD,18)	/* key-pad left parenthesis */
+#define K_PPARENR	K(KT_PAD,19)	/* key-pad right parenthesis */
+
+#define NR_PAD		20
+
+#define K_DGRAVE	K(KT_DEAD,0)
+#define K_DACUTE	K(KT_DEAD,1)
+#define K_DCIRCM	K(KT_DEAD,2)
+#define K_DTILDE	K(KT_DEAD,3)
+#define K_DDIERE	K(KT_DEAD,4)
+#define K_DCEDIL	K(KT_DEAD,5)
+
+#define NR_DEAD		6
+
+#define K_DOWN		K(KT_CUR,0)
+#define K_LEFT		K(KT_CUR,1)
+#define K_RIGHT		K(KT_CUR,2)
+#define K_UP		K(KT_CUR,3)
+
+#define K_SHIFT		K(KT_SHIFT,KG_SHIFT)
+#define K_CTRL		K(KT_SHIFT,KG_CTRL)
+#define K_ALT		K(KT_SHIFT,KG_ALT)
+#define K_ALTGR		K(KT_SHIFT,KG_ALTGR)
+#define K_SHIFTL	K(KT_SHIFT,KG_SHIFTL)
+#define K_SHIFTR	K(KT_SHIFT,KG_SHIFTR)
+#define K_CTRLL	 	K(KT_SHIFT,KG_CTRLL)
+#define K_CTRLR	 	K(KT_SHIFT,KG_CTRLR)
+#define K_CAPSSHIFT	K(KT_SHIFT,KG_CAPSSHIFT)
+
+#define K_ASC0		K(KT_ASCII,0)
+#define K_ASC1		K(KT_ASCII,1)
+#define K_ASC2		K(KT_ASCII,2)
+#define K_ASC3		K(KT_ASCII,3)
+#define K_ASC4		K(KT_ASCII,4)
+#define K_ASC5		K(KT_ASCII,5)
+#define K_ASC6		K(KT_ASCII,6)
+#define K_ASC7		K(KT_ASCII,7)
+#define K_ASC8		K(KT_ASCII,8)
+#define K_ASC9		K(KT_ASCII,9)
+#define K_HEX0		K(KT_ASCII,10)
+#define K_HEX1		K(KT_ASCII,11)
+#define K_HEX2		K(KT_ASCII,12)
+#define K_HEX3		K(KT_ASCII,13)
+#define K_HEX4		K(KT_ASCII,14)
+#define K_HEX5		K(KT_ASCII,15)
+#define K_HEX6		K(KT_ASCII,16)
+#define K_HEX7		K(KT_ASCII,17)
+#define K_HEX8		K(KT_ASCII,18)
+#define K_HEX9		K(KT_ASCII,19)
+#define K_HEXa		K(KT_ASCII,20)
+#define K_HEXb		K(KT_ASCII,21)
+#define K_HEXc		K(KT_ASCII,22)
+#define K_HEXd		K(KT_ASCII,23)
+#define K_HEXe		K(KT_ASCII,24)
+#define K_HEXf		K(KT_ASCII,25)
+
+#define NR_ASCII	26
+
+#define K_SHIFTLOCK	K(KT_LOCK,KG_SHIFT)
+#define K_CTRLLOCK	K(KT_LOCK,KG_CTRL)
+#define K_ALTLOCK	K(KT_LOCK,KG_ALT)
+#define K_ALTGRLOCK	K(KT_LOCK,KG_ALTGR)
+#define K_SHIFTLLOCK	K(KT_LOCK,KG_SHIFTL)
+#define K_SHIFTRLOCK	K(KT_LOCK,KG_SHIFTR)
+#define K_CTRLLLOCK	K(KT_LOCK,KG_CTRLL)
+#define K_CTRLRLOCK	K(KT_LOCK,KG_CTRLR)
+#define K_CAPSSHIFTLOCK	K(KT_LOCK,KG_CAPSSHIFT)
+
+#define K_SHIFT_SLOCK	K(KT_SLOCK,KG_SHIFT)
+#define K_CTRL_SLOCK	K(KT_SLOCK,KG_CTRL)
+#define K_ALT_SLOCK	K(KT_SLOCK,KG_ALT)
+#define K_ALTGR_SLOCK	K(KT_SLOCK,KG_ALTGR)
+#define K_SHIFTL_SLOCK	K(KT_SLOCK,KG_SHIFTL)
+#define K_SHIFTR_SLOCK	K(KT_SLOCK,KG_SHIFTR)
+#define K_CTRLL_SLOCK	K(KT_SLOCK,KG_CTRLL)
+#define K_CTRLR_SLOCK	K(KT_SLOCK,KG_CTRLR)
+#define K_CAPSSHIFT_SLOCK	K(KT_SLOCK,KG_CAPSSHIFT)
+
+#define NR_LOCK		9
+
+#define K_BRL_BLANK     K(KT_BRL, 0)
+#define K_BRL_DOT1      K(KT_BRL, 1)
+#define K_BRL_DOT2      K(KT_BRL, 2)
+#define K_BRL_DOT3      K(KT_BRL, 3)
+#define K_BRL_DOT4      K(KT_BRL, 4)
+#define K_BRL_DOT5      K(KT_BRL, 5)
+#define K_BRL_DOT6      K(KT_BRL, 6)
+#define K_BRL_DOT7      K(KT_BRL, 7)
+#define K_BRL_DOT8      K(KT_BRL, 8)
+#define K_BRL_DOT9      K(KT_BRL, 9)
+#define K_BRL_DOT10     K(KT_BRL, 10)
+
+#define NR_BRL		11
+
+#define MAX_DIACR	256
+#endif
diff -uNr linux-2.6.32/usr/include/linux/keyctl.h clean_modified/linux-2.6.32/usr/include/linux/keyctl.h
--- linux-2.6.32/usr/include/linux/keyctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/keyctl.h	2019-04-14 13:24:03.025222994 -0500
@@ -0,0 +1,57 @@
+/* keyctl.h: keyctl command IDs
+ *
+ * Copyright (C) 2004, 2008 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_KEYCTL_H
+#define _LINUX_KEYCTL_H
+
+/* special process keyring shortcut IDs */
+#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
+#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
+#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
+#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
+#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
+#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
+#define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
+#define KEY_SPEC_REQUESTOR_KEYRING	-8	/* - key ID for request_key() dest keyring */
+
+/* request-key default keyrings */
+#define KEY_REQKEY_DEFL_NO_CHANGE		-1
+#define KEY_REQKEY_DEFL_DEFAULT			0
+#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
+#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
+#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
+#define KEY_REQKEY_DEFL_USER_KEYRING		4
+#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
+#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
+#define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
+
+/* keyctl commands */
+#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
+#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
+#define KEYCTL_UPDATE			2	/* update a key */
+#define KEYCTL_REVOKE			3	/* revoke a key */
+#define KEYCTL_CHOWN			4	/* set ownership of a key */
+#define KEYCTL_SETPERM			5	/* set perms on a key */
+#define KEYCTL_DESCRIBE			6	/* describe a key */
+#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
+#define KEYCTL_LINK			8	/* link a key into a keyring */
+#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
+#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
+#define KEYCTL_READ			11	/* read a key or keyring's contents */
+#define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
+#define KEYCTL_NEGATE			13	/* negate a partially constructed key */
+#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
+#define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
+#define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
+#define KEYCTL_GET_SECURITY		17	/* get key security label */
+#define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
+
+#endif /*  _LINUX_KEYCTL_H */
diff -uNr linux-2.6.32/usr/include/linux/kvm.h clean_modified/linux-2.6.32/usr/include/linux/kvm.h
--- linux-2.6.32/usr/include/linux/kvm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kvm.h	2019-04-14 13:24:03.026651212 -0500
@@ -0,0 +1,699 @@
+#ifndef __LINUX_KVM_H
+#define __LINUX_KVM_H
+
+/*
+ * Userspace interface for /dev/kvm - kernel based virtual machine
+ *
+ * Note: you must update KVM_API_VERSION if you change this interface.
+ */
+
+#include <linux/types.h>
+
+#include <linux/ioctl.h>
+#include <asm/kvm.h>
+
+#define KVM_API_VERSION 12
+
+/* for KVM_TRACE_ENABLE, deprecated */
+struct kvm_user_trace_setup {
+	__u32 buf_size; /* sub_buffer size of each per-cpu */
+	__u32 buf_nr; /* the number of sub_buffers of each per-cpu */
+};
+
+/* for KVM_CREATE_MEMORY_REGION */
+struct kvm_memory_region {
+	__u32 slot;
+	__u32 flags;
+	__u64 guest_phys_addr;
+	__u64 memory_size; /* bytes */
+};
+
+/* for KVM_SET_USER_MEMORY_REGION */
+struct kvm_userspace_memory_region {
+	__u32 slot;
+	__u32 flags;
+	__u64 guest_phys_addr;
+	__u64 memory_size; /* bytes */
+	__u64 userspace_addr; /* start of the userspace allocated memory */
+};
+
+/* for kvm_memory_region::flags */
+#define KVM_MEM_LOG_DIRTY_PAGES  1UL
+
+
+/* for KVM_IRQ_LINE */
+struct kvm_irq_level {
+	/*
+	 * ACPI gsi notion of irq.
+	 * For IA-64 (APIC model) IOAPIC0: irq 0-23; IOAPIC1: irq 24-47..
+	 * For X86 (standard AT mode) PIC0/1: irq 0-15. IOAPIC0: 0-23..
+	 */
+	union {
+		__u32 irq;
+		__s32 status;
+	};
+	__u32 level;
+};
+
+
+struct kvm_irqchip {
+	__u32 chip_id;
+	__u32 pad;
+        union {
+		char dummy[512];  /* reserving space */
+#ifdef __KVM_HAVE_PIT
+		struct kvm_pic_state pic;
+#endif
+#ifdef __KVM_HAVE_IOAPIC
+		struct kvm_ioapic_state ioapic;
+#endif
+	} chip;
+};
+
+/* for KVM_CREATE_PIT2 */
+struct kvm_pit_config {
+	__u32 flags;
+	__u32 pad[15];
+};
+
+#define KVM_PIT_SPEAKER_DUMMY     1
+
+#define KVM_EXIT_UNKNOWN          0
+#define KVM_EXIT_EXCEPTION        1
+#define KVM_EXIT_IO               2
+#define KVM_EXIT_HYPERCALL        3
+#define KVM_EXIT_DEBUG            4
+#define KVM_EXIT_HLT              5
+#define KVM_EXIT_MMIO             6
+#define KVM_EXIT_IRQ_WINDOW_OPEN  7
+#define KVM_EXIT_SHUTDOWN         8
+#define KVM_EXIT_FAIL_ENTRY       9
+#define KVM_EXIT_INTR             10
+#define KVM_EXIT_SET_TPR          11
+#define KVM_EXIT_TPR_ACCESS       12
+#define KVM_EXIT_S390_SIEIC       13
+#define KVM_EXIT_S390_RESET       14
+#define KVM_EXIT_DCR              15
+#define KVM_EXIT_NMI              16
+#define KVM_EXIT_INTERNAL_ERROR   17
+
+/* For KVM_EXIT_INTERNAL_ERROR */
+#define KVM_INTERNAL_ERROR_EMULATION 1
+
+/* for KVM_RUN, returned by mmap(vcpu_fd, offset=0) */
+struct kvm_run {
+	/* in */
+	__u8 request_interrupt_window;
+	__u8 padding1[7];
+
+	/* out */
+	__u32 exit_reason;
+	__u8 ready_for_interrupt_injection;
+	__u8 if_flag;
+	__u8 padding2[2];
+
+	/* in (pre_kvm_run), out (post_kvm_run) */
+	__u64 cr8;
+	__u64 apic_base;
+
+	union {
+		/* KVM_EXIT_UNKNOWN */
+		struct {
+			__u64 hardware_exit_reason;
+		} hw;
+		/* KVM_EXIT_FAIL_ENTRY */
+		struct {
+			__u64 hardware_entry_failure_reason;
+		} fail_entry;
+		/* KVM_EXIT_EXCEPTION */
+		struct {
+			__u32 exception;
+			__u32 error_code;
+		} ex;
+		/* KVM_EXIT_IO */
+		struct {
+#define KVM_EXIT_IO_IN  0
+#define KVM_EXIT_IO_OUT 1
+			__u8 direction;
+			__u8 size; /* bytes */
+			__u16 port;
+			__u32 count;
+			__u64 data_offset; /* relative to kvm_run start */
+		} io;
+		struct {
+			struct kvm_debug_exit_arch arch;
+		} debug;
+		/* KVM_EXIT_MMIO */
+		struct {
+			__u64 phys_addr;
+			__u8  data[8];
+			__u32 len;
+			__u8  is_write;
+		} mmio;
+		/* KVM_EXIT_HYPERCALL */
+		struct {
+			__u64 nr;
+			__u64 args[6];
+			__u64 ret;
+			__u32 longmode;
+			__u32 pad;
+		} hypercall;
+		/* KVM_EXIT_TPR_ACCESS */
+		struct {
+			__u64 rip;
+			__u32 is_write;
+			__u32 pad;
+		} tpr_access;
+		/* KVM_EXIT_S390_SIEIC */
+		struct {
+			__u8 icptcode;
+			__u64 mask; /* psw upper half */
+			__u64 addr; /* psw lower half */
+			__u16 ipa;
+			__u32 ipb;
+		} s390_sieic;
+		/* KVM_EXIT_S390_RESET */
+#define KVM_S390_RESET_POR       1
+#define KVM_S390_RESET_CLEAR     2
+#define KVM_S390_RESET_SUBSYSTEM 4
+#define KVM_S390_RESET_CPU_INIT  8
+#define KVM_S390_RESET_IPL       16
+		__u64 s390_reset_flags;
+		/* KVM_EXIT_DCR */
+		struct {
+			__u32 dcrn;
+			__u32 data;
+			__u8  is_write;
+		} dcr;
+		struct {
+			__u32 suberror;
+		} internal;
+		/* Fix the size of the union. */
+		char padding[256];
+	};
+};
+
+/* for KVM_REGISTER_COALESCED_MMIO / KVM_UNREGISTER_COALESCED_MMIO */
+
+struct kvm_coalesced_mmio_zone {
+	__u64 addr;
+	__u32 size;
+	__u32 pad;
+};
+
+struct kvm_coalesced_mmio {
+	__u64 phys_addr;
+	__u32 len;
+	__u32 pad;
+	__u8  data[8];
+};
+
+struct kvm_coalesced_mmio_ring {
+	__u32 first, last;
+	struct kvm_coalesced_mmio coalesced_mmio[0];
+};
+
+#define KVM_COALESCED_MMIO_MAX \
+	((PAGE_SIZE - sizeof(struct kvm_coalesced_mmio_ring)) / \
+	 sizeof(struct kvm_coalesced_mmio))
+
+/* for KVM_TRANSLATE */
+struct kvm_translation {
+	/* in */
+	__u64 linear_address;
+
+	/* out */
+	__u64 physical_address;
+	__u8  valid;
+	__u8  writeable;
+	__u8  usermode;
+	__u8  pad[5];
+};
+
+/* for KVM_INTERRUPT */
+struct kvm_interrupt {
+	/* in */
+	__u32 irq;
+};
+
+/* for KVM_GET_DIRTY_LOG */
+struct kvm_dirty_log {
+	__u32 slot;
+	__u32 padding1;
+	union {
+		void *dirty_bitmap; /* one bit per page */
+		__u64 padding2;
+	};
+};
+
+/* for KVM_SET_SIGNAL_MASK */
+struct kvm_signal_mask {
+	__u32 len;
+	__u8  sigset[0];
+};
+
+/* for KVM_TPR_ACCESS_REPORTING */
+struct kvm_tpr_access_ctl {
+	__u32 enabled;
+	__u32 flags;
+	__u32 reserved[8];
+};
+
+/* for KVM_SET_VAPIC_ADDR */
+struct kvm_vapic_addr {
+	__u64 vapic_addr;
+};
+
+/* for KVM_SET_MPSTATE */
+
+#define KVM_MP_STATE_RUNNABLE          0
+#define KVM_MP_STATE_UNINITIALIZED     1
+#define KVM_MP_STATE_INIT_RECEIVED     2
+#define KVM_MP_STATE_HALTED            3
+#define KVM_MP_STATE_SIPI_RECEIVED     4
+
+struct kvm_mp_state {
+	__u32 mp_state;
+};
+
+struct kvm_s390_psw {
+	__u64 mask;
+	__u64 addr;
+};
+
+/* valid values for type in kvm_s390_interrupt */
+#define KVM_S390_SIGP_STOP		0xfffe0000u
+#define KVM_S390_PROGRAM_INT		0xfffe0001u
+#define KVM_S390_SIGP_SET_PREFIX	0xfffe0002u
+#define KVM_S390_RESTART		0xfffe0003u
+#define KVM_S390_INT_VIRTIO		0xffff2603u
+#define KVM_S390_INT_SERVICE		0xffff2401u
+#define KVM_S390_INT_EMERGENCY		0xffff1201u
+
+struct kvm_s390_interrupt {
+	__u32 type;
+	__u32 parm;
+	__u64 parm64;
+};
+
+/* for KVM_SET_GUEST_DEBUG */
+
+#define KVM_GUESTDBG_ENABLE		0x00000001
+#define KVM_GUESTDBG_SINGLESTEP		0x00000002
+
+struct kvm_guest_debug {
+	__u32 control;
+	__u32 pad;
+	struct kvm_guest_debug_arch arch;
+};
+
+enum {
+	kvm_ioeventfd_flag_nr_datamatch,
+	kvm_ioeventfd_flag_nr_pio,
+	kvm_ioeventfd_flag_nr_deassign,
+	kvm_ioeventfd_flag_nr_max,
+};
+
+#define KVM_IOEVENTFD_FLAG_DATAMATCH (1 << kvm_ioeventfd_flag_nr_datamatch)
+#define KVM_IOEVENTFD_FLAG_PIO       (1 << kvm_ioeventfd_flag_nr_pio)
+#define KVM_IOEVENTFD_FLAG_DEASSIGN  (1 << kvm_ioeventfd_flag_nr_deassign)
+
+#define KVM_IOEVENTFD_VALID_FLAG_MASK  ((1 << kvm_ioeventfd_flag_nr_max) - 1)
+
+struct kvm_ioeventfd {
+	__u64 datamatch;
+	__u64 addr;        /* legal pio/mmio address */
+	__u32 len;         /* 1, 2, 4, or 8 bytes    */
+	__s32 fd;
+	__u32 flags;
+	__u8  pad[36];
+};
+
+#define KVM_TRC_SHIFT           16
+/*
+ * kvm trace categories
+ */
+#define KVM_TRC_ENTRYEXIT       (1 << KVM_TRC_SHIFT)
+#define KVM_TRC_HANDLER         (1 << (KVM_TRC_SHIFT + 1)) /* only 12 bits */
+
+/*
+ * kvm trace action
+ */
+#define KVM_TRC_VMENTRY         (KVM_TRC_ENTRYEXIT + 0x01)
+#define KVM_TRC_VMEXIT          (KVM_TRC_ENTRYEXIT + 0x02)
+#define KVM_TRC_PAGE_FAULT      (KVM_TRC_HANDLER + 0x01)
+
+#define KVM_TRC_HEAD_SIZE       12
+#define KVM_TRC_CYCLE_SIZE      8
+#define KVM_TRC_EXTRA_MAX       7
+
+#define KVMIO 0xAE
+
+/*
+ * ioctls for /dev/kvm fds:
+ */
+#define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+#define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
+#define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
+
+#define KVM_S390_ENABLE_SIE       _IO(KVMIO,   0x06)
+/*
+ * Check if a kvm extension is available.  Argument is extension number,
+ * return is 1 (yes) or 0 (no, sorry).
+ */
+#define KVM_CHECK_EXTENSION       _IO(KVMIO,   0x03)
+/*
+ * Get size for mmap(vcpu_fd)
+ */
+#define KVM_GET_VCPU_MMAP_SIZE    _IO(KVMIO,   0x04) /* in bytes */
+#define KVM_GET_SUPPORTED_CPUID   _IOWR(KVMIO, 0x05, struct kvm_cpuid2)
+/*
+ * ioctls for kvm trace
+ */
+#define KVM_TRACE_ENABLE          _IOW(KVMIO, 0x06, struct kvm_user_trace_setup)
+#define KVM_TRACE_PAUSE           _IO(KVMIO,  0x07)
+#define KVM_TRACE_DISABLE         _IO(KVMIO,  0x08)
+/*
+ * Extension capability list.
+ */
+#define KVM_CAP_IRQCHIP	  0
+#define KVM_CAP_HLT	  1
+#define KVM_CAP_MMU_SHADOW_CACHE_CONTROL 2
+#define KVM_CAP_USER_MEMORY 3
+#define KVM_CAP_SET_TSS_ADDR 4
+#define KVM_CAP_VAPIC 6
+#define KVM_CAP_EXT_CPUID 7
+#define KVM_CAP_CLOCKSOURCE 8
+#define KVM_CAP_NR_VCPUS 9       /* returns max vcpus per vm */
+#define KVM_CAP_NR_MEMSLOTS 10   /* returns max memory slots per vm */
+#define KVM_CAP_PIT 11
+#define KVM_CAP_NOP_IO_DELAY 12
+#define KVM_CAP_PV_MMU 13
+#define KVM_CAP_MP_STATE 14
+#define KVM_CAP_COALESCED_MMIO 15
+#define KVM_CAP_SYNC_MMU 16  /* Changes to host mmap are reflected in guest */
+#ifdef __KVM_HAVE_DEVICE_ASSIGNMENT
+#define KVM_CAP_DEVICE_ASSIGNMENT 17
+#endif
+#define KVM_CAP_IOMMU 18
+#ifdef __KVM_HAVE_MSI
+#define KVM_CAP_DEVICE_MSI 20
+#endif
+/* Bug in KVM_SET_USER_MEMORY_REGION fixed: */
+#define KVM_CAP_DESTROY_MEMORY_REGION_WORKS 21
+#ifdef __KVM_HAVE_USER_NMI
+#define KVM_CAP_USER_NMI 22
+#endif
+#ifdef __KVM_HAVE_GUEST_DEBUG
+#define KVM_CAP_SET_GUEST_DEBUG 23
+#endif
+#ifdef __KVM_HAVE_PIT
+#define KVM_CAP_REINJECT_CONTROL 24
+#endif
+#ifdef __KVM_HAVE_IOAPIC
+#define KVM_CAP_IRQ_ROUTING 25
+#endif
+#define KVM_CAP_IRQ_INJECT_STATUS 26
+#ifdef __KVM_HAVE_DEVICE_ASSIGNMENT
+#define KVM_CAP_DEVICE_DEASSIGNMENT 27
+#endif
+#ifdef __KVM_HAVE_MSIX
+#define KVM_CAP_DEVICE_MSIX 28
+#endif
+#define KVM_CAP_ASSIGN_DEV_IRQ 29
+/* Another bug in KVM_SET_USER_MEMORY_REGION fixed: */
+#define KVM_CAP_JOIN_MEMORY_REGIONS_WORKS 30
+#ifdef __KVM_HAVE_MCE
+#define KVM_CAP_MCE 31
+#endif
+#define KVM_CAP_IRQFD 32
+#ifdef __KVM_HAVE_PIT
+#define KVM_CAP_PIT2 33
+#endif
+#define KVM_CAP_SET_BOOT_CPU_ID 34
+#ifdef __KVM_HAVE_PIT_STATE2
+#define KVM_CAP_PIT_STATE2 35
+#endif
+#define KVM_CAP_IOEVENTFD 36
+#define KVM_CAP_SET_IDENTITY_MAP_ADDR 37
+
+#ifdef KVM_CAP_IRQ_ROUTING
+
+struct kvm_irq_routing_irqchip {
+	__u32 irqchip;
+	__u32 pin;
+};
+
+struct kvm_irq_routing_msi {
+	__u32 address_lo;
+	__u32 address_hi;
+	__u32 data;
+	__u32 pad;
+};
+
+/* gsi routing entry types */
+#define KVM_IRQ_ROUTING_IRQCHIP 1
+#define KVM_IRQ_ROUTING_MSI 2
+
+struct kvm_irq_routing_entry {
+	__u32 gsi;
+	__u32 type;
+	__u32 flags;
+	__u32 pad;
+	union {
+		struct kvm_irq_routing_irqchip irqchip;
+		struct kvm_irq_routing_msi msi;
+		__u32 pad[8];
+	} u;
+};
+
+struct kvm_irq_routing {
+	__u32 nr;
+	__u32 flags;
+	struct kvm_irq_routing_entry entries[0];
+};
+
+#endif
+
+#ifdef KVM_CAP_MCE
+/* x86 MCE */
+struct kvm_x86_mce {
+	__u64 status;
+	__u64 addr;
+	__u64 misc;
+	__u64 mcg_status;
+	__u8 bank;
+	__u8 pad1[7];
+	__u64 pad2[3];
+};
+#endif
+
+#define KVM_IRQFD_FLAG_DEASSIGN (1 << 0)
+
+struct kvm_irqfd {
+	__u32 fd;
+	__u32 gsi;
+	__u32 flags;
+	__u8  pad[20];
+};
+
+/*
+ * ioctls for VM fds
+ */
+#define KVM_SET_MEMORY_REGION     _IOW(KVMIO, 0x40, struct kvm_memory_region)
+/*
+ * KVM_CREATE_VCPU receives as a parameter the vcpu slot, and returns
+ * a vcpu fd.
+ */
+#define KVM_CREATE_VCPU           _IO(KVMIO,  0x41)
+#define KVM_GET_DIRTY_LOG         _IOW(KVMIO, 0x42, struct kvm_dirty_log)
+#define KVM_SET_MEMORY_ALIAS      _IOW(KVMIO, 0x43, struct kvm_memory_alias)
+#define KVM_SET_NR_MMU_PAGES      _IO(KVMIO, 0x44)
+#define KVM_GET_NR_MMU_PAGES      _IO(KVMIO, 0x45)
+#define KVM_SET_USER_MEMORY_REGION _IOW(KVMIO, 0x46,\
+					struct kvm_userspace_memory_region)
+#define KVM_SET_TSS_ADDR          _IO(KVMIO, 0x47)
+#define KVM_SET_IDENTITY_MAP_ADDR _IOW(KVMIO, 0x48, __u64)
+/* Device model IOC */
+#define KVM_CREATE_IRQCHIP	  _IO(KVMIO,  0x60)
+#define KVM_IRQ_LINE		  _IOW(KVMIO, 0x61, struct kvm_irq_level)
+#define KVM_GET_IRQCHIP		  _IOWR(KVMIO, 0x62, struct kvm_irqchip)
+#define KVM_SET_IRQCHIP		  _IOR(KVMIO,  0x63, struct kvm_irqchip)
+#define KVM_CREATE_PIT		  _IO(KVMIO,  0x64)
+#define KVM_GET_PIT		  _IOWR(KVMIO, 0x65, struct kvm_pit_state)
+#define KVM_SET_PIT		  _IOR(KVMIO,  0x66, struct kvm_pit_state)
+#define KVM_IRQ_LINE_STATUS	  _IOWR(KVMIO, 0x67, struct kvm_irq_level)
+#define KVM_REGISTER_COALESCED_MMIO \
+			_IOW(KVMIO,  0x67, struct kvm_coalesced_mmio_zone)
+#define KVM_UNREGISTER_COALESCED_MMIO \
+			_IOW(KVMIO,  0x68, struct kvm_coalesced_mmio_zone)
+#define KVM_ASSIGN_PCI_DEVICE _IOR(KVMIO, 0x69, \
+				   struct kvm_assigned_pci_dev)
+#define KVM_SET_GSI_ROUTING       _IOW(KVMIO, 0x6a, struct kvm_irq_routing)
+/* deprecated, replaced by KVM_ASSIGN_DEV_IRQ */
+#define KVM_ASSIGN_IRQ _IOR(KVMIO, 0x70, \
+			    struct kvm_assigned_irq)
+#define KVM_ASSIGN_DEV_IRQ        _IOW(KVMIO, 0x70, struct kvm_assigned_irq)
+#define KVM_REINJECT_CONTROL      _IO(KVMIO, 0x71)
+#define KVM_DEASSIGN_PCI_DEVICE _IOW(KVMIO, 0x72, \
+				     struct kvm_assigned_pci_dev)
+#define KVM_ASSIGN_SET_MSIX_NR \
+			_IOW(KVMIO, 0x73, struct kvm_assigned_msix_nr)
+#define KVM_ASSIGN_SET_MSIX_ENTRY \
+			_IOW(KVMIO, 0x74, struct kvm_assigned_msix_entry)
+#define KVM_DEASSIGN_DEV_IRQ       _IOW(KVMIO, 0x75, struct kvm_assigned_irq)
+#define KVM_IRQFD                  _IOW(KVMIO, 0x76, struct kvm_irqfd)
+#define KVM_CREATE_PIT2		   _IOW(KVMIO, 0x77, struct kvm_pit_config)
+#define KVM_SET_BOOT_CPU_ID        _IO(KVMIO, 0x78)
+#define KVM_IOEVENTFD             _IOW(KVMIO, 0x79, struct kvm_ioeventfd)
+
+/*
+ * ioctls for vcpu fds
+ */
+#define KVM_RUN                   _IO(KVMIO,   0x80)
+#define KVM_GET_REGS              _IOR(KVMIO,  0x81, struct kvm_regs)
+#define KVM_SET_REGS              _IOW(KVMIO,  0x82, struct kvm_regs)
+#define KVM_GET_SREGS             _IOR(KVMIO,  0x83, struct kvm_sregs)
+#define KVM_SET_SREGS             _IOW(KVMIO,  0x84, struct kvm_sregs)
+#define KVM_TRANSLATE             _IOWR(KVMIO, 0x85, struct kvm_translation)
+#define KVM_INTERRUPT             _IOW(KVMIO,  0x86, struct kvm_interrupt)
+/* KVM_DEBUG_GUEST is no longer supported, use KVM_SET_GUEST_DEBUG instead */
+#define KVM_DEBUG_GUEST           __KVM_DEPRECATED_DEBUG_GUEST
+#define KVM_GET_MSRS              _IOWR(KVMIO, 0x88, struct kvm_msrs)
+#define KVM_SET_MSRS              _IOW(KVMIO,  0x89, struct kvm_msrs)
+#define KVM_SET_CPUID             _IOW(KVMIO,  0x8a, struct kvm_cpuid)
+#define KVM_SET_SIGNAL_MASK       _IOW(KVMIO,  0x8b, struct kvm_signal_mask)
+#define KVM_GET_FPU               _IOR(KVMIO,  0x8c, struct kvm_fpu)
+#define KVM_SET_FPU               _IOW(KVMIO,  0x8d, struct kvm_fpu)
+#define KVM_GET_LAPIC             _IOR(KVMIO,  0x8e, struct kvm_lapic_state)
+#define KVM_SET_LAPIC             _IOW(KVMIO,  0x8f, struct kvm_lapic_state)
+#define KVM_SET_CPUID2            _IOW(KVMIO,  0x90, struct kvm_cpuid2)
+#define KVM_GET_CPUID2            _IOWR(KVMIO, 0x91, struct kvm_cpuid2)
+/* Available with KVM_CAP_VAPIC */
+#define KVM_TPR_ACCESS_REPORTING  _IOWR(KVMIO,  0x92, struct kvm_tpr_access_ctl)
+/* Available with KVM_CAP_VAPIC */
+#define KVM_SET_VAPIC_ADDR        _IOW(KVMIO,  0x93, struct kvm_vapic_addr)
+/* valid for virtual machine (for floating interrupt)_and_ vcpu */
+#define KVM_S390_INTERRUPT        _IOW(KVMIO,  0x94, struct kvm_s390_interrupt)
+/* store status for s390 */
+#define KVM_S390_STORE_STATUS_NOADDR    (-1ul)
+#define KVM_S390_STORE_STATUS_PREFIXED  (-2ul)
+#define KVM_S390_STORE_STATUS	  _IOW(KVMIO,  0x95, unsigned long)
+/* initial ipl psw for s390 */
+#define KVM_S390_SET_INITIAL_PSW  _IOW(KVMIO,  0x96, struct kvm_s390_psw)
+/* initial reset for s390 */
+#define KVM_S390_INITIAL_RESET    _IO(KVMIO,  0x97)
+#define KVM_GET_MP_STATE          _IOR(KVMIO,  0x98, struct kvm_mp_state)
+#define KVM_SET_MP_STATE          _IOW(KVMIO,  0x99, struct kvm_mp_state)
+/* Available with KVM_CAP_NMI */
+#define KVM_NMI                   _IO(KVMIO,  0x9a)
+/* Available with KVM_CAP_SET_GUEST_DEBUG */
+#define KVM_SET_GUEST_DEBUG       _IOW(KVMIO,  0x9b, struct kvm_guest_debug)
+/* MCE for x86 */
+#define KVM_X86_SETUP_MCE         _IOW(KVMIO,  0x9c, __u64)
+#define KVM_X86_GET_MCE_CAP_SUPPORTED _IOR(KVMIO,  0x9d, __u64)
+#define KVM_X86_SET_MCE           _IOW(KVMIO,  0x9e, struct kvm_x86_mce)
+
+/*
+ * Deprecated interfaces
+ */
+struct kvm_breakpoint {
+	__u32 enabled;
+	__u32 padding;
+	__u64 address;
+};
+
+struct kvm_debug_guest {
+	__u32 enabled;
+	__u32 pad;
+	struct kvm_breakpoint breakpoints[4];
+	__u32 singlestep;
+};
+
+#define __KVM_DEPRECATED_DEBUG_GUEST _IOW(KVMIO,  0x87, struct kvm_debug_guest)
+
+#define KVM_IA64_VCPU_GET_STACK   _IOR(KVMIO,  0x9a, void *)
+#define KVM_IA64_VCPU_SET_STACK   _IOW(KVMIO,  0x9b, void *)
+
+#define KVM_GET_PIT2   _IOR(KVMIO,   0x9f, struct kvm_pit_state2)
+#define KVM_SET_PIT2   _IOW(KVMIO,   0xa0, struct kvm_pit_state2)
+
+#define KVM_TRC_INJ_VIRQ         (KVM_TRC_HANDLER + 0x02)
+#define KVM_TRC_REDELIVER_EVT    (KVM_TRC_HANDLER + 0x03)
+#define KVM_TRC_PEND_INTR        (KVM_TRC_HANDLER + 0x04)
+#define KVM_TRC_IO_READ          (KVM_TRC_HANDLER + 0x05)
+#define KVM_TRC_IO_WRITE         (KVM_TRC_HANDLER + 0x06)
+#define KVM_TRC_CR_READ          (KVM_TRC_HANDLER + 0x07)
+#define KVM_TRC_CR_WRITE         (KVM_TRC_HANDLER + 0x08)
+#define KVM_TRC_DR_READ          (KVM_TRC_HANDLER + 0x09)
+#define KVM_TRC_DR_WRITE         (KVM_TRC_HANDLER + 0x0A)
+#define KVM_TRC_MSR_READ         (KVM_TRC_HANDLER + 0x0B)
+#define KVM_TRC_MSR_WRITE        (KVM_TRC_HANDLER + 0x0C)
+#define KVM_TRC_CPUID            (KVM_TRC_HANDLER + 0x0D)
+#define KVM_TRC_INTR             (KVM_TRC_HANDLER + 0x0E)
+#define KVM_TRC_NMI              (KVM_TRC_HANDLER + 0x0F)
+#define KVM_TRC_VMMCALL          (KVM_TRC_HANDLER + 0x10)
+#define KVM_TRC_HLT              (KVM_TRC_HANDLER + 0x11)
+#define KVM_TRC_CLTS             (KVM_TRC_HANDLER + 0x12)
+#define KVM_TRC_LMSW             (KVM_TRC_HANDLER + 0x13)
+#define KVM_TRC_APIC_ACCESS      (KVM_TRC_HANDLER + 0x14)
+#define KVM_TRC_TDP_FAULT        (KVM_TRC_HANDLER + 0x15)
+#define KVM_TRC_GTLB_WRITE       (KVM_TRC_HANDLER + 0x16)
+#define KVM_TRC_STLB_WRITE       (KVM_TRC_HANDLER + 0x17)
+#define KVM_TRC_STLB_INVAL       (KVM_TRC_HANDLER + 0x18)
+#define KVM_TRC_PPC_INSTR        (KVM_TRC_HANDLER + 0x19)
+
+#define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
+
+struct kvm_assigned_pci_dev {
+	__u32 assigned_dev_id;
+	__u32 busnr;
+	__u32 devfn;
+	__u32 flags;
+	union {
+		__u32 reserved[12];
+	};
+};
+
+#define KVM_DEV_IRQ_HOST_INTX    (1 << 0)
+#define KVM_DEV_IRQ_HOST_MSI     (1 << 1)
+#define KVM_DEV_IRQ_HOST_MSIX    (1 << 2)
+
+#define KVM_DEV_IRQ_GUEST_INTX   (1 << 8)
+#define KVM_DEV_IRQ_GUEST_MSI    (1 << 9)
+#define KVM_DEV_IRQ_GUEST_MSIX   (1 << 10)
+
+#define KVM_DEV_IRQ_HOST_MASK	 0x00ff
+#define KVM_DEV_IRQ_GUEST_MASK   0xff00
+
+struct kvm_assigned_irq {
+	__u32 assigned_dev_id;
+	__u32 host_irq;
+	__u32 guest_irq;
+	__u32 flags;
+	union {
+		struct {
+			__u32 addr_lo;
+			__u32 addr_hi;
+			__u32 data;
+		} guest_msi;
+		__u32 reserved[12];
+	};
+};
+
+
+struct kvm_assigned_msix_nr {
+	__u32 assigned_dev_id;
+	__u16 entry_nr;
+	__u16 padding;
+};
+
+#define KVM_MAX_MSIX_PER_DEV		256
+struct kvm_assigned_msix_entry {
+	__u32 assigned_dev_id;
+	__u32 gsi;
+	__u16 entry; /* The index of entry in the MSI-X table */
+	__u16 padding[3];
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/kvm_para.h clean_modified/linux-2.6.32/usr/include/linux/kvm_para.h
--- linux-2.6.32/usr/include/linux/kvm_para.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/kvm_para.h	2019-04-14 13:24:03.026651212 -0500
@@ -0,0 +1,27 @@
+#ifndef __LINUX_KVM_PARA_H
+#define __LINUX_KVM_PARA_H
+
+/*
+ * This header file provides a method for making a hypercall to the host
+ * Architectures should define:
+ * - kvm_hypercall0, kvm_hypercall1...
+ * - kvm_arch_para_features
+ * - kvm_para_available
+ */
+
+/* Return values for hypercalls */
+#define KVM_ENOSYS		1000
+#define KVM_EFAULT		EFAULT
+#define KVM_E2BIG		E2BIG
+#define KVM_EPERM		EPERM
+
+#define KVM_HC_VAPIC_POLL_IRQ		1
+#define KVM_HC_MMU_OP			2
+
+/*
+ * hypercalls use architecture specific
+ */
+#include <asm/kvm_para.h>
+
+#endif /* __LINUX_KVM_PARA_H */
+
diff -uNr linux-2.6.32/usr/include/linux/limits.h clean_modified/linux-2.6.32/usr/include/linux/limits.h
--- linux-2.6.32/usr/include/linux/limits.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/limits.h	2019-04-14 13:24:03.026651212 -0500
@@ -0,0 +1,20 @@
+#ifndef _LINUX_LIMITS_H
+#define _LINUX_LIMITS_H
+
+#define NR_OPEN	        1024
+
+#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
+#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
+#define LINK_MAX         127	/* # links a file may have */
+#define MAX_CANON        255	/* size of the canonical input queue */
+#define MAX_INPUT        255	/* size of the type-ahead buffer */
+#define NAME_MAX         255	/* # chars in a file name */
+#define PATH_MAX        4096	/* # chars in a path name including nul */
+#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
+#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
+#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
+#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
+
+#define RTSIG_MAX	  32
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/llc.h clean_modified/linux-2.6.32/usr/include/linux/llc.h
--- linux-2.6.32/usr/include/linux/llc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/llc.h	2019-04-14 13:24:03.026651212 -0500
@@ -0,0 +1,73 @@
+#ifndef __LINUX_LLC_H
+#define __LINUX_LLC_H
+/*
+ * IEEE 802.2 User Interface SAPs for Linux, data structures and indicators.
+ *
+ * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#define __LLC_SOCK_SIZE__ 16	/* sizeof(sockaddr_llc), word align. */
+struct sockaddr_llc {
+	sa_family_t     sllc_family;	/* AF_LLC */
+	sa_family_t	sllc_arphrd;	/* ARPHRD_ETHER */
+	unsigned char   sllc_test;
+	unsigned char   sllc_xid;
+	unsigned char	sllc_ua;	/* UA data, only for SOCK_STREAM. */
+	unsigned char   sllc_sap;
+	unsigned char   sllc_mac[IFHWADDRLEN];
+	unsigned char   __pad[__LLC_SOCK_SIZE__ - sizeof(sa_family_t) * 2 -
+			      sizeof(unsigned char) * 4 - IFHWADDRLEN];
+};
+
+/* sockopt definitions. */
+enum llc_sockopts {
+	LLC_OPT_UNKNOWN = 0,
+	LLC_OPT_RETRY,		/* max retrans attempts. */
+	LLC_OPT_SIZE,		/* max PDU size (octets). */
+	LLC_OPT_ACK_TMR_EXP,	/* ack expire time (secs). */
+	LLC_OPT_P_TMR_EXP,	/* pf cycle expire time (secs). */
+	LLC_OPT_REJ_TMR_EXP,	/* rej sent expire time (secs). */
+	LLC_OPT_BUSY_TMR_EXP,	/* busy state expire time (secs). */
+	LLC_OPT_TX_WIN,		/* tx window size. */
+	LLC_OPT_RX_WIN,		/* rx window size. */
+	LLC_OPT_MAX
+};
+
+#define LLC_OPT_MAX_RETRY	 100
+#define LLC_OPT_MAX_SIZE	4196
+#define LLC_OPT_MAX_WIN		 127
+#define LLC_OPT_MAX_ACK_TMR_EXP	  60
+#define LLC_OPT_MAX_P_TMR_EXP	  60
+#define LLC_OPT_MAX_REJ_TMR_EXP	  60
+#define LLC_OPT_MAX_BUSY_TMR_EXP  60
+
+/* LLC SAP types. */
+#define LLC_SAP_NULL	0x00		/* NULL SAP. 			*/
+#define LLC_SAP_LLC	0x02		/* LLC Sublayer Management. 	*/
+#define LLC_SAP_SNA	0x04		/* SNA Path Control. 		*/
+#define LLC_SAP_PNM	0x0E		/* Proway Network Management.	*/	
+#define LLC_SAP_IP	0x06		/* TCP/IP. 			*/
+#define LLC_SAP_BSPAN	0x42		/* Bridge Spanning Tree Proto	*/
+#define LLC_SAP_MMS	0x4E		/* Manufacturing Message Srv.	*/
+#define LLC_SAP_8208	0x7E		/* ISO 8208			*/
+#define LLC_SAP_3COM	0x80		/* 3COM. 			*/
+#define LLC_SAP_PRO	0x8E		/* Proway Active Station List	*/
+#define LLC_SAP_SNAP	0xAA		/* SNAP. 			*/
+#define LLC_SAP_BANYAN	0xBC		/* Banyan. 			*/
+#define LLC_SAP_IPX	0xE0		/* IPX/SPX. 			*/
+#define LLC_SAP_NETBEUI	0xF0		/* NetBEUI. 			*/
+#define LLC_SAP_LANMGR	0xF4		/* LanManager. 			*/
+#define LLC_SAP_IMPL	0xF8		/* IMPL				*/
+#define LLC_SAP_DISC	0xFC		/* Discovery			*/
+#define LLC_SAP_OSI	0xFE		/* OSI Network Layers. 		*/
+#define LLC_SAP_LAR	0xDC		/* LAN Address Resolution 	*/
+#define LLC_SAP_RM	0xD4		/* Resource Management 		*/
+#define LLC_SAP_GLOBAL	0xFF		/* Global SAP. 			*/
+
+#endif /* __LINUX_LLC_H */
diff -uNr linux-2.6.32/usr/include/linux/loop.h clean_modified/linux-2.6.32/usr/include/linux/loop.h
--- linux-2.6.32/usr/include/linux/loop.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/loop.h	2019-04-14 13:24:03.027626702 -0500
@@ -0,0 +1,90 @@
+#ifndef _LINUX_LOOP_H
+#define _LINUX_LOOP_H
+
+/*
+ * include/linux/loop.h
+ *
+ * Written by Theodore Ts'o, 3/29/93.
+ *
+ * Copyright 1993 by Theodore Ts'o.  Redistribution of this file is
+ * permitted under the GNU General Public License.
+ */
+
+#define LO_NAME_SIZE	64
+#define LO_KEY_SIZE	32
+
+
+/*
+ * Loop flags
+ */
+enum {
+	LO_FLAGS_READ_ONLY	= 1,
+	LO_FLAGS_USE_AOPS	= 2,
+	LO_FLAGS_AUTOCLEAR	= 4,
+};
+
+#include <asm/posix_types.h>	/* for __kernel_old_dev_t */
+#include <linux/types.h>	/* for __u64 */
+
+/* Backwards compatibility version */
+struct loop_info {
+	int		   lo_number;		/* ioctl r/o */
+	__kernel_old_dev_t lo_device; 		/* ioctl r/o */
+	unsigned long	   lo_inode; 		/* ioctl r/o */
+	__kernel_old_dev_t lo_rdevice; 		/* ioctl r/o */
+	int		   lo_offset;
+	int		   lo_encrypt_type;
+	int		   lo_encrypt_key_size; 	/* ioctl w/o */
+	int		   lo_flags;			/* ioctl r/o */
+	char		   lo_name[LO_NAME_SIZE];
+	unsigned char	   lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */
+	unsigned long	   lo_init[2];
+	char		   reserved[4];
+};
+
+struct loop_info64 {
+	__u64		   lo_device;			/* ioctl r/o */
+	__u64		   lo_inode;			/* ioctl r/o */
+	__u64		   lo_rdevice;			/* ioctl r/o */
+	__u64		   lo_offset;
+	__u64		   lo_sizelimit;/* bytes, 0 == max available */
+	__u32		   lo_number;			/* ioctl r/o */
+	__u32		   lo_encrypt_type;
+	__u32		   lo_encrypt_key_size;		/* ioctl w/o */
+	__u32		   lo_flags;			/* ioctl r/o */
+	__u8		   lo_file_name[LO_NAME_SIZE];
+	__u8		   lo_crypt_name[LO_NAME_SIZE];
+	__u8		   lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */
+	__u64		   lo_init[2];
+};
+
+/*
+ * Loop filter types
+ */
+
+#define LO_CRYPT_NONE		0
+#define LO_CRYPT_XOR		1
+#define LO_CRYPT_DES		2
+#define LO_CRYPT_FISH2		3    /* Twofish encryption */
+#define LO_CRYPT_BLOW		4
+#define LO_CRYPT_CAST128	5
+#define LO_CRYPT_IDEA		6
+#define LO_CRYPT_DUMMY		9
+#define LO_CRYPT_SKIPJACK	10
+#define LO_CRYPT_CRYPTOAPI	18
+#define MAX_LO_CRYPT		20
+
+/*
+ * IOCTL commands --- we will commandeer 0x4C ('L')
+ */
+
+#define LOOP_SET_FD		0x4C00
+#define LOOP_CLR_FD		0x4C01
+#define LOOP_SET_STATUS		0x4C02
+#define LOOP_GET_STATUS		0x4C03
+#define LOOP_SET_STATUS64	0x4C04
+#define LOOP_GET_STATUS64	0x4C05
+#define LOOP_CHANGE_FD		0x4C06
+#define LOOP_SET_CAPACITY	0x4C07
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/lp.h clean_modified/linux-2.6.32/usr/include/linux/lp.h
--- linux-2.6.32/usr/include/linux/lp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/lp.h	2019-04-14 13:24:03.027626702 -0500
@@ -0,0 +1,100 @@
+#ifndef _LINUX_LP_H
+#define _LINUX_LP_H
+
+/*
+ * usr/include/linux/lp.h c.1991-1992 James Wiegand
+ * many modifications copyright (C) 1992 Michael K. Johnson
+ * Interrupt support added 1993 Nigel Gamble
+ * Removed 8255 status defines from inside __KERNEL__ Marcelo Tosatti 
+ */
+
+/*
+ * Per POSIX guidelines, this module reserves the LP and lp prefixes
+ * These are the lp_table[minor].flags flags...
+ */
+#define LP_EXIST 0x0001
+#define LP_SELEC 0x0002
+#define LP_BUSY	 0x0004
+#define LP_BUSY_BIT_POS 2
+#define LP_OFFL	 0x0008
+#define LP_NOPA  0x0010
+#define LP_ERR   0x0020
+#define LP_ABORT 0x0040
+#define LP_CAREFUL 0x0080 /* obsoleted -arca */
+#define LP_ABORTOPEN 0x0100
+
+#define LP_TRUST_IRQ_  0x0200 /* obsolete */
+#define LP_NO_REVERSE  0x0400 /* No reverse mode available. */
+#define LP_DATA_AVAIL  0x0800 /* Data is available. */
+
+/* 
+ * bit defines for 8255 status port
+ * base + 1
+ * accessed with LP_S(minor), which gets the byte...
+ */
+#define LP_PBUSY	0x80  /* inverted input, active high */
+#define LP_PACK		0x40  /* unchanged input, active low */
+#define LP_POUTPA	0x20  /* unchanged input, active high */
+#define LP_PSELECD	0x10  /* unchanged input, active high */
+#define LP_PERRORP	0x08  /* unchanged input, active low */
+
+/* timeout for each character.  This is relative to bus cycles -- it
+ * is the count in a busy loop.  THIS IS THE VALUE TO CHANGE if you
+ * have extremely slow printing, or if the machine seems to slow down
+ * a lot when you print.  If you have slow printing, increase this
+ * number and recompile, and if your system gets bogged down, decrease
+ * this number.  This can be changed with the tunelp(8) command as well.
+ */
+
+#define LP_INIT_CHAR 1000
+
+/* The parallel port specs apparently say that there needs to be
+ * a .5usec wait before and after the strobe.
+ */
+
+#define LP_INIT_WAIT 1
+
+/* This is the amount of time that the driver waits for the printer to
+ * catch up when the printer's buffer appears to be filled.  If you
+ * want to tune this and have a fast printer (i.e. HPIIIP), decrease
+ * this number, and if you have a slow printer, increase this number.
+ * This is in hundredths of a second, the default 2 being .05 second.
+ * Or use the tunelp(8) command, which is especially nice if you want
+ * change back and forth between character and graphics printing, which
+ * are wildly different...
+ */
+
+#define LP_INIT_TIME 2
+
+/* IOCTL numbers */
+#define LPCHAR   0x0601  /* corresponds to LP_INIT_CHAR */
+#define LPTIME   0x0602  /* corresponds to LP_INIT_TIME */
+#define LPABORT  0x0604  /* call with TRUE arg to abort on error,
+			    FALSE to retry.  Default is retry.  */
+#define LPSETIRQ 0x0605  /* call with new IRQ number,
+			    or 0 for polling (no IRQ) */
+#define LPGETIRQ 0x0606  /* get the current IRQ number */
+#define LPWAIT   0x0608  /* corresponds to LP_INIT_WAIT */
+/* NOTE: LPCAREFUL is obsoleted and it' s always the default right now -arca */
+#define LPCAREFUL   0x0609  /* call with TRUE arg to require out-of-paper, off-
+			    line, and error indicators good on all writes,
+			    FALSE to ignore them.  Default is ignore. */
+#define LPABORTOPEN 0x060a  /* call with TRUE arg to abort open() on error,
+			    FALSE to ignore error.  Default is ignore.  */
+#define LPGETSTATUS 0x060b  /* return LP_S(minor) */
+#define LPRESET     0x060c  /* reset printer */
+#ifdef LP_STATS
+#define LPGETSTATS  0x060d  /* get statistics (struct lp_stats) */
+#endif
+#define LPGETFLAGS  0x060e  /* get status flags */
+#define LPSETTIMEOUT 0x060f /* set parport timeout */
+
+/* timeout for printk'ing a timeout, in jiffies (100ths of a second).
+   This is also used for re-checking error conditions if LP_ABORT is
+   not set.  This is the default behavior. */
+
+#define LP_TIMEOUT_INTERRUPT	(60 * HZ)
+#define LP_TIMEOUT_POLLED	(10 * HZ)
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/magic.h clean_modified/linux-2.6.32/usr/include/linux/magic.h
--- linux-2.6.32/usr/include/linux/magic.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/magic.h	2019-04-14 13:24:03.027626702 -0500
@@ -0,0 +1,62 @@
+#ifndef __LINUX_MAGIC_H__
+#define __LINUX_MAGIC_H__
+
+#define ADFS_SUPER_MAGIC	0xadf5
+#define AFFS_SUPER_MAGIC	0xadff
+#define AFS_SUPER_MAGIC                0x5346414F
+#define AUTOFS_SUPER_MAGIC	0x0187
+#define CODA_SUPER_MAGIC	0x73757245
+#define CRAMFS_MAGIC		0x28cd3d45	/* some random number */
+#define CRAMFS_MAGIC_WEND	0x453dcd28	/* magic number with the wrong endianess */
+#define DEBUGFS_MAGIC          0x64626720
+#define SYSFS_MAGIC		0x62656572
+#define SECURITYFS_MAGIC	0x73636673
+#define SELINUX_MAGIC		0xf97cff8c
+#define RAMFS_MAGIC		0x858458f6	/* some random number */
+#define TMPFS_MAGIC		0x01021994
+#define HUGETLBFS_MAGIC 	0x958458f6	/* some random number */
+#define SQUASHFS_MAGIC		0x73717368
+#define EFS_SUPER_MAGIC		0x414A53
+#define EXT2_SUPER_MAGIC	0xEF53
+#define EXT3_SUPER_MAGIC	0xEF53
+#define XENFS_SUPER_MAGIC	0xabba1974
+#define EXT4_SUPER_MAGIC	0xEF53
+#define BTRFS_SUPER_MAGIC	0x9123683E
+#define HPFS_SUPER_MAGIC	0xf995e849
+#define ISOFS_SUPER_MAGIC	0x9660
+#define JFFS2_SUPER_MAGIC	0x72b6
+#define ANON_INODE_FS_MAGIC	0x09041934
+
+#define MINIX_SUPER_MAGIC	0x137F		/* original minix fs */
+#define MINIX_SUPER_MAGIC2	0x138F		/* minix fs, 30 char names */
+#define MINIX2_SUPER_MAGIC	0x2468		/* minix V2 fs */
+#define MINIX2_SUPER_MAGIC2	0x2478		/* minix V2 fs, 30 char names */
+#define MINIX3_SUPER_MAGIC	0x4d5a		/* minix V3 fs */
+
+#define MSDOS_SUPER_MAGIC	0x4d44		/* MD */
+#define NCP_SUPER_MAGIC		0x564c		/* Guess, what 0x564c is :-) */
+#define NFS_SUPER_MAGIC		0x6969
+#define OPENPROM_SUPER_MAGIC	0x9fa1
+#define PROC_SUPER_MAGIC	0x9fa0
+#define QNX4_SUPER_MAGIC	0x002f		/* qnx4 fs detection */
+
+#define REISERFS_SUPER_MAGIC	0x52654973	/* used by gcc */
+					/* used by file system utilities that
+	                                   look at the superblock, etc.  */
+#define REISERFS_SUPER_MAGIC_STRING	"ReIsErFs"
+#define REISER2FS_SUPER_MAGIC_STRING	"ReIsEr2Fs"
+#define REISER2FS_JR_SUPER_MAGIC_STRING	"ReIsEr3Fs"
+
+#define SMB_SUPER_MAGIC		0x517B
+#define USBDEVICE_SUPER_MAGIC	0x9fa2
+#define CGROUP_SUPER_MAGIC	0x27e0eb
+
+#define FUTEXFS_SUPER_MAGIC	0xBAD1DEA
+#define INOTIFYFS_SUPER_MAGIC	0x2BAD1DEA
+
+#define STACK_END_MAGIC		0x57AC6E9D
+
+#define DEVPTS_SUPER_MAGIC	0x1cd1
+#define SOCKFS_MAGIC		0x534F434B
+
+#endif /* __LINUX_MAGIC_H__ */
diff -uNr linux-2.6.32/usr/include/linux/major.h clean_modified/linux-2.6.32/usr/include/linux/major.h
--- linux-2.6.32/usr/include/linux/major.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/major.h	2019-04-14 13:24:03.028601082 -0500
@@ -0,0 +1,177 @@
+#ifndef _LINUX_MAJOR_H
+#define _LINUX_MAJOR_H
+
+/*
+ * This file has definitions for major device numbers.
+ * For the device number assignments, see Documentation/devices.txt.
+ */
+
+#define UNNAMED_MAJOR		0
+#define MEM_MAJOR		1
+#define RAMDISK_MAJOR		1
+#define FLOPPY_MAJOR		2
+#define PTY_MASTER_MAJOR	2
+#define IDE0_MAJOR		3
+#define HD_MAJOR		IDE0_MAJOR
+#define PTY_SLAVE_MAJOR		3
+#define TTY_MAJOR		4
+#define TTYAUX_MAJOR		5
+#define LP_MAJOR		6
+#define VCS_MAJOR		7
+#define LOOP_MAJOR		7
+#define SCSI_DISK0_MAJOR	8
+#define SCSI_TAPE_MAJOR		9
+#define MD_MAJOR		9
+#define MISC_MAJOR		10
+#define SCSI_CDROM_MAJOR	11
+#define MUX_MAJOR		11	/* PA-RISC only */
+#define XT_DISK_MAJOR		13
+#define INPUT_MAJOR		13
+#define SOUND_MAJOR		14
+#define CDU31A_CDROM_MAJOR	15
+#define JOYSTICK_MAJOR		15
+#define GOLDSTAR_CDROM_MAJOR	16
+#define OPTICS_CDROM_MAJOR	17
+#define SANYO_CDROM_MAJOR	18
+#define CYCLADES_MAJOR		19
+#define CYCLADESAUX_MAJOR	20
+#define MITSUMI_X_CDROM_MAJOR	20
+#define MFM_ACORN_MAJOR		21	/* ARM Linux /dev/mfm */
+#define SCSI_GENERIC_MAJOR	21
+#define IDE1_MAJOR		22
+#define DIGICU_MAJOR		22
+#define DIGI_MAJOR		23
+#define MITSUMI_CDROM_MAJOR	23
+#define CDU535_CDROM_MAJOR	24
+#define STL_SERIALMAJOR		24
+#define MATSUSHITA_CDROM_MAJOR	25
+#define STL_CALLOUTMAJOR	25
+#define MATSUSHITA_CDROM2_MAJOR	26
+#define QIC117_TAPE_MAJOR	27
+#define MATSUSHITA_CDROM3_MAJOR	27
+#define MATSUSHITA_CDROM4_MAJOR	28
+#define STL_SIOMEMMAJOR		28
+#define ACSI_MAJOR		28
+#define AZTECH_CDROM_MAJOR	29
+#define FB_MAJOR		29   /* /dev/fb* framebuffers */
+#define CM206_CDROM_MAJOR	32
+#define IDE2_MAJOR		33
+#define IDE3_MAJOR		34
+#define Z8530_MAJOR		34
+#define XPRAM_MAJOR		35   /* Expanded storage on S/390: "slow ram"*/
+#define NETLINK_MAJOR		36
+#define PS2ESDI_MAJOR		36
+#define IDETAPE_MAJOR		37
+#define Z2RAM_MAJOR		37
+#define APBLOCK_MAJOR		38   /* AP1000 Block device */
+#define DDV_MAJOR		39   /* AP1000 DDV block device */
+#define NBD_MAJOR		43   /* Network block device	*/
+#define RISCOM8_NORMAL_MAJOR	48
+#define DAC960_MAJOR		48   /* 48..55 */
+#define RISCOM8_CALLOUT_MAJOR	49
+#define MKISS_MAJOR		55
+#define DSP56K_MAJOR		55   /* DSP56001 processor device */
+
+#define IDE4_MAJOR		56
+#define IDE5_MAJOR		57
+
+#define SCSI_DISK1_MAJOR	65
+#define SCSI_DISK2_MAJOR	66
+#define SCSI_DISK3_MAJOR	67
+#define SCSI_DISK4_MAJOR	68
+#define SCSI_DISK5_MAJOR	69
+#define SCSI_DISK6_MAJOR	70
+#define SCSI_DISK7_MAJOR	71
+
+#define COMPAQ_SMART2_MAJOR	72
+#define COMPAQ_SMART2_MAJOR1	73
+#define COMPAQ_SMART2_MAJOR2	74
+#define COMPAQ_SMART2_MAJOR3	75
+#define COMPAQ_SMART2_MAJOR4	76
+#define COMPAQ_SMART2_MAJOR5	77
+#define COMPAQ_SMART2_MAJOR6	78
+#define COMPAQ_SMART2_MAJOR7	79
+
+#define SPECIALIX_NORMAL_MAJOR	75
+#define SPECIALIX_CALLOUT_MAJOR	76
+
+#define AURORA_MAJOR		79
+
+#define I2O_MAJOR		80	/* 80->87 */
+
+#define SHMIQ_MAJOR		85   /* Linux/mips, SGI /dev/shmiq */
+#define SCSI_CHANGER_MAJOR      86
+
+#define IDE6_MAJOR		88
+#define IDE7_MAJOR		89
+#define IDE8_MAJOR		90
+#define IDE9_MAJOR		91
+
+#define DASD_MAJOR		94
+
+#define MDISK_MAJOR		95
+
+#define UBD_MAJOR		98
+
+#define PP_MAJOR		99
+#define JSFD_MAJOR		99
+
+#define PHONE_MAJOR		100
+
+#define COMPAQ_CISS_MAJOR	104
+#define COMPAQ_CISS_MAJOR1	105
+#define COMPAQ_CISS_MAJOR2      106
+#define COMPAQ_CISS_MAJOR3      107
+#define COMPAQ_CISS_MAJOR4      108
+#define COMPAQ_CISS_MAJOR5      109
+#define COMPAQ_CISS_MAJOR6      110
+#define COMPAQ_CISS_MAJOR7      111
+
+#define VIODASD_MAJOR		112
+#define VIOCD_MAJOR		113
+
+#define ATARAID_MAJOR		114
+
+#define SCSI_DISK8_MAJOR	128
+#define SCSI_DISK9_MAJOR	129
+#define SCSI_DISK10_MAJOR	130
+#define SCSI_DISK11_MAJOR	131
+#define SCSI_DISK12_MAJOR	132
+#define SCSI_DISK13_MAJOR	133
+#define SCSI_DISK14_MAJOR	134
+#define SCSI_DISK15_MAJOR	135
+
+#define UNIX98_PTY_MASTER_MAJOR	128
+#define UNIX98_PTY_MAJOR_COUNT	8
+#define UNIX98_PTY_SLAVE_MAJOR	(UNIX98_PTY_MASTER_MAJOR+UNIX98_PTY_MAJOR_COUNT)
+
+#define DRBD_MAJOR		147
+#define RTF_MAJOR		150
+#define RAW_MAJOR		162
+
+#define USB_ACM_MAJOR		166
+#define USB_ACM_AUX_MAJOR	167
+#define USB_CHAR_MAJOR		180
+
+#define MMC_BLOCK_MAJOR		179
+
+#define VXVM_MAJOR		199	/* VERITAS volume i/o driver    */
+#define VXSPEC_MAJOR		200	/* VERITAS volume config driver */
+#define VXDMP_MAJOR		201	/* VERITAS volume multipath driver */
+
+#define XENVBD_MAJOR		202	/* Xen virtual block device */
+
+#define MSR_MAJOR		202
+#define CPUID_MAJOR		203
+
+#define OSST_MAJOR		206	/* OnStream-SCx0 SCSI tape */
+
+#define IBM_TTY3270_MAJOR	227
+#define IBM_FS3270_MAJOR	228
+
+#define VIOTAPE_MAJOR		230
+
+#define BLOCK_EXT_MAJOR		259
+#define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/map_to_7segment.h clean_modified/linux-2.6.32/usr/include/linux/map_to_7segment.h
--- linux-2.6.32/usr/include/linux/map_to_7segment.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/map_to_7segment.h	2019-04-14 13:24:03.028601082 -0500
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2005 Henk Vergonet <Henk.Vergonet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef MAP_TO_7SEGMENT_H
+#define MAP_TO_7SEGMENT_H
+
+/* This file provides translation primitives and tables for the conversion
+ * of (ASCII) characters to a 7-segments notation.
+ *
+ * The 7 segment's wikipedia notation below is used as standard.
+ * See: http://en.wikipedia.org/wiki/Seven_segment_display
+ *
+ * Notation:	+-a-+
+ *		f   b
+ *		+-g-+
+ *		e   c
+ *		+-d-+
+ *
+ * Usage:
+ *
+ *   Register a map variable, and fill it with a character set:
+ *	static SEG7_DEFAULT_MAP(map_seg7);
+ *
+ *
+ *   Then use for conversion:
+ *	seg7 = map_to_seg7(&map_seg7, some_char);
+ *	...
+ *
+ * In device drivers it is recommended, if required, to make the char map
+ * accessible via the sysfs interface using the following scheme:
+ *
+ * static ssize_t show_map(struct device *dev, char *buf) {
+ *	memcpy(buf, &map_seg7, sizeof(map_seg7));
+ *	return sizeof(map_seg7);
+ * }
+ * static ssize_t store_map(struct device *dev, const char *buf, size_t cnt) {
+ *	if(cnt != sizeof(map_seg7))
+ *		return -EINVAL;
+ *	memcpy(&map_seg7, buf, cnt);
+ *	return cnt;
+ * }
+ * static DEVICE_ATTR(map_seg7, PERMS_RW, show_map, store_map);
+ *
+ * History:
+ * 2005-05-31	RFC linux-kernel@vger.kernel.org
+ */
+#include <linux/errno.h>
+
+
+#define BIT_SEG7_A		0
+#define BIT_SEG7_B		1
+#define BIT_SEG7_C		2
+#define BIT_SEG7_D		3
+#define BIT_SEG7_E		4
+#define BIT_SEG7_F		5
+#define BIT_SEG7_G		6
+#define BIT_SEG7_RESERVED	7
+
+struct seg7_conversion_map {
+	unsigned char	table[128];
+};
+
+static __inline__ int map_to_seg7(struct seg7_conversion_map *map, int c)
+{
+	return c >= 0 && c < sizeof(map->table) ? map->table[c] : -EINVAL;
+}
+
+#define SEG7_CONVERSION_MAP(_name, _map)	\
+	struct seg7_conversion_map _name = { .table = { _map } }
+
+/*
+ * It is recommended to use a facility that allows user space to redefine
+ * custom character sets for LCD devices. Please use a sysfs interface
+ * as described above.
+ */
+#define MAP_TO_SEG7_SYSFS_FILE	"map_seg7"
+
+/*******************************************************************************
+ * ASCII conversion table
+ ******************************************************************************/
+
+#define _SEG7(l,a,b,c,d,e,f,g)	\
+      (	a<<BIT_SEG7_A |	b<<BIT_SEG7_B |	c<<BIT_SEG7_C |	d<<BIT_SEG7_D |	\
+	e<<BIT_SEG7_E |	f<<BIT_SEG7_F |	g<<BIT_SEG7_G )
+
+#define _MAP_0_32_ASCII_SEG7_NON_PRINTABLE	\
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+
+#define _MAP_33_47_ASCII_SEG7_SYMBOL		\
+ _SEG7('!',0,0,0,0,1,1,0), _SEG7('"',0,1,0,0,0,1,0), _SEG7('#',0,1,1,0,1,1,0),\
+ _SEG7('$',1,0,1,1,0,1,1), _SEG7('%',0,0,1,0,0,1,0), _SEG7('&',1,0,1,1,1,1,1),\
+ _SEG7('\'',0,0,0,0,0,1,0),_SEG7('(',1,0,0,1,1,1,0), _SEG7(')',1,1,1,1,0,0,0),\
+ _SEG7('*',0,1,1,0,1,1,1), _SEG7('+',0,1,1,0,0,0,1), _SEG7(',',0,0,0,0,1,0,0),\
+ _SEG7('-',0,0,0,0,0,0,1), _SEG7('.',0,0,0,0,1,0,0), _SEG7('/',0,1,0,0,1,0,1),
+
+#define _MAP_48_57_ASCII_SEG7_NUMERIC		\
+ _SEG7('0',1,1,1,1,1,1,0), _SEG7('1',0,1,1,0,0,0,0), _SEG7('2',1,1,0,1,1,0,1),\
+ _SEG7('3',1,1,1,1,0,0,1), _SEG7('4',0,1,1,0,0,1,1), _SEG7('5',1,0,1,1,0,1,1),\
+ _SEG7('6',1,0,1,1,1,1,1), _SEG7('7',1,1,1,0,0,0,0), _SEG7('8',1,1,1,1,1,1,1),\
+ _SEG7('9',1,1,1,1,0,1,1),
+
+#define _MAP_58_64_ASCII_SEG7_SYMBOL		\
+ _SEG7(':',0,0,0,1,0,0,1), _SEG7(';',0,0,0,1,0,0,1), _SEG7('<',1,0,0,0,0,1,1),\
+ _SEG7('=',0,0,0,1,0,0,1), _SEG7('>',1,1,0,0,0,0,1), _SEG7('?',1,1,1,0,0,1,0),\
+ _SEG7('@',1,1,0,1,1,1,1),
+
+#define _MAP_65_90_ASCII_SEG7_ALPHA_UPPR	\
+ _SEG7('A',1,1,1,0,1,1,1), _SEG7('B',1,1,1,1,1,1,1), _SEG7('C',1,0,0,1,1,1,0),\
+ _SEG7('D',1,1,1,1,1,1,0), _SEG7('E',1,0,0,1,1,1,1), _SEG7('F',1,0,0,0,1,1,1),\
+ _SEG7('G',1,1,1,1,0,1,1), _SEG7('H',0,1,1,0,1,1,1), _SEG7('I',0,1,1,0,0,0,0),\
+ _SEG7('J',0,1,1,1,0,0,0), _SEG7('K',0,1,1,0,1,1,1), _SEG7('L',0,0,0,1,1,1,0),\
+ _SEG7('M',1,1,1,0,1,1,0), _SEG7('N',1,1,1,0,1,1,0), _SEG7('O',1,1,1,1,1,1,0),\
+ _SEG7('P',1,1,0,0,1,1,1), _SEG7('Q',1,1,1,1,1,1,0), _SEG7('R',1,1,1,0,1,1,1),\
+ _SEG7('S',1,0,1,1,0,1,1), _SEG7('T',0,0,0,1,1,1,1), _SEG7('U',0,1,1,1,1,1,0),\
+ _SEG7('V',0,1,1,1,1,1,0), _SEG7('W',0,1,1,1,1,1,1), _SEG7('X',0,1,1,0,1,1,1),\
+ _SEG7('Y',0,1,1,0,0,1,1), _SEG7('Z',1,1,0,1,1,0,1),
+
+#define _MAP_91_96_ASCII_SEG7_SYMBOL		\
+ _SEG7('[',1,0,0,1,1,1,0), _SEG7('\\',0,0,1,0,0,1,1),_SEG7(']',1,1,1,1,0,0,0),\
+ _SEG7('^',1,1,0,0,0,1,0), _SEG7('_',0,0,0,1,0,0,0), _SEG7('`',0,1,0,0,0,0,0),
+
+#define _MAP_97_122_ASCII_SEG7_ALPHA_LOWER	\
+ _SEG7('A',1,1,1,0,1,1,1), _SEG7('b',0,0,1,1,1,1,1), _SEG7('c',0,0,0,1,1,0,1),\
+ _SEG7('d',0,1,1,1,1,0,1), _SEG7('E',1,0,0,1,1,1,1), _SEG7('F',1,0,0,0,1,1,1),\
+ _SEG7('G',1,1,1,1,0,1,1), _SEG7('h',0,0,1,0,1,1,1), _SEG7('i',0,0,1,0,0,0,0),\
+ _SEG7('j',0,0,1,1,0,0,0), _SEG7('k',0,0,1,0,1,1,1), _SEG7('L',0,0,0,1,1,1,0),\
+ _SEG7('M',1,1,1,0,1,1,0), _SEG7('n',0,0,1,0,1,0,1), _SEG7('o',0,0,1,1,1,0,1),\
+ _SEG7('P',1,1,0,0,1,1,1), _SEG7('q',1,1,1,0,0,1,1), _SEG7('r',0,0,0,0,1,0,1),\
+ _SEG7('S',1,0,1,1,0,1,1), _SEG7('T',0,0,0,1,1,1,1), _SEG7('u',0,0,1,1,1,0,0),\
+ _SEG7('v',0,0,1,1,1,0,0), _SEG7('W',0,1,1,1,1,1,1), _SEG7('X',0,1,1,0,1,1,1),\
+ _SEG7('y',0,1,1,1,0,1,1), _SEG7('Z',1,1,0,1,1,0,1),
+
+#define _MAP_123_126_ASCII_SEG7_SYMBOL		\
+ _SEG7('{',1,0,0,1,1,1,0), _SEG7('|',0,0,0,0,1,1,0), _SEG7('}',1,1,1,1,0,0,0),\
+ _SEG7('~',1,0,0,0,0,0,0),
+
+/* Maps */
+
+/* This set tries to map as close as possible to the visible characteristics
+ * of the ASCII symbol, lowercase and uppercase letters may differ in
+ * presentation on the display.
+ */
+#define MAP_ASCII7SEG_ALPHANUM			\
+	_MAP_0_32_ASCII_SEG7_NON_PRINTABLE	\
+	_MAP_33_47_ASCII_SEG7_SYMBOL		\
+	_MAP_48_57_ASCII_SEG7_NUMERIC		\
+	_MAP_58_64_ASCII_SEG7_SYMBOL		\
+	_MAP_65_90_ASCII_SEG7_ALPHA_UPPR	\
+	_MAP_91_96_ASCII_SEG7_SYMBOL		\
+	_MAP_97_122_ASCII_SEG7_ALPHA_LOWER	\
+	_MAP_123_126_ASCII_SEG7_SYMBOL
+
+/* This set tries to map as close as possible to the symbolic characteristics
+ * of the ASCII character for maximum discrimination.
+ * For now this means all alpha chars are in lower case representations.
+ * (This for example facilitates the use of hex numbers with uppercase input.)
+ */
+#define MAP_ASCII7SEG_ALPHANUM_LC			\
+	_MAP_0_32_ASCII_SEG7_NON_PRINTABLE	\
+	_MAP_33_47_ASCII_SEG7_SYMBOL		\
+	_MAP_48_57_ASCII_SEG7_NUMERIC		\
+	_MAP_58_64_ASCII_SEG7_SYMBOL		\
+	_MAP_97_122_ASCII_SEG7_ALPHA_LOWER	\
+	_MAP_91_96_ASCII_SEG7_SYMBOL		\
+	_MAP_97_122_ASCII_SEG7_ALPHA_LOWER	\
+	_MAP_123_126_ASCII_SEG7_SYMBOL
+
+#define SEG7_DEFAULT_MAP(_name)		\
+	SEG7_CONVERSION_MAP(_name,MAP_ASCII7SEG_ALPHANUM)
+
+#endif	/* MAP_TO_7SEGMENT_H */
+
diff -uNr linux-2.6.32/usr/include/linux/matroxfb.h clean_modified/linux-2.6.32/usr/include/linux/matroxfb.h
--- linux-2.6.32/usr/include/linux/matroxfb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/matroxfb.h	2019-04-14 13:24:03.028601082 -0500
@@ -0,0 +1,43 @@
+#ifndef __LINUX_MATROXFB_H__
+#define __LINUX_MATROXFB_H__
+
+#include <asm/ioctl.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+struct matroxioc_output_mode {
+	__u32	output;		/* which output */
+#define MATROXFB_OUTPUT_PRIMARY		0x0000
+#define MATROXFB_OUTPUT_SECONDARY	0x0001
+#define MATROXFB_OUTPUT_DFP		0x0002
+	__u32	mode;		/* which mode */
+#define MATROXFB_OUTPUT_MODE_PAL	0x0001
+#define MATROXFB_OUTPUT_MODE_NTSC	0x0002
+#define MATROXFB_OUTPUT_MODE_MONITOR	0x0080
+};
+#define MATROXFB_SET_OUTPUT_MODE	_IOW('n',0xFA,size_t)
+#define MATROXFB_GET_OUTPUT_MODE	_IOWR('n',0xFA,size_t)
+
+/* bitfield */
+#define MATROXFB_OUTPUT_CONN_PRIMARY	(1 << MATROXFB_OUTPUT_PRIMARY)
+#define MATROXFB_OUTPUT_CONN_SECONDARY	(1 << MATROXFB_OUTPUT_SECONDARY)
+#define MATROXFB_OUTPUT_CONN_DFP	(1 << MATROXFB_OUTPUT_DFP)
+/* connect these outputs to this framebuffer */
+#define MATROXFB_SET_OUTPUT_CONNECTION	_IOW('n',0xF8,size_t)
+/* which outputs are connected to this framebuffer */
+#define MATROXFB_GET_OUTPUT_CONNECTION	_IOR('n',0xF8,size_t)
+/* which outputs are available for this framebuffer */
+#define MATROXFB_GET_AVAILABLE_OUTPUTS	_IOR('n',0xF9,size_t)
+/* which outputs exist on this framebuffer */
+#define MATROXFB_GET_ALL_OUTPUTS	_IOR('n',0xFB,size_t)
+
+enum matroxfb_ctrl_id {
+  MATROXFB_CID_TESTOUT	 = V4L2_CID_PRIVATE_BASE,
+  MATROXFB_CID_DEFLICKER,
+  MATROXFB_CID_LAST
+};
+
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/mempolicy.h clean_modified/linux-2.6.32/usr/include/linux/mempolicy.h
--- linux-2.6.32/usr/include/linux/mempolicy.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mempolicy.h	2019-04-14 13:24:03.029586405 -0500
@@ -0,0 +1,56 @@
+#ifndef _LINUX_MEMPOLICY_H
+#define _LINUX_MEMPOLICY_H 1
+
+#include <linux/errno.h>
+
+/*
+ * NUMA memory policies for Linux.
+ * Copyright 2003,2004 Andi Kleen SuSE Labs
+ */
+
+/*
+ * Both the MPOL_* mempolicy mode and the MPOL_F_* optional mode flags are
+ * passed by the user to either set_mempolicy() or mbind() in an 'int' actual.
+ * The MPOL_MODE_FLAGS macro determines the legal set of optional mode flags.
+ */
+
+/* Policies */
+enum {
+	MPOL_DEFAULT,
+	MPOL_PREFERRED,
+	MPOL_BIND,
+	MPOL_INTERLEAVE,
+	MPOL_MAX,	/* always last member of enum */
+};
+
+/* Flags for set_mempolicy */
+#define MPOL_F_STATIC_NODES	(1 << 15)
+#define MPOL_F_RELATIVE_NODES	(1 << 14)
+
+/*
+ * MPOL_MODE_FLAGS is the union of all possible optional mode flags passed to
+ * either set_mempolicy() or mbind().
+ */
+#define MPOL_MODE_FLAGS	(MPOL_F_STATIC_NODES | MPOL_F_RELATIVE_NODES)
+
+/* Flags for get_mempolicy */
+#define MPOL_F_NODE	(1<<0)	/* return next IL mode instead of node mask */
+#define MPOL_F_ADDR	(1<<1)	/* look up vma using address */
+#define MPOL_F_MEMS_ALLOWED (1<<2) /* return allowed memories */
+
+/* Flags for mbind */
+#define MPOL_MF_STRICT	(1<<0)	/* Verify existing pages in the mapping */
+#define MPOL_MF_MOVE	(1<<1)	/* Move pages owned by this process to conform to mapping */
+#define MPOL_MF_MOVE_ALL (1<<2)	/* Move every page to conform to mapping */
+#define MPOL_MF_INTERNAL (1<<3)	/* Internal flags start here */
+
+/*
+ * Internal flags that share the struct mempolicy flags word with
+ * "mode flags".  These flags are allocated from bit 0 up, as they
+ * are never OR'ed into the mode in mempolicy API arguments.
+ */
+#define MPOL_F_SHARED  (1 << 0)	/* identify shared policies */
+#define MPOL_F_LOCAL   (1 << 1)	/* preferred local allocation */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/meye.h clean_modified/linux-2.6.32/usr/include/linux/meye.h
--- linux-2.6.32/usr/include/linux/meye.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/meye.h	2019-04-14 13:24:03.029586405 -0500
@@ -0,0 +1,66 @@
+/*
+ * Motion Eye video4linux driver for Sony Vaio PictureBook
+ *
+ * Copyright (C) 2001-2003 Stelian Pop <stelian@popies.net>
+ *
+ * Copyright (C) 2001-2002 Alcôve <www.alcove.com>
+ *
+ * Copyright (C) 2000 Andrew Tridgell <tridge@valinux.com>
+ *
+ * Earlier work by Werner Almesberger, Paul `Rusty' Russell and Paul Mackerras.
+ *
+ * Some parts borrowed from various video4linux drivers, especially
+ * bttv-driver.c and zoran.c, see original files for credits.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _MEYE_H_
+#define _MEYE_H_
+
+/****************************************************************************/
+/* Private API for handling mjpeg capture / playback.                       */
+/****************************************************************************/
+
+struct meye_params {
+	unsigned char subsample;
+	unsigned char quality;
+	unsigned char sharpness;
+	unsigned char agc;
+	unsigned char picture;
+	unsigned char framerate;
+};
+
+/* query the extended parameters */
+#define MEYEIOC_G_PARAMS	_IOR ('v', BASE_VIDIOCPRIVATE+0, struct meye_params)
+/* set the extended parameters */
+#define MEYEIOC_S_PARAMS	_IOW ('v', BASE_VIDIOCPRIVATE+1, struct meye_params)
+/* queue a buffer for mjpeg capture */
+#define MEYEIOC_QBUF_CAPT	_IOW ('v', BASE_VIDIOCPRIVATE+2, int)
+/* sync a previously queued mjpeg buffer */
+#define MEYEIOC_SYNC		_IOWR('v', BASE_VIDIOCPRIVATE+3, int)
+/* get a still uncompressed snapshot */
+#define MEYEIOC_STILLCAPT	_IO  ('v', BASE_VIDIOCPRIVATE+4)
+/* get a jpeg compressed snapshot */
+#define MEYEIOC_STILLJCAPT	_IOR ('v', BASE_VIDIOCPRIVATE+5, int)
+
+/* V4L2 private controls */
+#define V4L2_CID_AGC		V4L2_CID_PRIVATE_BASE
+#define V4L2_CID_MEYE_SHARPNESS	(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_PICTURE	(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_JPEGQUAL	(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_FRAMERATE	(V4L2_CID_PRIVATE_BASE + 4)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/mii.h clean_modified/linux-2.6.32/usr/include/linux/mii.h
--- linux-2.6.32/usr/include/linux/mii.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mii.h	2019-04-14 13:24:03.029586405 -0500
@@ -0,0 +1,150 @@
+/*
+ * linux/mii.h: definitions for MII-compatible transceivers
+ * Originally drivers/net/sunhme.h.
+ *
+ * Copyright (C) 1996, 1999, 2001 David S. Miller (davem@redhat.com)
+ */
+
+#ifndef __LINUX_MII_H__
+#define __LINUX_MII_H__
+
+#include <linux/types.h>
+
+/* Generic MII registers. */
+
+#define MII_BMCR            0x00        /* Basic mode control register */
+#define MII_BMSR            0x01        /* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+#define MII_LPA             0x05        /* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+#define MII_CTRL1000        0x09        /* 1000BASE-T control          */
+#define MII_STAT1000        0x0a        /* 1000BASE-T status           */
+#define MII_ESTATUS	    0x0f	/* Extended Status */
+#define MII_DCOUNTER        0x12        /* Disconnect counter          */
+#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+#define MII_SREVISION       0x16        /* Silicon revision            */
+#define MII_RESV1           0x17        /* Reserved...                 */
+#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+#define MII_PHYADDR         0x19        /* PHY address                 */
+#define MII_RESV2           0x1a        /* Reserved...                 */
+#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+#define MII_NCONFIG         0x1c        /* Network interface config    */
+
+/* Basic mode control register. */
+#define BMCR_RESV               0x003f  /* Unused...                   */
+#define BMCR_SPEED1000		0x0040  /* MSB of Speed (1000)         */
+#define BMCR_CTST               0x0080  /* Collision test              */
+#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+#define BMCR_RESET              0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_JCD                0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS            0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV               0x00c0  /* Unused...                   */
+#define BMSR_ESTATEN		0x0100	/* Extended Status in R15 */
+#define BMSR_100HALF2           0x0200  /* Can do 100BASE-T2 HDX */
+#define BMSR_100FULL2           0x0400  /* Can do 100BASE-T2 FDX */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_1000XFULL     0x0020  /* Try for 1000BASE-X full-duplex */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_1000XHALF     0x0040  /* Try for 1000BASE-X half-duplex */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_1000XPAUSE    0x0080  /* Try for 1000BASE-X pause    */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_1000XPSE_ASYM 0x0100  /* Try for 1000BASE-X asym pause */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_PAUSE_CAP     0x0400  /* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM    0x0800  /* Try for asymetric pause     */
+#define ADVERTISE_RESV          0x1000  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+			ADVERTISE_CSMA)
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                       ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f  /* Same as advertise selector  */
+#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+#define LPA_1000XFULL           0x0020  /* Can do 1000BASE-X full-duplex */
+#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+#define LPA_1000XHALF           0x0040  /* Can do 1000BASE-X half-duplex */
+#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+#define LPA_1000XPAUSE          0x0080  /* Can do 1000BASE-X pause     */
+#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+#define LPA_1000XPAUSE_ASYM     0x0100  /* Can do 1000BASE-X pause asym*/
+#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+#define LPA_PAUSE_CAP           0x0400  /* Can pause                   */
+#define LPA_PAUSE_ASYM          0x0800  /* Can pause asymetrically     */
+#define LPA_RESV                0x1000  /* Unused...                   */
+#define LPA_RFAULT              0x2000  /* Link partner faulted        */
+#define LPA_LPACK               0x4000  /* Link partner acked us       */
+#define LPA_NPAGE               0x8000  /* Next page bit               */
+
+#define LPA_DUPLEX		(LPA_10FULL | LPA_100FULL)
+#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* Expansion register for auto-negotiation. */
+#define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
+#define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
+#define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+#define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
+#define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
+#define EXPANSION_RESV          0xffe0  /* Unused...                   */
+
+#define ESTATUS_1000_TFULL	0x2000	/* Can do 1000BT Full */
+#define ESTATUS_1000_THALF	0x1000	/* Can do 1000BT Half */
+
+/* N-way test register. */
+#define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
+#define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
+#define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
+
+/* 1000BASE-T Control register */
+#define ADVERTISE_1000FULL      0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF      0x0100  /* Advertise 1000BASE-T half duplex */
+
+/* 1000BASE-T Status register */
+#define LPA_1000LOCALRXOK       0x2000  /* Link partner local receiver status */
+#define LPA_1000REMRXOK         0x1000  /* Link partner remote receiver status */
+#define LPA_1000FULL            0x0800  /* Link partner 1000BASE-T full duplex */
+#define LPA_1000HALF            0x0400  /* Link partner 1000BASE-T half duplex */
+
+/* Flow control flags */
+#define FLOW_CTRL_TX		0x01
+#define FLOW_CTRL_RX		0x02
+
+/* This structure is used in all SIOCxMIIxxx ioctl calls */
+struct mii_ioctl_data {
+	__u16		phy_id;
+	__u16		reg_num;
+	__u16		val_in;
+	__u16		val_out;
+};
+
+#endif /* __LINUX_MII_H__ */
diff -uNr linux-2.6.32/usr/include/linux/minix_fs.h clean_modified/linux-2.6.32/usr/include/linux/minix_fs.h
--- linux-2.6.32/usr/include/linux/minix_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/minix_fs.h	2019-04-14 13:24:03.030553772 -0500
@@ -0,0 +1,106 @@
+#ifndef _LINUX_MINIX_FS_H
+#define _LINUX_MINIX_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/*
+ * The minix filesystem constants/structures
+ */
+
+/*
+ * Thanks to Kees J Bot for sending me the definitions of the new
+ * minix filesystem (aka V2) with bigger inodes and 32-bit block
+ * pointers.
+ */
+
+#define MINIX_ROOT_INO 1
+
+/* Not the same as the bogus LINK_MAX in <linux/limits.h>. Oh well. */
+#define MINIX_LINK_MAX	250
+#define MINIX2_LINK_MAX	65530
+
+#define MINIX_I_MAP_SLOTS	8
+#define MINIX_Z_MAP_SLOTS	64
+#define MINIX_VALID_FS		0x0001		/* Clean fs. */
+#define MINIX_ERROR_FS		0x0002		/* fs has errors. */
+
+#define MINIX_INODES_PER_BLOCK ((BLOCK_SIZE)/(sizeof (struct minix_inode)))
+
+/*
+ * This is the original minix inode layout on disk.
+ * Note the 8-bit gid and atime and ctime.
+ */
+struct minix_inode {
+	__u16 i_mode;
+	__u16 i_uid;
+	__u32 i_size;
+	__u32 i_time;
+	__u8  i_gid;
+	__u8  i_nlinks;
+	__u16 i_zone[9];
+};
+
+/*
+ * The new minix inode has all the time entries, as well as
+ * long block numbers and a third indirect block (7+1+1+1
+ * instead of 7+1+1). Also, some previously 8-bit values are
+ * now 16-bit. The inode is now 64 bytes instead of 32.
+ */
+struct minix2_inode {
+	__u16 i_mode;
+	__u16 i_nlinks;
+	__u16 i_uid;
+	__u16 i_gid;
+	__u32 i_size;
+	__u32 i_atime;
+	__u32 i_mtime;
+	__u32 i_ctime;
+	__u32 i_zone[10];
+};
+
+/*
+ * minix super-block data on disk
+ */
+struct minix_super_block {
+	__u16 s_ninodes;
+	__u16 s_nzones;
+	__u16 s_imap_blocks;
+	__u16 s_zmap_blocks;
+	__u16 s_firstdatazone;
+	__u16 s_log_zone_size;
+	__u32 s_max_size;
+	__u16 s_magic;
+	__u16 s_state;
+	__u32 s_zones;
+};
+
+/*
+ * V3 minix super-block data on disk
+ */
+struct minix3_super_block {
+	__u32 s_ninodes;
+	__u16 s_pad0;
+	__u16 s_imap_blocks;
+	__u16 s_zmap_blocks;
+	__u16 s_firstdatazone;
+	__u16 s_log_zone_size;
+	__u16 s_pad1;
+	__u32 s_max_size;
+	__u32 s_zones;
+	__u16 s_magic;
+	__u16 s_pad2;
+	__u16 s_blocksize;
+	__u8  s_disk_version;
+};
+
+struct minix_dir_entry {
+	__u16 inode;
+	char name[0];
+};
+
+struct minix3_dir_entry {
+	__u32 inode;
+	char name[0];
+};
+#endif
diff -uNr linux-2.6.32/usr/include/linux/mman.h clean_modified/linux-2.6.32/usr/include/linux/mman.h
--- linux-2.6.32/usr/include/linux/mman.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mman.h	2019-04-14 13:24:03.030553772 -0500
@@ -0,0 +1,13 @@
+#ifndef _LINUX_MMAN_H
+#define _LINUX_MMAN_H
+
+#include <asm/mman.h>
+
+#define MREMAP_MAYMOVE	1
+#define MREMAP_FIXED	2
+
+#define OVERCOMMIT_GUESS		0
+#define OVERCOMMIT_ALWAYS		1
+#define OVERCOMMIT_NEVER		2
+
+#endif /* _LINUX_MMAN_H */
diff -uNr linux-2.6.32/usr/include/linux/mmtimer.h clean_modified/linux-2.6.32/usr/include/linux/mmtimer.h
--- linux-2.6.32/usr/include/linux/mmtimer.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mmtimer.h	2019-04-14 13:24:03.030553772 -0500
@@ -0,0 +1,56 @@
+/*
+ * Intel Multimedia Timer device interface
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 2001-2004 Silicon Graphics, Inc.  All rights reserved.
+ *
+ * This file should define an interface compatible with the IA-PC Multimedia
+ * Timers Draft Specification (rev. 0.97) from Intel.  Note that some
+ * hardware may not be able to safely export its registers to userspace,
+ * so the ioctl interface should support all necessary functionality.
+ *
+ * 11/01/01 - jbarnes - initial revision
+ * 9/10/04 - Christoph Lameter - remove interrupt support
+ * 9/17/04 - jbarnes - remove test program, move some #defines to the driver
+ */
+
+#ifndef _LINUX_MMTIMER_H
+#define _LINUX_MMTIMER_H
+
+/*
+ * Breakdown of the ioctl's available.  An 'optional' next to the command
+ * indicates that supporting this command is optional, while 'required'
+ * commands must be implemented if conformance is desired.
+ *
+ * MMTIMER_GETOFFSET - optional
+ *   Should return the offset (relative to the start of the page where the
+ *   registers are mapped) for the counter in question.
+ *
+ * MMTIMER_GETRES - required
+ *   The resolution of the clock in femto (10^-15) seconds
+ *
+ * MMTIMER_GETFREQ - required
+ *   Frequency of the clock in Hz
+ *
+ * MMTIMER_GETBITS - required
+ *   Number of bits in the clock's counter
+ *
+ * MMTIMER_MMAPAVAIL - required
+ *   Returns nonzero if the registers can be mmap'd into userspace, 0 otherwise
+ *
+ * MMTIMER_GETCOUNTER - required
+ *   Gets the current value in the counter
+ */
+#define MMTIMER_IOCTL_BASE 'm'
+
+#define MMTIMER_GETOFFSET _IO(MMTIMER_IOCTL_BASE, 0)
+#define MMTIMER_GETRES _IOR(MMTIMER_IOCTL_BASE, 1, unsigned long)
+#define MMTIMER_GETFREQ _IOR(MMTIMER_IOCTL_BASE, 2, unsigned long)
+#define MMTIMER_GETBITS _IO(MMTIMER_IOCTL_BASE, 4)
+#define MMTIMER_MMAPAVAIL _IO(MMTIMER_IOCTL_BASE, 6)
+#define MMTIMER_GETCOUNTER _IOR(MMTIMER_IOCTL_BASE, 9, unsigned long)
+
+#endif /* _LINUX_MMTIMER_H */
diff -uNr linux-2.6.32/usr/include/linux/mqueue.h clean_modified/linux-2.6.32/usr/include/linux/mqueue.h
--- linux-2.6.32/usr/include/linux/mqueue.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mqueue.h	2019-04-14 13:24:03.030553772 -0500
@@ -0,0 +1,53 @@
+/* Copyright (C) 2003 Krzysztof Benedyczak & Michal Wronski
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   It is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this software; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_MQUEUE_H
+#define _LINUX_MQUEUE_H
+
+#define MQ_PRIO_MAX 	32768
+/* per-uid limit of kernel memory used by mqueue, in bytes */
+#define MQ_BYTES_MAX	819200
+
+struct mq_attr {
+	long	mq_flags;	/* message queue flags			*/
+	long	mq_maxmsg;	/* maximum number of messages		*/
+	long	mq_msgsize;	/* maximum message size			*/
+	long	mq_curmsgs;	/* number of messages currently queued	*/
+	long	__reserved[4];	/* ignored for input, zeroed for output */
+};
+
+/*
+ * SIGEV_THREAD implementation:
+ * SIGEV_THREAD must be implemented in user space. If SIGEV_THREAD is passed
+ * to mq_notify, then
+ * - sigev_signo must be the file descriptor of an AF_NETLINK socket. It's not
+ *   necessary that the socket is bound.
+ * - sigev_value.sival_ptr must point to a cookie that is NOTIFY_COOKIE_LEN
+ *   bytes long.
+ * If the notification is triggered, then the cookie is sent to the netlink
+ * socket. The last byte of the cookie is replaced with the NOTIFY_?? codes:
+ * NOTIFY_WOKENUP if the notification got triggered, NOTIFY_REMOVED if it was
+ * removed, either due to a close() on the message queue fd or due to a
+ * mq_notify() that removed the notification.
+ */
+#define NOTIFY_NONE	0
+#define NOTIFY_WOKENUP	1
+#define NOTIFY_REMOVED	2
+
+#define NOTIFY_COOKIE_LEN	32
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/mroute6.h clean_modified/linux-2.6.32/usr/include/linux/mroute6.h
--- linux-2.6.32/usr/include/linux/mroute6.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mroute6.h	2019-04-14 13:24:03.031531571 -0500
@@ -0,0 +1,137 @@
+#ifndef __LINUX_MROUTE6_H
+#define __LINUX_MROUTE6_H
+
+#include <linux/types.h>
+#include <linux/sockios.h>
+
+/*
+ *	Based on the MROUTING 3.5 defines primarily to keep
+ *	source compatibility with BSD.
+ *
+ *	See the pim6sd code for the original history.
+ *
+ *      Protocol Independent Multicast (PIM) data structures included
+ *      Carlos Picoto (cap@di.fc.ul.pt)
+ *
+ */
+
+#define MRT6_BASE	200
+#define MRT6_INIT	(MRT6_BASE)	/* Activate the kernel mroute code 	*/
+#define MRT6_DONE	(MRT6_BASE+1)	/* Shutdown the kernel mroute		*/
+#define MRT6_ADD_MIF	(MRT6_BASE+2)	/* Add a virtual interface		*/
+#define MRT6_DEL_MIF	(MRT6_BASE+3)	/* Delete a virtual interface		*/
+#define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
+#define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
+#define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
+#define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
+#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code	*/
+
+#define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
+#define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
+#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+
+#define MAXMIFS		32
+typedef unsigned long mifbitmap_t;	/* User mode code depends on this lot */
+typedef unsigned short mifi_t;
+#define ALL_MIFS	((mifi_t)(-1))
+
+#ifndef IF_SETSIZE
+#define IF_SETSIZE	256
+#endif
+
+typedef	__u32		if_mask;
+#define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
+
+#if !defined(__KERNEL__) && !defined(DIV_ROUND_UP)
+#define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
+#endif
+
+typedef struct if_set {
+	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
+} if_set;
+
+#define IF_SET(n, p)    ((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))
+#define IF_CLR(n, p)    ((p)->ifs_bits[(n)/NIFBITS] &= ~(1 << ((n) % NIFBITS)))
+#define IF_ISSET(n, p)  ((p)->ifs_bits[(n)/NIFBITS] & (1 << ((n) % NIFBITS)))
+#define IF_COPY(f, t)   bcopy(f, t, sizeof(*(f)))
+#define IF_ZERO(p)      bzero(p, sizeof(*(p)))
+
+/*
+ *	Passed by mrouted for an MRT_ADD_MIF - again we use the
+ *	mrouted 3.6 structures for compatibility
+ */
+
+struct mif6ctl {
+	mifi_t	mif6c_mifi;		/* Index of MIF */
+	unsigned char mif6c_flags;	/* MIFF_ flags */
+	unsigned char vifc_threshold;	/* ttl limit */
+	__u16	 mif6c_pifi;		/* the index of the physical IF */
+	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
+};
+
+#define MIFF_REGISTER	0x1	/* register vif	*/
+
+/*
+ *	Cache manipulation structures for mrouted and PIMd
+ */
+
+struct mf6cctl
+{
+	struct sockaddr_in6 mf6cc_origin;		/* Origin of mcast	*/
+	struct sockaddr_in6 mf6cc_mcastgrp;		/* Group in question	*/
+	mifi_t	mf6cc_parent;			/* Where it arrived	*/
+	struct if_set mf6cc_ifset;		/* Where it is going */
+};
+
+/*
+ *	Group count retrieval for pim6sd
+ */
+
+struct sioc_sg_req6
+{
+	struct sockaddr_in6 src;
+	struct sockaddr_in6 grp;
+	unsigned long pktcnt;
+	unsigned long bytecnt;
+	unsigned long wrong_if;
+};
+
+/*
+ *	To get vif packet counts
+ */
+
+struct sioc_mif_req6
+{
+	mifi_t	mifi;		/* Which iface */
+	unsigned long icount;	/* In packets */
+	unsigned long ocount;	/* Out packets */
+	unsigned long ibytes;	/* In bytes */
+	unsigned long obytes;	/* Out bytes */
+};
+
+/*
+ *	That's all usermode folks
+ */
+
+
+
+/*
+ * Structure used to communicate from kernel to multicast router.
+ * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
+ * used for IPv4 implementation). This is because this structure will be passed via an
+ * IPv6 raw socket, on wich an application will only receiver the payload i.e the data after
+ * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
+ */
+
+struct mrt6msg {
+#define MRT6MSG_NOCACHE		1
+#define MRT6MSG_WRONGMIF	2
+#define MRT6MSG_WHOLEPKT	3		/* used for use level encap */
+	__u8		im6_mbz;		/* must be zero		   */
+	__u8		im6_msgtype;		/* what type of message    */
+	__u16		im6_mif;		/* mif rec'd on		   */
+	__u32		im6_pad;		/* padding for 64 bit arch */
+	struct in6_addr	im6_src, im6_dst;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/mroute.h clean_modified/linux-2.6.32/usr/include/linux/mroute.h
--- linux-2.6.32/usr/include/linux/mroute.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mroute.h	2019-04-14 13:24:03.031531571 -0500
@@ -0,0 +1,141 @@
+#ifndef __LINUX_MROUTE_H
+#define __LINUX_MROUTE_H
+
+#include <linux/sockios.h>
+#include <linux/types.h>
+
+/*
+ *	Based on the MROUTING 3.5 defines primarily to keep
+ *	source compatibility with BSD.
+ *
+ *	See the mrouted code for the original history.
+ *
+ *      Protocol Independent Multicast (PIM) data structures included
+ *      Carlos Picoto (cap@di.fc.ul.pt)
+ *
+ */
+
+#define MRT_BASE	200
+#define MRT_INIT	(MRT_BASE)	/* Activate the kernel mroute code 	*/
+#define MRT_DONE	(MRT_BASE+1)	/* Shutdown the kernel mroute		*/
+#define MRT_ADD_VIF	(MRT_BASE+2)	/* Add a virtual interface		*/
+#define MRT_DEL_VIF	(MRT_BASE+3)	/* Delete a virtual interface		*/
+#define MRT_ADD_MFC	(MRT_BASE+4)	/* Add a multicast forwarding entry	*/
+#define MRT_DEL_MFC	(MRT_BASE+5)	/* Delete a multicast forwarding entry	*/
+#define MRT_VERSION	(MRT_BASE+6)	/* Get the kernel multicast version	*/
+#define MRT_ASSERT	(MRT_BASE+7)	/* Activate PIM assert mode		*/
+#define MRT_PIM		(MRT_BASE+8)	/* enable PIM code	*/
+
+#define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
+#define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
+#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+
+#define MAXVIFS		32	
+typedef unsigned long vifbitmap_t;	/* User mode code depends on this lot */
+typedef unsigned short vifi_t;
+#define ALL_VIFS	((vifi_t)(-1))
+
+/*
+ *	Same idea as select
+ */
+ 
+#define VIFM_SET(n,m)	((m)|=(1<<(n)))
+#define VIFM_CLR(n,m)	((m)&=~(1<<(n)))
+#define VIFM_ISSET(n,m)	((m)&(1<<(n)))
+#define VIFM_CLRALL(m)	((m)=0)
+#define VIFM_COPY(mfrom,mto)	((mto)=(mfrom))
+#define VIFM_SAME(m1,m2)	((m1)==(m2))
+
+/*
+ *	Passed by mrouted for an MRT_ADD_VIF - again we use the
+ *	mrouted 3.6 structures for compatibility
+ */
+ 
+struct vifctl {
+	vifi_t	vifc_vifi;		/* Index of VIF */
+	unsigned char vifc_flags;	/* VIFF_ flags */
+	unsigned char vifc_threshold;	/* ttl limit */
+	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
+	struct in_addr vifc_lcl_addr;	/* Our address */
+	struct in_addr vifc_rmt_addr;	/* IPIP tunnel addr */
+};
+
+#define VIFF_TUNNEL	0x1	/* IPIP tunnel */
+#define VIFF_SRCRT	0x2	/* NI */
+#define VIFF_REGISTER	0x4	/* register vif	*/
+
+/*
+ *	Cache manipulation structures for mrouted and PIMd
+ */
+ 
+struct mfcctl
+{
+	struct in_addr mfcc_origin;		/* Origin of mcast	*/
+	struct in_addr mfcc_mcastgrp;		/* Group in question	*/
+	vifi_t	mfcc_parent;			/* Where it arrived	*/
+	unsigned char mfcc_ttls[MAXVIFS];	/* Where it is going	*/
+	unsigned int mfcc_pkt_cnt;		/* pkt count for src-grp */
+	unsigned int mfcc_byte_cnt;
+	unsigned int mfcc_wrong_if;
+	int	     mfcc_expire;
+};
+
+/* 
+ *	Group count retrieval for mrouted
+ */
+ 
+struct sioc_sg_req
+{
+	struct in_addr src;
+	struct in_addr grp;
+	unsigned long pktcnt;
+	unsigned long bytecnt;
+	unsigned long wrong_if;
+};
+
+/*
+ *	To get vif packet counts
+ */
+
+struct sioc_vif_req
+{
+	vifi_t	vifi;		/* Which iface */
+	unsigned long icount;	/* In packets */
+	unsigned long ocount;	/* Out packets */
+	unsigned long ibytes;	/* In bytes */
+	unsigned long obytes;	/* Out bytes */
+};
+
+/*
+ *	This is the format the mroute daemon expects to see IGMP control
+ *	data. Magically happens to be like an IP packet as per the original
+ */
+ 
+struct igmpmsg
+{
+	__u32 unused1,unused2;
+	unsigned char im_msgtype;		/* What is this */
+	unsigned char im_mbz;			/* Must be zero */
+	unsigned char im_vif;			/* Interface (this ought to be a vifi_t!) */
+	unsigned char unused3;
+	struct in_addr im_src,im_dst;
+};
+
+/*
+ *	That's all usermode folks
+ */
+
+
+
+#define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
+
+/*
+ *	Pseudo messages used by mrouted
+ */
+
+#define IGMPMSG_NOCACHE		1		/* Kern cache fill request to mrouted */
+#define IGMPMSG_WRONGVIF	2		/* For PIM assert processing (unused) */
+#define IGMPMSG_WHOLEPKT	3		/* For PIM Register processing */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/msdos_fs.h clean_modified/linux-2.6.32/usr/include/linux/msdos_fs.h
--- linux-2.6.32/usr/include/linux/msdos_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/msdos_fs.h	2019-04-14 13:24:03.031531571 -0500
@@ -0,0 +1,165 @@
+#ifndef _LINUX_MSDOS_FS_H
+#define _LINUX_MSDOS_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+#include <asm/byteorder.h>
+
+/*
+ * The MS-DOS filesystem constants/structures
+ */
+
+#define SECTOR_SIZE	512		/* sector size (bytes) */
+#define SECTOR_BITS	9		/* log2(SECTOR_SIZE) */
+#define MSDOS_DPB	(MSDOS_DPS)	/* dir entries per block */
+#define MSDOS_DPB_BITS	4		/* log2(MSDOS_DPB) */
+#define MSDOS_DPS	(SECTOR_SIZE / sizeof(struct msdos_dir_entry))
+#define MSDOS_DPS_BITS	4		/* log2(MSDOS_DPS) */
+#define CF_LE_W(v)	le16_to_cpu(v)
+#define CF_LE_L(v)	le32_to_cpu(v)
+#define CT_LE_W(v)	cpu_to_le16(v)
+#define CT_LE_L(v)	cpu_to_le32(v)
+
+
+#define MSDOS_ROOT_INO	1	/* == MINIX_ROOT_INO */
+#define MSDOS_DIR_BITS	5	/* log2(sizeof(struct msdos_dir_entry)) */
+
+/* directory limit */
+#define FAT_MAX_DIR_ENTRIES	(65536)
+#define FAT_MAX_DIR_SIZE	(FAT_MAX_DIR_ENTRIES << MSDOS_DIR_BITS)
+
+#define ATTR_NONE	0	/* no attribute bits */
+#define ATTR_RO		1	/* read-only */
+#define ATTR_HIDDEN	2	/* hidden */
+#define ATTR_SYS	4	/* system */
+#define ATTR_VOLUME	8	/* volume label */
+#define ATTR_DIR	16	/* directory */
+#define ATTR_ARCH	32	/* archived */
+
+/* attribute bits that are copied "as is" */
+#define ATTR_UNUSED	(ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+/* bits that are used by the Windows 95/Windows NT extended FAT */
+#define ATTR_EXT	(ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)
+
+#define CASE_LOWER_BASE	8	/* base is lower case */
+#define CASE_LOWER_EXT	16	/* extension is lower case */
+
+#define DELETED_FLAG	0xe5	/* marks file as deleted when in name[0] */
+#define IS_FREE(n)	(!*(n) || *(n) == DELETED_FLAG)
+
+#define MSDOS_NAME	11	/* maximum name length */
+#define MSDOS_LONGNAME	256	/* maximum name length */
+#define MSDOS_SLOTS	21	/* max # of slots for short and long names */
+#define MSDOS_DOT	".          "	/* ".", padded to MSDOS_NAME chars */
+#define MSDOS_DOTDOT	"..         "	/* "..", padded to MSDOS_NAME chars */
+
+#define FAT_FIRST_ENT(s, x)	((MSDOS_SB(s)->fat_bits == 32 ? 0x0FFFFF00 : \
+	MSDOS_SB(s)->fat_bits == 16 ? 0xFF00 : 0xF00) | (x))
+
+/* start of data cluster's entry (number of reserved clusters) */
+#define FAT_START_ENT	2
+
+/* maximum number of clusters */
+#define MAX_FAT12	0xFF4
+#define MAX_FAT16	0xFFF4
+#define MAX_FAT32	0x0FFFFFF6
+#define MAX_FAT(s)	(MSDOS_SB(s)->fat_bits == 32 ? MAX_FAT32 : \
+	MSDOS_SB(s)->fat_bits == 16 ? MAX_FAT16 : MAX_FAT12)
+
+/* bad cluster mark */
+#define BAD_FAT12	0xFF7
+#define BAD_FAT16	0xFFF7
+#define BAD_FAT32	0x0FFFFFF7
+
+/* standard EOF */
+#define EOF_FAT12	0xFFF
+#define EOF_FAT16	0xFFFF
+#define EOF_FAT32	0x0FFFFFFF
+
+#define FAT_ENT_FREE	(0)
+#define FAT_ENT_BAD	(BAD_FAT32)
+#define FAT_ENT_EOF	(EOF_FAT32)
+
+#define FAT_FSINFO_SIG1	0x41615252
+#define FAT_FSINFO_SIG2	0x61417272
+#define IS_FSINFO(x)	(le32_to_cpu((x)->signature1) == FAT_FSINFO_SIG1 \
+			 && le32_to_cpu((x)->signature2) == FAT_FSINFO_SIG2)
+
+struct __fat_dirent {
+	long		d_ino;
+	__kernel_off_t	d_off;
+	unsigned short	d_reclen;
+	char		d_name[256]; /* We must not include limits.h! */
+};
+
+/*
+ * ioctl commands
+ */
+#define VFAT_IOCTL_READDIR_BOTH		_IOR('r', 1, struct __fat_dirent[2])
+#define VFAT_IOCTL_READDIR_SHORT	_IOR('r', 2, struct __fat_dirent[2])
+/* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
+#define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
+#define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+
+struct fat_boot_sector {
+	__u8	ignored[3];	/* Boot strap short or near jump */
+	__u8	system_id[8];	/* Name - can be used to special case
+				   partition manager volumes */
+	__u8	sector_size[2];	/* bytes per logical sector */
+	__u8	sec_per_clus;	/* sectors/cluster */
+	__le16	reserved;	/* reserved sectors */
+	__u8	fats;		/* number of FATs */
+	__u8	dir_entries[2];	/* root directory entries */
+	__u8	sectors[2];	/* number of sectors */
+	__u8	media;		/* media code */
+	__le16	fat_length;	/* sectors/FAT */
+	__le16	secs_track;	/* sectors per track */
+	__le16	heads;		/* number of heads */
+	__le32	hidden;		/* hidden sectors (unused) */
+	__le32	total_sect;	/* number of sectors (if sectors == 0) */
+
+	/* The following fields are only used by FAT32 */
+	__le32	fat32_length;	/* sectors/FAT */
+	__le16	flags;		/* bit 8: fat mirroring, low 4: active fat */
+	__u8	version[2];	/* major, minor filesystem version */
+	__le32	root_cluster;	/* first cluster in root directory */
+	__le16	info_sector;	/* filesystem info sector */
+	__le16	backup_boot;	/* backup boot sector */
+	__le16	reserved2[6];	/* Unused */
+};
+
+struct fat_boot_fsinfo {
+	__le32   signature1;	/* 0x41615252L */
+	__le32   reserved1[120];	/* Nothing as far as I can tell */
+	__le32   signature2;	/* 0x61417272L */
+	__le32   free_clusters;	/* Free cluster count.  -1 if unknown */
+	__le32   next_cluster;	/* Most recently allocated cluster */
+	__le32   reserved2[4];
+};
+
+struct msdos_dir_entry {
+	__u8	name[MSDOS_NAME];/* name and extension */
+	__u8	attr;		/* attribute bits */
+	__u8    lcase;		/* Case for base and extension */
+	__u8	ctime_cs;	/* Creation time, centiseconds (0-199) */
+	__le16	ctime;		/* Creation time */
+	__le16	cdate;		/* Creation date */
+	__le16	adate;		/* Last access date */
+	__le16	starthi;	/* High 16 bits of cluster in FAT32 */
+	__le16	time,date,start;/* time, date and first cluster */
+	__le32	size;		/* file size (in bytes) */
+};
+
+/* Up to 13 characters of the name */
+struct msdos_dir_slot {
+	__u8    id;		/* sequence number for slot */
+	__u8    name0_4[10];	/* first 5 characters in name */
+	__u8    attr;		/* attribute byte */
+	__u8    reserved;	/* always 0 */
+	__u8    alias_checksum;	/* checksum for 8.3 alias */
+	__u8    name5_10[12];	/* 6 more characters in name */
+	__le16   start;		/* starting cluster number, 0 in long slots */
+	__u8    name11_12[4];	/* last 2 characters in name */
+};
+
+#endif /* !_LINUX_MSDOS_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/msg.h clean_modified/linux-2.6.32/usr/include/linux/msg.h
--- linux-2.6.32/usr/include/linux/msg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/msg.h	2019-04-14 13:24:03.032500807 -0500
@@ -0,0 +1,75 @@
+#ifndef _LINUX_MSG_H
+#define _LINUX_MSG_H
+
+#include <linux/ipc.h>
+
+/* ipcs ctl commands */
+#define MSG_STAT 11
+#define MSG_INFO 12
+
+/* msgrcv options */
+#define MSG_NOERROR     010000  /* no error if message is too big */
+#define MSG_EXCEPT      020000  /* recv any msg except of specified type.*/
+
+/* Obsolete, used only for backwards compatibility and libc5 compiles */
+struct msqid_ds {
+	struct ipc_perm msg_perm;
+	struct msg *msg_first;		/* first message on queue,unused  */
+	struct msg *msg_last;		/* last message in queue,unused */
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long  msg_lcbytes;	/* Reuse junk fields for 32 bit */
+	unsigned long  msg_lqbytes;	/* ditto */
+	unsigned short msg_cbytes;	/* current number of bytes on queue */
+	unsigned short msg_qnum;	/* number of messages in queue */
+	unsigned short msg_qbytes;	/* max number of bytes on queue */
+	__kernel_ipc_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_ipc_pid_t msg_lrpid;	/* last receive pid */
+};
+
+/* Include the definition of msqid64_ds */
+#include <asm/msgbuf.h>
+
+/* message buffer for msgsnd and msgrcv calls */
+struct msgbuf {
+	long mtype;         /* type of message */
+	char mtext[1];      /* message text */
+};
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo {
+	int msgpool;
+	int msgmap; 
+	int msgmax; 
+	int msgmnb; 
+	int msgmni; 
+	int msgssz; 
+	int msgtql; 
+	unsigned short  msgseg; 
+};
+
+/*
+ * Scaling factor to compute msgmni:
+ * the memory dedicated to msg queues (msgmni * msgmnb) should occupy
+ * at most 1/MSG_MEM_SCALE of the lowmem (see the formula in ipc/msg.c):
+ * up to 8MB       : msgmni = 16 (MSGMNI)
+ * 4 GB            : msgmni = 8K
+ * more than 16 GB : msgmni = 32K (IPCMNI)
+ */
+#define MSG_MEM_SCALE 32
+
+#define MSGMNI    16   /* <= IPCMNI */     /* max # of msg queue identifiers */
+#define MSGMAX  8192   /* <= INT_MAX */   /* max size of message (bytes) */
+#define MSGMNB 16384   /* <= INT_MAX */   /* default max size of a message queue */
+
+/* unused */
+#define MSGPOOL (MSGMNI * MSGMNB / 1024) /* size in kbytes of message pool */
+#define MSGTQL  MSGMNB            /* number of system message headers */
+#define MSGMAP  MSGMNB            /* number of entries in message map */
+#define MSGSSZ  16                /* message segment size */
+#define __MSGSEG ((MSGPOOL * 1024) / MSGSSZ) /* max no. of segments */
+#define MSGSEG (__MSGSEG <= 0xffff ? __MSGSEG : 0xffff)
+
+
+#endif /* _LINUX_MSG_H */
diff -uNr linux-2.6.32/usr/include/linux/mtio.h clean_modified/linux-2.6.32/usr/include/linux/mtio.h
--- linux-2.6.32/usr/include/linux/mtio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/mtio.h	2019-04-14 13:24:03.032500807 -0500
@@ -0,0 +1,206 @@
+/* 
+ * linux/mtio.h header file for Linux. Written by H. Bergman
+ *
+ * Modified for special ioctls provided by zftape in September 1997
+ * by C.-J. Heine.
+ */
+
+#ifndef _LINUX_MTIO_H
+#define _LINUX_MTIO_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/*
+ * Structures and definitions for mag tape io control commands
+ */
+
+/* structure for MTIOCTOP - mag tape op command */
+struct	mtop {
+	short	mt_op;		/* operations defined below */
+	int	mt_count;	/* how many of them */
+};
+
+/* Magnetic Tape operations [Not all operations supported by all drivers]: */
+#define MTRESET 0	/* +reset drive in case of problems */
+#define MTFSF	1	/* forward space over FileMark,
+			 * position at first record of next file 
+			 */
+#define MTBSF	2	/* backward space FileMark (position before FM) */
+#define MTFSR	3	/* forward space record */
+#define MTBSR	4	/* backward space record */
+#define MTWEOF	5	/* write an end-of-file record (mark) */
+#define MTREW	6	/* rewind */
+#define MTOFFL	7	/* rewind and put the drive offline (eject?) */
+#define MTNOP	8	/* no op, set status only (read with MTIOCGET) */
+#define MTRETEN 9	/* retension tape */
+#define MTBSFM	10	/* +backward space FileMark, position at FM */
+#define MTFSFM  11	/* +forward space FileMark, position at FM */
+#define MTEOM	12	/* goto end of recorded media (for appending files).
+			 * MTEOM positions after the last FM, ready for
+			 * appending another file.
+			 */
+#define MTERASE 13	/* erase tape -- be careful! */
+
+#define MTRAS1  14	/* run self test 1 (nondestructive) */
+#define MTRAS2	15	/* run self test 2 (destructive) */
+#define MTRAS3  16	/* reserved for self test 3 */
+
+#define MTSETBLK 20	/* set block length (SCSI) */
+#define MTSETDENSITY 21	/* set tape density (SCSI) */
+#define MTSEEK	22	/* seek to block (Tandberg, etc.) */
+#define MTTELL	23	/* tell block (Tandberg, etc.) */
+#define MTSETDRVBUFFER 24 /* set the drive buffering according to SCSI-2 */
+			/* ordinary buffered operation with code 1 */
+#define MTFSS	25	/* space forward over setmarks */
+#define MTBSS	26	/* space backward over setmarks */
+#define MTWSM	27	/* write setmarks */
+
+#define MTLOCK  28	/* lock the drive door */
+#define MTUNLOCK 29	/* unlock the drive door */
+#define MTLOAD  30	/* execute the SCSI load command */
+#define MTUNLOAD 31	/* execute the SCSI unload command */
+#define MTCOMPRESSION 32/* control compression with SCSI mode page 15 */
+#define MTSETPART 33	/* Change the active tape partition */
+#define MTMKPART  34	/* Format the tape with one or two partitions */
+
+/* structure for MTIOCGET - mag tape get status command */
+
+struct	mtget {
+	long	mt_type;	/* type of magtape device */
+	long	mt_resid;	/* residual count: (not sure)
+				 *	number of bytes ignored, or
+				 *	number of files not skipped, or
+				 *	number of records not skipped.
+				 */
+	/* the following registers are device dependent */
+	long	mt_dsreg;	/* status register */
+	long	mt_gstat;	/* generic (device independent) status */
+	long	mt_erreg;	/* error register */
+	/* The next two fields are not always used */
+	__kernel_daddr_t mt_fileno;	/* number of current file on tape */
+	__kernel_daddr_t mt_blkno;	/* current block number */
+};
+
+
+
+/*
+ * Constants for mt_type. Not all of these are supported,
+ * and these are not all of the ones that are supported.
+ */
+#define MT_ISUNKNOWN		0x01
+#define MT_ISQIC02		0x02	/* Generic QIC-02 tape streamer */
+#define MT_ISWT5150		0x03	/* Wangtek 5150EQ, QIC-150, QIC-02 */
+#define MT_ISARCHIVE_5945L2	0x04	/* Archive 5945L-2, QIC-24, QIC-02? */
+#define MT_ISCMSJ500		0x05	/* CMS Jumbo 500 (QIC-02?) */
+#define MT_ISTDC3610		0x06	/* Tandberg 6310, QIC-24 */
+#define MT_ISARCHIVE_VP60I	0x07	/* Archive VP60i, QIC-02 */
+#define MT_ISARCHIVE_2150L	0x08	/* Archive Viper 2150L */
+#define MT_ISARCHIVE_2060L	0x09	/* Archive Viper 2060L */
+#define MT_ISARCHIVESC499	0x0A	/* Archive SC-499 QIC-36 controller */
+#define MT_ISQIC02_ALL_FEATURES	0x0F	/* Generic QIC-02 with all features */
+#define MT_ISWT5099EEN24	0x11	/* Wangtek 5099-een24, 60MB, QIC-24 */
+#define MT_ISTEAC_MT2ST		0x12	/* Teac MT-2ST 155mb drive, Teac DC-1 card (Wangtek type) */
+#define MT_ISEVEREX_FT40A	0x32	/* Everex FT40A (QIC-40) */
+#define MT_ISDDS1		0x51	/* DDS device without partitions */
+#define MT_ISDDS2		0x52	/* DDS device with partitions */
+#define MT_ISONSTREAM_SC        0x61   /* OnStream SCSI tape drives (SC-x0)
+					  and SCSI emulated (DI, DP, USB) */
+#define MT_ISSCSI1		0x71	/* Generic ANSI SCSI-1 tape unit */
+#define MT_ISSCSI2		0x72	/* Generic ANSI SCSI-2 tape unit */
+
+/* QIC-40/80/3010/3020 ftape supported drives.
+ * 20bit vendor ID + 0x800000 (see ftape-vendors.h)
+ */
+#define MT_ISFTAPE_UNKNOWN	0x800000 /* obsolete */
+#define MT_ISFTAPE_FLAG	0x800000
+
+
+/* structure for MTIOCPOS - mag tape get position command */
+
+struct	mtpos {
+	long 	mt_blkno;	/* current block number */
+};
+
+
+/* mag tape io control commands */
+#define	MTIOCTOP	_IOW('m', 1, struct mtop)	/* do a mag tape op */
+#define	MTIOCGET	_IOR('m', 2, struct mtget)	/* get tape status */
+#define	MTIOCPOS	_IOR('m', 3, struct mtpos)	/* get tape position */
+
+
+/* Generic Mag Tape (device independent) status macros for examining
+ * mt_gstat -- HP-UX compatible.
+ * There is room for more generic status bits here, but I don't
+ * know which of them are reserved. At least three or so should
+ * be added to make this really useful.
+ */
+#define GMT_EOF(x)              ((x) & 0x80000000)
+#define GMT_BOT(x)              ((x) & 0x40000000)
+#define GMT_EOT(x)              ((x) & 0x20000000)
+#define GMT_SM(x)               ((x) & 0x10000000)  /* DDS setmark */
+#define GMT_EOD(x)              ((x) & 0x08000000)  /* DDS EOD */
+#define GMT_WR_PROT(x)          ((x) & 0x04000000)
+/* #define GMT_ ? 		((x) & 0x02000000) */
+#define GMT_ONLINE(x)           ((x) & 0x01000000)
+#define GMT_D_6250(x)           ((x) & 0x00800000)
+#define GMT_D_1600(x)           ((x) & 0x00400000)
+#define GMT_D_800(x)            ((x) & 0x00200000)
+/* #define GMT_ ? 		((x) & 0x00100000) */
+/* #define GMT_ ? 		((x) & 0x00080000) */
+#define GMT_DR_OPEN(x)          ((x) & 0x00040000)  /* door open (no tape) */
+/* #define GMT_ ? 		((x) & 0x00020000) */
+#define GMT_IM_REP_EN(x)        ((x) & 0x00010000)  /* immediate report mode */
+#define GMT_CLN(x)              ((x) & 0x00008000)  /* cleaning requested */
+/* 15 generic status bits unused */
+
+
+/* SCSI-tape specific definitions */
+/* Bitfield shifts in the status  */
+#define MT_ST_BLKSIZE_SHIFT	0
+#define MT_ST_BLKSIZE_MASK	0xffffff
+#define MT_ST_DENSITY_SHIFT	24
+#define MT_ST_DENSITY_MASK	0xff000000
+
+#define MT_ST_SOFTERR_SHIFT	0
+#define MT_ST_SOFTERR_MASK	0xffff
+
+/* Bitfields for the MTSETDRVBUFFER ioctl */
+#define MT_ST_OPTIONS		0xf0000000
+#define MT_ST_BOOLEANS		0x10000000
+#define MT_ST_SETBOOLEANS	0x30000000
+#define MT_ST_CLEARBOOLEANS	0x40000000
+#define MT_ST_WRITE_THRESHOLD	0x20000000
+#define MT_ST_DEF_BLKSIZE	0x50000000
+#define MT_ST_DEF_OPTIONS	0x60000000
+#define MT_ST_TIMEOUTS		0x70000000
+#define MT_ST_SET_TIMEOUT	(MT_ST_TIMEOUTS | 0x000000)
+#define MT_ST_SET_LONG_TIMEOUT	(MT_ST_TIMEOUTS | 0x100000)
+#define MT_ST_SET_CLN		0x80000000
+
+#define MT_ST_BUFFER_WRITES	0x1
+#define MT_ST_ASYNC_WRITES	0x2
+#define MT_ST_READ_AHEAD	0x4
+#define MT_ST_DEBUGGING		0x8
+#define MT_ST_TWO_FM		0x10
+#define MT_ST_FAST_MTEOM	0x20
+#define MT_ST_AUTO_LOCK		0x40
+#define MT_ST_DEF_WRITES	0x80
+#define MT_ST_CAN_BSR		0x100
+#define MT_ST_NO_BLKLIMS	0x200
+#define MT_ST_CAN_PARTITIONS    0x400
+#define MT_ST_SCSI2LOGICAL      0x800
+#define MT_ST_SYSV              0x1000
+#define MT_ST_NOWAIT            0x2000
+#define MT_ST_SILI		0x4000
+
+/* The mode parameters to be controlled. Parameter chosen with bits 20-28 */
+#define MT_ST_CLEAR_DEFAULT	0xfffff
+#define MT_ST_DEF_DENSITY	(MT_ST_DEF_OPTIONS | 0x100000)
+#define MT_ST_DEF_COMPRESSION	(MT_ST_DEF_OPTIONS | 0x200000)
+#define MT_ST_DEF_DRVBUFFER	(MT_ST_DEF_OPTIONS | 0x300000)
+
+/* The offset for the arguments for the special HP changer load command. */
+#define MT_ST_HPLOADER_OFFSET 10000
+
+#endif /* _LINUX_MTIO_H */
diff -uNr linux-2.6.32/usr/include/linux/nbd.h clean_modified/linux-2.6.32/usr/include/linux/nbd.h
--- linux-2.6.32/usr/include/linux/nbd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nbd.h	2019-04-14 13:24:03.032500807 -0500
@@ -0,0 +1,68 @@
+/*
+ * 1999 Copyright (C) Pavel Machek, pavel@ucw.cz. This code is GPL.
+ * 1999/11/04 Copyright (C) 1999 VMware, Inc. (Regis "HPReg" Duchesne)
+ *            Made nbd_end_request() use the io_request_lock
+ * 2001 Copyright (C) Steven Whitehouse
+ *            New nbd_end_request() for compatibility with new linux block
+ *            layer code.
+ * 2003/06/24 Louis D. Langholtz <ldl@aros.net>
+ *            Removed unneeded blksize_bits field from nbd_device struct.
+ *            Cleanup PARANOIA usage & code.
+ * 2004/02/19 Paul Clements
+ *            Removed PARANOIA, plus various cleanup and comments
+ */
+
+#ifndef LINUX_NBD_H
+#define LINUX_NBD_H
+
+#include <linux/types.h>
+
+#define NBD_SET_SOCK	_IO( 0xab, 0 )
+#define NBD_SET_BLKSIZE	_IO( 0xab, 1 )
+#define NBD_SET_SIZE	_IO( 0xab, 2 )
+#define NBD_DO_IT	_IO( 0xab, 3 )
+#define NBD_CLEAR_SOCK	_IO( 0xab, 4 )
+#define NBD_CLEAR_QUE	_IO( 0xab, 5 )
+#define NBD_PRINT_DEBUG	_IO( 0xab, 6 )
+#define NBD_SET_SIZE_BLOCKS	_IO( 0xab, 7 )
+#define NBD_DISCONNECT  _IO( 0xab, 8 )
+#define NBD_SET_TIMEOUT _IO( 0xab, 9 )
+
+enum {
+	NBD_CMD_READ = 0,
+	NBD_CMD_WRITE = 1,
+	NBD_CMD_DISC = 2
+};
+
+#define nbd_cmd(req) ((req)->cmd[0])
+
+/* userspace doesn't need the nbd_device structure */
+
+/* These are sent over the network in the request/reply magic fields */
+
+#define NBD_REQUEST_MAGIC 0x25609513
+#define NBD_REPLY_MAGIC 0x67446698
+/* Do *not* use magics: 0x12560953 0x96744668. */
+
+/*
+ * This is the packet used for communication between client and
+ * server. All data are in network byte order.
+ */
+struct nbd_request {
+	__be32 magic;
+	__be32 type;	/* == READ || == WRITE 	*/
+	char handle[8];
+	__be64 from;
+	__be32 len;
+} __attribute__ ((packed));
+
+/*
+ * This is the reply packet that nbd-server sends back to the client after
+ * it has completed an I/O request (or an error occurs).
+ */
+struct nbd_reply {
+	__be32 magic;
+	__be32 error;		/* 0 = ok, else error	*/
+	char handle[8];		/* handle you got from request	*/
+};
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ncp_fs.h clean_modified/linux-2.6.32/usr/include/linux/ncp_fs.h
--- linux-2.6.32/usr/include/linux/ncp_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ncp_fs.h	2019-04-14 13:24:03.033479747 -0500
@@ -0,0 +1,147 @@
+/*
+ *  ncp_fs.h
+ *
+ *  Copyright (C) 1995, 1996 by Volker Lendecke
+ *
+ */
+
+#ifndef _LINUX_NCP_FS_H
+#define _LINUX_NCP_FS_H
+
+#include <linux/fs.h>
+#include <linux/in.h>
+#include <linux/types.h>
+#include <linux/magic.h>
+
+#include <linux/ipx.h>
+#include <linux/ncp_no.h>
+
+/*
+ * ioctl commands
+ */
+
+struct ncp_ioctl_request {
+	unsigned int function;
+	unsigned int size;
+	char *data;
+};
+
+struct ncp_fs_info {
+	int version;
+	struct sockaddr_ipx addr;
+	__kernel_uid_t mounted_uid;
+	int connection;		/* Connection number the server assigned us */
+	int buffer_size;	/* The negotiated buffer size, to be
+				   used for read/write requests! */
+
+	int volume_number;
+	__le32 directory_id;
+};
+
+struct ncp_fs_info_v2 {
+	int version;
+	unsigned long mounted_uid;
+	unsigned int connection;
+	unsigned int buffer_size;
+
+	unsigned int volume_number;
+	__le32 directory_id;
+
+	__u32 dummy1;
+	__u32 dummy2;
+	__u32 dummy3;
+};
+
+struct ncp_sign_init
+{
+	char sign_root[8];
+	char sign_last[16];
+};
+
+struct ncp_lock_ioctl
+{
+#define NCP_LOCK_LOG	0
+#define NCP_LOCK_SH	1
+#define NCP_LOCK_EX	2
+#define NCP_LOCK_CLEAR	256
+	int		cmd;
+	int		origin;
+	unsigned int	offset;
+	unsigned int	length;
+#define NCP_LOCK_DEFAULT_TIMEOUT	18
+#define NCP_LOCK_MAX_TIMEOUT		180
+	int		timeout;
+};
+
+struct ncp_setroot_ioctl
+{
+	int		volNumber;
+	int		namespace;
+	__le32		dirEntNum;
+};
+
+struct ncp_objectname_ioctl
+{
+#define NCP_AUTH_NONE	0x00
+#define NCP_AUTH_BIND	0x31
+#define NCP_AUTH_NDS	0x32
+	int		auth_type;
+	size_t		object_name_len;
+	void *	object_name;	/* a userspace data, in most cases user name */
+};
+
+struct ncp_privatedata_ioctl
+{
+	size_t		len;
+	void *	data;		/* ~1000 for NDS */
+};
+
+/* NLS charsets by ioctl */
+#define NCP_IOCSNAME_LEN 20
+struct ncp_nls_ioctl
+{
+	unsigned char codepage[NCP_IOCSNAME_LEN+1];
+	unsigned char iocharset[NCP_IOCSNAME_LEN+1];
+};
+
+#define	NCP_IOC_NCPREQUEST		_IOR('n', 1, struct ncp_ioctl_request)
+#define	NCP_IOC_GETMOUNTUID		_IOW('n', 2, __kernel_old_uid_t)
+#define NCP_IOC_GETMOUNTUID2		_IOW('n', 2, unsigned long)
+
+#define NCP_IOC_CONN_LOGGED_IN          _IO('n', 3)
+
+#define NCP_GET_FS_INFO_VERSION    (1)
+#define NCP_IOC_GET_FS_INFO             _IOWR('n', 4, struct ncp_fs_info)
+#define NCP_GET_FS_INFO_VERSION_V2 (2)
+#define NCP_IOC_GET_FS_INFO_V2		_IOWR('n', 4, struct ncp_fs_info_v2)
+
+#define NCP_IOC_SIGN_INIT		_IOR('n', 5, struct ncp_sign_init)
+#define NCP_IOC_SIGN_WANTED		_IOR('n', 6, int)
+#define NCP_IOC_SET_SIGN_WANTED		_IOW('n', 6, int)
+
+#define NCP_IOC_LOCKUNLOCK		_IOR('n', 7, struct ncp_lock_ioctl)
+
+#define NCP_IOC_GETROOT			_IOW('n', 8, struct ncp_setroot_ioctl)
+#define NCP_IOC_SETROOT			_IOR('n', 8, struct ncp_setroot_ioctl)
+
+#define NCP_IOC_GETOBJECTNAME		_IOWR('n', 9, struct ncp_objectname_ioctl)
+#define NCP_IOC_SETOBJECTNAME		_IOR('n', 9, struct ncp_objectname_ioctl)
+#define NCP_IOC_GETPRIVATEDATA		_IOWR('n', 10, struct ncp_privatedata_ioctl)
+#define NCP_IOC_SETPRIVATEDATA		_IOR('n', 10, struct ncp_privatedata_ioctl)
+
+#define NCP_IOC_GETCHARSETS		_IOWR('n', 11, struct ncp_nls_ioctl)
+#define NCP_IOC_SETCHARSETS		_IOR('n', 11, struct ncp_nls_ioctl)
+
+#define NCP_IOC_GETDENTRYTTL		_IOW('n', 12, __u32)
+#define NCP_IOC_SETDENTRYTTL		_IOR('n', 12, __u32)
+
+/*
+ * The packet size to allocate. One page should be enough.
+ */
+#define NCP_PACKET_SIZE 4070
+
+#define NCP_MAXPATHLEN 255
+#define NCP_MAXNAMELEN 14
+
+
+#endif				/* _LINUX_NCP_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/ncp.h clean_modified/linux-2.6.32/usr/include/linux/ncp.h
--- linux-2.6.32/usr/include/linux/ncp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ncp.h	2019-04-14 13:24:03.033479747 -0500
@@ -0,0 +1,198 @@
+/*
+ *  ncp.h
+ *
+ *  Copyright (C) 1995 by Volker Lendecke
+ *  Modified for sparc by J.F. Chadima
+ *  Modified for __constant_ntoh by Frank A. Vorstenbosch
+ *
+ */
+
+#ifndef _LINUX_NCP_H
+#define _LINUX_NCP_H
+
+#include <linux/types.h>
+
+#define NCP_PTYPE                (0x11)
+#define NCP_PORT                 (0x0451)
+
+#define NCP_ALLOC_SLOT_REQUEST   (0x1111)
+#define NCP_REQUEST              (0x2222)
+#define NCP_DEALLOC_SLOT_REQUEST (0x5555)
+
+struct ncp_request_header {
+	__u16 type;
+	__u8 sequence;
+	__u8 conn_low;
+	__u8 task;
+	__u8 conn_high;
+	__u8 function;
+	__u8 data[0];
+} __attribute__((packed));
+
+#define NCP_REPLY                (0x3333)
+#define NCP_WATCHDOG		 (0x3E3E)
+#define NCP_POSITIVE_ACK         (0x9999)
+
+struct ncp_reply_header {
+	__u16 type;
+	__u8 sequence;
+	__u8 conn_low;
+	__u8 task;
+	__u8 conn_high;
+	__u8 completion_code;
+	__u8 connection_state;
+	__u8 data[0];
+} __attribute__((packed));
+
+#define NCP_VOLNAME_LEN (16)
+#define NCP_NUMBER_OF_VOLUMES (256)
+struct ncp_volume_info {
+	__u32 total_blocks;
+	__u32 free_blocks;
+	__u32 purgeable_blocks;
+	__u32 not_yet_purgeable_blocks;
+	__u32 total_dir_entries;
+	__u32 available_dir_entries;
+	__u8 sectors_per_block;
+	char volume_name[NCP_VOLNAME_LEN + 1];
+};
+
+#define AR_READ      (cpu_to_le16(1))
+#define AR_WRITE     (cpu_to_le16(2))
+#define AR_EXCLUSIVE (cpu_to_le16(0x20))
+
+#define NCP_FILE_ID_LEN 6
+
+/* Defines for Name Spaces */
+#define NW_NS_DOS     0
+#define NW_NS_MAC     1
+#define NW_NS_NFS     2
+#define NW_NS_FTAM    3
+#define NW_NS_OS2     4
+
+/*  Defines for ReturnInformationMask */
+#define RIM_NAME	      (cpu_to_le32(1))
+#define RIM_SPACE_ALLOCATED   (cpu_to_le32(2))
+#define RIM_ATTRIBUTES	      (cpu_to_le32(4))
+#define RIM_DATA_SIZE	      (cpu_to_le32(8))
+#define RIM_TOTAL_SIZE	      (cpu_to_le32(0x10))
+#define RIM_EXT_ATTR_INFO     (cpu_to_le32(0x20))
+#define RIM_ARCHIVE	      (cpu_to_le32(0x40))
+#define RIM_MODIFY	      (cpu_to_le32(0x80))
+#define RIM_CREATION	      (cpu_to_le32(0x100))
+#define RIM_OWNING_NAMESPACE  (cpu_to_le32(0x200))
+#define RIM_DIRECTORY	      (cpu_to_le32(0x400))
+#define RIM_RIGHTS	      (cpu_to_le32(0x800))
+#define RIM_ALL 	      (cpu_to_le32(0xFFF))
+#define RIM_COMPRESSED_INFO   (cpu_to_le32(0x80000000))
+
+/* Defines for NSInfoBitMask */
+#define NSIBM_NFS_NAME		0x0001
+#define NSIBM_NFS_MODE		0x0002
+#define NSIBM_NFS_GID		0x0004
+#define NSIBM_NFS_NLINKS	0x0008
+#define NSIBM_NFS_RDEV		0x0010
+#define NSIBM_NFS_LINK		0x0020
+#define NSIBM_NFS_CREATED	0x0040
+#define NSIBM_NFS_UID		0x0080
+#define NSIBM_NFS_ACSFLAG	0x0100
+#define NSIBM_NFS_MYFLAG	0x0200
+
+/* open/create modes */
+#define OC_MODE_OPEN	  0x01
+#define OC_MODE_TRUNCATE  0x02
+#define OC_MODE_REPLACE   0x02
+#define OC_MODE_CREATE	  0x08
+
+/* open/create results */
+#define OC_ACTION_NONE	   0x00
+#define OC_ACTION_OPEN	   0x01
+#define OC_ACTION_CREATE   0x02
+#define OC_ACTION_TRUNCATE 0x04
+#define OC_ACTION_REPLACE  0x04
+
+/* access rights attributes */
+#ifndef AR_READ_ONLY
+#define AR_READ_ONLY	   0x0001
+#define AR_WRITE_ONLY	   0x0002
+#define AR_DENY_READ	   0x0004
+#define AR_DENY_WRITE	   0x0008
+#define AR_COMPATIBILITY   0x0010
+#define AR_WRITE_THROUGH   0x0040
+#define AR_OPEN_COMPRESSED 0x0100
+#endif
+
+struct nw_nfs_info {
+	__u32 mode;
+	__u32 rdev;
+};
+
+struct nw_info_struct {
+	__u32 spaceAlloc;
+	__le32 attributes;
+	__u16 flags;
+	__le32 dataStreamSize;
+	__le32 totalStreamSize;
+	__u16 numberOfStreams;
+	__le16 creationTime;
+	__le16 creationDate;
+	__u32 creatorID;
+	__le16 modifyTime;
+	__le16 modifyDate;
+	__u32 modifierID;
+	__le16 lastAccessDate;
+	__u16 archiveTime;
+	__u16 archiveDate;
+	__u32 archiverID;
+	__u16 inheritedRightsMask;
+	__le32 dirEntNum;
+	__le32 DosDirNum;
+	__u32 volNumber;
+	__u32 EADataSize;
+	__u32 EAKeyCount;
+	__u32 EAKeySize;
+	__u32 NSCreator;
+	__u8 nameLen;
+	__u8 entryName[256];
+	/* libncp may depend on there being nothing after entryName */
+} __attribute__((packed));
+
+/* modify mask - use with MODIFY_DOS_INFO structure */
+#define DM_ATTRIBUTES		  (cpu_to_le32(0x02))
+#define DM_CREATE_DATE		  (cpu_to_le32(0x04))
+#define DM_CREATE_TIME		  (cpu_to_le32(0x08))
+#define DM_CREATOR_ID		  (cpu_to_le32(0x10))
+#define DM_ARCHIVE_DATE 	  (cpu_to_le32(0x20))
+#define DM_ARCHIVE_TIME 	  (cpu_to_le32(0x40))
+#define DM_ARCHIVER_ID		  (cpu_to_le32(0x80))
+#define DM_MODIFY_DATE		  (cpu_to_le32(0x0100))
+#define DM_MODIFY_TIME		  (cpu_to_le32(0x0200))
+#define DM_MODIFIER_ID		  (cpu_to_le32(0x0400))
+#define DM_LAST_ACCESS_DATE	  (cpu_to_le32(0x0800))
+#define DM_INHERITED_RIGHTS_MASK  (cpu_to_le32(0x1000))
+#define DM_MAXIMUM_SPACE	  (cpu_to_le32(0x2000))
+
+struct nw_modify_dos_info {
+	__le32 attributes;
+	__le16 creationDate;
+	__le16 creationTime;
+	__u32 creatorID;
+	__le16 modifyDate;
+	__le16 modifyTime;
+	__u32 modifierID;
+	__u16 archiveDate;
+	__u16 archiveTime;
+	__u32 archiverID;
+	__le16 lastAccessDate;
+	__u16 inheritanceGrantMask;
+	__u16 inheritanceRevokeMask;
+	__u32 maximumSpace;
+} __attribute__((packed));
+
+struct nw_search_sequence {
+	__u8 volNumber;
+	__u32 dirBase;
+	__u32 sequence;
+} __attribute__((packed));
+
+#endif				/* _LINUX_NCP_H */
diff -uNr linux-2.6.32/usr/include/linux/ncp_mount.h clean_modified/linux-2.6.32/usr/include/linux/ncp_mount.h
--- linux-2.6.32/usr/include/linux/ncp_mount.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ncp_mount.h	2019-04-14 13:24:03.033479747 -0500
@@ -0,0 +1,72 @@
+/*
+ *  ncp_mount.h
+ *
+ *  Copyright (C) 1995, 1996 by Volker Lendecke
+ *
+ */
+
+#ifndef _LINUX_NCP_MOUNT_H
+#define _LINUX_NCP_MOUNT_H
+
+#include <linux/types.h>
+#include <linux/ncp.h>
+
+#define NCP_MOUNT_VERSION 3	/* Binary */
+
+/* Values for flags */
+#define NCP_MOUNT_SOFT		0x0001
+#define NCP_MOUNT_INTR		0x0002
+#define NCP_MOUNT_STRONG	0x0004	/* enable delete/rename of r/o files */
+#define NCP_MOUNT_NO_OS2	0x0008	/* do not use OS/2 (LONG) namespace */
+#define NCP_MOUNT_NO_NFS	0x0010	/* do not use NFS namespace */
+#define NCP_MOUNT_EXTRAS	0x0020
+#define NCP_MOUNT_SYMLINKS	0x0040	/* enable symlinks */
+#define NCP_MOUNT_NFS_EXTRAS	0x0080	/* Enable use of NFS NS meta-info */
+
+struct ncp_mount_data {
+	int version;
+	unsigned int ncp_fd;	/* The socket to the ncp port */
+	__kernel_uid_t mounted_uid;	/* Who may umount() this filesystem? */
+	__kernel_pid_t wdog_pid;		/* Who cares for our watchdog packets? */
+
+	unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
+	unsigned int time_out;	/* How long should I wait after
+				   sending a NCP request? */
+	unsigned int retry_count;	/* And how often should I retry? */
+	unsigned int flags;
+
+	__kernel_uid_t uid;
+	__kernel_gid_t gid;
+	__kernel_mode_t file_mode;
+	__kernel_mode_t dir_mode;
+};
+
+#define NCP_MOUNT_VERSION_V4	(4)	/* Binary or text */
+
+struct ncp_mount_data_v4 {
+	int version;
+	unsigned long flags;	/* NCP_MOUNT_* flags */
+	/* MIPS uses long __kernel_uid_t, but... */
+	/* we neever pass -1, so it is safe */
+	unsigned long mounted_uid;	/* Who may umount() this filesystem? */
+	/* MIPS uses long __kernel_pid_t */
+	long wdog_pid;		/* Who cares for our watchdog packets? */
+
+	unsigned int ncp_fd;	/* The socket to the ncp port */
+	unsigned int time_out;	/* How long should I wait after
+				   sending a NCP request? */
+	unsigned int retry_count;	/* And how often should I retry? */
+
+	/* MIPS uses long __kernel_uid_t... */
+	/* we never pass -1, so it is safe */
+	unsigned long uid;
+	unsigned long gid;
+	/* MIPS uses unsigned long __kernel_mode_t */
+	unsigned long file_mode;
+	unsigned long dir_mode;
+};
+
+#define NCP_MOUNT_VERSION_V5	(5)	/* Text only */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ncp_no.h clean_modified/linux-2.6.32/usr/include/linux/ncp_no.h
--- linux-2.6.32/usr/include/linux/ncp_no.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ncp_no.h	2019-04-14 13:24:03.034455922 -0500
@@ -0,0 +1,19 @@
+#ifndef _NCP_NO
+#define _NCP_NO
+
+/* these define the attribute byte as seen by NCP */
+#define aRONLY			(__cpu_to_le32(1))
+#define aHIDDEN			(__cpu_to_le32(2))
+#define aSYSTEM			(__cpu_to_le32(4))
+#define aEXECUTE		(__cpu_to_le32(8))
+#define aDIR			(__cpu_to_le32(0x10))
+#define aARCH			(__cpu_to_le32(0x20))
+#define aSHARED			(__cpu_to_le32(0x80))
+#define aDONTSUBALLOCATE	(__cpu_to_le32(1L<<11))
+#define aTRANSACTIONAL		(__cpu_to_le32(1L<<12))
+#define aPURGE			(__cpu_to_le32(1L<<16))
+#define aRENAMEINHIBIT		(__cpu_to_le32(1L<<17))
+#define aDELETEINHIBIT		(__cpu_to_le32(1L<<18))
+#define aDONTCOMPRESS		(__cpu_to_le32(1L<<27))
+
+#endif /* _NCP_NO */
diff -uNr linux-2.6.32/usr/include/linux/neighbour.h clean_modified/linux-2.6.32/usr/include/linux/neighbour.h
--- linux-2.6.32/usr/include/linux/neighbour.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/neighbour.h	2019-04-14 13:24:03.034455922 -0500
@@ -0,0 +1,161 @@
+#ifndef __LINUX_NEIGHBOUR_H
+#define __LINUX_NEIGHBOUR_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct ndmsg
+{
+	__u8		ndm_family;
+	__u8		ndm_pad1;
+	__u16		ndm_pad2;
+	__s32		ndm_ifindex;
+	__u16		ndm_state;
+	__u8		ndm_flags;
+	__u8		ndm_type;
+};
+
+enum
+{
+	NDA_UNSPEC,
+	NDA_DST,
+	NDA_LLADDR,
+	NDA_CACHEINFO,
+	NDA_PROBES,
+	__NDA_MAX
+};
+
+#define NDA_MAX (__NDA_MAX - 1)
+
+/*
+ *	Neighbor Cache Entry Flags
+ */
+
+#define NTF_USE		0x01
+#define NTF_PROXY	0x08	/* == ATF_PUBL */
+#define NTF_ROUTER	0x80
+
+/*
+ *	Neighbor Cache Entry States.
+ */
+
+#define NUD_INCOMPLETE	0x01
+#define NUD_REACHABLE	0x02
+#define NUD_STALE	0x04
+#define NUD_DELAY	0x08
+#define NUD_PROBE	0x10
+#define NUD_FAILED	0x20
+
+/* Dummy states */
+#define NUD_NOARP	0x40
+#define NUD_PERMANENT	0x80
+#define NUD_NONE	0x00
+
+/* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
+   and make no address resolution or NUD.
+   NUD_PERMANENT is also cannot be deleted by garbage collectors.
+ */
+
+struct nda_cacheinfo
+{
+	__u32		ndm_confirmed;
+	__u32		ndm_used;
+	__u32		ndm_updated;
+	__u32		ndm_refcnt;
+};
+
+/*****************************************************************
+ *		Neighbour tables specific messages.
+ *
+ * To retrieve the neighbour tables send RTM_GETNEIGHTBL with the
+ * NLM_F_DUMP flag set. Every neighbour table configuration is
+ * spread over multiple messages to avoid running into message
+ * size limits on systems with many interfaces. The first message
+ * in the sequence transports all not device specific data such as
+ * statistics, configuration, and the default parameter set.
+ * This message is followed by 0..n messages carrying device
+ * specific parameter sets.
+ * Although the ordering should be sufficient, NDTA_NAME can be
+ * used to identify sequences. The initial message can be identified
+ * by checking for NDTA_CONFIG. The device specific messages do
+ * not contain this TLV but have NDTPA_IFINDEX set to the
+ * corresponding interface index.
+ *
+ * To change neighbour table attributes, send RTM_SETNEIGHTBL
+ * with NDTA_NAME set. Changeable attribute include NDTA_THRESH[1-3],
+ * NDTA_GC_INTERVAL, and all TLVs in NDTA_PARMS unless marked
+ * otherwise. Device specific parameter sets can be changed by
+ * setting NDTPA_IFINDEX to the interface index of the corresponding
+ * device.
+ ****/
+
+struct ndt_stats
+{
+	__u64		ndts_allocs;
+	__u64		ndts_destroys;
+	__u64		ndts_hash_grows;
+	__u64		ndts_res_failed;
+	__u64		ndts_lookups;
+	__u64		ndts_hits;
+	__u64		ndts_rcv_probes_mcast;
+	__u64		ndts_rcv_probes_ucast;
+	__u64		ndts_periodic_gc_runs;
+	__u64		ndts_forced_gc_runs;
+};
+
+enum {
+	NDTPA_UNSPEC,
+	NDTPA_IFINDEX,			/* u32, unchangeable */
+	NDTPA_REFCNT,			/* u32, read-only */
+	NDTPA_REACHABLE_TIME,		/* u64, read-only, msecs */
+	NDTPA_BASE_REACHABLE_TIME,	/* u64, msecs */
+	NDTPA_RETRANS_TIME,		/* u64, msecs */
+	NDTPA_GC_STALETIME,		/* u64, msecs */
+	NDTPA_DELAY_PROBE_TIME,		/* u64, msecs */
+	NDTPA_QUEUE_LEN,		/* u32 */
+	NDTPA_APP_PROBES,		/* u32 */
+	NDTPA_UCAST_PROBES,		/* u32 */
+	NDTPA_MCAST_PROBES,		/* u32 */
+	NDTPA_ANYCAST_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_QLEN,		/* u32 */
+	NDTPA_LOCKTIME,			/* u64, msecs */
+	__NDTPA_MAX
+};
+#define NDTPA_MAX (__NDTPA_MAX - 1)
+
+struct ndtmsg
+{
+	__u8		ndtm_family;
+	__u8		ndtm_pad1;
+	__u16		ndtm_pad2;
+};
+
+struct ndt_config
+{
+	__u16		ndtc_key_len;
+	__u16		ndtc_entry_size;
+	__u32		ndtc_entries;
+	__u32		ndtc_last_flush;	/* delta to now in msecs */
+	__u32		ndtc_last_rand;		/* delta to now in msecs */
+	__u32		ndtc_hash_rnd;
+	__u32		ndtc_hash_mask;
+	__u32		ndtc_hash_chain_gc;
+	__u32		ndtc_proxy_qlen;
+};
+
+enum {
+	NDTA_UNSPEC,
+	NDTA_NAME,			/* char *, unchangeable */
+	NDTA_THRESH1,			/* u32 */
+	NDTA_THRESH2,			/* u32 */
+	NDTA_THRESH3,			/* u32 */
+	NDTA_CONFIG,			/* struct ndt_config, read-only */
+	NDTA_PARMS,			/* nested TLV NDTPA_* */
+	NDTA_STATS,			/* struct ndt_stats, read-only */
+	NDTA_GC_INTERVAL,		/* u64, msecs */
+	__NDTA_MAX
+};
+#define NDTA_MAX (__NDTA_MAX - 1)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netdevice.h clean_modified/linux-2.6.32/usr/include/linux/netdevice.h
--- linux-2.6.32/usr/include/linux/netdevice.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netdevice.h	2019-04-14 13:24:03.034455922 -0500
@@ -0,0 +1,87 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the Interfaces handler.
+ *
+ * Version:	@(#)dev.h	1.0.10	08/12/93
+ *
+ * Authors:	Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Corey Minyard <wf-rch!minyard@relay.EU.net>
+ *		Donald J. Becker, <becker@cesdis.gsfc.nasa.gov>
+ *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *		Bjorn Ekwall. <bj0rn@blox.se>
+ *              Pekka Riikonen <priikone@poseidon.pspt.fi>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *		Moved to /usr/include/linux for NET3
+ */
+#ifndef _LINUX_NETDEVICE_H
+#define _LINUX_NETDEVICE_H
+
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+
+
+#define MAX_ADDR_LEN	32		/* Largest hardware address length */
+
+
+/*
+ *	Network device statistics. Akin to the 2.0 ether stats but
+ *	with byte counters.
+ */
+
+struct net_device_stats
+{
+	unsigned long	rx_packets;		/* total packets received	*/
+	unsigned long	tx_packets;		/* total packets transmitted	*/
+	unsigned long	rx_bytes;		/* total bytes received 	*/
+	unsigned long	tx_bytes;		/* total bytes transmitted	*/
+	unsigned long	rx_errors;		/* bad packets received		*/
+	unsigned long	tx_errors;		/* packet transmit problems	*/
+	unsigned long	rx_dropped;		/* no space in linux buffers	*/
+	unsigned long	tx_dropped;		/* no space available in linux	*/
+	unsigned long	multicast;		/* multicast packets received	*/
+	unsigned long	collisions;
+
+	/* detailed rx_errors: */
+	unsigned long	rx_length_errors;
+	unsigned long	rx_over_errors;		/* receiver ring buff overflow	*/
+	unsigned long	rx_crc_errors;		/* recved pkt with crc error	*/
+	unsigned long	rx_frame_errors;	/* recv'd frame alignment error */
+	unsigned long	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	unsigned long	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	unsigned long	tx_aborted_errors;
+	unsigned long	tx_carrier_errors;
+	unsigned long	tx_fifo_errors;
+	unsigned long	tx_heartbeat_errors;
+	unsigned long	tx_window_errors;
+	
+	/* for cslip etc */
+	unsigned long	rx_compressed;
+	unsigned long	tx_compressed;
+};
+
+
+/* Media selection options. */
+enum {
+        IF_PORT_UNKNOWN = 0,
+        IF_PORT_10BASE2,
+        IF_PORT_10BASET,
+        IF_PORT_AUI,
+        IF_PORT_100BASET,
+        IF_PORT_100BASETX,
+        IF_PORT_100BASEFX
+};
+
+
+#endif	/* _LINUX_NETDEVICE_H */
diff -uNr linux-2.6.32/usr/include/linux/net_dropmon.h clean_modified/linux-2.6.32/usr/include/linux/net_dropmon.h
--- linux-2.6.32/usr/include/linux/net_dropmon.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/net_dropmon.h	2019-04-14 13:24:03.035446938 -0500
@@ -0,0 +1,64 @@
+#ifndef __NET_DROPMON_H
+#define __NET_DROPMON_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct net_dm_drop_point {
+	__u8 pc[8];
+	__u32 count;
+};
+
+#define is_drop_point_hw(x) do {\
+	int ____i, ____j;\
+	for (____i = 0; ____i < 8; i ____i++)\
+		____j |= x[____i];\
+	____j;\
+} while (0)
+
+#define NET_DM_CFG_VERSION  0
+#define NET_DM_CFG_ALERT_COUNT  1
+#define NET_DM_CFG_ALERT_DELAY 2
+#define NET_DM_CFG_MAX 3
+
+struct net_dm_config_entry {
+	__u32 type;
+	__u64 data __attribute__((aligned(8)));
+};
+
+struct net_dm_config_msg {
+	__u32 entries;
+	struct net_dm_config_entry options[0];
+};
+
+struct net_dm_alert_msg {
+	__u32 entries;
+	struct net_dm_drop_point points[0];
+};
+
+struct net_dm_user_msg {
+	union {
+		struct net_dm_config_msg user;
+		struct net_dm_alert_msg alert;
+	} u;
+};
+
+
+/* These are the netlink message types for this protocol */
+
+enum {
+	NET_DM_CMD_UNSPEC = 0,
+	NET_DM_CMD_ALERT,
+	NET_DM_CMD_CONFIG,
+	NET_DM_CMD_START,
+	NET_DM_CMD_STOP,
+	_NET_DM_CMD_MAX,
+};
+
+#define NET_DM_CMD_MAX (_NET_DM_CMD_MAX - 1)
+
+/*
+ * Our group identifiers
+ */
+#define NET_DM_GRP_ALERT 1
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_common.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_common.h
--- linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_common.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_common.h	2019-04-14 13:24:03.037415645 -0500
@@ -0,0 +1,79 @@
+#ifndef _NF_CONNTRACK_COMMON_H
+#define _NF_CONNTRACK_COMMON_H
+/* Connection state tracking for netfilter.  This is separated from,
+   but required by, the NAT layer; it can also be used by an iptables
+   extension. */
+enum ip_conntrack_info
+{
+	/* Part of an established connection (either direction). */
+	IP_CT_ESTABLISHED,
+
+	/* Like NEW, but related to an existing connection, or ICMP error
+	   (in either direction). */
+	IP_CT_RELATED,
+
+	/* Started a new connection to track (only
+           IP_CT_DIR_ORIGINAL); may be a retransmission. */
+	IP_CT_NEW,
+
+	/* >= this indicates reply direction */
+	IP_CT_IS_REPLY,
+
+	/* Number of distinct IP_CT types (no NEW in reply dirn). */
+	IP_CT_NUMBER = IP_CT_IS_REPLY * 2 - 1
+};
+
+/* Bitset representing status of connection. */
+enum ip_conntrack_status {
+	/* It's an expected connection: bit 0 set.  This bit never changed */
+	IPS_EXPECTED_BIT = 0,
+	IPS_EXPECTED = (1 << IPS_EXPECTED_BIT),
+
+	/* We've seen packets both ways: bit 1 set.  Can be set, not unset. */
+	IPS_SEEN_REPLY_BIT = 1,
+	IPS_SEEN_REPLY = (1 << IPS_SEEN_REPLY_BIT),
+
+	/* Conntrack should never be early-expired. */
+	IPS_ASSURED_BIT = 2,
+	IPS_ASSURED = (1 << IPS_ASSURED_BIT),
+
+	/* Connection is confirmed: originating packet has left box */
+	IPS_CONFIRMED_BIT = 3,
+	IPS_CONFIRMED = (1 << IPS_CONFIRMED_BIT),
+
+	/* Connection needs src nat in orig dir.  This bit never changed. */
+	IPS_SRC_NAT_BIT = 4,
+	IPS_SRC_NAT = (1 << IPS_SRC_NAT_BIT),
+
+	/* Connection needs dst nat in orig dir.  This bit never changed. */
+	IPS_DST_NAT_BIT = 5,
+	IPS_DST_NAT = (1 << IPS_DST_NAT_BIT),
+
+	/* Both together. */
+	IPS_NAT_MASK = (IPS_DST_NAT | IPS_SRC_NAT),
+
+	/* Connection needs TCP sequence adjusted. */
+	IPS_SEQ_ADJUST_BIT = 6,
+	IPS_SEQ_ADJUST = (1 << IPS_SEQ_ADJUST_BIT),
+
+	/* NAT initialization bits. */
+	IPS_SRC_NAT_DONE_BIT = 7,
+	IPS_SRC_NAT_DONE = (1 << IPS_SRC_NAT_DONE_BIT),
+
+	IPS_DST_NAT_DONE_BIT = 8,
+	IPS_DST_NAT_DONE = (1 << IPS_DST_NAT_DONE_BIT),
+
+	/* Both together */
+	IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),
+
+	/* Connection is dying (removed from lists), can not be unset. */
+	IPS_DYING_BIT = 9,
+	IPS_DYING = (1 << IPS_DYING_BIT),
+
+	/* Connection has fixed timeout. */
+	IPS_FIXED_TIMEOUT_BIT = 10,
+	IPS_FIXED_TIMEOUT = (1 << IPS_FIXED_TIMEOUT_BIT),
+};
+
+
+#endif /* _NF_CONNTRACK_COMMON_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_ftp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_ftp.h
--- linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_ftp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_ftp.h	2019-04-14 13:24:03.038603030 -0500
@@ -0,0 +1,19 @@
+#ifndef _NF_CONNTRACK_FTP_H
+#define _NF_CONNTRACK_FTP_H
+/* FTP tracking. */
+
+/* This enum is exposed to userspace */
+enum nf_ct_ftp_type
+{
+	/* PORT command from client */
+	NF_CT_FTP_PORT,
+	/* PASV response from server */
+	NF_CT_FTP_PASV,
+	/* EPRT command from client */
+	NF_CT_FTP_EPRT,
+	/* EPSV response from server */
+	NF_CT_FTP_EPSV,
+};
+
+
+#endif /* _NF_CONNTRACK_FTP_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_sctp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_sctp.h
--- linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_sctp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_sctp.h	2019-04-14 13:24:03.043274389 -0500
@@ -0,0 +1,26 @@
+#ifndef _NF_CONNTRACK_SCTP_H
+#define _NF_CONNTRACK_SCTP_H
+/* SCTP tracking. */
+
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+
+enum sctp_conntrack {
+	SCTP_CONNTRACK_NONE,
+	SCTP_CONNTRACK_CLOSED,
+	SCTP_CONNTRACK_COOKIE_WAIT,
+	SCTP_CONNTRACK_COOKIE_ECHOED,
+	SCTP_CONNTRACK_ESTABLISHED,
+	SCTP_CONNTRACK_SHUTDOWN_SENT,
+	SCTP_CONNTRACK_SHUTDOWN_RECD,
+	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT,
+	SCTP_CONNTRACK_MAX
+};
+
+struct ip_ct_sctp
+{
+	enum sctp_conntrack state;
+
+	__be32 vtag[IP_CT_DIR_MAX];
+};
+
+#endif /* _NF_CONNTRACK_SCTP_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tcp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tcp.h
--- linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tcp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tcp.h	2019-04-14 13:24:03.043274389 -0500
@@ -0,0 +1,48 @@
+#ifndef _NF_CONNTRACK_TCP_H
+#define _NF_CONNTRACK_TCP_H
+/* TCP tracking. */
+
+#include <linux/types.h>
+
+/* This is exposed to userspace (ctnetlink) */
+enum tcp_conntrack {
+	TCP_CONNTRACK_NONE,
+	TCP_CONNTRACK_SYN_SENT,
+	TCP_CONNTRACK_SYN_RECV,
+	TCP_CONNTRACK_ESTABLISHED,
+	TCP_CONNTRACK_FIN_WAIT,
+	TCP_CONNTRACK_CLOSE_WAIT,
+	TCP_CONNTRACK_LAST_ACK,
+	TCP_CONNTRACK_TIME_WAIT,
+	TCP_CONNTRACK_CLOSE,
+	TCP_CONNTRACK_LISTEN,	/* obsolete */
+#define TCP_CONNTRACK_SYN_SENT2	TCP_CONNTRACK_LISTEN
+	TCP_CONNTRACK_MAX,
+	TCP_CONNTRACK_IGNORE
+};
+
+/* Window scaling is advertised by the sender */
+#define IP_CT_TCP_FLAG_WINDOW_SCALE		0x01
+
+/* SACK is permitted by the sender */
+#define IP_CT_TCP_FLAG_SACK_PERM		0x02
+
+/* This sender sent FIN first */
+#define IP_CT_TCP_FLAG_CLOSE_INIT		0x04
+
+/* Be liberal in window checking */
+#define IP_CT_TCP_FLAG_BE_LIBERAL		0x08
+
+/* Has unacknowledged data */
+#define IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED	0x10
+
+/* The field td_maxack has been set */
+#define IP_CT_TCP_FLAG_MAXACK_SET		0x20
+
+struct nf_ct_tcp_flags {
+	__u8 flags;
+	__u8 mask;
+};
+
+
+#endif /* _NF_CONNTRACK_TCP_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tuple_common.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tuple_common.h
--- linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tuple_common.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nf_conntrack_tuple_common.h	2019-04-14 13:24:03.043274389 -0500
@@ -0,0 +1,13 @@
+#ifndef _NF_CONNTRACK_TUPLE_COMMON_H
+#define _NF_CONNTRACK_TUPLE_COMMON_H
+
+enum ip_conntrack_dir
+{
+	IP_CT_DIR_ORIGINAL,
+	IP_CT_DIR_REPLY,
+	IP_CT_DIR_MAX
+};
+
+#define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)
+
+#endif /* _NF_CONNTRACK_TUPLE_COMMON_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nfnetlink_compat.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_compat.h
--- linux-2.6.32/usr/include/linux/netfilter/nfnetlink_compat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_compat.h	2019-04-14 13:24:03.045240583 -0500
@@ -0,0 +1,62 @@
+#ifndef _NFNETLINK_COMPAT_H
+#define _NFNETLINK_COMPAT_H
+
+#include <linux/types.h>
+
+/* Old nfnetlink macros for userspace */
+
+/* nfnetlink groups: Up to 32 maximum */
+#define NF_NETLINK_CONNTRACK_NEW 		0x00000001
+#define NF_NETLINK_CONNTRACK_UPDATE		0x00000002
+#define NF_NETLINK_CONNTRACK_DESTROY		0x00000004
+#define NF_NETLINK_CONNTRACK_EXP_NEW		0x00000008
+#define NF_NETLINK_CONNTRACK_EXP_UPDATE		0x00000010
+#define NF_NETLINK_CONNTRACK_EXP_DESTROY	0x00000020
+
+/* Generic structure for encapsulation optional netfilter information.
+ * It is reminiscent of sockaddr, but with sa_family replaced
+ * with attribute type.
+ * ! This should someday be put somewhere generic as now rtnetlink and
+ * ! nfnetlink use the same attributes methods. - J. Schulist.
+ */
+
+struct nfattr
+{
+	__u16 nfa_len;
+	__u16 nfa_type;	/* we use 15 bits for the type, and the highest
+				 * bit to indicate whether the payload is nested */
+};
+
+/* FIXME: Apart from NFNL_NFA_NESTED shamelessly copy and pasted from
+ * rtnetlink.h, it's time to put this in a generic file */
+
+#define NFNL_NFA_NEST	0x8000
+#define NFA_TYPE(attr) 	((attr)->nfa_type & 0x7fff)
+
+#define NFA_ALIGNTO     4
+#define NFA_ALIGN(len)	(((len) + NFA_ALIGNTO - 1) & ~(NFA_ALIGNTO - 1))
+#define NFA_OK(nfa,len)	((len) > 0 && (nfa)->nfa_len >= sizeof(struct nfattr) \
+	&& (nfa)->nfa_len <= (len))
+#define NFA_NEXT(nfa,attrlen)	((attrlen) -= NFA_ALIGN((nfa)->nfa_len), \
+	(struct nfattr *)(((char *)(nfa)) + NFA_ALIGN((nfa)->nfa_len)))
+#define NFA_LENGTH(len)	(NFA_ALIGN(sizeof(struct nfattr)) + (len))
+#define NFA_SPACE(len)	NFA_ALIGN(NFA_LENGTH(len))
+#define NFA_DATA(nfa)   ((void *)(((char *)(nfa)) + NFA_LENGTH(0)))
+#define NFA_PAYLOAD(nfa) ((int)((nfa)->nfa_len) - NFA_LENGTH(0))
+#define NFA_NEST(skb, type) \
+({	struct nfattr *__start = (struct nfattr *)skb_tail_pointer(skb); \
+	NFA_PUT(skb, (NFNL_NFA_NEST | type), 0, NULL); \
+	__start;  })
+#define NFA_NEST_END(skb, start) \
+({      (start)->nfa_len = skb_tail_pointer(skb) - (unsigned char *)(start); \
+        (skb)->len; })
+#define NFA_NEST_CANCEL(skb, start) \
+({      if (start) \
+                skb_trim(skb, (unsigned char *) (start) - (skb)->data); \
+        -1; })
+
+#define NFM_NFA(n)      ((struct nfattr *)(((char *)(n)) \
+        + NLMSG_ALIGN(sizeof(struct nfgenmsg))))
+#define NFM_PAYLOAD(n)  NLMSG_PAYLOAD(n, sizeof(struct nfgenmsg))
+
+#endif /* _NFNETLINK_COMPAT_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nfnetlink_conntrack.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_conntrack.h
--- linux-2.6.32/usr/include/linux/netfilter/nfnetlink_conntrack.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_conntrack.h	2019-04-14 13:24:03.045240583 -0500
@@ -0,0 +1,173 @@
+#ifndef _IPCONNTRACK_NETLINK_H
+#define _IPCONNTRACK_NETLINK_H
+#include <linux/netfilter/nfnetlink.h>
+
+enum cntl_msg_types {
+	IPCTNL_MSG_CT_NEW,
+	IPCTNL_MSG_CT_GET,
+	IPCTNL_MSG_CT_DELETE,
+	IPCTNL_MSG_CT_GET_CTRZERO,
+
+	IPCTNL_MSG_MAX
+};
+
+enum ctnl_exp_msg_types {
+	IPCTNL_MSG_EXP_NEW,
+	IPCTNL_MSG_EXP_GET,
+	IPCTNL_MSG_EXP_DELETE,
+
+	IPCTNL_MSG_EXP_MAX
+};
+
+
+enum ctattr_type {
+	CTA_UNSPEC,
+	CTA_TUPLE_ORIG,
+	CTA_TUPLE_REPLY,
+	CTA_STATUS,
+	CTA_PROTOINFO,
+	CTA_HELP,
+	CTA_NAT_SRC,
+#define CTA_NAT	CTA_NAT_SRC	/* backwards compatibility */
+	CTA_TIMEOUT,
+	CTA_MARK,
+	CTA_COUNTERS_ORIG,
+	CTA_COUNTERS_REPLY,
+	CTA_USE,
+	CTA_ID,
+	CTA_NAT_DST,
+	CTA_TUPLE_MASTER,
+	CTA_NAT_SEQ_ADJ_ORIG,
+	CTA_NAT_SEQ_ADJ_REPLY,
+	CTA_SECMARK,
+	__CTA_MAX
+};
+#define CTA_MAX (__CTA_MAX - 1)
+
+enum ctattr_tuple {
+	CTA_TUPLE_UNSPEC,
+	CTA_TUPLE_IP,
+	CTA_TUPLE_PROTO,
+	__CTA_TUPLE_MAX
+};
+#define CTA_TUPLE_MAX (__CTA_TUPLE_MAX - 1)
+
+enum ctattr_ip {
+	CTA_IP_UNSPEC,
+	CTA_IP_V4_SRC,
+	CTA_IP_V4_DST,
+	CTA_IP_V6_SRC,
+	CTA_IP_V6_DST,
+	__CTA_IP_MAX
+};
+#define CTA_IP_MAX (__CTA_IP_MAX - 1)
+
+enum ctattr_l4proto {
+	CTA_PROTO_UNSPEC,
+	CTA_PROTO_NUM,
+	CTA_PROTO_SRC_PORT,
+	CTA_PROTO_DST_PORT,
+	CTA_PROTO_ICMP_ID,
+	CTA_PROTO_ICMP_TYPE,
+	CTA_PROTO_ICMP_CODE,
+	CTA_PROTO_ICMPV6_ID,
+	CTA_PROTO_ICMPV6_TYPE,
+	CTA_PROTO_ICMPV6_CODE,
+	__CTA_PROTO_MAX
+};
+#define CTA_PROTO_MAX (__CTA_PROTO_MAX - 1)
+
+enum ctattr_protoinfo {
+	CTA_PROTOINFO_UNSPEC,
+	CTA_PROTOINFO_TCP,
+	CTA_PROTOINFO_DCCP,
+	CTA_PROTOINFO_SCTP,
+	__CTA_PROTOINFO_MAX
+};
+#define CTA_PROTOINFO_MAX (__CTA_PROTOINFO_MAX - 1)
+
+enum ctattr_protoinfo_tcp {
+	CTA_PROTOINFO_TCP_UNSPEC,
+	CTA_PROTOINFO_TCP_STATE,
+	CTA_PROTOINFO_TCP_WSCALE_ORIGINAL,
+	CTA_PROTOINFO_TCP_WSCALE_REPLY,
+	CTA_PROTOINFO_TCP_FLAGS_ORIGINAL,
+	CTA_PROTOINFO_TCP_FLAGS_REPLY,
+	__CTA_PROTOINFO_TCP_MAX
+};
+#define CTA_PROTOINFO_TCP_MAX (__CTA_PROTOINFO_TCP_MAX - 1)
+
+enum ctattr_protoinfo_dccp {
+	CTA_PROTOINFO_DCCP_UNSPEC,
+	CTA_PROTOINFO_DCCP_STATE,
+	CTA_PROTOINFO_DCCP_ROLE,
+	CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ,
+	__CTA_PROTOINFO_DCCP_MAX,
+};
+#define CTA_PROTOINFO_DCCP_MAX (__CTA_PROTOINFO_DCCP_MAX - 1)
+
+enum ctattr_protoinfo_sctp {
+	CTA_PROTOINFO_SCTP_UNSPEC,
+	CTA_PROTOINFO_SCTP_STATE,
+	CTA_PROTOINFO_SCTP_VTAG_ORIGINAL,
+	CTA_PROTOINFO_SCTP_VTAG_REPLY,
+	__CTA_PROTOINFO_SCTP_MAX
+};
+#define CTA_PROTOINFO_SCTP_MAX (__CTA_PROTOINFO_SCTP_MAX - 1)
+
+enum ctattr_counters {
+	CTA_COUNTERS_UNSPEC,
+	CTA_COUNTERS_PACKETS,		/* 64bit counters */
+	CTA_COUNTERS_BYTES,		/* 64bit counters */
+	CTA_COUNTERS32_PACKETS,		/* old 32bit counters, unused */
+	CTA_COUNTERS32_BYTES,		/* old 32bit counters, unused */
+	__CTA_COUNTERS_MAX
+};
+#define CTA_COUNTERS_MAX (__CTA_COUNTERS_MAX - 1)
+
+enum ctattr_nat {
+	CTA_NAT_UNSPEC,
+	CTA_NAT_MINIP,
+	CTA_NAT_MAXIP,
+	CTA_NAT_PROTO,
+	__CTA_NAT_MAX
+};
+#define CTA_NAT_MAX (__CTA_NAT_MAX - 1)
+
+enum ctattr_protonat {
+	CTA_PROTONAT_UNSPEC,
+	CTA_PROTONAT_PORT_MIN,
+	CTA_PROTONAT_PORT_MAX,
+	__CTA_PROTONAT_MAX
+};
+#define CTA_PROTONAT_MAX (__CTA_PROTONAT_MAX - 1)
+
+enum ctattr_natseq {
+	CTA_NAT_SEQ_UNSPEC,
+	CTA_NAT_SEQ_CORRECTION_POS,
+	CTA_NAT_SEQ_OFFSET_BEFORE,
+	CTA_NAT_SEQ_OFFSET_AFTER,
+	__CTA_NAT_SEQ_MAX
+};
+#define CTA_NAT_SEQ_MAX (__CTA_NAT_SEQ_MAX - 1)
+
+enum ctattr_expect {
+	CTA_EXPECT_UNSPEC,
+	CTA_EXPECT_MASTER,
+	CTA_EXPECT_TUPLE,
+	CTA_EXPECT_MASK,
+	CTA_EXPECT_TIMEOUT,
+	CTA_EXPECT_ID,
+	CTA_EXPECT_HELP_NAME,
+	__CTA_EXPECT_MAX
+};
+#define CTA_EXPECT_MAX (__CTA_EXPECT_MAX - 1)
+
+enum ctattr_help {
+	CTA_HELP_UNSPEC,
+	CTA_HELP_NAME,
+	__CTA_HELP_MAX
+};
+#define CTA_HELP_MAX (__CTA_HELP_MAX - 1)
+
+#endif /* _IPCONNTRACK_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nfnetlink.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink.h
--- linux-2.6.32/usr/include/linux/netfilter/nfnetlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink.h	2019-04-14 13:24:03.047273741 -0500
@@ -0,0 +1,52 @@
+#ifndef _NFNETLINK_H
+#define _NFNETLINK_H
+#include <linux/types.h>
+#include <linux/netfilter/nfnetlink_compat.h>
+
+enum nfnetlink_groups {
+	NFNLGRP_NONE,
+#define NFNLGRP_NONE			NFNLGRP_NONE
+	NFNLGRP_CONNTRACK_NEW,
+#define NFNLGRP_CONNTRACK_NEW		NFNLGRP_CONNTRACK_NEW
+	NFNLGRP_CONNTRACK_UPDATE,
+#define NFNLGRP_CONNTRACK_UPDATE	NFNLGRP_CONNTRACK_UPDATE
+	NFNLGRP_CONNTRACK_DESTROY,
+#define NFNLGRP_CONNTRACK_DESTROY	NFNLGRP_CONNTRACK_DESTROY
+	NFNLGRP_CONNTRACK_EXP_NEW,
+#define	NFNLGRP_CONNTRACK_EXP_NEW	NFNLGRP_CONNTRACK_EXP_NEW
+	NFNLGRP_CONNTRACK_EXP_UPDATE,
+#define NFNLGRP_CONNTRACK_EXP_UPDATE	NFNLGRP_CONNTRACK_EXP_UPDATE
+	NFNLGRP_CONNTRACK_EXP_DESTROY,
+#define NFNLGRP_CONNTRACK_EXP_DESTROY	NFNLGRP_CONNTRACK_EXP_DESTROY
+	__NFNLGRP_MAX,
+};
+#define NFNLGRP_MAX	(__NFNLGRP_MAX - 1)
+
+/* General form of address family dependent message.
+ */
+struct nfgenmsg {
+	__u8  nfgen_family;		/* AF_xxx */
+	__u8  version;		/* nfnetlink version */
+	__be16    res_id;		/* resource id */
+};
+
+#define NFNETLINK_V0	0
+
+/* netfilter netlink message types are split in two pieces:
+ * 8 bit subsystem, 8bit operation.
+ */
+
+#define NFNL_SUBSYS_ID(x)	((x & 0xff00) >> 8)
+#define NFNL_MSG_TYPE(x)	(x & 0x00ff)
+
+/* No enum here, otherwise __stringify() trick of MODULE_ALIAS_NFNL_SUBSYS()
+ * won't work anymore */
+#define NFNL_SUBSYS_NONE 		0
+#define NFNL_SUBSYS_CTNETLINK		1
+#define NFNL_SUBSYS_CTNETLINK_EXP	2
+#define NFNL_SUBSYS_QUEUE		3
+#define NFNL_SUBSYS_ULOG		4
+#define NFNL_SUBSYS_OSF			5
+#define NFNL_SUBSYS_COUNT		6
+
+#endif	/* _NFNETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nfnetlink_log.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_log.h
--- linux-2.6.32/usr/include/linux/netfilter/nfnetlink_log.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_log.h	2019-04-14 13:24:03.047273741 -0500
@@ -0,0 +1,96 @@
+#ifndef _NFNETLINK_LOG_H
+#define _NFNETLINK_LOG_H
+
+/* This file describes the netlink messages (i.e. 'protocol packets'),
+ * and not any kind of function definitions.  It is shared between kernel and
+ * userspace.  Don't put kernel specific stuff in here */
+
+#include <linux/types.h>
+#include <linux/netfilter/nfnetlink.h>
+
+enum nfulnl_msg_types {
+	NFULNL_MSG_PACKET,		/* packet from kernel to userspace */
+	NFULNL_MSG_CONFIG,		/* connect to a particular queue */
+
+	NFULNL_MSG_MAX
+};
+
+struct nfulnl_msg_packet_hdr {
+	__be16		hw_protocol;	/* hw protocol (network order) */
+	__u8	hook;		/* netfilter hook */
+	__u8	_pad;
+};
+
+struct nfulnl_msg_packet_hw {
+	__be16		hw_addrlen;
+	__u16	_pad;
+	__u8	hw_addr[8];
+};
+
+struct nfulnl_msg_packet_timestamp {
+	aligned_be64	sec;
+	aligned_be64	usec;
+};
+
+enum nfulnl_attr_type {
+	NFULA_UNSPEC,
+	NFULA_PACKET_HDR,
+	NFULA_MARK,			/* __u32 nfmark */
+	NFULA_TIMESTAMP,		/* nfulnl_msg_packet_timestamp */
+	NFULA_IFINDEX_INDEV,		/* __u32 ifindex */
+	NFULA_IFINDEX_OUTDEV,		/* __u32 ifindex */
+	NFULA_IFINDEX_PHYSINDEV,	/* __u32 ifindex */
+	NFULA_IFINDEX_PHYSOUTDEV,	/* __u32 ifindex */
+	NFULA_HWADDR,			/* nfulnl_msg_packet_hw */
+	NFULA_PAYLOAD,			/* opaque data payload */
+	NFULA_PREFIX,			/* string prefix */
+	NFULA_UID,			/* user id of socket */
+	NFULA_SEQ,			/* instance-local sequence number */
+	NFULA_SEQ_GLOBAL,		/* global sequence number */
+	NFULA_GID,			/* group id of socket */
+	NFULA_HWTYPE,			/* hardware type */
+	NFULA_HWHEADER,			/* hardware header */
+	NFULA_HWLEN,			/* hardware header length */
+
+	__NFULA_MAX
+};
+#define NFULA_MAX (__NFULA_MAX - 1)
+
+enum nfulnl_msg_config_cmds {
+	NFULNL_CFG_CMD_NONE,
+	NFULNL_CFG_CMD_BIND,
+	NFULNL_CFG_CMD_UNBIND,
+	NFULNL_CFG_CMD_PF_BIND,
+	NFULNL_CFG_CMD_PF_UNBIND,
+};
+
+struct nfulnl_msg_config_cmd {
+	__u8	command;	/* nfulnl_msg_config_cmds */
+} __attribute__ ((packed));
+
+struct nfulnl_msg_config_mode {
+	__be32		copy_range;
+	__u8	copy_mode;
+	__u8	_pad;
+} __attribute__ ((packed));
+
+enum nfulnl_attr_config {
+	NFULA_CFG_UNSPEC,
+	NFULA_CFG_CMD,			/* nfulnl_msg_config_cmd */
+	NFULA_CFG_MODE,			/* nfulnl_msg_config_mode */
+	NFULA_CFG_NLBUFSIZ,		/* __u32 buffer size */
+	NFULA_CFG_TIMEOUT,		/* __u32 in 1/100 s */
+	NFULA_CFG_QTHRESH,		/* __u32 */
+	NFULA_CFG_FLAGS,		/* __u16 */
+	__NFULA_CFG_MAX
+};
+#define NFULA_CFG_MAX (__NFULA_CFG_MAX -1)
+
+#define NFULNL_COPY_NONE	0x00
+#define NFULNL_COPY_META	0x01
+#define NFULNL_COPY_PACKET	0x02
+
+#define NFULNL_CFG_F_SEQ	0x0001
+#define NFULNL_CFG_F_SEQ_GLOBAL	0x0002
+
+#endif /* _NFNETLINK_LOG_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/nfnetlink_queue.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_queue.h
--- linux-2.6.32/usr/include/linux/netfilter/nfnetlink_queue.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/nfnetlink_queue.h	2019-04-14 13:24:03.047273741 -0500
@@ -0,0 +1,90 @@
+#ifndef _NFNETLINK_QUEUE_H
+#define _NFNETLINK_QUEUE_H
+
+#include <linux/types.h>
+#include <linux/netfilter/nfnetlink.h>
+
+enum nfqnl_msg_types {
+	NFQNL_MSG_PACKET,		/* packet from kernel to userspace */
+	NFQNL_MSG_VERDICT,		/* verdict from userspace to kernel */
+	NFQNL_MSG_CONFIG,		/* connect to a particular queue */
+
+	NFQNL_MSG_MAX
+};
+
+struct nfqnl_msg_packet_hdr {
+	__be32		packet_id;	/* unique ID of packet in queue */
+	__be16		hw_protocol;	/* hw protocol (network order) */
+	__u8	hook;		/* netfilter hook */
+} __attribute__ ((packed));
+
+struct nfqnl_msg_packet_hw {
+	__be16		hw_addrlen;
+	__u16	_pad;
+	__u8	hw_addr[8];
+};
+
+struct nfqnl_msg_packet_timestamp {
+	aligned_be64	sec;
+	aligned_be64	usec;
+};
+
+enum nfqnl_attr_type {
+	NFQA_UNSPEC,
+	NFQA_PACKET_HDR,
+	NFQA_VERDICT_HDR,		/* nfqnl_msg_verdict_hrd */
+	NFQA_MARK,			/* __u32 nfmark */
+	NFQA_TIMESTAMP,			/* nfqnl_msg_packet_timestamp */
+	NFQA_IFINDEX_INDEV,		/* __u32 ifindex */
+	NFQA_IFINDEX_OUTDEV,		/* __u32 ifindex */
+	NFQA_IFINDEX_PHYSINDEV,		/* __u32 ifindex */
+	NFQA_IFINDEX_PHYSOUTDEV,	/* __u32 ifindex */
+	NFQA_HWADDR,			/* nfqnl_msg_packet_hw */
+	NFQA_PAYLOAD,			/* opaque data payload */
+
+	__NFQA_MAX
+};
+#define NFQA_MAX (__NFQA_MAX - 1)
+
+struct nfqnl_msg_verdict_hdr {
+	__be32 verdict;
+	__be32 id;
+};
+
+
+enum nfqnl_msg_config_cmds {
+	NFQNL_CFG_CMD_NONE,
+	NFQNL_CFG_CMD_BIND,
+	NFQNL_CFG_CMD_UNBIND,
+	NFQNL_CFG_CMD_PF_BIND,
+	NFQNL_CFG_CMD_PF_UNBIND,
+};
+
+struct nfqnl_msg_config_cmd {
+	__u8	command;	/* nfqnl_msg_config_cmds */
+	__u8	_pad;
+	__be16		pf;		/* AF_xxx for PF_[UN]BIND */
+};
+
+enum nfqnl_config_mode {
+	NFQNL_COPY_NONE,
+	NFQNL_COPY_META,
+	NFQNL_COPY_PACKET,
+};
+
+struct nfqnl_msg_config_params {
+	__be32		copy_range;
+	__u8	copy_mode;	/* enum nfqnl_config_mode */
+} __attribute__ ((packed));
+
+
+enum nfqnl_attr_config {
+	NFQA_CFG_UNSPEC,
+	NFQA_CFG_CMD,			/* nfqnl_msg_config_cmd */
+	NFQA_CFG_PARAMS,		/* nfqnl_msg_config_params */
+	NFQA_CFG_QUEUE_MAXLEN,		/* __u32 */
+	__NFQA_CFG_MAX
+};
+#define NFQA_CFG_MAX (__NFQA_CFG_MAX-1)
+
+#endif /* _NFNETLINK_QUEUE_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/x_tables.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/x_tables.h
--- linux-2.6.32/usr/include/linux/netfilter/x_tables.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/x_tables.h	2019-04-14 13:24:03.048124571 -0500
@@ -0,0 +1,175 @@
+#ifndef _X_TABLES_H
+#define _X_TABLES_H
+
+#include <linux/types.h>
+
+#define XT_FUNCTION_MAXNAMELEN 30
+#define XT_TABLE_MAXNAMELEN 32
+
+struct xt_entry_match
+{
+	union {
+		struct {
+			__u16 match_size;
+
+			/* Used by userspace */
+			char name[XT_FUNCTION_MAXNAMELEN-1];
+
+			__u8 revision;
+		} user;
+		struct {
+			__u16 match_size;
+
+			/* Used inside the kernel */
+			struct xt_match *match;
+		} kernel;
+
+		/* Total length */
+		__u16 match_size;
+	} u;
+
+	unsigned char data[0];
+};
+
+struct xt_entry_target
+{
+	union {
+		struct {
+			__u16 target_size;
+
+			/* Used by userspace */
+			char name[XT_FUNCTION_MAXNAMELEN-1];
+
+			__u8 revision;
+		} user;
+		struct {
+			__u16 target_size;
+
+			/* Used inside the kernel */
+			struct xt_target *target;
+		} kernel;
+
+		/* Total length */
+		__u16 target_size;
+	} u;
+
+	unsigned char data[0];
+};
+
+#define XT_TARGET_INIT(__name, __size)					       \
+{									       \
+	.target.u.user = {						       \
+		.target_size	= XT_ALIGN(__size),			       \
+		.name		= __name,				       \
+	},								       \
+}
+
+struct xt_standard_target
+{
+	struct xt_entry_target target;
+	int verdict;
+};
+
+/* The argument to IPT_SO_GET_REVISION_*.  Returns highest revision
+ * kernel supports, if >= revision. */
+struct xt_get_revision
+{
+	char name[XT_FUNCTION_MAXNAMELEN-1];
+
+	__u8 revision;
+};
+
+/* CONTINUE verdict for targets */
+#define XT_CONTINUE 0xFFFFFFFF
+
+/* For standard target */
+#define XT_RETURN (-NF_REPEAT - 1)
+
+/* this is a dummy structure to find out the alignment requirement for a struct
+ * containing all the fundamental data types that are used in ipt_entry,
+ * ip6t_entry and arpt_entry.  This sucks, and it is a hack.  It will be my
+ * personal pleasure to remove it -HW
+ */
+struct _xt_align
+{
+	__u8 u8;
+	__u16 u16;
+	__u32 u32;
+	__u64 u64;
+};
+
+#define XT_ALIGN(s) (((s) + (__alignof__(struct _xt_align)-1)) 	\
+			& ~(__alignof__(struct _xt_align)-1))
+
+/* Standard return verdict, or do jump. */
+#define XT_STANDARD_TARGET ""
+/* Error verdict. */
+#define XT_ERROR_TARGET "ERROR"
+
+#define SET_COUNTER(c,b,p) do { (c).bcnt = (b); (c).pcnt = (p); } while(0)
+#define ADD_COUNTER(c,b,p) do { (c).bcnt += (b); (c).pcnt += (p); } while(0)
+
+struct xt_counters
+{
+	__u64 pcnt, bcnt;			/* Packet and byte counters */
+};
+
+/* The argument to IPT_SO_ADD_COUNTERS. */
+struct xt_counters_info
+{
+	/* Which table. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	unsigned int num_counters;
+
+	/* The counters (actually `number' of these). */
+	struct xt_counters counters[0];
+};
+
+#define XT_INV_PROTO		0x40	/* Invert the sense of PROTO. */
+
+/* fn returns 0 to continue iteration */
+#define XT_MATCH_ITERATE(type, e, fn, args...)			\
+({								\
+	unsigned int __i;					\
+	int __ret = 0;						\
+	struct xt_entry_match *__m;				\
+								\
+	for (__i = sizeof(type);				\
+	     __i < (e)->target_offset;				\
+	     __i += __m->u.match_size) {			\
+		__m = (void *)e + __i;				\
+								\
+		__ret = fn(__m , ## args);			\
+		if (__ret != 0)					\
+			break;					\
+	}							\
+	__ret;							\
+})
+
+/* fn returns 0 to continue iteration */
+#define XT_ENTRY_ITERATE_CONTINUE(type, entries, size, n, fn, args...) \
+({								\
+	unsigned int __i, __n;					\
+	int __ret = 0;						\
+	type *__entry;						\
+								\
+	for (__i = 0, __n = 0; __i < (size);			\
+	     __i += __entry->next_offset, __n++) { 		\
+		__entry = (void *)(entries) + __i;		\
+		if (__n < n)					\
+			continue;				\
+								\
+		__ret = fn(__entry , ## args);			\
+		if (__ret != 0)					\
+			break;					\
+	}							\
+	__ret;							\
+})
+
+/* fn returns 0 to continue iteration */
+#define XT_ENTRY_ITERATE(type, entries, size, fn, args...) \
+	XT_ENTRY_ITERATE_CONTINUE(type, entries, size, 0, fn, args)
+
+
+#endif /* _X_TABLES_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_CLASSIFY.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CLASSIFY.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_CLASSIFY.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CLASSIFY.h	2019-04-14 13:24:03.048124571 -0500
@@ -0,0 +1,10 @@
+#ifndef _XT_CLASSIFY_H
+#define _XT_CLASSIFY_H
+
+#include <linux/types.h>
+
+struct xt_classify_target_info {
+	__u32 priority;
+};
+
+#endif /*_XT_CLASSIFY_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_cluster.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_cluster.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_cluster.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_cluster.h	2019-04-14 13:24:03.048124571 -0500
@@ -0,0 +1,17 @@
+#ifndef _XT_CLUSTER_MATCH_H
+#define _XT_CLUSTER_MATCH_H
+
+enum xt_cluster_flags {
+	XT_CLUSTER_F_INV	= (1 << 0)
+};
+
+struct xt_cluster_match_info {
+	u_int32_t		total_nodes;
+	u_int32_t		node_mask;
+	u_int32_t		hash_seed;
+	u_int32_t		flags;
+};
+
+#define XT_CLUSTER_NODES_MAX	32
+
+#endif /* _XT_CLUSTER_MATCH_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_comment.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_comment.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_comment.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_comment.h	2019-04-14 13:24:03.048124571 -0500
@@ -0,0 +1,10 @@
+#ifndef _XT_COMMENT_H
+#define _XT_COMMENT_H
+
+#define XT_MAX_COMMENT_LEN 256
+
+struct xt_comment_info {
+	unsigned char comment[XT_MAX_COMMENT_LEN];
+};
+
+#endif /* XT_COMMENT_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_connbytes.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connbytes.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_connbytes.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connbytes.h	2019-04-14 13:24:03.049105458 -0500
@@ -0,0 +1,27 @@
+#ifndef _XT_CONNBYTES_H
+#define _XT_CONNBYTES_H
+
+#include <linux/types.h>
+
+enum xt_connbytes_what {
+	XT_CONNBYTES_PKTS,
+	XT_CONNBYTES_BYTES,
+	XT_CONNBYTES_AVGPKT,
+};
+
+enum xt_connbytes_direction {
+	XT_CONNBYTES_DIR_ORIGINAL,
+	XT_CONNBYTES_DIR_REPLY,
+	XT_CONNBYTES_DIR_BOTH,
+};
+
+struct xt_connbytes_info
+{
+	struct {
+		aligned_u64 from;	/* count to be matched */
+		aligned_u64 to;		/* count to be matched */
+	} count;
+	__u8 what;		/* ipt_connbytes_what */
+	__u8 direction;	/* ipt_connbytes_direction */
+};
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_connlimit.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connlimit.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_connlimit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connlimit.h	2019-04-14 13:24:03.049105458 -0500
@@ -0,0 +1,20 @@
+#ifndef _XT_CONNLIMIT_H
+#define _XT_CONNLIMIT_H
+
+struct xt_connlimit_data;
+
+struct xt_connlimit_info {
+	union {
+		union nf_inet_addr mask;
+		union {
+			__be32 v4_mask;
+			__be32 v6_mask[4];
+		};
+	};
+	unsigned int limit, inverse;
+
+	/* Used internally by the kernel */
+	struct xt_connlimit_data *data __attribute__((aligned(8)));
+};
+
+#endif /* _XT_CONNLIMIT_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_connmark.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connmark.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_connmark.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_connmark.h	2019-04-14 13:24:03.049105458 -0500
@@ -0,0 +1,20 @@
+#ifndef _XT_CONNMARK_H
+#define _XT_CONNMARK_H
+
+#include <linux/types.h>
+
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+struct xt_connmark_mtinfo1 {
+	__u32 mark, mask;
+	__u8 invert;
+};
+
+#endif /*_XT_CONNMARK_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_CONNMARK.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CONNMARK.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_CONNMARK.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CONNMARK.h	2019-04-14 13:24:03.049105458 -0500
@@ -0,0 +1,26 @@
+#ifndef _XT_CONNMARK_H_target
+#define _XT_CONNMARK_H_target
+
+#include <linux/types.h>
+
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+enum {
+	XT_CONNMARK_SET = 0,
+	XT_CONNMARK_SAVE,
+	XT_CONNMARK_RESTORE
+};
+
+struct xt_connmark_tginfo1 {
+	__u32 ctmark, ctmask, nfmask;
+	__u8 mode;
+};
+
+#endif /*_XT_CONNMARK_H_target*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_CONNSECMARK.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CONNSECMARK.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_CONNSECMARK.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_CONNSECMARK.h	2019-04-14 13:24:03.049105458 -0500
@@ -0,0 +1,15 @@
+#ifndef _XT_CONNSECMARK_H_target
+#define _XT_CONNSECMARK_H_target
+
+#include <linux/types.h>
+
+enum {
+	CONNSECMARK_SAVE = 1,
+	CONNSECMARK_RESTORE,
+};
+
+struct xt_connsecmark_target_info {
+	__u8 mode;
+};
+
+#endif /*_XT_CONNSECMARK_H_target */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_conntrack.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_conntrack.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_conntrack.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_conntrack.h	2019-04-14 13:24:03.050069896 -0500
@@ -0,0 +1,61 @@
+/* Header file for kernel module to match connection tracking information.
+ * GPL (C) 2001  Marc Boucher (marc@mbsi.ca).
+ */
+
+#ifndef _XT_CONNTRACK_H
+#define _XT_CONNTRACK_H
+
+#include <linux/types.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+
+#define XT_CONNTRACK_STATE_BIT(ctinfo) (1 << ((ctinfo)%IP_CT_IS_REPLY+1))
+#define XT_CONNTRACK_STATE_INVALID (1 << 0)
+
+#define XT_CONNTRACK_STATE_SNAT (1 << (IP_CT_NUMBER + 1))
+#define XT_CONNTRACK_STATE_DNAT (1 << (IP_CT_NUMBER + 2))
+#define XT_CONNTRACK_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 3))
+
+/* flags, invflags: */
+enum {
+	XT_CONNTRACK_STATE        = 1 << 0,
+	XT_CONNTRACK_PROTO        = 1 << 1,
+	XT_CONNTRACK_ORIGSRC      = 1 << 2,
+	XT_CONNTRACK_ORIGDST      = 1 << 3,
+	XT_CONNTRACK_REPLSRC      = 1 << 4,
+	XT_CONNTRACK_REPLDST      = 1 << 5,
+	XT_CONNTRACK_STATUS       = 1 << 6,
+	XT_CONNTRACK_EXPIRES      = 1 << 7,
+	XT_CONNTRACK_ORIGSRC_PORT = 1 << 8,
+	XT_CONNTRACK_ORIGDST_PORT = 1 << 9,
+	XT_CONNTRACK_REPLSRC_PORT = 1 << 10,
+	XT_CONNTRACK_REPLDST_PORT = 1 << 11,
+	XT_CONNTRACK_DIRECTION    = 1 << 12,
+};
+
+struct xt_conntrack_mtinfo1 {
+	union nf_inet_addr origsrc_addr, origsrc_mask;
+	union nf_inet_addr origdst_addr, origdst_mask;
+	union nf_inet_addr replsrc_addr, replsrc_mask;
+	union nf_inet_addr repldst_addr, repldst_mask;
+	__u32 expires_min, expires_max;
+	__u16 l4proto;
+	__be16 origsrc_port, origdst_port;
+	__be16 replsrc_port, repldst_port;
+	__u16 match_flags, invert_flags;
+	__u8 state_mask, status_mask;
+};
+
+struct xt_conntrack_mtinfo2 {
+	union nf_inet_addr origsrc_addr, origsrc_mask;
+	union nf_inet_addr origdst_addr, origdst_mask;
+	union nf_inet_addr replsrc_addr, replsrc_mask;
+	union nf_inet_addr repldst_addr, repldst_mask;
+	__u32 expires_min, expires_max;
+	__u16 l4proto;
+	__be16 origsrc_port, origdst_port;
+	__be16 replsrc_port, repldst_port;
+	__u16 match_flags, invert_flags;
+	__u16 state_mask, status_mask;
+};
+
+#endif /*_XT_CONNTRACK_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_dccp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_dccp.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_dccp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_dccp.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,25 @@
+#ifndef _XT_DCCP_H_
+#define _XT_DCCP_H_
+
+#include <linux/types.h>
+
+#define XT_DCCP_SRC_PORTS	        0x01
+#define XT_DCCP_DEST_PORTS	        0x02
+#define XT_DCCP_TYPE			0x04
+#define XT_DCCP_OPTION			0x08
+
+#define XT_DCCP_VALID_FLAGS		0x0f
+
+struct xt_dccp_info {
+	__u16 dpts[2];  /* Min, Max */
+	__u16 spts[2];  /* Min, Max */
+
+	__u16 flags;
+	__u16 invflags;
+
+	__u16 typemask;
+	__u8 option;
+};
+
+#endif /* _XT_DCCP_H_ */
+
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_dscp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_dscp.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_dscp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_dscp.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,31 @@
+/* x_tables module for matching the IPv4/IPv6 DSCP field
+ *
+ * (C) 2002 Harald Welte <laforge@gnumonks.org>
+ * This software is distributed under GNU GPL v2, 1991
+ *
+ * See RFC2474 for a description of the DSCP field within the IP Header.
+ *
+ * xt_dscp.h,v 1.3 2002/08/05 19:00:21 laforge Exp
+*/
+#ifndef _XT_DSCP_H
+#define _XT_DSCP_H
+
+#include <linux/types.h>
+
+#define XT_DSCP_MASK	0xfc	/* 11111100 */
+#define XT_DSCP_SHIFT	2
+#define XT_DSCP_MAX	0x3f	/* 00111111 */
+
+/* match info */
+struct xt_dscp_info {
+	__u8 dscp;
+	__u8 invert;
+};
+
+struct xt_tos_match_info {
+	__u8 tos_mask;
+	__u8 tos_value;
+	__u8 invert;
+};
+
+#endif /* _XT_DSCP_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_DSCP.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_DSCP.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_DSCP.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_DSCP.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,26 @@
+/* x_tables module for setting the IPv4/IPv6 DSCP field
+ *
+ * (C) 2002 Harald Welte <laforge@gnumonks.org>
+ * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
+ * This software is distributed under GNU GPL v2, 1991
+ *
+ * See RFC2474 for a description of the DSCP field within the IP Header.
+ *
+ * xt_DSCP.h,v 1.7 2002/03/14 12:03:13 laforge Exp
+*/
+#ifndef _XT_DSCP_TARGET_H
+#define _XT_DSCP_TARGET_H
+#include <linux/netfilter/xt_dscp.h>
+#include <linux/types.h>
+
+/* target info */
+struct xt_DSCP_info {
+	__u8 dscp;
+};
+
+struct xt_tos_target_info {
+	__u8 tos_value;
+	__u8 tos_mask;
+};
+
+#endif /* _XT_DSCP_TARGET_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_esp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_esp.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_esp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_esp.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,16 @@
+#ifndef _XT_ESP_H
+#define _XT_ESP_H
+
+#include <linux/types.h>
+
+struct xt_esp
+{
+	__u32 spis[2];	/* Security Parameter Index */
+	__u8  invflags;	/* Inverse flags */
+};
+
+/* Values for "invflags" field in struct xt_esp. */
+#define XT_ESP_INV_SPI	0x01	/* Invert the sense of spi. */
+#define XT_ESP_INV_MASK	0x01	/* All possible flags. */
+
+#endif /*_XT_ESP_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_hashlimit.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_hashlimit.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_hashlimit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_hashlimit.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,68 @@
+#ifndef _XT_HASHLIMIT_H
+#define _XT_HASHLIMIT_H
+
+#include <linux/types.h>
+
+/* timings are in milliseconds. */
+#define XT_HASHLIMIT_SCALE 10000
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+
+/* details of this structure hidden by the implementation */
+struct xt_hashlimit_htable;
+
+enum {
+	XT_HASHLIMIT_HASH_DIP = 1 << 0,
+	XT_HASHLIMIT_HASH_DPT = 1 << 1,
+	XT_HASHLIMIT_HASH_SIP = 1 << 2,
+	XT_HASHLIMIT_HASH_SPT = 1 << 3,
+	XT_HASHLIMIT_INVERT   = 1 << 4,
+};
+
+struct hashlimit_cfg {
+	__u32 mode;	  /* bitmask of XT_HASHLIMIT_HASH_* */
+	__u32 avg;    /* Average secs between packets * scale */
+	__u32 burst;  /* Period multiplier for upper limit. */
+
+	/* user specified */
+	__u32 size;		/* how many buckets */
+	__u32 max;		/* max number of entries */
+	__u32 gc_interval;	/* gc interval */
+	__u32 expire;	/* when do entries expire? */
+};
+
+struct xt_hashlimit_info {
+	char name [IFNAMSIZ];		/* name */
+	struct hashlimit_cfg cfg;
+
+	/* Used internally by the kernel */
+	struct xt_hashlimit_htable *hinfo;
+	union {
+		void *ptr;
+		struct xt_hashlimit_info *master;
+	} u;
+};
+
+struct hashlimit_cfg1 {
+	__u32 mode;	  /* bitmask of XT_HASHLIMIT_HASH_* */
+	__u32 avg;    /* Average secs between packets * scale */
+	__u32 burst;  /* Period multiplier for upper limit. */
+
+	/* user specified */
+	__u32 size;		/* how many buckets */
+	__u32 max;		/* max number of entries */
+	__u32 gc_interval;	/* gc interval */
+	__u32 expire;	/* when do entries expire? */
+
+	__u8 srcmask, dstmask;
+};
+
+struct xt_hashlimit_mtinfo1 {
+	char name[IFNAMSIZ];
+	struct hashlimit_cfg1 cfg;
+
+	/* Used internally by the kernel */
+	struct xt_hashlimit_htable *hinfo __attribute__((aligned(8)));
+};
+
+#endif /*_XT_HASHLIMIT_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_helper.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_helper.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_helper.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_helper.h	2019-04-14 13:24:03.050798874 -0500
@@ -0,0 +1,8 @@
+#ifndef _XT_HELPER_H
+#define _XT_HELPER_H
+
+struct xt_helper_info {
+	int invert;
+	char name[30];
+};
+#endif /* _XT_HELPER_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_iprange.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_iprange.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_iprange.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_iprange.h	2019-04-14 13:24:03.052056063 -0500
@@ -0,0 +1,19 @@
+#ifndef _LINUX_NETFILTER_XT_IPRANGE_H
+#define _LINUX_NETFILTER_XT_IPRANGE_H 1
+
+#include <linux/types.h>
+
+enum {
+	IPRANGE_SRC     = 1 << 0,	/* match source IP address */
+	IPRANGE_DST     = 1 << 1,	/* match destination IP address */
+	IPRANGE_SRC_INV = 1 << 4,	/* negate the condition */
+	IPRANGE_DST_INV = 1 << 5,	/* -"- */
+};
+
+struct xt_iprange_mtinfo {
+	union nf_inet_addr src_min, src_max;
+	union nf_inet_addr dst_min, dst_max;
+	__u8 flags;
+};
+
+#endif /* _LINUX_NETFILTER_XT_IPRANGE_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_LED.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_LED.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_LED.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_LED.h	2019-04-14 13:24:03.052056063 -0500
@@ -0,0 +1,15 @@
+#ifndef _XT_LED_H
+#define _XT_LED_H
+
+#include <linux/types.h>
+
+struct xt_led_info {
+	char id[27];        /* Unique ID for this trigger in the LED class */
+	__u8 always_blink;  /* Blink even if the LED is already on */
+	__u32 delay;        /* Delay until LED is switched off after trigger */
+
+	/* Kernel data used in the module */
+	void *internal_data __attribute__((aligned(8)));
+};
+
+#endif /* _XT_LED_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_length.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_length.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_length.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_length.h	2019-04-14 13:24:03.052056063 -0500
@@ -0,0 +1,11 @@
+#ifndef _XT_LENGTH_H
+#define _XT_LENGTH_H
+
+#include <linux/types.h>
+
+struct xt_length_info {
+    __u16	min, max;
+    __u8	invert;
+};
+
+#endif /*_XT_LENGTH_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_limit.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_limit.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_limit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_limit.h	2019-04-14 13:24:03.052056063 -0500
@@ -0,0 +1,24 @@
+#ifndef _XT_RATE_H
+#define _XT_RATE_H
+
+#include <linux/types.h>
+
+/* timings are in milliseconds. */
+#define XT_LIMIT_SCALE 10000
+
+struct xt_limit_priv;
+
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+struct xt_rateinfo {
+	__u32 avg;    /* Average secs between packets * scale */
+	__u32 burst;  /* Period multiplier for upper limit. */
+
+	/* Used internally by the kernel */
+	unsigned long prev; /* moved to xt_limit_priv */
+	__u32 credit; /* moved to xt_limit_priv */
+	__u32 credit_cap, cost;
+
+	struct xt_limit_priv *master;
+};
+#endif /*_XT_RATE_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_mac.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_mac.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_mac.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_mac.h	2019-04-14 13:24:03.053072234 -0500
@@ -0,0 +1,8 @@
+#ifndef _XT_MAC_H
+#define _XT_MAC_H
+
+struct xt_mac_info {
+    unsigned char srcaddr[ETH_ALEN];
+    int invert;
+};
+#endif /*_XT_MAC_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_mark.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_mark.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_mark.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_mark.h	2019-04-14 13:24:03.053072234 -0500
@@ -0,0 +1,11 @@
+#ifndef _XT_MARK_H
+#define _XT_MARK_H
+
+#include <linux/types.h>
+
+struct xt_mark_mtinfo1 {
+	__u32 mark, mask;
+	__u8 invert;
+};
+
+#endif /*_XT_MARK_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_MARK.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_MARK.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_MARK.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_MARK.h	2019-04-14 13:24:03.053072234 -0500
@@ -0,0 +1,10 @@
+#ifndef _XT_MARK_H_target
+#define _XT_MARK_H_target
+
+#include <linux/types.h>
+
+struct xt_mark_tginfo2 {
+	__u32 mark, mask;
+};
+
+#endif /*_XT_MARK_H_target */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_multiport.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_multiport.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_multiport.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_multiport.h	2019-04-14 13:24:03.054009950 -0500
@@ -0,0 +1,32 @@
+#ifndef _XT_MULTIPORT_H
+#define _XT_MULTIPORT_H
+
+#include <linux/types.h>
+
+enum xt_multiport_flags
+{
+	XT_MULTIPORT_SOURCE,
+	XT_MULTIPORT_DESTINATION,
+	XT_MULTIPORT_EITHER
+};
+
+#define XT_MULTI_PORTS	15
+
+/* Must fit inside union xt_matchinfo: 16 bytes */
+struct xt_multiport
+{
+	__u8 flags;				/* Type of comparison */
+	__u8 count;				/* Number of ports */
+	__u16 ports[XT_MULTI_PORTS];	/* Ports */
+};
+
+struct xt_multiport_v1
+{
+	__u8 flags;				/* Type of comparison */
+	__u8 count;				/* Number of ports */
+	__u16 ports[XT_MULTI_PORTS];	/* Ports */
+	__u8 pflags[XT_MULTI_PORTS];	/* Port flags */
+	__u8 invert;			/* Invert flag */
+};
+
+#endif /*_XT_MULTIPORT_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_NFLOG.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_NFLOG.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_NFLOG.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_NFLOG.h	2019-04-14 13:24:03.054009950 -0500
@@ -0,0 +1,20 @@
+#ifndef _XT_NFLOG_TARGET
+#define _XT_NFLOG_TARGET
+
+#include <linux/types.h>
+
+#define XT_NFLOG_DEFAULT_GROUP		0x1
+#define XT_NFLOG_DEFAULT_THRESHOLD	0
+
+#define XT_NFLOG_MASK			0x0
+
+struct xt_nflog_info {
+	__u32	len;
+	__u16	group;
+	__u16	threshold;
+	__u16	flags;
+	__u16	pad;
+	char		prefix[64];
+};
+
+#endif /* _XT_NFLOG_TARGET */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_NFQUEUE.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_NFQUEUE.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_NFQUEUE.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_NFQUEUE.h	2019-04-14 13:24:03.054009950 -0500
@@ -0,0 +1,23 @@
+/* iptables module for using NFQUEUE mechanism
+ *
+ * (C) 2005 Harald Welte <laforge@netfilter.org>
+ *
+ * This software is distributed under GNU GPL v2, 1991
+ * 
+*/
+#ifndef _XT_NFQ_TARGET_H
+#define _XT_NFQ_TARGET_H
+
+#include <linux/types.h>
+
+/* target info */
+struct xt_NFQ_info {
+	__u16 queuenum;
+};
+
+struct xt_NFQ_info_v1 {
+	__u16 queuenum;
+	__u16 queues_total;
+};
+
+#endif /* _XT_NFQ_TARGET_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_osf.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_osf.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_osf.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_osf.h	2019-04-14 13:24:03.055101429 -0500
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2003+ Evgeniy Polyakov <johnpol@2ka.mxt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _XT_OSF_H
+#define _XT_OSF_H
+
+#include <linux/types.h>
+
+#define MAXGENRELEN		32
+
+#define XT_OSF_GENRE		(1<<0)
+#define	XT_OSF_TTL		(1<<1)
+#define XT_OSF_LOG		(1<<2)
+#define XT_OSF_INVERT		(1<<3)
+
+#define XT_OSF_LOGLEVEL_ALL	0	/* log all matched fingerprints */
+#define XT_OSF_LOGLEVEL_FIRST	1	/* log only the first matced fingerprint */
+#define XT_OSF_LOGLEVEL_ALL_KNOWN	2 /* do not log unknown packets */
+
+#define XT_OSF_TTL_TRUE		0	/* True ip and fingerprint TTL comparison */
+#define XT_OSF_TTL_LESS		1	/* Check if ip TTL is less than fingerprint one */
+#define XT_OSF_TTL_NOCHECK	2	/* Do not compare ip and fingerprint TTL at all */
+
+struct xt_osf_info {
+	char			genre[MAXGENRELEN];
+	__u32			len;
+	__u32			flags;
+	__u32			loglevel;
+	__u32			ttl;
+};
+
+/*
+ * Wildcard MSS (kind of).
+ * It is used to implement a state machine for the different wildcard values
+ * of the MSS and window sizes.
+ */
+struct xt_osf_wc {
+	__u32			wc;
+	__u32			val;
+};
+
+/*
+ * This struct represents IANA options
+ * http://www.iana.org/assignments/tcp-parameters
+ */
+struct xt_osf_opt {
+	__u16			kind, length;
+	struct xt_osf_wc	wc;
+};
+
+struct xt_osf_user_finger {
+	struct xt_osf_wc	wss;
+
+	__u8			ttl, df;
+	__u16			ss, mss;
+	__u16			opt_num;
+
+	char			genre[MAXGENRELEN];
+	char			version[MAXGENRELEN];
+	char			subtype[MAXGENRELEN];
+
+	/* MAX_IPOPTLEN is maximum if all options are NOPs or EOLs */
+	struct xt_osf_opt	opt[MAX_IPOPTLEN];
+};
+
+struct xt_osf_nlmsg {
+	struct xt_osf_user_finger	f;
+	struct iphdr		ip;
+	struct tcphdr		tcp;
+};
+
+/* Defines for IANA option kinds */
+
+enum iana_options {
+	OSFOPT_EOL = 0,		/* End of options */
+	OSFOPT_NOP, 		/* NOP */
+	OSFOPT_MSS, 		/* Maximum segment size */
+	OSFOPT_WSO, 		/* Window scale option */
+	OSFOPT_SACKP,		/* SACK permitted */
+	OSFOPT_SACK,		/* SACK */
+	OSFOPT_ECHO,
+	OSFOPT_ECHOREPLY,
+	OSFOPT_TS,		/* Timestamp option */
+	OSFOPT_POCP,		/* Partial Order Connection Permitted */
+	OSFOPT_POSP,		/* Partial Order Service Profile */
+
+	/* Others are not used in the current OSF */
+	OSFOPT_EMPTY = 255,
+};
+
+/*
+ * Initial window size option state machine: multiple of mss, mtu or
+ * plain numeric value. Can also be made as plain numeric value which
+ * is not a multiple of specified value.
+ */
+enum xt_osf_window_size_options {
+	OSF_WSS_PLAIN	= 0,
+	OSF_WSS_MSS,
+	OSF_WSS_MTU,
+	OSF_WSS_MODULO,
+	OSF_WSS_MAX,
+};
+
+/*
+ * Add/remove fingerprint from the kernel.
+ */
+enum xt_osf_msg_types {
+	OSF_MSG_ADD,
+	OSF_MSG_REMOVE,
+	OSF_MSG_MAX,
+};
+
+enum xt_osf_attr_type {
+	OSF_ATTR_UNSPEC,
+	OSF_ATTR_FINGER,
+	OSF_ATTR_MAX,
+};
+
+#endif				/* _XT_OSF_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_owner.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_owner.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_owner.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_owner.h	2019-04-14 13:24:03.055101429 -0500
@@ -0,0 +1,18 @@
+#ifndef _XT_OWNER_MATCH_H
+#define _XT_OWNER_MATCH_H
+
+#include <linux/types.h>
+
+enum {
+	XT_OWNER_UID    = 1 << 0,
+	XT_OWNER_GID    = 1 << 1,
+	XT_OWNER_SOCKET = 1 << 2,
+};
+
+struct xt_owner_match_info {
+	__u32 uid_min, uid_max;
+	__u32 gid_min, gid_max;
+	__u8 match, invert;
+};
+
+#endif /* _XT_OWNER_MATCH_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_physdev.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_physdev.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_physdev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_physdev.h	2019-04-14 13:24:03.055101429 -0500
@@ -0,0 +1,23 @@
+#ifndef _XT_PHYSDEV_H
+#define _XT_PHYSDEV_H
+
+#include <linux/types.h>
+
+
+#define XT_PHYSDEV_OP_IN		0x01
+#define XT_PHYSDEV_OP_OUT		0x02
+#define XT_PHYSDEV_OP_BRIDGED		0x04
+#define XT_PHYSDEV_OP_ISIN		0x08
+#define XT_PHYSDEV_OP_ISOUT		0x10
+#define XT_PHYSDEV_OP_MASK		(0x20 - 1)
+
+struct xt_physdev_info {
+	char physindev[IFNAMSIZ];
+	char in_mask[IFNAMSIZ];
+	char physoutdev[IFNAMSIZ];
+	char out_mask[IFNAMSIZ];
+	__u8 invert;
+	__u8 bitmask;
+};
+
+#endif /*_XT_PHYSDEV_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_pkttype.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_pkttype.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_pkttype.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_pkttype.h	2019-04-14 13:24:03.055975800 -0500
@@ -0,0 +1,8 @@
+#ifndef _XT_PKTTYPE_H
+#define _XT_PKTTYPE_H
+
+struct xt_pkttype_info {
+	int	pkttype;
+	int	invert;
+};
+#endif /*_XT_PKTTYPE_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_policy.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_policy.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_policy.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_policy.h	2019-04-14 13:24:03.056915479 -0500
@@ -0,0 +1,64 @@
+#ifndef _XT_POLICY_H
+#define _XT_POLICY_H
+
+#include <linux/types.h>
+
+#define XT_POLICY_MAX_ELEM	4
+
+enum xt_policy_flags
+{
+	XT_POLICY_MATCH_IN	= 0x1,
+	XT_POLICY_MATCH_OUT	= 0x2,
+	XT_POLICY_MATCH_NONE	= 0x4,
+	XT_POLICY_MATCH_STRICT	= 0x8,
+};
+
+enum xt_policy_modes
+{
+	XT_POLICY_MODE_TRANSPORT,
+	XT_POLICY_MODE_TUNNEL
+};
+
+struct xt_policy_spec
+{
+	__u8	saddr:1,
+			daddr:1,
+			proto:1,
+			mode:1,
+			spi:1,
+			reqid:1;
+};
+
+union xt_policy_addr
+{
+	struct in_addr	a4;
+	struct in6_addr	a6;
+};
+
+struct xt_policy_elem
+{
+	union {
+		struct {
+			union xt_policy_addr saddr;
+			union xt_policy_addr smask;
+			union xt_policy_addr daddr;
+			union xt_policy_addr dmask;
+		};
+	};
+	__be32			spi;
+	__u32		reqid;
+	__u8		proto;
+	__u8		mode;
+
+	struct xt_policy_spec	match;
+	struct xt_policy_spec	invert;
+};
+
+struct xt_policy_info
+{
+	struct xt_policy_elem pol[XT_POLICY_MAX_ELEM];
+	__u16 flags;
+	__u16 len;
+};
+
+#endif /* _XT_POLICY_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_quota.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_quota.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_quota.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_quota.h	2019-04-14 13:24:03.056915479 -0500
@@ -0,0 +1,20 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT		= 0x1,
+};
+#define XT_QUOTA_MASK		0x1
+
+struct xt_quota_priv;
+
+struct xt_quota_info {
+	u_int32_t		flags;
+	u_int32_t		pad;
+
+	/* Used internally by the kernel */
+	aligned_u64		quota;
+	struct xt_quota_priv	*master;
+};
+
+#endif /* _XT_QUOTA_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_rateest.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_rateest.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_rateest.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_rateest.h	2019-04-14 13:24:03.056915479 -0500
@@ -0,0 +1,37 @@
+#ifndef _XT_RATEEST_MATCH_H
+#define _XT_RATEEST_MATCH_H
+
+#include <linux/types.h>
+
+enum xt_rateest_match_flags {
+	XT_RATEEST_MATCH_INVERT	= 1<<0,
+	XT_RATEEST_MATCH_ABS	= 1<<1,
+	XT_RATEEST_MATCH_REL	= 1<<2,
+	XT_RATEEST_MATCH_DELTA	= 1<<3,
+	XT_RATEEST_MATCH_BPS	= 1<<4,
+	XT_RATEEST_MATCH_PPS	= 1<<5,
+};
+
+enum xt_rateest_match_mode {
+	XT_RATEEST_MATCH_NONE,
+	XT_RATEEST_MATCH_EQ,
+	XT_RATEEST_MATCH_LT,
+	XT_RATEEST_MATCH_GT,
+};
+
+struct xt_rateest_match_info {
+	char			name1[IFNAMSIZ];
+	char			name2[IFNAMSIZ];
+	__u16		flags;
+	__u16		mode;
+	__u32		bps1;
+	__u32		pps1;
+	__u32		bps2;
+	__u32		pps2;
+
+	/* Used internally by the kernel */
+	struct xt_rateest	*est1 __attribute__((aligned(8)));
+	struct xt_rateest	*est2 __attribute__((aligned(8)));
+};
+
+#endif /* _XT_RATEEST_MATCH_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_RATEEST.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_RATEEST.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_RATEEST.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_RATEEST.h	2019-04-14 13:24:03.057964544 -0500
@@ -0,0 +1,15 @@
+#ifndef _XT_RATEEST_TARGET_H
+#define _XT_RATEEST_TARGET_H
+
+#include <linux/types.h>
+
+struct xt_rateest_target_info {
+	char			name[IFNAMSIZ];
+	__s8			interval;
+	__u8		ewma_log;
+
+	/* Used internally by the kernel */
+	struct xt_rateest	*est __attribute__((aligned(8)));
+};
+
+#endif /* _XT_RATEEST_TARGET_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_realm.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_realm.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_realm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_realm.h	2019-04-14 13:24:03.057964544 -0500
@@ -0,0 +1,12 @@
+#ifndef _XT_REALM_H
+#define _XT_REALM_H
+
+#include <linux/types.h>
+
+struct xt_realm_info {
+	__u32 id;
+	__u32 mask;
+	__u8 invert;
+};
+
+#endif /* _XT_REALM_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_recent.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_recent.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_recent.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_recent.h	2019-04-14 13:24:03.057964544 -0500
@@ -0,0 +1,28 @@
+#ifndef _LINUX_NETFILTER_XT_RECENT_H
+#define _LINUX_NETFILTER_XT_RECENT_H 1
+
+#include <linux/types.h>
+
+enum {
+	XT_RECENT_CHECK    = 1 << 0,
+	XT_RECENT_SET      = 1 << 1,
+	XT_RECENT_UPDATE   = 1 << 2,
+	XT_RECENT_REMOVE   = 1 << 3,
+	XT_RECENT_TTL      = 1 << 4,
+
+	XT_RECENT_SOURCE   = 0,
+	XT_RECENT_DEST     = 1,
+
+	XT_RECENT_NAME_LEN = 200,
+};
+
+struct xt_recent_mtinfo {
+	__u32 seconds;
+	__u32 hit_count;
+	__u8 check_set;
+	__u8 invert;
+	char name[XT_RECENT_NAME_LEN];
+	__u8 side;
+};
+
+#endif /* _LINUX_NETFILTER_XT_RECENT_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_sctp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_sctp.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_sctp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_sctp.h	2019-04-14 13:24:03.057964544 -0500
@@ -0,0 +1,92 @@
+#ifndef _XT_SCTP_H_
+#define _XT_SCTP_H_
+
+#include <linux/types.h>
+
+#define XT_SCTP_SRC_PORTS	        0x01
+#define XT_SCTP_DEST_PORTS	        0x02
+#define XT_SCTP_CHUNK_TYPES		0x04
+
+#define XT_SCTP_VALID_FLAGS		0x07
+
+struct xt_sctp_flag_info {
+	__u8 chunktype;
+	__u8 flag;
+	__u8 flag_mask;
+};
+
+#define XT_NUM_SCTP_FLAGS	4
+
+struct xt_sctp_info {
+	__u16 dpts[2];  /* Min, Max */
+	__u16 spts[2];  /* Min, Max */
+
+	__u32 chunkmap[256 / sizeof (__u32)];  /* Bit mask of chunks to be matched according to RFC 2960 */
+
+#define SCTP_CHUNK_MATCH_ANY   0x01  /* Match if any of the chunk types are present */
+#define SCTP_CHUNK_MATCH_ALL   0x02  /* Match if all of the chunk types are present */
+#define SCTP_CHUNK_MATCH_ONLY  0x04  /* Match if these are the only chunk types present */
+
+	__u32 chunk_match_type;
+	struct xt_sctp_flag_info flag_info[XT_NUM_SCTP_FLAGS];
+	int flag_count;
+
+	__u32 flags;
+	__u32 invflags;
+};
+
+#define bytes(type) (sizeof(type) * 8)
+
+#define SCTP_CHUNKMAP_SET(chunkmap, type) 		\
+	do { 						\
+		(chunkmap)[type / bytes(__u32)] |= 	\
+			1 << (type % bytes(__u32));	\
+	} while (0)
+
+#define SCTP_CHUNKMAP_CLEAR(chunkmap, type)		 	\
+	do {							\
+		(chunkmap)[type / bytes(__u32)] &= 		\
+			~(1 << (type % bytes(__u32)));	\
+	} while (0)
+
+#define SCTP_CHUNKMAP_IS_SET(chunkmap, type) 			\
+({								\
+	((chunkmap)[type / bytes (__u32)] & 		\
+		(1 << (type % bytes (__u32)))) ? 1: 0;	\
+})
+
+#define SCTP_CHUNKMAP_RESET(chunkmap) \
+	memset((chunkmap), 0, sizeof(chunkmap))
+
+#define SCTP_CHUNKMAP_SET_ALL(chunkmap) \
+	memset((chunkmap), ~0U, sizeof(chunkmap))
+
+#define SCTP_CHUNKMAP_COPY(destmap, srcmap) \
+	memcpy((destmap), (srcmap), sizeof(srcmap))
+
+#define SCTP_CHUNKMAP_IS_CLEAR(chunkmap) \
+	__sctp_chunkmap_is_clear((chunkmap), ARRAY_SIZE(chunkmap))
+static __inline__ bool
+__sctp_chunkmap_is_clear(const __u32 *chunkmap, unsigned int n)
+{
+	unsigned int i;
+	for (i = 0; i < n; ++i)
+		if (chunkmap[i])
+			return false;
+	return true;
+}
+
+#define SCTP_CHUNKMAP_IS_ALL_SET(chunkmap) \
+	__sctp_chunkmap_is_all_set((chunkmap), ARRAY_SIZE(chunkmap))
+static __inline__ bool
+__sctp_chunkmap_is_all_set(const __u32 *chunkmap, unsigned int n)
+{
+	unsigned int i;
+	for (i = 0; i < n; ++i)
+		if (chunkmap[i] != ~0U)
+			return false;
+	return true;
+}
+
+#endif /* _XT_SCTP_H_ */
+
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_SECMARK.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_SECMARK.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_SECMARK.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_SECMARK.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,28 @@
+#ifndef _XT_SECMARK_H_target
+#define _XT_SECMARK_H_target
+
+#include <linux/types.h>
+
+/*
+ * This is intended for use by various security subsystems (but not
+ * at the same time).
+ *
+ * 'mode' refers to the specific security subsystem which the
+ * packets are being marked for.
+ */
+#define SECMARK_MODE_SEL	0x01		/* SELinux */
+#define SECMARK_SELCTX_MAX	256
+
+struct xt_secmark_target_selinux_info {
+	__u32 selsid;
+	char selctx[SECMARK_SELCTX_MAX];
+};
+
+struct xt_secmark_target_info {
+	__u8 mode;
+	union {
+		struct xt_secmark_target_selinux_info sel;
+	} u;
+};
+
+#endif /*_XT_SECMARK_H_target */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_state.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_state.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_state.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_state.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,13 @@
+#ifndef _XT_STATE_H
+#define _XT_STATE_H
+
+#define XT_STATE_BIT(ctinfo) (1 << ((ctinfo)%IP_CT_IS_REPLY+1))
+#define XT_STATE_INVALID (1 << 0)
+
+#define XT_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 1))
+
+struct xt_state_info
+{
+	unsigned int statemask;
+};
+#endif /*_XT_STATE_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_statistic.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_statistic.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_statistic.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_statistic.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,36 @@
+#ifndef _XT_STATISTIC_H
+#define _XT_STATISTIC_H
+
+#include <linux/types.h>
+
+enum xt_statistic_mode {
+	XT_STATISTIC_MODE_RANDOM,
+	XT_STATISTIC_MODE_NTH,
+	__XT_STATISTIC_MODE_MAX
+};
+#define XT_STATISTIC_MODE_MAX (__XT_STATISTIC_MODE_MAX - 1)
+
+enum xt_statistic_flags {
+	XT_STATISTIC_INVERT		= 0x1,
+};
+#define XT_STATISTIC_MASK		0x1
+
+struct xt_statistic_priv;
+
+struct xt_statistic_info {
+	__u16			mode;
+	__u16			flags;
+	union {
+		struct {
+			__u32	probability;
+		} random;
+		struct {
+			__u32	every;
+			__u32	packet;
+			__u32	count; /* unused */
+		} nth;
+	} u;
+	struct xt_statistic_priv *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_STATISTIC_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_string.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_string.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_string.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_string.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,35 @@
+#ifndef _XT_STRING_H
+#define _XT_STRING_H
+
+#include <linux/types.h>
+
+#define XT_STRING_MAX_PATTERN_SIZE 128
+#define XT_STRING_MAX_ALGO_NAME_SIZE 16
+
+enum {
+	XT_STRING_FLAG_INVERT		= 0x01,
+	XT_STRING_FLAG_IGNORECASE	= 0x02
+};
+
+struct xt_string_info
+{
+	__u16 from_offset;
+	__u16 to_offset;
+	char	  algo[XT_STRING_MAX_ALGO_NAME_SIZE];
+	char 	  pattern[XT_STRING_MAX_PATTERN_SIZE];
+	__u8  patlen;
+	union {
+		struct {
+			__u8  invert;
+		} v0;
+
+		struct {
+			__u8  flags;
+		} v1;
+	} u;
+
+	/* Used internally by the kernel */
+	struct ts_config __attribute__((aligned(8))) *config;
+};
+
+#endif /*_XT_STRING_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_tcpmss.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_tcpmss.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_tcpmss.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_tcpmss.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,11 @@
+#ifndef _XT_TCPMSS_MATCH_H
+#define _XT_TCPMSS_MATCH_H
+
+#include <linux/types.h>
+
+struct xt_tcpmss_match_info {
+    __u16 mss_min, mss_max;
+    __u8 invert;
+};
+
+#endif /*_XT_TCPMSS_MATCH_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_TCPMSS.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TCPMSS.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_TCPMSS.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TCPMSS.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,12 @@
+#ifndef _XT_TCPMSS_H
+#define _XT_TCPMSS_H
+
+#include <linux/types.h>
+
+struct xt_tcpmss_info {
+	__u16 mss;
+};
+
+#define XT_TCPMSS_CLAMP_PMTU 0xffff
+
+#endif /* _XT_TCPMSS_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_TCPOPTSTRIP.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TCPOPTSTRIP.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_TCPOPTSTRIP.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TCPOPTSTRIP.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,13 @@
+#ifndef _XT_TCPOPTSTRIP_H
+#define _XT_TCPOPTSTRIP_H
+
+#define tcpoptstrip_set_bit(bmap, idx) \
+	(bmap[(idx) >> 5] |= 1U << (idx & 31))
+#define tcpoptstrip_test_bit(bmap, idx) \
+	(((1U << (idx & 31)) & bmap[(idx) >> 5]) != 0)
+
+struct xt_tcpoptstrip_target_info {
+	u_int32_t strip_bmap[8];
+};
+
+#endif /* _XT_TCPOPTSTRIP_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_tcpudp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_tcpudp.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_tcpudp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_tcpudp.h	2019-04-14 13:24:03.059043711 -0500
@@ -0,0 +1,38 @@
+#ifndef _XT_TCPUDP_H
+#define _XT_TCPUDP_H
+
+#include <linux/types.h>
+
+/* TCP matching stuff */
+struct xt_tcp
+{
+	__u16 spts[2];			/* Source port range. */
+	__u16 dpts[2];			/* Destination port range. */
+	__u8 option;			/* TCP Option iff non-zero*/
+	__u8 flg_mask;			/* TCP flags mask byte */
+	__u8 flg_cmp;			/* TCP flags compare byte */
+	__u8 invflags;			/* Inverse flags */
+};
+
+/* Values for "inv" field in struct ipt_tcp. */
+#define XT_TCP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
+#define XT_TCP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
+#define XT_TCP_INV_FLAGS	0x04	/* Invert the sense of TCP flags. */
+#define XT_TCP_INV_OPTION	0x08	/* Invert the sense of option test. */
+#define XT_TCP_INV_MASK		0x0F	/* All possible flags. */
+
+/* UDP matching stuff */
+struct xt_udp
+{
+	__u16 spts[2];			/* Source port range. */
+	__u16 dpts[2];			/* Destination port range. */
+	__u8 invflags;			/* Inverse flags */
+};
+
+/* Values for "invflags" field in struct ipt_udp. */
+#define XT_UDP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
+#define XT_UDP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
+#define XT_UDP_INV_MASK	0x03	/* All possible flags. */
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_time.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_time.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_time.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_time.h	2019-04-14 13:24:03.060524270 -0500
@@ -0,0 +1,25 @@
+#ifndef _XT_TIME_H
+#define _XT_TIME_H 1
+
+struct xt_time_info {
+	u_int32_t date_start;
+	u_int32_t date_stop;
+	u_int32_t daytime_start;
+	u_int32_t daytime_stop;
+	u_int32_t monthdays_match;
+	u_int8_t weekdays_match;
+	u_int8_t flags;
+};
+
+enum {
+	/* Match against local time (instead of UTC) */
+	XT_TIME_LOCAL_TZ = 1 << 0,
+
+	/* Shortcuts */
+	XT_TIME_ALL_MONTHDAYS = 0xFFFFFFFE,
+	XT_TIME_ALL_WEEKDAYS  = 0xFE,
+	XT_TIME_MIN_DAYTIME   = 0,
+	XT_TIME_MAX_DAYTIME   = 24 * 60 * 60 - 1,
+};
+
+#endif /* _XT_TIME_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_TPROXY.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TPROXY.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_TPROXY.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_TPROXY.h	2019-04-14 13:24:03.060524270 -0500
@@ -0,0 +1,14 @@
+#ifndef _XT_TPROXY_H_target
+#define _XT_TPROXY_H_target
+
+/* TPROXY target is capable of marking the packet to perform
+ * redirection. We can get rid of that whenever we get support for
+ * mutliple targets in the same rule. */
+struct xt_tproxy_target_info {
+	u_int32_t mark_mask;
+	u_int32_t mark_value;
+	__be32 laddr;
+	__be16 lport;
+};
+
+#endif /* _XT_TPROXY_H_target */
diff -uNr linux-2.6.32/usr/include/linux/netfilter/xt_u32.h clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_u32.h
--- linux-2.6.32/usr/include/linux/netfilter/xt_u32.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter/xt_u32.h	2019-04-14 13:24:03.060524270 -0500
@@ -0,0 +1,40 @@
+#ifndef _XT_U32_H
+#define _XT_U32_H 1
+
+enum xt_u32_ops {
+	XT_U32_AND,
+	XT_U32_LEFTSH,
+	XT_U32_RIGHTSH,
+	XT_U32_AT,
+};
+
+struct xt_u32_location_element {
+	u_int32_t number;
+	u_int8_t nextop;
+};
+
+struct xt_u32_value_element {
+	u_int32_t min;
+	u_int32_t max;
+};
+
+/*
+ * Any way to allow for an arbitrary number of elements?
+ * For now, I settle with a limit of 10 each.
+ */
+#define XT_U32_MAXSIZE 10
+
+struct xt_u32_test {
+	struct xt_u32_location_element location[XT_U32_MAXSIZE+1];
+	struct xt_u32_value_element value[XT_U32_MAXSIZE+1];
+	u_int8_t nnums;
+	u_int8_t nvalues;
+};
+
+struct xt_u32 {
+	struct xt_u32_test tests[XT_U32_MAXSIZE+1];
+	u_int8_t ntests;
+	u_int8_t invert;
+};
+
+#endif /* _XT_U32_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_arp/arp_tables.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp/arp_tables.h
--- linux-2.6.32/usr/include/linux/netfilter_arp/arp_tables.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp/arp_tables.h	2019-04-14 13:24:03.061438139 -0500
@@ -0,0 +1,218 @@
+/*
+ * 	Format of an ARP firewall descriptor
+ *
+ * 	src, tgt, src_mask, tgt_mask, arpop, arpop_mask are always stored in
+ *	network byte order.
+ * 	flags are stored in host byte order (of course).
+ */
+
+#ifndef _ARPTABLES_H
+#define _ARPTABLES_H
+
+#include <linux/types.h>
+
+#include <linux/netfilter_arp.h>
+
+#include <linux/netfilter/x_tables.h>
+
+#define ARPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
+#define ARPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
+
+#define ARPT_DEV_ADDR_LEN_MAX 16
+
+struct arpt_devaddr_info {
+	char addr[ARPT_DEV_ADDR_LEN_MAX];
+	char mask[ARPT_DEV_ADDR_LEN_MAX];
+};
+
+/* Yes, Virginia, you have to zero the padding. */
+struct arpt_arp {
+	/* Source and target IP addr */
+	struct in_addr src, tgt;
+	/* Mask for src and target IP addr */
+	struct in_addr smsk, tmsk;
+
+	/* Device hw address length, src+target device addresses */
+	u_int8_t arhln, arhln_mask;
+	struct arpt_devaddr_info src_devaddr;
+	struct arpt_devaddr_info tgt_devaddr;
+
+	/* ARP operation code. */
+	__be16 arpop, arpop_mask;
+
+	/* ARP hardware address and protocol address format. */
+	__be16 arhrd, arhrd_mask;
+	__be16 arpro, arpro_mask;
+
+	/* The protocol address length is only accepted if it is 4
+	 * so there is no use in offering a way to do filtering on it.
+	 */
+
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
+
+	/* Flags word */
+	u_int8_t flags;
+	/* Inverse flags */
+	u_int16_t invflags;
+};
+
+#define arpt_entry_target xt_entry_target
+#define arpt_standard_target xt_standard_target
+
+/* Values for "flag" field in struct arpt_ip (general arp structure).
+ * No flags defined yet.
+ */
+#define ARPT_F_MASK		0x00	/* All possible flag bits mask. */
+
+/* Values for "inv" field in struct arpt_arp. */
+#define ARPT_INV_VIA_IN		0x0001	/* Invert the sense of IN IFACE. */
+#define ARPT_INV_VIA_OUT	0x0002	/* Invert the sense of OUT IFACE */
+#define ARPT_INV_SRCIP		0x0004	/* Invert the sense of SRC IP. */
+#define ARPT_INV_TGTIP		0x0008	/* Invert the sense of TGT IP. */
+#define ARPT_INV_SRCDEVADDR	0x0010	/* Invert the sense of SRC DEV ADDR. */
+#define ARPT_INV_TGTDEVADDR	0x0020	/* Invert the sense of TGT DEV ADDR. */
+#define ARPT_INV_ARPOP		0x0040	/* Invert the sense of ARP OP. */
+#define ARPT_INV_ARPHRD		0x0080	/* Invert the sense of ARP HRD. */
+#define ARPT_INV_ARPPRO		0x0100	/* Invert the sense of ARP PRO. */
+#define ARPT_INV_ARPHLN		0x0200	/* Invert the sense of ARP HLN. */
+#define ARPT_INV_MASK		0x03FF	/* All possible flag bits mask. */
+
+/* This structure defines each of the firewall rules.  Consists of 3
+   parts which are 1) general ARP header stuff 2) match specific
+   stuff 3) the target to perform if the rule matches */
+struct arpt_entry
+{
+	struct arpt_arp arp;
+
+	/* Size of arpt_entry + matches */
+	u_int16_t target_offset;
+	/* Size of arpt_entry + matches + target */
+	u_int16_t next_offset;
+
+	/* Back pointer */
+	unsigned int comefrom;
+
+	/* Packet and byte counters. */
+	struct xt_counters counters;
+
+	/* The matches (if any), then the target. */
+	unsigned char elems[0];
+};
+
+/*
+ * New IP firewall options for [gs]etsockopt at the RAW IP level.
+ * Unlike BSD Linux inherits IP options so you don't have to use a raw
+ * socket for this. Instead we check rights in the calls.
+ *
+ * ATTENTION: check linux/in.h before adding new number here.
+ */
+#define ARPT_BASE_CTL		96
+
+#define ARPT_SO_SET_REPLACE		(ARPT_BASE_CTL)
+#define ARPT_SO_SET_ADD_COUNTERS	(ARPT_BASE_CTL + 1)
+#define ARPT_SO_SET_MAX			ARPT_SO_SET_ADD_COUNTERS
+
+#define ARPT_SO_GET_INFO		(ARPT_BASE_CTL)
+#define ARPT_SO_GET_ENTRIES		(ARPT_BASE_CTL + 1)
+/* #define ARPT_SO_GET_REVISION_MATCH	(APRT_BASE_CTL + 2) */
+#define ARPT_SO_GET_REVISION_TARGET	(ARPT_BASE_CTL + 3)
+#define ARPT_SO_GET_MAX			(ARPT_SO_GET_REVISION_TARGET)
+
+/* CONTINUE verdict for targets */
+#define ARPT_CONTINUE XT_CONTINUE
+
+/* For standard target */
+#define ARPT_RETURN XT_RETURN
+
+/* The argument to ARPT_SO_GET_INFO */
+struct arpt_getinfo
+{
+	/* Which table: caller fills this in. */
+	char name[ARPT_TABLE_MAXNAMELEN];
+
+	/* Kernel fills these in. */
+	/* Which hook entry points are valid: bitmask */
+	unsigned int valid_hooks;
+
+	/* Hook entry points: one per netfilter hook. */
+	unsigned int hook_entry[NF_ARP_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_ARP_NUMHOOKS];
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Size of entries. */
+	unsigned int size;
+};
+
+/* The argument to ARPT_SO_SET_REPLACE. */
+struct arpt_replace
+{
+	/* Which table. */
+	char name[ARPT_TABLE_MAXNAMELEN];
+
+	/* Which hook entry points are valid: bitmask.  You can't
+           change this. */
+	unsigned int valid_hooks;
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Total size of new entries */
+	unsigned int size;
+
+	/* Hook entry points. */
+	unsigned int hook_entry[NF_ARP_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_ARP_NUMHOOKS];
+
+	/* Information about old entries: */
+	/* Number of counters (must be equal to current number of entries). */
+	unsigned int num_counters;
+	/* The old entries' counters. */
+	struct xt_counters *counters;
+
+	/* The entries (hang off end: not really an array). */
+	struct arpt_entry entries[0];
+};
+
+/* The argument to ARPT_SO_ADD_COUNTERS. */
+#define arpt_counters_info xt_counters_info
+#define arpt_counters xt_counters
+
+/* The argument to ARPT_SO_GET_ENTRIES. */
+struct arpt_get_entries
+{
+	/* Which table: user fills this in. */
+	char name[ARPT_TABLE_MAXNAMELEN];
+
+	/* User fills this in: total entry size. */
+	unsigned int size;
+
+	/* The entries. */
+	struct arpt_entry entrytable[0];
+};
+
+/* Standard return verdict, or do jump. */
+#define ARPT_STANDARD_TARGET XT_STANDARD_TARGET
+/* Error verdict. */
+#define ARPT_ERROR_TARGET XT_ERROR_TARGET
+
+/* Helper functions */
+static __inline__ struct arpt_entry_target *arpt_get_target(struct arpt_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+
+/* fn returns 0 to continue iteration */
+#define ARPT_ENTRY_ITERATE(entries, size, fn, args...) \
+	XT_ENTRY_ITERATE(struct arpt_entry, entries, size, fn, ## args)
+
+/*
+ *	Main firewall chains definitions and global var's definitions.
+ */
+#endif /* _ARPTABLES_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_arp/arpt_mangle.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp/arpt_mangle.h
--- linux-2.6.32/usr/include/linux/netfilter_arp/arpt_mangle.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp/arpt_mangle.h	2019-04-14 13:24:03.061977218 -0500
@@ -0,0 +1,26 @@
+#ifndef _ARPT_MANGLE_H
+#define _ARPT_MANGLE_H
+#include <linux/netfilter_arp/arp_tables.h>
+
+#define ARPT_MANGLE_ADDR_LEN_MAX sizeof(struct in_addr)
+struct arpt_mangle
+{
+	char src_devaddr[ARPT_DEV_ADDR_LEN_MAX];
+	char tgt_devaddr[ARPT_DEV_ADDR_LEN_MAX];
+	union {
+		struct in_addr src_ip;
+	} u_s;
+	union {
+		struct in_addr tgt_ip;
+	} u_t;
+	u_int8_t flags;
+	int target;
+};
+
+#define ARPT_MANGLE_SDEV 0x01
+#define ARPT_MANGLE_TDEV 0x02
+#define ARPT_MANGLE_SIP 0x04
+#define ARPT_MANGLE_TIP 0x08
+#define ARPT_MANGLE_MASK 0x0f
+
+#endif /* _ARPT_MANGLE_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_arp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp.h
--- linux-2.6.32/usr/include/linux/netfilter_arp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_arp.h	2019-04-14 13:24:03.061977218 -0500
@@ -0,0 +1,19 @@
+#ifndef __LINUX_ARP_NETFILTER_H
+#define __LINUX_ARP_NETFILTER_H
+
+/* ARP-specific defines for netfilter.
+ * (C)2002 Rusty Russell IBM -- This code is GPL.
+ */
+
+#include <linux/netfilter.h>
+
+/* There is no PF_ARP. */
+#define NF_ARP		0
+
+/* ARP Hooks */
+#define NF_ARP_IN	0
+#define NF_ARP_OUT	1
+#define NF_ARP_FORWARD	2
+#define NF_ARP_NUMHOOKS	3
+
+#endif /* __LINUX_ARP_NETFILTER_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_802_3.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_802_3.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_802_3.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_802_3.h	2019-04-14 13:24:03.062986034 -0500
@@ -0,0 +1,61 @@
+#ifndef __LINUX_BRIDGE_EBT_802_3_H
+#define __LINUX_BRIDGE_EBT_802_3_H
+
+#define EBT_802_3_SAP 0x01
+#define EBT_802_3_TYPE 0x02
+
+#define EBT_802_3_MATCH "802_3"
+
+/*
+ * If frame has DSAP/SSAP value 0xaa you must check the SNAP type
+ * to discover what kind of packet we're carrying. 
+ */
+#define CHECK_TYPE 0xaa
+
+/*
+ * Control field may be one or two bytes.  If the first byte has
+ * the value 0x03 then the entire length is one byte, otherwise it is two.
+ * One byte controls are used in Unnumbered Information frames.
+ * Two byte controls are used in Numbered Information frames.
+ */
+#define IS_UI 0x03
+
+#define EBT_802_3_MASK (EBT_802_3_SAP | EBT_802_3_TYPE | EBT_802_3)
+
+/* ui has one byte ctrl, ni has two */
+struct hdr_ui {
+	uint8_t dsap;
+	uint8_t ssap;
+	uint8_t ctrl;
+	uint8_t orig[3];
+	__be16 type;
+};
+
+struct hdr_ni {
+	uint8_t dsap;
+	uint8_t ssap;
+	__be16 ctrl;
+	uint8_t  orig[3];
+	__be16 type;
+};
+
+struct ebt_802_3_hdr {
+	uint8_t  daddr[6];
+	uint8_t  saddr[6];
+	__be16 len;
+	union {
+		struct hdr_ui ui;
+		struct hdr_ni ni;
+	} llc;
+};
+
+
+struct ebt_802_3_info 
+{
+	uint8_t  sap;
+	__be16 type;
+	uint8_t  bitmask;
+	uint8_t  invflags;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebtables.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebtables.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebtables.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebtables.h	2019-04-14 13:24:03.063959329 -0500
@@ -0,0 +1,275 @@
+/*
+ *  ebtables
+ *
+ *	Authors:
+ *	Bart De Schuymer		<bdschuym@pandora.be>
+ *
+ *  ebtables.c,v 2.0, April, 2002
+ *
+ *  This code is stongly inspired on the iptables code which is
+ *  Copyright (C) 1999 Paul `Rusty' Russell & Michael J. Neuling
+ */
+
+#ifndef __LINUX_BRIDGE_EFF_H
+#define __LINUX_BRIDGE_EFF_H
+#include <linux/if.h>
+#include <linux/netfilter_bridge.h>
+#include <linux/if_ether.h>
+
+#define EBT_TABLE_MAXNAMELEN 32
+#define EBT_CHAIN_MAXNAMELEN EBT_TABLE_MAXNAMELEN
+#define EBT_FUNCTION_MAXNAMELEN EBT_TABLE_MAXNAMELEN
+
+/* verdicts >0 are "branches" */
+#define EBT_ACCEPT   -1
+#define EBT_DROP     -2
+#define EBT_CONTINUE -3
+#define EBT_RETURN   -4
+#define NUM_STANDARD_TARGETS   4
+/* ebtables target modules store the verdict inside an int. We can
+ * reclaim a part of this int for backwards compatible extensions.
+ * The 4 lsb are more than enough to store the verdict. */
+#define EBT_VERDICT_BITS 0x0000000F
+
+struct xt_match;
+struct xt_target;
+
+struct ebt_counter
+{
+	uint64_t pcnt;
+	uint64_t bcnt;
+};
+
+struct ebt_replace
+{
+	char name[EBT_TABLE_MAXNAMELEN];
+	unsigned int valid_hooks;
+	/* nr of rules in the table */
+	unsigned int nentries;
+	/* total size of the entries */
+	unsigned int entries_size;
+	/* start of the chains */
+	struct ebt_entries *hook_entry[NF_BR_NUMHOOKS];
+	/* nr of counters userspace expects back */
+	unsigned int num_counters;
+	/* where the kernel will put the old counters */
+	struct ebt_counter *counters;
+	char *entries;
+};
+
+struct ebt_replace_kernel
+{
+	char name[EBT_TABLE_MAXNAMELEN];
+	unsigned int valid_hooks;
+	/* nr of rules in the table */
+	unsigned int nentries;
+	/* total size of the entries */
+	unsigned int entries_size;
+	/* start of the chains */
+	struct ebt_entries *hook_entry[NF_BR_NUMHOOKS];
+	/* nr of counters userspace expects back */
+	unsigned int num_counters;
+	/* where the kernel will put the old counters */
+	struct ebt_counter *counters;
+	char *entries;
+};
+
+struct ebt_entries {
+	/* this field is always set to zero
+	 * See EBT_ENTRY_OR_ENTRIES.
+	 * Must be same size as ebt_entry.bitmask */
+	unsigned int distinguisher;
+	/* the chain name */
+	char name[EBT_CHAIN_MAXNAMELEN];
+	/* counter offset for this chain */
+	unsigned int counter_offset;
+	/* one standard (accept, drop, return) per hook */
+	int policy;
+	/* nr. of entries */
+	unsigned int nentries;
+	/* entry list */
+	char data[0] __attribute__ ((aligned (__alignof__(struct ebt_replace))));
+};
+
+/* used for the bitmask of struct ebt_entry */
+
+/* This is a hack to make a difference between an ebt_entry struct and an
+ * ebt_entries struct when traversing the entries from start to end.
+ * Using this simplifies the code alot, while still being able to use
+ * ebt_entries.
+ * Contrary, iptables doesn't use something like ebt_entries and therefore uses
+ * different techniques for naming the policy and such. So, iptables doesn't
+ * need a hack like this.
+ */
+#define EBT_ENTRY_OR_ENTRIES 0x01
+/* these are the normal masks */
+#define EBT_NOPROTO 0x02
+#define EBT_802_3 0x04
+#define EBT_SOURCEMAC 0x08
+#define EBT_DESTMAC 0x10
+#define EBT_F_MASK (EBT_NOPROTO | EBT_802_3 | EBT_SOURCEMAC | EBT_DESTMAC \
+   | EBT_ENTRY_OR_ENTRIES)
+
+#define EBT_IPROTO 0x01
+#define EBT_IIN 0x02
+#define EBT_IOUT 0x04
+#define EBT_ISOURCE 0x8
+#define EBT_IDEST 0x10
+#define EBT_ILOGICALIN 0x20
+#define EBT_ILOGICALOUT 0x40
+#define EBT_INV_MASK (EBT_IPROTO | EBT_IIN | EBT_IOUT | EBT_ILOGICALIN \
+   | EBT_ILOGICALOUT | EBT_ISOURCE | EBT_IDEST)
+
+struct ebt_entry_match
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct xt_match *match;
+	} u;
+	/* size of data */
+	unsigned int match_size;
+	unsigned char data[0] __attribute__ ((aligned (__alignof__(struct ebt_replace))));
+};
+
+struct ebt_entry_watcher
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct xt_target *watcher;
+	} u;
+	/* size of data */
+	unsigned int watcher_size;
+	unsigned char data[0] __attribute__ ((aligned (__alignof__(struct ebt_replace))));
+};
+
+struct ebt_entry_target
+{
+	union {
+		char name[EBT_FUNCTION_MAXNAMELEN];
+		struct xt_target *target;
+	} u;
+	/* size of data */
+	unsigned int target_size;
+	unsigned char data[0] __attribute__ ((aligned (__alignof__(struct ebt_replace))));
+};
+
+#define EBT_STANDARD_TARGET "standard"
+struct ebt_standard_target
+{
+	struct ebt_entry_target target;
+	int verdict;
+};
+
+/* one entry */
+struct ebt_entry {
+	/* this needs to be the first field */
+	unsigned int bitmask;
+	unsigned int invflags;
+	__be16 ethproto;
+	/* the physical in-dev */
+	char in[IFNAMSIZ];
+	/* the logical in-dev */
+	char logical_in[IFNAMSIZ];
+	/* the physical out-dev */
+	char out[IFNAMSIZ];
+	/* the logical out-dev */
+	char logical_out[IFNAMSIZ];
+	unsigned char sourcemac[ETH_ALEN];
+	unsigned char sourcemsk[ETH_ALEN];
+	unsigned char destmac[ETH_ALEN];
+	unsigned char destmsk[ETH_ALEN];
+	/* sizeof ebt_entry + matches */
+	unsigned int watchers_offset;
+	/* sizeof ebt_entry + matches + watchers */
+	unsigned int target_offset;
+	/* sizeof ebt_entry + matches + watchers + target */
+	unsigned int next_offset;
+	unsigned char elems[0] __attribute__ ((aligned (__alignof__(struct ebt_replace))));
+};
+
+/* {g,s}etsockopt numbers */
+#define EBT_BASE_CTL            128
+
+#define EBT_SO_SET_ENTRIES      (EBT_BASE_CTL)
+#define EBT_SO_SET_COUNTERS     (EBT_SO_SET_ENTRIES+1)
+#define EBT_SO_SET_MAX          (EBT_SO_SET_COUNTERS+1)
+
+#define EBT_SO_GET_INFO         (EBT_BASE_CTL)
+#define EBT_SO_GET_ENTRIES      (EBT_SO_GET_INFO+1)
+#define EBT_SO_GET_INIT_INFO    (EBT_SO_GET_ENTRIES+1)
+#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO+1)
+#define EBT_SO_GET_MAX          (EBT_SO_GET_INIT_ENTRIES+1)
+
+
+/* blatently stolen from ip_tables.h
+ * fn returns 0 to continue iteration */
+#define EBT_MATCH_ITERATE(e, fn, args...)                   \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry_match *__match;                    \
+	                                                    \
+	for (__i = sizeof(struct ebt_entry);                \
+	     __i < (e)->watchers_offset;                    \
+	     __i += __match->match_size +                   \
+	     sizeof(struct ebt_entry_match)) {              \
+		__match = (void *)(e) + __i;                \
+		                                            \
+		__ret = fn(__match , ## args);              \
+		if (__ret != 0)                             \
+			break;                              \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (e)->watchers_offset)            \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#define EBT_WATCHER_ITERATE(e, fn, args...)                 \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry_watcher *__watcher;                \
+	                                                    \
+	for (__i = e->watchers_offset;                      \
+	     __i < (e)->target_offset;                      \
+	     __i += __watcher->watcher_size +               \
+	     sizeof(struct ebt_entry_watcher)) {            \
+		__watcher = (void *)(e) + __i;              \
+		                                            \
+		__ret = fn(__watcher , ## args);            \
+		if (__ret != 0)                             \
+			break;                              \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (e)->target_offset)              \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#define EBT_ENTRY_ITERATE(entries, size, fn, args...)       \
+({                                                          \
+	unsigned int __i;                                   \
+	int __ret = 0;                                      \
+	struct ebt_entry *__entry;                          \
+	                                                    \
+	for (__i = 0; __i < (size);) {                      \
+		__entry = (void *)(entries) + __i;          \
+		__ret = fn(__entry , ## args);              \
+		if (__ret != 0)                             \
+			break;                              \
+		if (__entry->bitmask != 0)                  \
+			__i += __entry->next_offset;        \
+		else                                        \
+			__i += sizeof(struct ebt_entries);  \
+	}                                                   \
+	if (__ret == 0) {                                   \
+		if (__i != (size))                          \
+			__ret = -EINVAL;                    \
+	}                                                   \
+	__ret;                                              \
+})
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_among.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_among.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_among.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_among.h	2019-04-14 13:24:03.063959329 -0500
@@ -0,0 +1,65 @@
+#ifndef __LINUX_BRIDGE_EBT_AMONG_H
+#define __LINUX_BRIDGE_EBT_AMONG_H
+
+#define EBT_AMONG_DST 0x01
+#define EBT_AMONG_SRC 0x02
+
+/* Grzegorz Borowiak <grzes@gnu.univ.gda.pl> 2003
+ * 
+ * Write-once-read-many hash table, used for checking if a given
+ * MAC address belongs to a set or not and possibly for checking
+ * if it is related with a given IPv4 address.
+ *
+ * The hash value of an address is its last byte.
+ * 
+ * In real-world ethernet addresses, values of the last byte are
+ * evenly distributed and there is no need to consider other bytes.
+ * It would only slow the routines down.
+ *
+ * For MAC address comparison speedup reasons, we introduce a trick.
+ * MAC address is mapped onto an array of two 32-bit integers.
+ * This pair of integers is compared with MAC addresses in the
+ * hash table, which are stored also in form of pairs of integers
+ * (in `cmp' array). This is quick as it requires only two elementary
+ * number comparisons in worst case. Further, we take advantage of
+ * fact that entropy of 3 last bytes of address is larger than entropy
+ * of 3 first bytes. So first we compare 4 last bytes of addresses and
+ * if they are the same we compare 2 first.
+ *
+ * Yes, it is a memory overhead, but in 2003 AD, who cares?
+ */
+
+struct ebt_mac_wormhash_tuple
+{
+	uint32_t cmp[2];
+	__be32 ip;
+};
+
+struct ebt_mac_wormhash
+{
+	int table[257];
+	int poolsize;
+	struct ebt_mac_wormhash_tuple pool[0];
+};
+
+#define ebt_mac_wormhash_size(x) ((x) ? sizeof(struct ebt_mac_wormhash) \
+		+ (x)->poolsize * sizeof(struct ebt_mac_wormhash_tuple) : 0)
+
+struct ebt_among_info
+{
+	int wh_dst_ofs;
+	int wh_src_ofs;
+	int bitmask;
+};
+
+#define EBT_AMONG_DST_NEG 0x1
+#define EBT_AMONG_SRC_NEG 0x2
+
+#define ebt_among_wh_dst(x) ((x)->wh_dst_ofs ? \
+	(struct ebt_mac_wormhash*)((char*)(x) + (x)->wh_dst_ofs) : NULL)
+#define ebt_among_wh_src(x) ((x)->wh_src_ofs ? \
+	(struct ebt_mac_wormhash*)((char*)(x) + (x)->wh_src_ofs) : NULL)
+
+#define EBT_AMONG_MATCH "among"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arp.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arp.h	2019-04-14 13:24:03.063959329 -0500
@@ -0,0 +1,34 @@
+#ifndef __LINUX_BRIDGE_EBT_ARP_H
+#define __LINUX_BRIDGE_EBT_ARP_H
+
+#define EBT_ARP_OPCODE 0x01
+#define EBT_ARP_HTYPE 0x02
+#define EBT_ARP_PTYPE 0x04
+#define EBT_ARP_SRC_IP 0x08
+#define EBT_ARP_DST_IP 0x10
+#define EBT_ARP_SRC_MAC 0x20
+#define EBT_ARP_DST_MAC 0x40
+#define EBT_ARP_GRAT 0x80
+#define EBT_ARP_MASK (EBT_ARP_OPCODE | EBT_ARP_HTYPE | EBT_ARP_PTYPE | \
+   EBT_ARP_SRC_IP | EBT_ARP_DST_IP | EBT_ARP_SRC_MAC | EBT_ARP_DST_MAC | \
+   EBT_ARP_GRAT)
+#define EBT_ARP_MATCH "arp"
+
+struct ebt_arp_info
+{
+	__be16 htype;
+	__be16 ptype;
+	__be16 opcode;
+	__be32 saddr;
+	__be32 smsk;
+	__be32 daddr;
+	__be32 dmsk;
+	unsigned char smaddr[ETH_ALEN];
+	unsigned char smmsk[ETH_ALEN];
+	unsigned char dmaddr[ETH_ALEN];
+	unsigned char dmmsk[ETH_ALEN];
+	uint8_t  bitmask;
+	uint8_t  invflags;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arpreply.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arpreply.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arpreply.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_arpreply.h	2019-04-14 13:24:03.063959329 -0500
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_ARPREPLY_H
+#define __LINUX_BRIDGE_EBT_ARPREPLY_H
+
+struct ebt_arpreply_info
+{
+	unsigned char mac[ETH_ALEN];
+	int target;
+};
+#define EBT_ARPREPLY_TARGET "arpreply"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ip.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ip.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ip.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ip.h	2019-04-14 13:24:03.064932790 -0500
@@ -0,0 +1,43 @@
+/*
+ *  ebt_ip
+ *
+ *	Authors:
+ *	Bart De Schuymer <bart.de.schuymer@pandora.be>
+ *
+ *  April, 2002
+ *
+ *  Changes:
+ *    added ip-sport and ip-dport
+ *    Innominate Security Technologies AG <mhopf@innominate.com>
+ *    September, 2002
+ */
+
+#ifndef __LINUX_BRIDGE_EBT_IP_H
+#define __LINUX_BRIDGE_EBT_IP_H
+
+#define EBT_IP_SOURCE 0x01
+#define EBT_IP_DEST 0x02
+#define EBT_IP_TOS 0x04
+#define EBT_IP_PROTO 0x08
+#define EBT_IP_SPORT 0x10
+#define EBT_IP_DPORT 0x20
+#define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
+ EBT_IP_SPORT | EBT_IP_DPORT )
+#define EBT_IP_MATCH "ip"
+
+/* the same values are used for the invflags */
+struct ebt_ip_info
+{
+	__be32 saddr;
+	__be32 daddr;
+	__be32 smsk;
+	__be32 dmsk;
+	uint8_t  tos;
+	uint8_t  protocol;
+	uint8_t  bitmask;
+	uint8_t  invflags;
+	uint16_t sport[2];
+	uint16_t dport[2];
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_limit.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_limit.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_limit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_limit.h	2019-04-14 13:24:03.064932790 -0500
@@ -0,0 +1,23 @@
+#ifndef __LINUX_BRIDGE_EBT_LIMIT_H
+#define __LINUX_BRIDGE_EBT_LIMIT_H
+
+#define EBT_LIMIT_MATCH "limit"
+
+/* timings are in milliseconds. */
+#define EBT_LIMIT_SCALE 10000
+
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+
+struct ebt_limit_info
+{
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+	/* Used internally by the kernel */
+	unsigned long prev;
+	u_int32_t credit;
+	u_int32_t credit_cap, cost;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_log.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_log.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_log.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_log.h	2019-04-14 13:24:03.064932790 -0500
@@ -0,0 +1,19 @@
+#ifndef __LINUX_BRIDGE_EBT_LOG_H
+#define __LINUX_BRIDGE_EBT_LOG_H
+
+#define EBT_LOG_IP 0x01 /* if the frame is made by ip, log the ip information */
+#define EBT_LOG_ARP 0x02
+#define EBT_LOG_NFLOG 0x04
+#define EBT_LOG_IP6 0x08
+#define EBT_LOG_MASK (EBT_LOG_IP | EBT_LOG_ARP | EBT_LOG_IP6)
+#define EBT_LOG_PREFIX_SIZE 30
+#define EBT_LOG_WATCHER "log"
+
+struct ebt_log_info
+{
+	uint8_t loglevel;
+	uint8_t prefix[EBT_LOG_PREFIX_SIZE];
+	uint32_t bitmask;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_m.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_m.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_m.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_m.h	2019-04-14 13:24:03.064932790 -0500
@@ -0,0 +1,15 @@
+#ifndef __LINUX_BRIDGE_EBT_MARK_M_H
+#define __LINUX_BRIDGE_EBT_MARK_M_H
+
+#define EBT_MARK_AND 0x01
+#define EBT_MARK_OR 0x02
+#define EBT_MARK_MASK (EBT_MARK_AND | EBT_MARK_OR)
+struct ebt_mark_m_info
+{
+	unsigned long mark, mask;
+	uint8_t invert;
+	uint8_t bitmask;
+};
+#define EBT_MARK_MATCH "mark_m"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_t.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_t.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_t.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_mark_t.h	2019-04-14 13:24:03.064932790 -0500
@@ -0,0 +1,24 @@
+#ifndef __LINUX_BRIDGE_EBT_MARK_T_H
+#define __LINUX_BRIDGE_EBT_MARK_T_H
+
+/* The target member is reused for adding new actions, the
+ * value of the real target is -1 to -NUM_STANDARD_TARGETS.
+ * For backward compatibility, the 4 lsb (2 would be enough,
+ * but let's play it safe) are kept to designate this target.
+ * The remaining bits designate the action. By making the set
+ * action 0xfffffff0, the result will look ok for older
+ * versions. [September 2006] */
+#define MARK_SET_VALUE (0xfffffff0)
+#define MARK_OR_VALUE  (0xffffffe0)
+#define MARK_AND_VALUE (0xffffffd0)
+#define MARK_XOR_VALUE (0xffffffc0)
+
+struct ebt_mark_t_info
+{
+	unsigned long mark;
+	/* EBT_ACCEPT, EBT_DROP, EBT_CONTINUE or EBT_RETURN */
+	int target;
+};
+#define EBT_MARK_TARGET "mark"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_nat.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_nat.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_nat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_nat.h	2019-04-14 13:24:03.065922136 -0500
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BRIDGE_EBT_NAT_H
+#define __LINUX_BRIDGE_EBT_NAT_H
+
+#define NAT_ARP_BIT  (0x00000010)
+struct ebt_nat_info
+{
+	unsigned char mac[ETH_ALEN];
+	/* EBT_ACCEPT, EBT_DROP, EBT_CONTINUE or EBT_RETURN */
+	int target;
+};
+#define EBT_SNAT_TARGET "snat"
+#define EBT_DNAT_TARGET "dnat"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_pkttype.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_pkttype.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_pkttype.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_pkttype.h	2019-04-14 13:24:03.065922136 -0500
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_PKTTYPE_H
+#define __LINUX_BRIDGE_EBT_PKTTYPE_H
+
+struct ebt_pkttype_info
+{
+	uint8_t pkt_type;
+	uint8_t invert;
+};
+#define EBT_PKTTYPE_MATCH "pkttype"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_redirect.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_redirect.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_redirect.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_redirect.h	2019-04-14 13:24:03.065922136 -0500
@@ -0,0 +1,11 @@
+#ifndef __LINUX_BRIDGE_EBT_REDIRECT_H
+#define __LINUX_BRIDGE_EBT_REDIRECT_H
+
+struct ebt_redirect_info
+{
+	/* EBT_ACCEPT, EBT_DROP, EBT_CONTINUE or EBT_RETURN */
+	int target;
+};
+#define EBT_REDIRECT_TARGET "redirect"
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_stp.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_stp.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_stp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_stp.h	2019-04-14 13:24:03.065922136 -0500
@@ -0,0 +1,46 @@
+#ifndef __LINUX_BRIDGE_EBT_STP_H
+#define __LINUX_BRIDGE_EBT_STP_H
+
+#define EBT_STP_TYPE		0x0001
+
+#define EBT_STP_FLAGS		0x0002
+#define EBT_STP_ROOTPRIO	0x0004
+#define EBT_STP_ROOTADDR	0x0008
+#define EBT_STP_ROOTCOST	0x0010
+#define EBT_STP_SENDERPRIO	0x0020
+#define EBT_STP_SENDERADDR	0x0040
+#define EBT_STP_PORT		0x0080
+#define EBT_STP_MSGAGE		0x0100
+#define EBT_STP_MAXAGE		0x0200
+#define EBT_STP_HELLOTIME	0x0400
+#define EBT_STP_FWDD		0x0800
+
+#define EBT_STP_MASK		0x0fff
+#define EBT_STP_CONFIG_MASK	0x0ffe
+
+#define EBT_STP_MATCH "stp"
+
+struct ebt_stp_config_info
+{
+	uint8_t flags;
+	uint16_t root_priol, root_priou;
+	char root_addr[6], root_addrmsk[6];
+	uint32_t root_costl, root_costu;
+	uint16_t sender_priol, sender_priou;
+	char sender_addr[6], sender_addrmsk[6];
+	uint16_t portl, portu;
+	uint16_t msg_agel, msg_ageu;
+	uint16_t max_agel, max_ageu;
+	uint16_t hello_timel, hello_timeu;
+	uint16_t forward_delayl, forward_delayu;
+};
+
+struct ebt_stp_info
+{
+	uint8_t type;
+	struct ebt_stp_config_info config;
+	uint16_t bitmask;
+	uint16_t invflags;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ulog.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ulog.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ulog.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_ulog.h	2019-04-14 13:24:03.065922136 -0500
@@ -0,0 +1,36 @@
+#ifndef _EBT_ULOG_H
+#define _EBT_ULOG_H
+
+#define EBT_ULOG_DEFAULT_NLGROUP 0
+#define EBT_ULOG_DEFAULT_QTHRESHOLD 1
+#define EBT_ULOG_MAXNLGROUPS 32 /* hardcoded netlink max */
+#define EBT_ULOG_PREFIX_LEN 32
+#define EBT_ULOG_MAX_QLEN 50
+#define EBT_ULOG_WATCHER "ulog"
+#define EBT_ULOG_VERSION 1
+
+struct ebt_ulog_info {
+	uint32_t nlgroup;
+	unsigned int cprange;
+	unsigned int qthreshold;
+	char prefix[EBT_ULOG_PREFIX_LEN];
+};
+
+typedef struct ebt_ulog_packet_msg {
+	int version;
+	char indev[IFNAMSIZ];
+	char outdev[IFNAMSIZ];
+	char physindev[IFNAMSIZ];
+	char physoutdev[IFNAMSIZ];
+	char prefix[EBT_ULOG_PREFIX_LEN];
+	struct timeval stamp;
+	unsigned long mark;
+	unsigned int hook;
+	size_t data_len;
+	/* The complete packet, including Ethernet header and perhaps
+	 * the VLAN header is appended */
+	unsigned char data[0] __attribute__
+	                      ((aligned (__alignof__(struct ebt_ulog_info))));
+} ebt_ulog_packet_msg_t;
+
+#endif /* _EBT_ULOG_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_vlan.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_vlan.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_vlan.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge/ebt_vlan.h	2019-04-14 13:24:03.066912559 -0500
@@ -0,0 +1,20 @@
+#ifndef __LINUX_BRIDGE_EBT_VLAN_H
+#define __LINUX_BRIDGE_EBT_VLAN_H
+
+#define EBT_VLAN_ID	0x01
+#define EBT_VLAN_PRIO	0x02
+#define EBT_VLAN_ENCAP	0x04
+#define EBT_VLAN_MASK (EBT_VLAN_ID | EBT_VLAN_PRIO | EBT_VLAN_ENCAP)
+#define EBT_VLAN_MATCH "vlan"
+
+struct ebt_vlan_info {
+	uint16_t id;		/* VLAN ID {1-4095} */
+	uint8_t prio;		/* VLAN User Priority {0-7} */
+	__be16 encap;		/* VLAN Encapsulated frame code {0-65535} */
+	uint8_t bitmask;		/* Args bitmask bit 1=1 - ID arg,
+				   bit 2=1 User-Priority arg, bit 3=1 encap*/
+	uint8_t invflags;		/* Inverse bitmask  bit 1=1 - inversed ID arg, 
+				   bit 2=1 - inversed Pirority arg */
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_bridge.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge.h
--- linux-2.6.32/usr/include/linux/netfilter_bridge.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_bridge.h	2019-04-14 13:24:03.066912559 -0500
@@ -0,0 +1,27 @@
+#ifndef __LINUX_BRIDGE_NETFILTER_H
+#define __LINUX_BRIDGE_NETFILTER_H
+
+/* bridge-specific defines for netfilter. 
+ */
+
+#include <linux/netfilter.h>
+#include <linux/if_ether.h>
+#include <linux/if_vlan.h>
+#include <linux/if_pppox.h>
+
+/* Bridge Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_BR_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_BR_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_BR_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_BR_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_BR_POST_ROUTING	4
+/* Not really a hook, but used for the ebtables broute table */
+#define NF_BR_BROUTING		5
+#define NF_BR_NUMHOOKS		6
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_decnet.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_decnet.h
--- linux-2.6.32/usr/include/linux/netfilter_decnet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_decnet.h	2019-04-14 13:24:03.066912559 -0500
@@ -0,0 +1,72 @@
+#ifndef __LINUX_DECNET_NETFILTER_H
+#define __LINUX_DECNET_NETFILTER_H
+
+/* DECnet-specific defines for netfilter. 
+ * This file (C) Steve Whitehouse 1999 derived from the
+ * ipv4 netfilter header file which is
+ * (C)1998 Rusty Russell -- This code is GPL.
+ */
+
+#include <linux/netfilter.h>
+
+/* only for userspace compatibility */
+/* IP Cache bits. */
+/* Src IP address. */
+#define NFC_DN_SRC		0x0001
+/* Dest IP address. */
+#define NFC_DN_DST		0x0002
+/* Input device. */
+#define NFC_DN_IF_IN		0x0004
+/* Output device. */
+#define NFC_DN_IF_OUT		0x0008
+
+/* DECnet Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_DN_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_DN_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_DN_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_DN_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_DN_POST_ROUTING	4
+/* Input Hello Packets */
+#define NF_DN_HELLO		5
+/* Input Routing Packets */
+#define NF_DN_ROUTE		6
+#define NF_DN_NUMHOOKS		7
+
+enum nf_dn_hook_priorities {
+	NF_DN_PRI_FIRST = INT_MIN,
+	NF_DN_PRI_CONNTRACK = -200,
+	NF_DN_PRI_MANGLE = -150,
+	NF_DN_PRI_NAT_DST = -100,
+	NF_DN_PRI_FILTER = 0,
+	NF_DN_PRI_NAT_SRC = 100,
+	NF_DN_PRI_DNRTMSG = 200,
+	NF_DN_PRI_LAST = INT_MAX,
+};
+
+struct nf_dn_rtmsg {
+	int nfdn_ifindex;
+};
+
+#define NFDN_RTMSG(r) ((unsigned char *)(r) + NLMSG_ALIGN(sizeof(struct nf_dn_rtmsg)))
+
+/* backwards compatibility for userspace */
+#define DNRMG_L1_GROUP 0x01
+#define DNRMG_L2_GROUP 0x02
+
+enum {
+	DNRNG_NLGRP_NONE,
+#define DNRNG_NLGRP_NONE	DNRNG_NLGRP_NONE
+	DNRNG_NLGRP_L1,
+#define DNRNG_NLGRP_L1		DNRNG_NLGRP_L1
+	DNRNG_NLGRP_L2,
+#define DNRNG_NLGRP_L2		DNRNG_NLGRP_L2
+	__DNRNG_NLGRP_MAX
+};
+#define DNRNG_NLGRP_MAX	(__DNRNG_NLGRP_MAX - 1)
+
+#endif /*__LINUX_DECNET_NETFILTER_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter.h clean_modified/linux-2.6.32/usr/include/linux/netfilter.h
--- linux-2.6.32/usr/include/linux/netfilter.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter.h	2019-04-14 13:24:03.067877526 -0500
@@ -0,0 +1,59 @@
+#ifndef __LINUX_NETFILTER_H
+#define __LINUX_NETFILTER_H
+
+#include <linux/types.h>
+
+
+/* Responses from hook functions. */
+#define NF_DROP 0
+#define NF_ACCEPT 1
+#define NF_STOLEN 2
+#define NF_QUEUE 3
+#define NF_REPEAT 4
+#define NF_STOP 5
+#define NF_MAX_VERDICT NF_STOP
+
+/* we overload the higher bits for encoding auxiliary data such as the queue
+ * number. Not nice, but better than additional function arguments. */
+#define NF_VERDICT_MASK 0x0000ffff
+#define NF_VERDICT_BITS 16
+
+#define NF_VERDICT_QMASK 0xffff0000
+#define NF_VERDICT_QBITS 16
+
+#define NF_QUEUE_NR(x) ((((x) << NF_VERDICT_BITS) & NF_VERDICT_QMASK) | NF_QUEUE)
+
+/* only for userspace compatibility */
+/* Generic cache responses from hook functions.
+   <= 0x2000 is used for protocol-flags. */
+#define NFC_UNKNOWN 0x4000
+#define NFC_ALTERED 0x8000
+
+enum nf_inet_hooks {
+	NF_INET_PRE_ROUTING,
+	NF_INET_LOCAL_IN,
+	NF_INET_FORWARD,
+	NF_INET_LOCAL_OUT,
+	NF_INET_POST_ROUTING,
+	NF_INET_NUMHOOKS
+};
+
+enum {
+	NFPROTO_UNSPEC =  0,
+	NFPROTO_IPV4   =  2,
+	NFPROTO_ARP    =  3,
+	NFPROTO_BRIDGE =  7,
+	NFPROTO_IPV6   = 10,
+	NFPROTO_DECNET = 12,
+	NFPROTO_NUMPROTO,
+};
+
+union nf_inet_addr {
+	__u32		all[4];
+	__be32		ip;
+	__be32		ip6[4];
+	struct in_addr	in;
+	struct in6_addr	in6;
+};
+
+#endif /*__LINUX_NETFILTER_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_queue.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_queue.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_queue.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_queue.h	2019-04-14 13:24:03.067877526 -0500
@@ -0,0 +1,64 @@
+/*
+ * This is a module which is used for queueing IPv4 packets and
+ * communicating with userspace via netlink.
+ *
+ * (C) 2000 James Morris, this code is GPL.
+ */
+#ifndef _IP_QUEUE_H
+#define _IP_QUEUE_H
+
+#include <net/if.h>
+
+/* Messages sent from kernel */
+typedef struct ipq_packet_msg {
+	unsigned long packet_id;	/* ID of queued packet */
+	unsigned long mark;		/* Netfilter mark value */
+	long timestamp_sec;		/* Packet arrival time (seconds) */
+	long timestamp_usec;		/* Packet arrvial time (+useconds) */
+	unsigned int hook;		/* Netfilter hook we rode in on */
+	char indev_name[IFNAMSIZ];	/* Name of incoming interface */
+	char outdev_name[IFNAMSIZ];	/* Name of outgoing interface */
+	__be16 hw_protocol;		/* Hardware protocol (network order) */
+	unsigned short hw_type;		/* Hardware type */
+	unsigned char hw_addrlen;	/* Hardware address length */
+	unsigned char hw_addr[8];	/* Hardware address */
+	size_t data_len;		/* Length of packet data */
+	unsigned char payload[0];	/* Optional packet data */
+} ipq_packet_msg_t;
+
+/* Messages sent from userspace */
+typedef struct ipq_mode_msg {
+	unsigned char value;		/* Requested mode */
+	size_t range;			/* Optional range of packet requested */
+} ipq_mode_msg_t;
+
+typedef struct ipq_verdict_msg {
+	unsigned int value;		/* Verdict to hand to netfilter */
+	unsigned long id;		/* Packet ID for this verdict */
+	size_t data_len;		/* Length of replacement data */
+	unsigned char payload[0];	/* Optional replacement packet */
+} ipq_verdict_msg_t;
+
+typedef struct ipq_peer_msg {
+	union {
+		ipq_verdict_msg_t verdict;
+		ipq_mode_msg_t mode;
+	} msg;
+} ipq_peer_msg_t;
+
+/* Packet delivery modes */
+enum {
+	IPQ_COPY_NONE,		/* Initial mode, packets are dropped */
+	IPQ_COPY_META,		/* Copy metadata */
+	IPQ_COPY_PACKET		/* Copy metadata + packet (range) */
+};
+#define IPQ_COPY_MAX IPQ_COPY_PACKET
+
+/* Types of messages */
+#define IPQM_BASE	0x10	/* standard netlink messages below this */
+#define IPQM_MODE	(IPQM_BASE + 1)		/* Mode request from peer */
+#define IPQM_VERDICT	(IPQM_BASE + 2)		/* Verdict from peer */ 
+#define IPQM_PACKET	(IPQM_BASE + 3)		/* Packet from kernel */
+#define IPQM_MAX	(IPQM_BASE + 4)
+
+#endif /*_IP_QUEUE_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_tables.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_tables.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ip_tables.h	2019-04-14 13:24:03.068855545 -0500
@@ -0,0 +1,236 @@
+/*
+ * 25-Jul-1998 Major changes to allow for ip chain table
+ *
+ * 3-Jan-2000 Named tables to allow packet selection for different uses.
+ */
+
+/*
+ * 	Format of an IP firewall descriptor
+ *
+ * 	src, dst, src_mask, dst_mask are always stored in network byte order.
+ * 	flags are stored in host byte order (of course).
+ * 	Port numbers are stored in HOST byte order.
+ */
+
+#ifndef _IPTABLES_H
+#define _IPTABLES_H
+
+#include <linux/types.h>
+
+#include <linux/netfilter_ipv4.h>
+
+#include <linux/netfilter/x_tables.h>
+
+#define IPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
+#define IPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
+#define ipt_match xt_match
+#define ipt_target xt_target
+#define ipt_table xt_table
+#define ipt_get_revision xt_get_revision
+
+/* Yes, Virginia, you have to zero the padding. */
+struct ipt_ip {
+	/* Source and destination IP addr */
+	struct in_addr src, dst;
+	/* Mask for src and dest IP addr */
+	struct in_addr smsk, dmsk;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
+
+	/* Protocol, 0 = ANY */
+	u_int16_t proto;
+
+	/* Flags word */
+	u_int8_t flags;
+	/* Inverse flags */
+	u_int8_t invflags;
+};
+
+#define ipt_entry_match xt_entry_match
+#define ipt_entry_target xt_entry_target
+#define ipt_standard_target xt_standard_target
+
+#define ipt_counters xt_counters
+
+/* Values for "flag" field in struct ipt_ip (general ip structure). */
+#define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
+#define IPT_F_GOTO		0x02	/* Set if jump is a goto */
+#define IPT_F_MASK		0x03	/* All possible flag bits mask. */
+
+/* Values for "inv" field in struct ipt_ip. */
+#define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+#define IPT_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
+#define IPT_INV_TOS		0x04	/* Invert the sense of TOS. */
+#define IPT_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
+#define IPT_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
+#define IPT_INV_FRAG		0x20	/* Invert the sense of FRAG. */
+#define IPT_INV_PROTO		XT_INV_PROTO
+#define IPT_INV_MASK		0x7F	/* All possible flag bits mask. */
+
+/* This structure defines each of the firewall rules.  Consists of 3
+   parts which are 1) general IP header stuff 2) match specific
+   stuff 3) the target to perform if the rule matches */
+struct ipt_entry
+{
+	struct ipt_ip ip;
+
+	/* Mark with fields that we care about. */
+	unsigned int nfcache;
+
+	/* Size of ipt_entry + matches */
+	u_int16_t target_offset;
+	/* Size of ipt_entry + matches + target */
+	u_int16_t next_offset;
+
+	/* Back pointer */
+	unsigned int comefrom;
+
+	/* Packet and byte counters. */
+	struct xt_counters counters;
+
+	/* The matches (if any), then the target. */
+	unsigned char elems[0];
+};
+
+/*
+ * New IP firewall options for [gs]etsockopt at the RAW IP level.
+ * Unlike BSD Linux inherits IP options so you don't have to use a raw
+ * socket for this. Instead we check rights in the calls.
+ *
+ * ATTENTION: check linux/in.h before adding new number here.
+ */
+#define IPT_BASE_CTL		64
+
+#define IPT_SO_SET_REPLACE	(IPT_BASE_CTL)
+#define IPT_SO_SET_ADD_COUNTERS	(IPT_BASE_CTL + 1)
+#define IPT_SO_SET_MAX		IPT_SO_SET_ADD_COUNTERS
+
+#define IPT_SO_GET_INFO			(IPT_BASE_CTL)
+#define IPT_SO_GET_ENTRIES		(IPT_BASE_CTL + 1)
+#define IPT_SO_GET_REVISION_MATCH	(IPT_BASE_CTL + 2)
+#define IPT_SO_GET_REVISION_TARGET	(IPT_BASE_CTL + 3)
+#define IPT_SO_GET_MAX			IPT_SO_GET_REVISION_TARGET
+
+#define IPT_CONTINUE XT_CONTINUE
+#define IPT_RETURN XT_RETURN
+
+#include <linux/netfilter/xt_tcpudp.h>
+#define ipt_udp xt_udp
+#define ipt_tcp xt_tcp
+
+#define IPT_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
+#define IPT_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
+#define IPT_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
+#define IPT_TCP_INV_OPTION	XT_TCP_INV_OPTION
+#define IPT_TCP_INV_MASK	XT_TCP_INV_MASK
+
+#define IPT_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
+#define IPT_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
+#define IPT_UDP_INV_MASK	XT_UDP_INV_MASK
+
+/* ICMP matching stuff */
+struct ipt_icmp
+{
+	u_int8_t type;				/* type to match */
+	u_int8_t code[2];			/* range of code */
+	u_int8_t invflags;			/* Inverse flags */
+};
+
+/* Values for "inv" field for struct ipt_icmp. */
+#define IPT_ICMP_INV	0x01	/* Invert the sense of type/code test */
+
+/* The argument to IPT_SO_GET_INFO */
+struct ipt_getinfo
+{
+	/* Which table: caller fills this in. */
+	char name[IPT_TABLE_MAXNAMELEN];
+
+	/* Kernel fills these in. */
+	/* Which hook entry points are valid: bitmask */
+	unsigned int valid_hooks;
+
+	/* Hook entry points: one per netfilter hook. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Size of entries. */
+	unsigned int size;
+};
+
+/* The argument to IPT_SO_SET_REPLACE. */
+struct ipt_replace
+{
+	/* Which table. */
+	char name[IPT_TABLE_MAXNAMELEN];
+
+	/* Which hook entry points are valid: bitmask.  You can't
+           change this. */
+	unsigned int valid_hooks;
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Total size of new entries */
+	unsigned int size;
+
+	/* Hook entry points. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Information about old entries: */
+	/* Number of counters (must be equal to current number of entries). */
+	unsigned int num_counters;
+	/* The old entries' counters. */
+	struct xt_counters *counters;
+
+	/* The entries (hang off end: not really an array). */
+	struct ipt_entry entries[0];
+};
+
+/* The argument to IPT_SO_ADD_COUNTERS. */
+#define ipt_counters_info xt_counters_info
+
+/* The argument to IPT_SO_GET_ENTRIES. */
+struct ipt_get_entries
+{
+	/* Which table: user fills this in. */
+	char name[IPT_TABLE_MAXNAMELEN];
+
+	/* User fills this in: total entry size. */
+	unsigned int size;
+
+	/* The entries. */
+	struct ipt_entry entrytable[0];
+};
+
+/* Standard return verdict, or do jump. */
+#define IPT_STANDARD_TARGET XT_STANDARD_TARGET
+/* Error verdict. */
+#define IPT_ERROR_TARGET XT_ERROR_TARGET
+
+/* Helper functions */
+static __inline__ struct ipt_entry_target *
+ipt_get_target(struct ipt_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+
+/* fn returns 0 to continue iteration */
+#define IPT_MATCH_ITERATE(e, fn, args...) \
+	XT_MATCH_ITERATE(struct ipt_entry, e, fn, ## args)
+
+/* fn returns 0 to continue iteration */
+#define IPT_ENTRY_ITERATE(entries, size, fn, args...) \
+	XT_ENTRY_ITERATE(struct ipt_entry, entries, size, fn, ## args)
+
+/*
+ *	Main firewall chains definitions and global var's definitions.
+ */
+#endif /* _IPTABLES_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_addrtype.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_addrtype.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_addrtype.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_addrtype.h	2019-04-14 13:24:03.072783787 -0500
@@ -0,0 +1,25 @@
+#ifndef _IPT_ADDRTYPE_H
+#define _IPT_ADDRTYPE_H
+
+enum {
+	IPT_ADDRTYPE_INVERT_SOURCE	= 0x0001,
+	IPT_ADDRTYPE_INVERT_DEST	= 0x0002,
+	IPT_ADDRTYPE_LIMIT_IFACE_IN	= 0x0004,
+	IPT_ADDRTYPE_LIMIT_IFACE_OUT	= 0x0008,
+};
+
+struct ipt_addrtype_info_v1 {
+	u_int16_t	source;		/* source-type mask */
+	u_int16_t	dest;		/* dest-type mask */
+	u_int32_t	flags;
+};
+
+/* revision 0 */
+struct ipt_addrtype_info {
+	u_int16_t	source;		/* source-type mask */
+	u_int16_t	dest;		/* dest-type mask */
+	u_int32_t	invert_source;
+	u_int32_t	invert_dest;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ah.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ah.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ah.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ah.h	2019-04-14 13:24:03.072783787 -0500
@@ -0,0 +1,16 @@
+#ifndef _IPT_AH_H
+#define _IPT_AH_H
+
+struct ipt_ah
+{
+	u_int32_t spis[2];			/* Security Parameter Index */
+	u_int8_t  invflags;			/* Inverse flags */
+};
+
+
+
+/* Values for "invflags" field in struct ipt_ah. */
+#define IPT_AH_INV_SPI		0x01	/* Invert the sense of spi. */
+#define IPT_AH_INV_MASK	0x01	/* All possible flags. */
+
+#endif /*_IPT_AH_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_CLUSTERIP.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_CLUSTERIP.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_CLUSTERIP.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_CLUSTERIP.h	2019-04-14 13:24:03.078078946 -0500
@@ -0,0 +1,34 @@
+#ifndef _IPT_CLUSTERIP_H_target
+#define _IPT_CLUSTERIP_H_target
+
+enum clusterip_hashmode {
+    CLUSTERIP_HASHMODE_SIP = 0,
+    CLUSTERIP_HASHMODE_SIP_SPT,
+    CLUSTERIP_HASHMODE_SIP_SPT_DPT,
+};
+
+#define CLUSTERIP_HASHMODE_MAX CLUSTERIP_HASHMODE_SIP_SPT_DPT
+
+#define CLUSTERIP_MAX_NODES 16
+
+#define CLUSTERIP_FLAG_NEW 0x00000001
+
+struct clusterip_config;
+
+struct ipt_clusterip_tgt_info {
+
+	u_int32_t flags;
+
+	/* only relevant for new ones */
+	u_int8_t clustermac[6];
+	u_int16_t num_total_nodes;
+	u_int16_t num_local_nodes;
+	u_int16_t local_nodes[CLUSTERIP_MAX_NODES];
+	u_int32_t hash_mode;
+	u_int32_t hash_initval;
+
+	/* Used internally by the kernel */
+	struct clusterip_config *config;
+};
+
+#endif /*_IPT_CLUSTERIP_H_target*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ecn.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ecn.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ecn.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ecn.h	2019-04-14 13:24:03.078078946 -0500
@@ -0,0 +1,33 @@
+/* iptables module for matching the ECN header in IPv4 and TCP header
+ *
+ * (C) 2002 Harald Welte <laforge@gnumonks.org>
+ *
+ * This software is distributed under GNU GPL v2, 1991
+ * 
+ * ipt_ecn.h,v 1.4 2002/08/05 19:39:00 laforge Exp
+*/
+#ifndef _IPT_ECN_H
+#define _IPT_ECN_H
+#include <linux/netfilter/xt_dscp.h>
+
+#define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
+
+#define IPT_ECN_OP_MATCH_IP	0x01
+#define IPT_ECN_OP_MATCH_ECE	0x10
+#define IPT_ECN_OP_MATCH_CWR	0x20
+
+#define IPT_ECN_OP_MATCH_MASK	0xce
+
+/* match info */
+struct ipt_ecn_info {
+	u_int8_t operation;
+	u_int8_t invert;
+	u_int8_t ip_ect;
+	union {
+		struct {
+			u_int8_t ect;
+		} tcp;
+	} proto;
+};
+
+#endif /* _IPT_ECN_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ECN.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ECN.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ECN.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ECN.h	2019-04-14 13:24:03.079074109 -0500
@@ -0,0 +1,31 @@
+/* Header file for iptables ipt_ECN target
+ *
+ * (C) 2002 by Harald Welte <laforge@gnumonks.org>
+ *
+ * This software is distributed under GNU GPL v2, 1991
+ * 
+ * ipt_ECN.h,v 1.3 2002/05/29 12:17:40 laforge Exp
+*/
+#ifndef _IPT_ECN_TARGET_H
+#define _IPT_ECN_TARGET_H
+#include <linux/netfilter/xt_DSCP.h>
+
+#define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
+
+#define IPT_ECN_OP_SET_IP	0x01	/* set ECN bits of IPv4 header */
+#define IPT_ECN_OP_SET_ECE	0x10	/* set ECE bit of TCP header */
+#define IPT_ECN_OP_SET_CWR	0x20	/* set CWR bit of TCP header */
+
+#define IPT_ECN_OP_MASK		0xce
+
+struct ipt_ECN_info {
+	u_int8_t operation;	/* bitset of operations */
+	u_int8_t ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
+	union {
+		struct {
+			u_int8_t ece:1, cwr:1; /* TCP ECT bits */
+		} tcp;
+	} proto;
+};
+
+#endif /* _IPT_ECN_TARGET_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_LOG.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_LOG.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_LOG.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_LOG.h	2019-04-14 13:24:03.079074109 -0500
@@ -0,0 +1,18 @@
+#ifndef _IPT_LOG_H
+#define _IPT_LOG_H
+
+/* make sure not to change this without changing netfilter.h:NF_LOG_* (!) */
+#define IPT_LOG_TCPSEQ		0x01	/* Log TCP sequence numbers */
+#define IPT_LOG_TCPOPT		0x02	/* Log TCP options */
+#define IPT_LOG_IPOPT		0x04	/* Log IP options */
+#define IPT_LOG_UID		0x08	/* Log UID owning local socket */
+#define IPT_LOG_NFLOG		0x10	/* Unsupported, don't reuse */
+#define IPT_LOG_MASK		0x1f
+
+struct ipt_log_info {
+	unsigned char level;
+	unsigned char logflags;
+	char prefix[30];
+};
+
+#endif /*_IPT_LOG_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_realm.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_realm.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_realm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_realm.h	2019-04-14 13:24:03.079074109 -0500
@@ -0,0 +1,7 @@
+#ifndef _IPT_REALM_H
+#define _IPT_REALM_H
+
+#include <linux/netfilter/xt_realm.h>
+#define ipt_realm_info xt_realm_info
+
+#endif /* _IPT_REALM_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_REJECT.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_REJECT.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_REJECT.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_REJECT.h	2019-04-14 13:24:03.079074109 -0500
@@ -0,0 +1,20 @@
+#ifndef _IPT_REJECT_H
+#define _IPT_REJECT_H
+
+enum ipt_reject_with {
+	IPT_ICMP_NET_UNREACHABLE,
+	IPT_ICMP_HOST_UNREACHABLE,
+	IPT_ICMP_PROT_UNREACHABLE,
+	IPT_ICMP_PORT_UNREACHABLE,
+	IPT_ICMP_ECHOREPLY,
+	IPT_ICMP_NET_PROHIBITED,
+	IPT_ICMP_HOST_PROHIBITED,
+	IPT_TCP_RESET,
+	IPT_ICMP_ADMIN_PROHIBITED
+};
+
+struct ipt_reject_info {
+	enum ipt_reject_with with;      /* reject type */
+};
+
+#endif /*_IPT_REJECT_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_SAME.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_SAME.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_SAME.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_SAME.h	2019-04-14 13:24:03.080049781 -0500
@@ -0,0 +1,19 @@
+#ifndef _IPT_SAME_H
+#define _IPT_SAME_H
+
+#define IPT_SAME_MAX_RANGE	10
+
+#define IPT_SAME_NODST		0x01
+
+struct ipt_same_info
+{
+	unsigned char info;
+	u_int32_t rangesize;
+	u_int32_t ipnum;
+	u_int32_t *iparray;
+
+	/* hangs off end. */
+	struct nf_nat_range range[IPT_SAME_MAX_RANGE];
+};
+
+#endif /*_IPT_SAME_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ttl.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ttl.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ttl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ttl.h	2019-04-14 13:24:03.080049781 -0500
@@ -0,0 +1,21 @@
+/* IP tables module for matching the value of the TTL
+ * (C) 2000 by Harald Welte <laforge@gnumonks.org> */
+
+#ifndef _IPT_TTL_H
+#define _IPT_TTL_H
+
+enum {
+	IPT_TTL_EQ = 0,		/* equals */
+	IPT_TTL_NE,		/* not equals */
+	IPT_TTL_LT,		/* less than */
+	IPT_TTL_GT,		/* greater than */
+};
+
+
+struct ipt_ttl_info {
+	u_int8_t	mode;
+	u_int8_t	ttl;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_TTL.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_TTL.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_TTL.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_TTL.h	2019-04-14 13:24:03.080049781 -0500
@@ -0,0 +1,21 @@
+/* TTL modification module for IP tables
+ * (C) 2000 by Harald Welte <laforge@netfilter.org> */
+
+#ifndef _IPT_TTL_H
+#define _IPT_TTL_H
+
+enum {
+	IPT_TTL_SET = 0,
+	IPT_TTL_INC,
+	IPT_TTL_DEC
+};
+
+#define IPT_TTL_MAXMODE	IPT_TTL_DEC
+
+struct ipt_TTL_info {
+	u_int8_t	mode;
+	u_int8_t	ttl;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ULOG.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ULOG.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ULOG.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4/ipt_ULOG.h	2019-04-14 13:24:03.080049781 -0500
@@ -0,0 +1,49 @@
+/* Header file for IP tables userspace logging, Version 1.8
+ *
+ * (C) 2000-2002 by Harald Welte <laforge@gnumonks.org>
+ * 
+ * Distributed under the terms of GNU GPL */
+
+#ifndef _IPT_ULOG_H
+#define _IPT_ULOG_H
+
+#ifndef NETLINK_NFLOG
+#define NETLINK_NFLOG 	5
+#endif
+
+#define ULOG_DEFAULT_NLGROUP	1
+#define ULOG_DEFAULT_QTHRESHOLD	1
+
+#define ULOG_MAC_LEN	80
+#define ULOG_PREFIX_LEN	32
+
+#define ULOG_MAX_QLEN	50
+/* Why 50? Well... there is a limit imposed by the slab cache 131000
+ * bytes. So the multipart netlink-message has to be < 131000 bytes.
+ * Assuming a standard ethernet-mtu of 1500, we could define this up
+ * to 80... but even 50 seems to be big enough. */
+
+/* private data structure for each rule with a ULOG target */
+struct ipt_ulog_info {
+	unsigned int nl_group;
+	size_t copy_range;
+	size_t qthreshold;
+	char prefix[ULOG_PREFIX_LEN];
+};
+
+/* Format of the ULOG packets passed through netlink */
+typedef struct ulog_packet_msg {
+	unsigned long mark;
+	long timestamp_sec;
+	long timestamp_usec;
+	unsigned int hook;
+	char indev_name[IFNAMSIZ];
+	char outdev_name[IFNAMSIZ];
+	size_t data_len;
+	char prefix[ULOG_PREFIX_LEN];
+	unsigned char mac_len;
+	unsigned char mac[ULOG_MAC_LEN];
+	unsigned char payload[0];
+} ulog_packet_msg_t;
+
+#endif /*_IPT_ULOG_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv4.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv4.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv4.h	2019-04-14 13:24:03.080998076 -0500
@@ -0,0 +1,75 @@
+#ifndef __LINUX_IP_NETFILTER_H
+#define __LINUX_IP_NETFILTER_H
+
+/* IPv4-specific defines for netfilter. 
+ * (C)1998 Rusty Russell -- This code is GPL.
+ */
+
+#include <linux/netfilter.h>
+
+/* only for userspace compatibility */
+/* IP Cache bits. */
+/* Src IP address. */
+#define NFC_IP_SRC		0x0001
+/* Dest IP address. */
+#define NFC_IP_DST		0x0002
+/* Input device. */
+#define NFC_IP_IF_IN		0x0004
+/* Output device. */
+#define NFC_IP_IF_OUT		0x0008
+/* TOS. */
+#define NFC_IP_TOS		0x0010
+/* Protocol. */
+#define NFC_IP_PROTO		0x0020
+/* IP options. */
+#define NFC_IP_OPTIONS		0x0040
+/* Frag & flags. */
+#define NFC_IP_FRAG		0x0080
+
+/* Per-protocol information: only matters if proto match. */
+/* TCP flags. */
+#define NFC_IP_TCPFLAGS		0x0100
+/* Source port. */
+#define NFC_IP_SRC_PT		0x0200
+/* Dest port. */
+#define NFC_IP_DST_PT		0x0400
+/* Something else about the proto */
+#define NFC_IP_PROTO_UNKNOWN	0x2000
+
+/* IP Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_IP_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_IP_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_IP_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_IP_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_IP_POST_ROUTING	4
+#define NF_IP_NUMHOOKS		5
+
+enum nf_ip_hook_priorities {
+	NF_IP_PRI_FIRST = INT_MIN,
+	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
+	NF_IP_PRI_RAW = -300,
+	NF_IP_PRI_SELINUX_FIRST = -225,
+	NF_IP_PRI_CONNTRACK = -200,
+	NF_IP_PRI_MANGLE = -150,
+	NF_IP_PRI_NAT_DST = -100,
+	NF_IP_PRI_FILTER = 0,
+	NF_IP_PRI_SECURITY = 50,
+	NF_IP_PRI_NAT_SRC = 100,
+	NF_IP_PRI_SELINUX_LAST = 225,
+	NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,
+	NF_IP_PRI_LAST = INT_MAX,
+};
+
+/* Arguments for setsockopt SOL_IP: */
+/* 2.0 firewalling went from 64 through 71 (and +256, +512, etc). */
+/* 2.2 firewalling (+ masq) went from 64 through 76 */
+/* 2.4 firewalling went 64 through 67. */
+#define SO_ORIGINAL_DST 80
+
+
+#endif /*__LINUX_IP_NETFILTER_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6_tables.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6_tables.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6_tables.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6_tables.h	2019-04-14 13:24:03.081995362 -0500
@@ -0,0 +1,297 @@
+/*
+ * 25-Jul-1998 Major changes to allow for ip chain table
+ *
+ * 3-Jan-2000 Named tables to allow packet selection for different uses.
+ */
+
+/*
+ * 	Format of an IP6 firewall descriptor
+ *
+ * 	src, dst, src_mask, dst_mask are always stored in network byte order.
+ * 	flags are stored in host byte order (of course).
+ * 	Port numbers are stored in HOST byte order.
+ */
+
+#ifndef _IP6_TABLES_H
+#define _IP6_TABLES_H
+
+#include <linux/types.h>
+
+#include <linux/netfilter_ipv6.h>
+
+#include <linux/netfilter/x_tables.h>
+
+#define IP6T_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
+#define IP6T_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
+
+#define ip6t_match xt_match
+#define ip6t_target xt_target
+#define ip6t_table xt_table
+#define ip6t_get_revision xt_get_revision
+
+/* Yes, Virginia, you have to zero the padding. */
+struct ip6t_ip6 {
+	/* Source and destination IP6 addr */
+	struct in6_addr src, dst;		
+	/* Mask for src and dest IP6 addr */
+	struct in6_addr smsk, dmsk;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
+
+	/* Upper protocol number
+	 * - The allowed value is 0 (any) or protocol number of last parsable
+	 *   header, which is 50 (ESP), 59 (No Next Header), 135 (MH), or
+	 *   the non IPv6 extension headers.
+	 * - The protocol numbers of IPv6 extension headers except of ESP and
+	 *   MH do not match any packets.
+	 * - You also need to set IP6T_FLAGS_PROTO to "flags" to check protocol.
+	 */
+	u_int16_t proto;
+	/* TOS to match iff flags & IP6T_F_TOS */
+	u_int8_t tos;
+
+	/* Flags word */
+	u_int8_t flags;
+	/* Inverse flags */
+	u_int8_t invflags;
+};
+
+#define ip6t_entry_match xt_entry_match
+#define ip6t_entry_target xt_entry_target
+#define ip6t_standard_target xt_standard_target
+
+#define ip6t_counters	xt_counters
+
+/* Values for "flag" field in struct ip6t_ip6 (general ip6 structure). */
+#define IP6T_F_PROTO		0x01	/* Set if rule cares about upper 
+					   protocols */
+#define IP6T_F_TOS		0x02	/* Match the TOS. */
+#define IP6T_F_GOTO		0x04	/* Set if jump is a goto */
+#define IP6T_F_MASK		0x07	/* All possible flag bits mask. */
+
+/* Values for "inv" field in struct ip6t_ip6. */
+#define IP6T_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+#define IP6T_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
+#define IP6T_INV_TOS		0x04	/* Invert the sense of TOS. */
+#define IP6T_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
+#define IP6T_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
+#define IP6T_INV_FRAG		0x20	/* Invert the sense of FRAG. */
+#define IP6T_INV_PROTO		XT_INV_PROTO
+#define IP6T_INV_MASK		0x7F	/* All possible flag bits mask. */
+
+/* This structure defines each of the firewall rules.  Consists of 3
+   parts which are 1) general IP header stuff 2) match specific
+   stuff 3) the target to perform if the rule matches */
+struct ip6t_entry
+{
+	struct ip6t_ip6 ipv6;
+
+	/* Mark with fields that we care about. */
+	unsigned int nfcache;
+
+	/* Size of ipt_entry + matches */
+	u_int16_t target_offset;
+	/* Size of ipt_entry + matches + target */
+	u_int16_t next_offset;
+
+	/* Back pointer */
+	unsigned int comefrom;
+
+	/* Packet and byte counters. */
+	struct xt_counters counters;
+
+	/* The matches (if any), then the target. */
+	unsigned char elems[0];
+};
+
+/* Standard entry */
+struct ip6t_standard
+{
+	struct ip6t_entry entry;
+	struct ip6t_standard_target target;
+};
+
+struct ip6t_error_target
+{
+	struct ip6t_entry_target target;
+	char errorname[IP6T_FUNCTION_MAXNAMELEN];
+};
+
+struct ip6t_error
+{
+	struct ip6t_entry entry;
+	struct ip6t_error_target target;
+};
+
+#define IP6T_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ip6t_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IP6T_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
+	.target		= XT_TARGET_INIT(IP6T_STANDARD_TARGET,		       \
+					 sizeof(struct ip6t_standard_target)), \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IP6T_ERROR_INIT							       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
+	.target		= XT_TARGET_INIT(IP6T_ERROR_TARGET,		       \
+					 sizeof(struct ip6t_error_target)),    \
+	.target.errorname = "ERROR",					       \
+}
+
+/*
+ * New IP firewall options for [gs]etsockopt at the RAW IP level.
+ * Unlike BSD Linux inherits IP options so you don't have to use
+ * a raw socket for this. Instead we check rights in the calls.
+ *
+ * ATTENTION: check linux/in6.h before adding new number here.
+ */
+#define IP6T_BASE_CTL			64
+
+#define IP6T_SO_SET_REPLACE		(IP6T_BASE_CTL)
+#define IP6T_SO_SET_ADD_COUNTERS	(IP6T_BASE_CTL + 1)
+#define IP6T_SO_SET_MAX			IP6T_SO_SET_ADD_COUNTERS
+
+#define IP6T_SO_GET_INFO		(IP6T_BASE_CTL)
+#define IP6T_SO_GET_ENTRIES		(IP6T_BASE_CTL + 1)
+#define IP6T_SO_GET_REVISION_MATCH	(IP6T_BASE_CTL + 4)
+#define IP6T_SO_GET_REVISION_TARGET	(IP6T_BASE_CTL + 5)
+#define IP6T_SO_GET_MAX			IP6T_SO_GET_REVISION_TARGET
+
+/* CONTINUE verdict for targets */
+#define IP6T_CONTINUE XT_CONTINUE
+
+/* For standard target */
+#define IP6T_RETURN XT_RETURN
+
+/* TCP/UDP matching stuff */
+#include <linux/netfilter/xt_tcpudp.h>
+
+#define ip6t_tcp xt_tcp
+#define ip6t_udp xt_udp
+
+/* Values for "inv" field in struct ipt_tcp. */
+#define IP6T_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
+#define IP6T_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
+#define IP6T_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
+#define IP6T_TCP_INV_OPTION	XT_TCP_INV_OPTION
+#define IP6T_TCP_INV_MASK	XT_TCP_INV_MASK
+
+/* Values for "invflags" field in struct ipt_udp. */
+#define IP6T_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
+#define IP6T_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
+#define IP6T_UDP_INV_MASK	XT_UDP_INV_MASK
+
+/* ICMP matching stuff */
+struct ip6t_icmp
+{
+	u_int8_t type;				/* type to match */
+	u_int8_t code[2];			/* range of code */
+	u_int8_t invflags;			/* Inverse flags */
+};
+
+/* Values for "inv" field for struct ipt_icmp. */
+#define IP6T_ICMP_INV	0x01	/* Invert the sense of type/code test */
+
+/* The argument to IP6T_SO_GET_INFO */
+struct ip6t_getinfo
+{
+	/* Which table: caller fills this in. */
+	char name[IP6T_TABLE_MAXNAMELEN];
+
+	/* Kernel fills these in. */
+	/* Which hook entry points are valid: bitmask */
+	unsigned int valid_hooks;
+
+	/* Hook entry points: one per netfilter hook. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Size of entries. */
+	unsigned int size;
+};
+
+/* The argument to IP6T_SO_SET_REPLACE. */
+struct ip6t_replace
+{
+	/* Which table. */
+	char name[IP6T_TABLE_MAXNAMELEN];
+
+	/* Which hook entry points are valid: bitmask.  You can't
+           change this. */
+	unsigned int valid_hooks;
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Total size of new entries */
+	unsigned int size;
+
+	/* Hook entry points. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Information about old entries: */
+	/* Number of counters (must be equal to current number of entries). */
+	unsigned int num_counters;
+	/* The old entries' counters. */
+	struct xt_counters *counters;
+
+	/* The entries (hang off end: not really an array). */
+	struct ip6t_entry entries[0];
+};
+
+/* The argument to IP6T_SO_ADD_COUNTERS. */
+#define ip6t_counters_info xt_counters_info
+
+/* The argument to IP6T_SO_GET_ENTRIES. */
+struct ip6t_get_entries
+{
+	/* Which table: user fills this in. */
+	char name[IP6T_TABLE_MAXNAMELEN];
+
+	/* User fills this in: total entry size. */
+	unsigned int size;
+
+	/* The entries. */
+	struct ip6t_entry entrytable[0];
+};
+
+/* Standard return verdict, or do jump. */
+#define IP6T_STANDARD_TARGET XT_STANDARD_TARGET
+/* Error verdict. */
+#define IP6T_ERROR_TARGET XT_ERROR_TARGET
+
+/* Helper functions */
+static __inline__ struct ip6t_entry_target *
+ip6t_get_target(struct ip6t_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+
+/* fn returns 0 to continue iteration */
+#define IP6T_MATCH_ITERATE(e, fn, args...) \
+	XT_MATCH_ITERATE(struct ip6t_entry, e, fn, ## args)
+
+/* fn returns 0 to continue iteration */
+#define IP6T_ENTRY_ITERATE(entries, size, fn, args...) \
+	XT_ENTRY_ITERATE(struct ip6t_entry, entries, size, fn, ## args)
+
+/*
+ *	Main firewall chains definitions and global var's definitions.
+ */
+
+#endif /* _IP6_TABLES_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ah.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ah.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ah.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ah.h	2019-04-14 13:24:03.082994965 -0500
@@ -0,0 +1,21 @@
+#ifndef _IP6T_AH_H
+#define _IP6T_AH_H
+
+struct ip6t_ah
+{
+	u_int32_t spis[2];			/* Security Parameter Index */
+	u_int32_t hdrlen;			/* Header Length */
+	u_int8_t  hdrres;			/* Test of the Reserved Filed */
+	u_int8_t  invflags;			/* Inverse flags */
+};
+
+#define IP6T_AH_SPI 0x01
+#define IP6T_AH_LEN 0x02
+#define IP6T_AH_RES 0x04
+
+/* Values for "invflags" field in struct ip6t_ah. */
+#define IP6T_AH_INV_SPI		0x01	/* Invert the sense of spi. */
+#define IP6T_AH_INV_LEN		0x02	/* Invert the sense of length. */
+#define IP6T_AH_INV_MASK	0x03	/* All possible flags. */
+
+#endif /*_IP6T_AH_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_frag.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_frag.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_frag.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_frag.h	2019-04-14 13:24:03.082994965 -0500
@@ -0,0 +1,24 @@
+#ifndef _IP6T_FRAG_H
+#define _IP6T_FRAG_H
+
+struct ip6t_frag
+{
+	u_int32_t ids[2];			/* Security Parameter Index */
+	u_int32_t hdrlen;			/* Header Length */
+	u_int8_t  flags;			/*  */
+	u_int8_t  invflags;			/* Inverse flags */
+};
+
+#define IP6T_FRAG_IDS 		0x01
+#define IP6T_FRAG_LEN 		0x02
+#define IP6T_FRAG_RES 		0x04
+#define IP6T_FRAG_FST 		0x08
+#define IP6T_FRAG_MF  		0x10
+#define IP6T_FRAG_NMF  		0x20
+
+/* Values for "invflags" field in struct ip6t_frag. */
+#define IP6T_FRAG_INV_IDS	0x01	/* Invert the sense of ids. */
+#define IP6T_FRAG_INV_LEN	0x02	/* Invert the sense of length. */
+#define IP6T_FRAG_INV_MASK	0x03	/* All possible flags. */
+
+#endif /*_IP6T_FRAG_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_hl.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_hl.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_hl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_hl.h	2019-04-14 13:24:03.082994965 -0500
@@ -0,0 +1,22 @@
+/* ip6tables module for matching the Hop Limit value
+ * Maciej Soltysiak <solt@dns.toxicfilms.tv>
+ * Based on HW's ttl module */
+
+#ifndef _IP6T_HL_H
+#define _IP6T_HL_H
+
+enum {
+	IP6T_HL_EQ = 0,		/* equals */
+	IP6T_HL_NE,		/* not equals */
+	IP6T_HL_LT,		/* less than */
+	IP6T_HL_GT,		/* greater than */
+};
+
+
+struct ip6t_hl_info {
+	u_int8_t	mode;
+	u_int8_t	hop_limit;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_HL.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_HL.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_HL.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_HL.h	2019-04-14 13:24:03.082994965 -0500
@@ -0,0 +1,22 @@
+/* Hop Limit modification module for ip6tables
+ * Maciej Soltysiak <solt@dns.toxicfilms.tv>
+ * Based on HW's TTL module */
+
+#ifndef _IP6T_HL_H
+#define _IP6T_HL_H
+
+enum {
+	IP6T_HL_SET = 0,
+	IP6T_HL_INC,
+	IP6T_HL_DEC
+};
+
+#define IP6T_HL_MAXMODE	IP6T_HL_DEC
+
+struct ip6t_HL_info {
+	u_int8_t	mode;
+	u_int8_t	hop_limit;
+};
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ipv6header.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ipv6header.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ipv6header.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_ipv6header.h	2019-04-14 13:24:03.082994965 -0500
@@ -0,0 +1,27 @@
+/* ipv6header match - matches IPv6 packets based
+on whether they contain certain headers */
+
+/* Original idea: Brad Chapman 
+ * Rewritten by: Andras Kis-Szabo <kisza@sch.bme.hu> */
+
+
+#ifndef __IPV6HEADER_H
+#define __IPV6HEADER_H
+
+struct ip6t_ipv6header_info
+{
+	u_int8_t matchflags;
+	u_int8_t invflags;
+	u_int8_t modeflag;
+};
+
+#define MASK_HOPOPTS    128
+#define MASK_DSTOPTS    64
+#define MASK_ROUTING    32
+#define MASK_FRAGMENT   16
+#define MASK_AH         8
+#define MASK_ESP        4
+#define MASK_NONE       2
+#define MASK_PROTO      1
+
+#endif /* __IPV6HEADER_H */
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_LOG.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_LOG.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_LOG.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_LOG.h	2019-04-14 13:24:03.083980290 -0500
@@ -0,0 +1,18 @@
+#ifndef _IP6T_LOG_H
+#define _IP6T_LOG_H
+
+/* make sure not to change this without changing netfilter.h:NF_LOG_* (!) */
+#define IP6T_LOG_TCPSEQ		0x01	/* Log TCP sequence numbers */
+#define IP6T_LOG_TCPOPT		0x02	/* Log TCP options */
+#define IP6T_LOG_IPOPT		0x04	/* Log IP options */
+#define IP6T_LOG_UID		0x08	/* Log UID owning local socket */
+#define IP6T_LOG_NFLOG		0x10	/* Unsupported, don't use */
+#define IP6T_LOG_MASK		0x1f
+
+struct ip6t_log_info {
+	unsigned char level;
+	unsigned char logflags;
+	char prefix[30];
+};
+
+#endif /*_IPT_LOG_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_mh.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_mh.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_mh.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_mh.h	2019-04-14 13:24:03.083980290 -0500
@@ -0,0 +1,15 @@
+#ifndef _IP6T_MH_H
+#define _IP6T_MH_H
+
+/* MH matching stuff */
+struct ip6t_mh
+{
+	u_int8_t types[2];	/* MH type range */
+	u_int8_t invflags;	/* Inverse flags */
+};
+
+/* Values for "invflags" field in struct ip6t_mh. */
+#define IP6T_MH_INV_TYPE	0x01	/* Invert the sense of type. */
+#define IP6T_MH_INV_MASK	0x01	/* All possible flags. */
+
+#endif /*_IP6T_MH_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_opts.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_opts.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_opts.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_opts.h	2019-04-14 13:24:03.083980290 -0500
@@ -0,0 +1,23 @@
+#ifndef _IP6T_OPTS_H
+#define _IP6T_OPTS_H
+
+#define IP6T_OPTS_OPTSNR 16
+
+struct ip6t_opts
+{
+	u_int32_t hdrlen;			/* Header Length */
+	u_int8_t flags;				/*  */
+	u_int8_t invflags;			/* Inverse flags */
+	u_int16_t opts[IP6T_OPTS_OPTSNR];	/* opts */
+	u_int8_t optsnr;			/* Nr of OPts */
+};
+
+#define IP6T_OPTS_LEN 		0x01
+#define IP6T_OPTS_OPTS 		0x02
+#define IP6T_OPTS_NSTRICT	0x04
+
+/* Values for "invflags" field in struct ip6t_rt. */
+#define IP6T_OPTS_INV_LEN	0x01	/* Invert the sense of length. */
+#define IP6T_OPTS_INV_MASK	0x01	/* All possible flags. */
+
+#endif /*_IP6T_OPTS_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_REJECT.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_REJECT.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_REJECT.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_REJECT.h	2019-04-14 13:24:03.083980290 -0500
@@ -0,0 +1,18 @@
+#ifndef _IP6T_REJECT_H
+#define _IP6T_REJECT_H
+
+enum ip6t_reject_with {
+	IP6T_ICMP6_NO_ROUTE,
+	IP6T_ICMP6_ADM_PROHIBITED,
+	IP6T_ICMP6_NOT_NEIGHBOUR,
+	IP6T_ICMP6_ADDR_UNREACH,
+	IP6T_ICMP6_PORT_UNREACH,
+	IP6T_ICMP6_ECHOREPLY,
+	IP6T_TCP_RESET
+};
+
+struct ip6t_reject_info {
+	u_int32_t	with;	/* reject type */
+};
+
+#endif /*_IP6T_REJECT_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_rt.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_rt.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_rt.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6/ip6t_rt.h	2019-04-14 13:24:03.083980290 -0500
@@ -0,0 +1,33 @@
+#ifndef _IP6T_RT_H
+#define _IP6T_RT_H
+
+/*#include <linux/in6.h>*/
+
+#define IP6T_RT_HOPS 16
+
+struct ip6t_rt
+{
+	u_int32_t rt_type;			/* Routing Type */
+	u_int32_t segsleft[2];			/* Segments Left */
+	u_int32_t hdrlen;			/* Header Length */
+	u_int8_t  flags;			/*  */
+	u_int8_t  invflags;			/* Inverse flags */
+	struct in6_addr addrs[IP6T_RT_HOPS];	/* Hops */
+	u_int8_t addrnr;			/* Nr of Addresses */
+};
+
+#define IP6T_RT_TYP 		0x01
+#define IP6T_RT_SGS 		0x02
+#define IP6T_RT_LEN 		0x04
+#define IP6T_RT_RES 		0x08
+#define IP6T_RT_FST_MASK	0x30
+#define IP6T_RT_FST 		0x10
+#define IP6T_RT_FST_NSTRICT	0x20
+
+/* Values for "invflags" field in struct ip6t_rt. */
+#define IP6T_RT_INV_TYP		0x01	/* Invert the sense of type. */
+#define IP6T_RT_INV_SGS		0x02	/* Invert the sense of Segments. */
+#define IP6T_RT_INV_LEN		0x04	/* Invert the sense of length. */
+#define IP6T_RT_INV_MASK	0x07	/* All possible flags. */
+
+#endif /*_IP6T_RT_H*/
diff -uNr linux-2.6.32/usr/include/linux/netfilter_ipv6.h clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6.h
--- linux-2.6.32/usr/include/linux/netfilter_ipv6.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netfilter_ipv6.h	2019-04-14 13:24:03.084943216 -0500
@@ -0,0 +1,72 @@
+#ifndef __LINUX_IP6_NETFILTER_H
+#define __LINUX_IP6_NETFILTER_H
+
+/* IPv6-specific defines for netfilter. 
+ * (C)1998 Rusty Russell -- This code is GPL.
+ * (C)1999 David Jeffery
+ *   this header was blatantly ripped from netfilter_ipv4.h 
+ *   it's amazing what adding a bunch of 6s can do =8^)
+ */
+
+#include <linux/netfilter.h>
+
+/* only for userspace compatibility */
+/* IP Cache bits. */
+/* Src IP address. */
+#define NFC_IP6_SRC              0x0001
+/* Dest IP address. */
+#define NFC_IP6_DST              0x0002
+/* Input device. */
+#define NFC_IP6_IF_IN            0x0004
+/* Output device. */
+#define NFC_IP6_IF_OUT           0x0008
+/* TOS. */
+#define NFC_IP6_TOS              0x0010
+/* Protocol. */
+#define NFC_IP6_PROTO            0x0020
+/* IP options. */
+#define NFC_IP6_OPTIONS          0x0040
+/* Frag & flags. */
+#define NFC_IP6_FRAG             0x0080
+
+
+/* Per-protocol information: only matters if proto match. */
+/* TCP flags. */
+#define NFC_IP6_TCPFLAGS         0x0100
+/* Source port. */
+#define NFC_IP6_SRC_PT           0x0200
+/* Dest port. */
+#define NFC_IP6_DST_PT           0x0400
+/* Something else about the proto */
+#define NFC_IP6_PROTO_UNKNOWN    0x2000
+
+/* IP6 Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_IP6_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_IP6_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_IP6_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_IP6_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_IP6_POST_ROUTING	4
+#define NF_IP6_NUMHOOKS		5
+
+
+enum nf_ip6_hook_priorities {
+	NF_IP6_PRI_FIRST = INT_MIN,
+	NF_IP6_PRI_CONNTRACK_DEFRAG = -400,
+	NF_IP6_PRI_SELINUX_FIRST = -225,
+	NF_IP6_PRI_CONNTRACK = -200,
+	NF_IP6_PRI_MANGLE = -150,
+	NF_IP6_PRI_NAT_DST = -100,
+	NF_IP6_PRI_FILTER = 0,
+	NF_IP6_PRI_SECURITY = 50,
+	NF_IP6_PRI_NAT_SRC = 100,
+	NF_IP6_PRI_SELINUX_LAST = 225,
+	NF_IP6_PRI_LAST = INT_MAX,
+};
+
+
+#endif /*__LINUX_IP6_NETFILTER_H*/
diff -uNr linux-2.6.32/usr/include/linux/net.h clean_modified/linux-2.6.32/usr/include/linux/net.h
--- linux-2.6.32/usr/include/linux/net.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/net.h	2019-04-14 13:24:03.084943216 -0500
@@ -0,0 +1,55 @@
+/*
+ * NET		An implementation of the SOCKET network access protocol.
+ *		This is the master header file for the Linux NET layer,
+ *		or, in plain English: the networking handling part of the
+ *		kernel.
+ *
+ * Version:	@(#)net.h	1.0.3	05/25/93
+ *
+ * Authors:	Orest Zborowski, <obz@Kodak.COM>
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_NET_H
+#define _LINUX_NET_H
+
+#include <linux/socket.h>
+#include <asm/socket.h>
+
+#define NPROTO		AF_MAX
+
+#define SYS_SOCKET	1		/* sys_socket(2)		*/
+#define SYS_BIND	2		/* sys_bind(2)			*/
+#define SYS_CONNECT	3		/* sys_connect(2)		*/
+#define SYS_LISTEN	4		/* sys_listen(2)		*/
+#define SYS_ACCEPT	5		/* sys_accept(2)		*/
+#define SYS_GETSOCKNAME	6		/* sys_getsockname(2)		*/
+#define SYS_GETPEERNAME	7		/* sys_getpeername(2)		*/
+#define SYS_SOCKETPAIR	8		/* sys_socketpair(2)		*/
+#define SYS_SEND	9		/* sys_send(2)			*/
+#define SYS_RECV	10		/* sys_recv(2)			*/
+#define SYS_SENDTO	11		/* sys_sendto(2)		*/
+#define SYS_RECVFROM	12		/* sys_recvfrom(2)		*/
+#define SYS_SHUTDOWN	13		/* sys_shutdown(2)		*/
+#define SYS_SETSOCKOPT	14		/* sys_setsockopt(2)		*/
+#define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
+#define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
+#define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
+#define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
+
+typedef enum {
+	SS_FREE = 0,			/* not allocated		*/
+	SS_UNCONNECTED,			/* unconnected to any socket	*/
+	SS_CONNECTING,			/* in process of connecting	*/
+	SS_CONNECTED,			/* connected to socket		*/
+	SS_DISCONNECTING		/* in process of disconnecting	*/
+} socket_state;
+
+#define __SO_ACCEPTCON	(1 << 16)	/* performed a listen		*/
+
+#endif	/* _LINUX_NET_H */
diff -uNr linux-2.6.32/usr/include/linux/netlink.h clean_modified/linux-2.6.32/usr/include/linux/netlink.h
--- linux-2.6.32/usr/include/linux/netlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netlink.h	2019-04-14 13:24:03.084943216 -0500
@@ -0,0 +1,155 @@
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+#include <linux/socket.h> /* for sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Firewalling hook				*/
+#define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
+
+#define MAX_LINKS 32		
+
+struct net;
+
+struct sockaddr_nl
+{
+	sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* port ID	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr
+{
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process port ID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		1	/* It is request message. 	*/
+#define NLM_F_MULTI		2	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		4	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		8	/* Echo this request 		*/
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
+struct nlmsgerr
+{
+	int		error;
+	struct nlmsghdr msg;
+};
+
+#define NETLINK_ADD_MEMBERSHIP	1
+#define NETLINK_DROP_MEMBERSHIP	2
+#define NETLINK_PKTINFO		3
+#define NETLINK_BROADCAST_ERROR	4
+#define NETLINK_NO_ENOBUFS	5
+
+struct nl_pktinfo
+{
+	__u32	group;
+};
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr
+{
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
+
+#endif	/* __LINUX_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/netrom.h clean_modified/linux-2.6.32/usr/include/linux/netrom.h
--- linux-2.6.32/usr/include/linux/netrom.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/netrom.h	2019-04-14 13:24:03.085877960 -0500
@@ -0,0 +1,34 @@
+/*
+ * These are the public elements of the Linux kernel NET/ROM implementation.
+ * For kernel AX.25 see the file ax25.h. This file requires ax25.h for the
+ * definition of the ax25_address structure.
+ */
+
+#ifndef	NETROM_KERNEL_H
+#define	NETROM_KERNEL_H
+
+#define NETROM_MTU	236
+
+#define NETROM_T1	1
+#define NETROM_T2	2
+#define NETROM_N2	3
+#define	NETROM_T4	6
+#define	NETROM_IDLE	7
+
+#define	SIOCNRDECOBS		(SIOCPROTOPRIVATE+2)
+
+struct nr_route_struct {
+#define	NETROM_NEIGH	0
+#define	NETROM_NODE	1
+	int		type;
+	ax25_address	callsign;
+	char		device[16];
+	unsigned int	quality;
+	char		mnemonic[7];
+	ax25_address	neighbour;
+	unsigned int	obs_count;
+	unsigned int	ndigis;
+	ax25_address	digipeaters[AX25_MAX_DIGIS];
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/nfs2.h clean_modified/linux-2.6.32/usr/include/linux/nfs2.h
--- linux-2.6.32/usr/include/linux/nfs2.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs2.h	2019-04-14 13:24:03.085877960 -0500
@@ -0,0 +1,67 @@
+/*
+ * NFS protocol definitions
+ *
+ * This file contains constants for Version 2 of the protocol.
+ */
+#ifndef _LINUX_NFS2_H
+#define _LINUX_NFS2_H
+
+#define NFS2_PORT	2049
+#define NFS2_MAXDATA	8192
+#define NFS2_MAXPATHLEN	1024
+#define NFS2_MAXNAMLEN	255
+#define NFS2_MAXGROUPS	16
+#define NFS2_FHSIZE	32
+#define NFS2_COOKIESIZE	4
+#define NFS2_FIFO_DEV	(-1)
+#define NFS2MODE_FMT	0170000
+#define NFS2MODE_DIR	0040000
+#define NFS2MODE_CHR	0020000
+#define NFS2MODE_BLK	0060000
+#define NFS2MODE_REG	0100000
+#define NFS2MODE_LNK	0120000
+#define NFS2MODE_SOCK	0140000
+#define NFS2MODE_FIFO	0010000
+
+
+/* NFSv2 file types - beware, these are not the same in NFSv3 */
+enum nfs2_ftype {
+	NF2NON = 0,
+	NF2REG = 1,
+	NF2DIR = 2,
+	NF2BLK = 3,
+	NF2CHR = 4,
+	NF2LNK = 5,
+	NF2SOCK = 6,
+	NF2BAD = 7,
+	NF2FIFO = 8
+};
+
+struct nfs2_fh {
+	char			data[NFS2_FHSIZE];
+};
+
+/*
+ * Procedure numbers for NFSv2
+ */
+#define NFS2_VERSION		2
+#define NFSPROC_NULL		0
+#define NFSPROC_GETATTR		1
+#define NFSPROC_SETATTR		2
+#define NFSPROC_ROOT		3
+#define NFSPROC_LOOKUP		4
+#define NFSPROC_READLINK	5
+#define NFSPROC_READ		6
+#define NFSPROC_WRITECACHE	7
+#define NFSPROC_WRITE		8
+#define NFSPROC_CREATE		9
+#define NFSPROC_REMOVE		10
+#define NFSPROC_RENAME		11
+#define NFSPROC_LINK		12
+#define NFSPROC_SYMLINK		13
+#define NFSPROC_MKDIR		14
+#define NFSPROC_RMDIR		15
+#define NFSPROC_READDIR		16
+#define NFSPROC_STATFS		17
+
+#endif /* _LINUX_NFS2_H */
diff -uNr linux-2.6.32/usr/include/linux/nfs3.h clean_modified/linux-2.6.32/usr/include/linux/nfs3.h
--- linux-2.6.32/usr/include/linux/nfs3.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs3.h	2019-04-14 13:24:03.086870732 -0500
@@ -0,0 +1,94 @@
+/*
+ * NFSv3 protocol definitions
+ */
+#ifndef _LINUX_NFS3_H
+#define _LINUX_NFS3_H
+
+#define NFS3_PORT		2049
+#define NFS3_MAXDATA		32768
+#define NFS3_MAXPATHLEN		PATH_MAX
+#define NFS3_MAXNAMLEN		NAME_MAX
+#define NFS3_MAXGROUPS		16
+#define NFS3_FHSIZE		64
+#define NFS3_COOKIESIZE		4
+#define NFS3_FIFO_DEV		(-1)
+#define NFS3MODE_FMT		0170000
+#define NFS3MODE_DIR		0040000
+#define NFS3MODE_CHR		0020000
+#define NFS3MODE_BLK		0060000
+#define NFS3MODE_REG		0100000
+#define NFS3MODE_LNK		0120000
+#define NFS3MODE_SOCK		0140000
+#define NFS3MODE_FIFO		0010000
+
+/* Flags for access() call */
+#define NFS3_ACCESS_READ	0x0001
+#define NFS3_ACCESS_LOOKUP	0x0002
+#define NFS3_ACCESS_MODIFY	0x0004
+#define NFS3_ACCESS_EXTEND	0x0008
+#define NFS3_ACCESS_DELETE	0x0010
+#define NFS3_ACCESS_EXECUTE	0x0020
+#define NFS3_ACCESS_FULL	0x003f
+
+/* Flags for create mode */
+enum nfs3_createmode {
+	NFS3_CREATE_UNCHECKED = 0,
+	NFS3_CREATE_GUARDED = 1,
+	NFS3_CREATE_EXCLUSIVE = 2
+};
+
+/* NFSv3 file system properties */
+#define NFS3_FSF_LINK		0x0001
+#define NFS3_FSF_SYMLINK	0x0002
+#define NFS3_FSF_HOMOGENEOUS	0x0008
+#define NFS3_FSF_CANSETTIME	0x0010
+/* Some shorthands. See fs/nfsd/nfs3proc.c */
+#define NFS3_FSF_DEFAULT	0x001B
+#define NFS3_FSF_BILLYBOY	0x0018
+#define NFS3_FSF_READONLY	0x0008
+
+enum nfs3_ftype {
+	NF3NON  = 0,
+	NF3REG  = 1,
+	NF3DIR  = 2,
+	NF3BLK  = 3,
+	NF3CHR  = 4,
+	NF3LNK  = 5,
+	NF3SOCK = 6,
+	NF3FIFO = 7,	/* changed from NFSv2 (was 8) */
+	NF3BAD  = 8
+};
+
+struct nfs3_fh {
+	unsigned short size;
+	unsigned char  data[NFS3_FHSIZE];
+};
+
+#define NFS3_VERSION		3
+#define NFS3PROC_NULL		0
+#define NFS3PROC_GETATTR	1
+#define NFS3PROC_SETATTR	2
+#define NFS3PROC_LOOKUP		3
+#define NFS3PROC_ACCESS		4
+#define NFS3PROC_READLINK	5
+#define NFS3PROC_READ		6
+#define NFS3PROC_WRITE		7
+#define NFS3PROC_CREATE		8
+#define NFS3PROC_MKDIR		9
+#define NFS3PROC_SYMLINK	10
+#define NFS3PROC_MKNOD		11
+#define NFS3PROC_REMOVE		12
+#define NFS3PROC_RMDIR		13
+#define NFS3PROC_RENAME		14
+#define NFS3PROC_LINK		15
+#define NFS3PROC_READDIR	16
+#define NFS3PROC_READDIRPLUS	17
+#define NFS3PROC_FSSTAT		18
+#define NFS3PROC_FSINFO		19
+#define NFS3PROC_PATHCONF	20
+#define NFS3PROC_COMMIT		21
+
+#define NFS_MNT3_VERSION	3
+ 
+
+#endif /* _LINUX_NFS3_H */
diff -uNr linux-2.6.32/usr/include/linux/nfs4.h clean_modified/linux-2.6.32/usr/include/linux/nfs4.h
--- linux-2.6.32/usr/include/linux/nfs4.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs4.h	2019-04-14 13:24:03.087945901 -0500
@@ -0,0 +1,157 @@
+/*
+ *  include/linux/nfs4.h
+ *
+ *  NFSv4 protocol definitions.
+ *
+ *  Copyright (c) 2002 The Regents of the University of Michigan.
+ *  All rights reserved.
+ *
+ *  Kendrick Smith <kmsmith@umich.edu>
+ *  Andy Adamson   <andros@umich.edu>
+ */
+
+#ifndef _LINUX_NFS4_H
+#define _LINUX_NFS4_H
+
+#include <linux/types.h>
+
+#define NFS4_BITMAP_SIZE	2
+#define NFS4_VERIFIER_SIZE	8
+#define NFS4_STATEID_SIZE	16
+#define NFS4_FHSIZE		128
+#define NFS4_MAXPATHLEN		PATH_MAX
+#define NFS4_MAXNAMLEN		NAME_MAX
+#define NFS4_OPAQUE_LIMIT	1024
+#define NFS4_MAX_SESSIONID_LEN	16
+
+#define NFS4_ACCESS_READ        0x0001
+#define NFS4_ACCESS_LOOKUP      0x0002
+#define NFS4_ACCESS_MODIFY      0x0004
+#define NFS4_ACCESS_EXTEND      0x0008
+#define NFS4_ACCESS_DELETE      0x0010
+#define NFS4_ACCESS_EXECUTE     0x0020
+
+#define NFS4_FH_PERSISTENT		0x0000
+#define NFS4_FH_NOEXPIRE_WITH_OPEN	0x0001
+#define NFS4_FH_VOLATILE_ANY		0x0002
+#define NFS4_FH_VOL_MIGRATION		0x0004
+#define NFS4_FH_VOL_RENAME		0x0008
+
+#define NFS4_OPEN_RESULT_CONFIRM 0x0002
+#define NFS4_OPEN_RESULT_LOCKTYPE_POSIX 0x0004
+
+#define NFS4_SHARE_ACCESS_MASK	0x000F
+#define NFS4_SHARE_ACCESS_READ	0x0001
+#define NFS4_SHARE_ACCESS_WRITE	0x0002
+#define NFS4_SHARE_ACCESS_BOTH	0x0003
+#define NFS4_SHARE_DENY_READ	0x0001
+#define NFS4_SHARE_DENY_WRITE	0x0002
+#define NFS4_SHARE_DENY_BOTH	0x0003
+
+/* nfs41 */
+#define NFS4_SHARE_WANT_MASK		0xFF00
+#define NFS4_SHARE_WANT_NO_PREFERENCE	0x0000
+#define NFS4_SHARE_WANT_READ_DELEG	0x0100
+#define NFS4_SHARE_WANT_WRITE_DELEG	0x0200
+#define NFS4_SHARE_WANT_ANY_DELEG	0x0300
+#define NFS4_SHARE_WANT_NO_DELEG	0x0400
+#define NFS4_SHARE_WANT_CANCEL		0x0500
+
+#define NFS4_SHARE_WHEN_MASK		0xF0000
+#define NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL	0x10000
+#define NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED		0x20000
+
+#define NFS4_SET_TO_SERVER_TIME	0
+#define NFS4_SET_TO_CLIENT_TIME	1
+
+#define NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE 0
+#define NFS4_ACE_ACCESS_DENIED_ACE_TYPE  1
+#define NFS4_ACE_SYSTEM_AUDIT_ACE_TYPE   2
+#define NFS4_ACE_SYSTEM_ALARM_ACE_TYPE   3
+
+#define ACL4_SUPPORT_ALLOW_ACL 0x01
+#define ACL4_SUPPORT_DENY_ACL  0x02
+#define ACL4_SUPPORT_AUDIT_ACL 0x04
+#define ACL4_SUPPORT_ALARM_ACL 0x08
+
+#define NFS4_ACE_FILE_INHERIT_ACE             0x00000001
+#define NFS4_ACE_DIRECTORY_INHERIT_ACE        0x00000002
+#define NFS4_ACE_NO_PROPAGATE_INHERIT_ACE     0x00000004
+#define NFS4_ACE_INHERIT_ONLY_ACE             0x00000008
+#define NFS4_ACE_SUCCESSFUL_ACCESS_ACE_FLAG   0x00000010
+#define NFS4_ACE_FAILED_ACCESS_ACE_FLAG       0x00000020
+#define NFS4_ACE_IDENTIFIER_GROUP             0x00000040
+
+#define NFS4_ACE_READ_DATA                    0x00000001
+#define NFS4_ACE_LIST_DIRECTORY               0x00000001
+#define NFS4_ACE_WRITE_DATA                   0x00000002
+#define NFS4_ACE_ADD_FILE                     0x00000002
+#define NFS4_ACE_APPEND_DATA                  0x00000004
+#define NFS4_ACE_ADD_SUBDIRECTORY             0x00000004
+#define NFS4_ACE_READ_NAMED_ATTRS             0x00000008
+#define NFS4_ACE_WRITE_NAMED_ATTRS            0x00000010
+#define NFS4_ACE_EXECUTE                      0x00000020
+#define NFS4_ACE_DELETE_CHILD                 0x00000040
+#define NFS4_ACE_READ_ATTRIBUTES              0x00000080
+#define NFS4_ACE_WRITE_ATTRIBUTES             0x00000100
+#define NFS4_ACE_DELETE                       0x00010000
+#define NFS4_ACE_READ_ACL                     0x00020000
+#define NFS4_ACE_WRITE_ACL                    0x00040000
+#define NFS4_ACE_WRITE_OWNER                  0x00080000
+#define NFS4_ACE_SYNCHRONIZE                  0x00100000
+#define NFS4_ACE_GENERIC_READ                 0x00120081
+#define NFS4_ACE_GENERIC_WRITE                0x00160106
+#define NFS4_ACE_GENERIC_EXECUTE              0x001200A0
+#define NFS4_ACE_MASK_ALL                     0x001F01FF
+
+#define EXCHGID4_FLAG_SUPP_MOVED_REFER		0x00000001
+#define EXCHGID4_FLAG_SUPP_MOVED_MIGR		0x00000002
+#define EXCHGID4_FLAG_USE_NON_PNFS		0x00010000
+#define EXCHGID4_FLAG_USE_PNFS_MDS		0x00020000
+#define EXCHGID4_FLAG_USE_PNFS_DS		0x00040000
+#define EXCHGID4_FLAG_UPD_CONFIRMED_REC_A	0x40000000
+#define EXCHGID4_FLAG_CONFIRMED_R		0x80000000
+/*
+ * Since the validity of these bits depends on whether
+ * they're set in the argument or response, have separate
+ * invalid flag masks for arg (_A) and resp (_R).
+ */
+#define EXCHGID4_FLAG_MASK_A			0x40070003
+#define EXCHGID4_FLAG_MASK_R			0x80070003
+
+#define SEQ4_STATUS_CB_PATH_DOWN		0x00000001
+#define SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING	0x00000002
+#define SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED	0x00000004
+#define SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED	0x00000008
+#define SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED	0x00000010
+#define SEQ4_STATUS_ADMIN_STATE_REVOKED		0x00000020
+#define SEQ4_STATUS_RECALLABLE_STATE_REVOKED	0x00000040
+#define SEQ4_STATUS_LEASE_MOVED			0x00000080
+#define SEQ4_STATUS_RESTART_RECLAIM_NEEDED	0x00000100
+
+#define NFS4_MAX_UINT64	(~(u64)0)
+
+/* An NFS4 sessions server must support at least NFS4_MAX_OPS operations.
+ * If a compound requires more operations, adjust NFS4_MAX_OPS accordingly.
+ */
+#define NFS4_MAX_OPS   8
+
+/* Our NFS4 client back channel server only wants the cb_sequene and the
+ * actual operation per compound
+ */
+#define NFS4_MAX_BACK_CHANNEL_OPS 2
+
+enum nfs4_acl_whotype {
+	NFS4_ACL_WHO_NAMED = 0,
+	NFS4_ACL_WHO_OWNER,
+	NFS4_ACL_WHO_GROUP,
+	NFS4_ACL_WHO_EVERYONE,
+};
+
+#endif
+
+/*
+ * Local variables:
+ *  c-basic-offset: 8
+ * End:
+ */
diff -uNr linux-2.6.32/usr/include/linux/nfs4_mount.h clean_modified/linux-2.6.32/usr/include/linux/nfs4_mount.h
--- linux-2.6.32/usr/include/linux/nfs4_mount.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs4_mount.h	2019-04-14 13:24:03.088860603 -0500
@@ -0,0 +1,71 @@
+#ifndef _LINUX_NFS4_MOUNT_H
+#define _LINUX_NFS4_MOUNT_H
+
+/*
+ *  linux/include/linux/nfs4_mount.h
+ *
+ *  Copyright (C) 2002  Trond Myklebust
+ *
+ *  structure passed from user-space to kernel-space during an nfsv4 mount
+ */
+
+/*
+ * WARNING!  Do not delete or change the order of these fields.  If
+ * a new field is required then add it to the end.  The version field
+ * tracks which fields are present.  This will ensure some measure of
+ * mount-to-kernel version compatibility.  Some of these aren't used yet
+ * but here they are anyway.
+ */
+#define NFS4_MOUNT_VERSION	1
+
+struct nfs_string {
+	unsigned int len;
+	const char * data;
+};
+
+struct nfs4_mount_data {
+	int version;				/* 1 */
+	int flags;				/* 1 */
+	int rsize;				/* 1 */
+	int wsize;				/* 1 */
+	int timeo;				/* 1 */
+	int retrans;				/* 1 */
+	int acregmin;				/* 1 */
+	int acregmax;				/* 1 */
+	int acdirmin;				/* 1 */
+	int acdirmax;				/* 1 */
+
+	/* see the definition of 'struct clientaddr4' in RFC3010 */
+	struct nfs_string client_addr;		/* 1 */
+
+	/* Mount path */
+	struct nfs_string mnt_path;		/* 1 */
+
+	/* Server details */
+	struct nfs_string hostname;		/* 1 */
+	/* Server IP address */
+	unsigned int host_addrlen;		/* 1 */
+	struct sockaddr * host_addr;	/* 1 */
+
+	/* Transport protocol to use */
+	int proto;				/* 1 */
+
+	/* Pseudo-flavours to use for authentication. See RFC2623 */
+	int auth_flavourlen;			/* 1 */
+	int *auth_flavours;		/* 1 */
+};
+
+/* bits in the flags field */
+/* Note: the fields that correspond to existing NFSv2/v3 mount options
+ * 	 should mirror the values from include/linux/nfs_mount.h
+ */
+
+#define NFS4_MOUNT_SOFT		0x0001	/* 1 */
+#define NFS4_MOUNT_INTR		0x0002	/* 1 */
+#define NFS4_MOUNT_NOCTO	0x0010	/* 1 */
+#define NFS4_MOUNT_NOAC		0x0020	/* 1 */
+#define NFS4_MOUNT_STRICTLOCK	0x1000	/* 1 */
+#define NFS4_MOUNT_UNSHARED	0x8000	/* 1 */
+#define NFS4_MOUNT_FLAGMASK	0x9033
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/nfsacl.h clean_modified/linux-2.6.32/usr/include/linux/nfsacl.h
--- linux-2.6.32/usr/include/linux/nfsacl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsacl.h	2019-04-14 13:24:03.088860603 -0500
@@ -0,0 +1,29 @@
+/*
+ * File: linux/nfsacl.h
+ *
+ * (C) 2003 Andreas Gruenbacher <agruen@suse.de>
+ */
+#ifndef __LINUX_NFSACL_H
+#define __LINUX_NFSACL_H
+
+#define NFS_ACL_PROGRAM	100227
+
+#define ACLPROC2_GETACL		1
+#define ACLPROC2_SETACL		2
+#define ACLPROC2_GETATTR	3
+#define ACLPROC2_ACCESS		4
+
+#define ACLPROC3_GETACL		1
+#define ACLPROC3_SETACL		2
+
+
+/* Flags for the getacl/setacl mode */
+#define NFS_ACL			0x0001
+#define NFS_ACLCNT		0x0002
+#define NFS_DFACL		0x0004
+#define NFS_DFACLCNT		0x0008
+
+/* Flag for Default ACL entries */
+#define NFS_ACL_DEFAULT		0x1000
+
+#endif  /* __LINUX_NFSACL_H */
diff -uNr linux-2.6.32/usr/include/linux/nfsd/const.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/const.h
--- linux-2.6.32/usr/include/linux/nfsd/const.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/const.h	2019-04-14 13:24:03.088860603 -0500
@@ -0,0 +1,30 @@
+/*
+ * include/linux/nfsd/const.h
+ *
+ * Various constants related to NFS.
+ *
+ * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef _LINUX_NFSD_CONST_H
+#define _LINUX_NFSD_CONST_H
+
+#include <linux/nfs.h>
+#include <linux/nfs2.h>
+#include <linux/nfs3.h>
+#include <linux/nfs4.h>
+
+/*
+ * Maximum protocol version supported by knfsd
+ */
+#define NFSSVC_MAXVERS		3
+
+/*
+ * Maximum blocksizes supported by daemon under various circumstances.
+ */
+#define NFSSVC_MAXBLKSIZE	RPCSVC_MAXPAYLOAD
+/* NFSv2 is limited by the protocol specification, see RFC 1094 */
+#define NFSSVC_MAXBLKSIZE_V2	(8*1024)
+
+
+#endif /* _LINUX_NFSD_CONST_H */
diff -uNr linux-2.6.32/usr/include/linux/nfsd/debug.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/debug.h
--- linux-2.6.32/usr/include/linux/nfsd/debug.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/debug.h	2019-04-14 13:24:03.089828944 -0500
@@ -0,0 +1,40 @@
+/*
+ * linux/include/linux/nfsd/debug.h
+ *
+ * Debugging-related stuff for nfsd
+ *
+ * Copyright (C) 1995 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef LINUX_NFSD_DEBUG_H
+#define LINUX_NFSD_DEBUG_H
+
+#include <linux/sunrpc/debug.h>
+
+/*
+ * Enable debugging for nfsd.
+ * Requires RPC_DEBUG.
+ */
+#ifdef RPC_DEBUG
+# define NFSD_DEBUG		1
+#endif
+
+/*
+ * knfsd debug flags
+ */
+#define NFSDDBG_SOCK		0x0001
+#define NFSDDBG_FH		0x0002
+#define NFSDDBG_EXPORT		0x0004
+#define NFSDDBG_SVC		0x0008
+#define NFSDDBG_PROC		0x0010
+#define NFSDDBG_FILEOP		0x0020
+#define NFSDDBG_AUTH		0x0040
+#define NFSDDBG_REPCACHE	0x0080
+#define NFSDDBG_XDR		0x0100
+#define NFSDDBG_LOCKD		0x0200
+#define NFSDDBG_ALL		0x7FFF
+#define NFSDDBG_NOCHANGE	0xFFFF
+
+
+
+#endif /* LINUX_NFSD_DEBUG_H */
diff -uNr linux-2.6.32/usr/include/linux/nfsd/export.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/export.h
--- linux-2.6.32/usr/include/linux/nfsd/export.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/export.h	2019-04-14 13:24:03.089828944 -0500
@@ -0,0 +1,47 @@
+/*
+ * include/linux/nfsd/export.h
+ * 
+ * Public declarations for NFS exports. The definitions for the
+ * syscall interface are in nfsctl.h
+ *
+ * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef NFSD_EXPORT_H
+#define NFSD_EXPORT_H
+
+# include <linux/types.h>
+
+/*
+ * Important limits for the exports stuff.
+ */
+#define NFSCLNT_IDMAX		1024
+#define NFSCLNT_ADDRMAX		16
+#define NFSCLNT_KEYMAX		32
+
+/*
+ * Export flags.
+ */
+#define NFSEXP_READONLY		0x0001
+#define NFSEXP_INSECURE_PORT	0x0002
+#define NFSEXP_ROOTSQUASH	0x0004
+#define NFSEXP_ALLSQUASH	0x0008
+#define NFSEXP_ASYNC		0x0010
+#define NFSEXP_GATHERED_WRITES	0x0020
+/* 40 80 100 currently unused */
+#define NFSEXP_NOHIDE		0x0200
+#define NFSEXP_NOSUBTREECHECK	0x0400
+#define	NFSEXP_NOAUTHNLM	0x0800		/* Don't authenticate NLM requests - just trust */
+#define NFSEXP_MSNFS		0x1000	/* do silly things that MS clients expect */
+#define NFSEXP_FSID		0x2000
+#define	NFSEXP_CROSSMOUNT	0x4000
+#define	NFSEXP_NOACL		0x8000	/* reserved for possible ACL related use */
+#define NFSEXP_ALLFLAGS		0xFE3F
+
+/* The flags that may vary depending on security flavor: */
+#define NFSEXP_SECINFO_FLAGS	(NFSEXP_READONLY | NFSEXP_ROOTSQUASH \
+					| NFSEXP_ALLSQUASH)
+
+
+#endif /* NFSD_EXPORT_H */
+
diff -uNr linux-2.6.32/usr/include/linux/nfsd/nfsfh.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/nfsfh.h
--- linux-2.6.32/usr/include/linux/nfsd/nfsfh.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/nfsfh.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,120 @@
+/*
+ * include/linux/nfsd/nfsfh.h
+ *
+ * This file describes the layout of the file handles as passed
+ * over the wire.
+ *
+ * Earlier versions of knfsd used to sign file handles using keyed MD5
+ * or SHA. I've removed this code, because it doesn't give you more
+ * security than blocking external access to port 2049 on your firewall.
+ *
+ * Copyright (C) 1995, 1996, 1997 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef _LINUX_NFSD_FH_H
+#define _LINUX_NFSD_FH_H
+
+# include <linux/types.h>
+#include <linux/nfsd/const.h>
+#include <linux/nfsd/debug.h>
+
+/*
+ * This is the old "dentry style" Linux NFSv2 file handle.
+ *
+ * The xino and xdev fields are currently used to transport the
+ * ino/dev of the exported inode.
+ */
+struct nfs_fhbase_old {
+	__u32		fb_dcookie;	/* dentry cookie - always 0xfeebbaca */
+	__u32		fb_ino;		/* our inode number */
+	__u32		fb_dirino;	/* dir inode number, 0 for directories */
+	__u32		fb_dev;		/* our device */
+	__u32		fb_xdev;
+	__u32		fb_xino;
+	__u32		fb_generation;
+};
+
+/*
+ * This is the new flexible, extensible style NFSv2/v3 file handle.
+ * by Neil Brown <neilb@cse.unsw.edu.au> - March 2000
+ *
+ * The file handle is seens as a list of 4byte words.
+ * The first word contains a version number (1) and four descriptor bytes
+ * that tell how the remaining 3 variable length fields should be handled.
+ * These three bytes are auth_type, fsid_type and fileid_type.
+ *
+ * All 4byte values are in host-byte-order.
+ *
+ * The auth_type field specifies how the filehandle can be authenticated
+ * This might allow a file to be confirmed to be in a writable part of a
+ * filetree without checking the path from it upto the root.
+ * Current values:
+ *     0  - No authentication.  fb_auth is 0 bytes long
+ * Possible future values:
+ *     1  - 4 bytes taken from MD5 hash of the remainer of the file handle
+ *          prefixed by a secret and with the important export flags.
+ *
+ * The fsid_type identifies how the filesystem (or export point) is
+ *    encoded.
+ *  Current values:
+ *     0  - 4 byte device id (ms-2-bytes major, ls-2-bytes minor), 4byte inode number
+ *        NOTE: we cannot use the kdev_t device id value, because kdev_t.h
+ *              says we mustn't.  We must break it up and reassemble.
+ *     1  - 4 byte user specified identifier
+ *     2  - 4 byte major, 4 byte minor, 4 byte inode number - DEPRECATED
+ *     3  - 4 byte device id, encoded for user-space, 4 byte inode number
+ *     4  - 4 byte inode number and 4 byte uuid
+ *     5  - 8 byte uuid
+ *     6  - 16 byte uuid
+ *     7  - 8 byte inode number and 16 byte uuid
+ *
+ * The fileid_type identified how the file within the filesystem is encoded.
+ * This is (will be) passed to, and set by, the underlying filesystem if it supports
+ * filehandle operations.  The filesystem must not use the value '0' or '0xff' and may
+ * only use the values 1 and 2 as defined below:
+ *  Current values:
+ *    0   - The root, or export point, of the filesystem.  fb_fileid is 0 bytes.
+ *    1   - 32bit inode number, 32 bit generation number.
+ *    2   - 32bit inode number, 32 bit generation number, 32 bit parent directory inode number.
+ *
+ */
+struct nfs_fhbase_new {
+	__u8		fb_version;	/* == 1, even => nfs_fhbase_old */
+	__u8		fb_auth_type;
+	__u8		fb_fsid_type;
+	__u8		fb_fileid_type;
+	__u32		fb_auth[1];
+/*	__u32		fb_fsid[0]; floating */
+/*	__u32		fb_fileid[0]; floating */
+};
+
+struct knfsd_fh {
+	unsigned int	fh_size;	/* significant for NFSv3.
+					 * Points to the current size while building
+					 * a new file handle
+					 */
+	union {
+		struct nfs_fhbase_old	fh_old;
+		__u32			fh_pad[NFS4_FHSIZE/4];
+		struct nfs_fhbase_new	fh_new;
+	} fh_base;
+};
+
+#define ofh_dcookie		fh_base.fh_old.fb_dcookie
+#define ofh_ino			fh_base.fh_old.fb_ino
+#define ofh_dirino		fh_base.fh_old.fb_dirino
+#define ofh_dev			fh_base.fh_old.fb_dev
+#define ofh_xdev		fh_base.fh_old.fb_xdev
+#define ofh_xino		fh_base.fh_old.fb_xino
+#define ofh_generation		fh_base.fh_old.fb_generation
+
+#define	fh_version		fh_base.fh_new.fb_version
+#define	fh_fsid_type		fh_base.fh_new.fb_fsid_type
+#define	fh_auth_type		fh_base.fh_new.fb_auth_type
+#define	fh_fileid_type		fh_base.fh_new.fb_fileid_type
+#define	fh_auth			fh_base.fh_new.fb_auth
+#define	fh_fsid			fh_base.fh_new.fb_auth
+
+
+
+#endif /* _LINUX_NFSD_FH_H */
diff -uNr linux-2.6.32/usr/include/linux/nfsd/stats.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/stats.h
--- linux-2.6.32/usr/include/linux/nfsd/stats.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/stats.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,17 @@
+/*
+ * linux/include/linux/nfsd/stats.h
+ *
+ * Statistics for NFS server.
+ *
+ * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef LINUX_NFSD_STATS_H
+#define LINUX_NFSD_STATS_H
+
+#include <linux/nfs4.h>
+
+/* thread usage wraps very million seconds (approx one fortnight) */
+#define	NFSD_USAGE_WRAP	(HZ*1000000)
+
+#endif /* LINUX_NFSD_STATS_H */
diff -uNr linux-2.6.32/usr/include/linux/nfsd/syscall.h clean_modified/linux-2.6.32/usr/include/linux/nfsd/syscall.h
--- linux-2.6.32/usr/include/linux/nfsd/syscall.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfsd/syscall.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,109 @@
+/*
+ * include/linux/nfsd/syscall.h
+ *
+ * This file holds all declarations for the knfsd syscall interface.
+ *
+ * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef NFSD_SYSCALL_H
+#define NFSD_SYSCALL_H
+
+# include <linux/types.h>
+#include <linux/posix_types.h>
+#include <linux/nfsd/const.h>
+#include <linux/nfsd/export.h>
+#include <linux/nfsd/nfsfh.h>
+
+/*
+ * Version of the syscall interface
+ */
+#define NFSCTL_VERSION		0x0201
+
+/*
+ * These are the commands understood by nfsctl().
+ */
+#define NFSCTL_SVC		0	/* This is a server process. */
+#define NFSCTL_ADDCLIENT	1	/* Add an NFS client. */
+#define NFSCTL_DELCLIENT	2	/* Remove an NFS client. */
+#define NFSCTL_EXPORT		3	/* export a file system. */
+#define NFSCTL_UNEXPORT		4	/* unexport a file system. */
+/*#define NFSCTL_UGIDUPDATE	5	/ * update a client's uid/gid map. DISCARDED */
+/*#define NFSCTL_GETFH		6	/ * get an fh by ino DISCARDED */
+#define NFSCTL_GETFD		7	/* get an fh by path (used by mountd) */
+#define	NFSCTL_GETFS		8	/* get an fh by path with max FH len */
+
+/* SVC */
+struct nfsctl_svc {
+	unsigned short		svc_port;
+	int			svc_nthreads;
+};
+
+/* ADDCLIENT/DELCLIENT */
+struct nfsctl_client {
+	char			cl_ident[NFSCLNT_IDMAX+1];
+	int			cl_naddr;
+	struct in_addr		cl_addrlist[NFSCLNT_ADDRMAX];
+	int			cl_fhkeytype;
+	int			cl_fhkeylen;
+	unsigned char		cl_fhkey[NFSCLNT_KEYMAX];
+};
+
+/* EXPORT/UNEXPORT */
+struct nfsctl_export {
+	char			ex_client[NFSCLNT_IDMAX+1];
+	char			ex_path[NFS_MAXPATHLEN+1];
+	__kernel_old_dev_t	ex_dev;
+	__kernel_ino_t		ex_ino;
+	int			ex_flags;
+	__kernel_uid_t		ex_anon_uid;
+	__kernel_gid_t		ex_anon_gid;
+};
+
+/* GETFD */
+struct nfsctl_fdparm {
+	struct sockaddr		gd_addr;
+	char			gd_path[NFS_MAXPATHLEN+1];
+	int			gd_version;
+};
+
+/* GETFS - GET Filehandle with Size */
+struct nfsctl_fsparm {
+	struct sockaddr		gd_addr;
+	char			gd_path[NFS_MAXPATHLEN+1];
+	int			gd_maxlen;
+};
+
+/*
+ * This is the argument union.
+ */
+struct nfsctl_arg {
+	int			ca_version;	/* safeguard */
+	union {
+		struct nfsctl_svc	u_svc;
+		struct nfsctl_client	u_client;
+		struct nfsctl_export	u_export;
+		struct nfsctl_fdparm	u_getfd;
+		struct nfsctl_fsparm	u_getfs;
+		/*
+		 * The following dummy member is needed to preserve binary compatibility
+		 * on platforms where alignof(void*)>alignof(int).  It's needed because
+		 * this union used to contain a member (u_umap) which contained a
+		 * pointer.
+		 */
+		void *u_ptr;
+	} u;
+#define ca_svc		u.u_svc
+#define ca_client	u.u_client
+#define ca_export	u.u_export
+#define ca_getfd	u.u_getfd
+#define	ca_getfs	u.u_getfs
+};
+
+union nfsctl_res {
+	__u8			cr_getfh[NFS_FHSIZE];
+	struct knfsd_fh		cr_getfs;
+};
+
+
+#endif /* NFSD_SYSCALL_H */
diff -uNr linux-2.6.32/usr/include/linux/nfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/nfs_fs.h
--- linux-2.6.32/usr/include/linux/nfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs_fs.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,59 @@
+/*
+ *  linux/include/linux/nfs_fs.h
+ *
+ *  Copyright (C) 1992  Rick Sladkey
+ *
+ *  OS-specific nfs filesystem definitions and declarations
+ */
+
+#ifndef _LINUX_NFS_FS_H
+#define _LINUX_NFS_FS_H
+
+#include <linux/magic.h>
+
+/* Default timeout values */
+#define NFS_DEF_UDP_TIMEO	(11)
+#define NFS_DEF_UDP_RETRANS	(3)
+#define NFS_DEF_TCP_TIMEO	(600)
+#define NFS_DEF_TCP_RETRANS	(2)
+
+#define NFS_MAX_UDP_TIMEOUT	(60*HZ)
+#define NFS_MAX_TCP_TIMEOUT	(600*HZ)
+
+#define NFS_DEF_ACREGMIN	(3)
+#define NFS_DEF_ACREGMAX	(60)
+#define NFS_DEF_ACDIRMIN	(30)
+#define NFS_DEF_ACDIRMAX	(60)
+
+/*
+ * When flushing a cluster of dirty pages, there can be different
+ * strategies:
+ */
+#define FLUSH_SYNC		1	/* file being synced, or contention */
+#define FLUSH_STABLE		4	/* commit to stable storage */
+#define FLUSH_LOWPRI		8	/* low priority background flush */
+#define FLUSH_HIGHPRI		16	/* high priority memory reclaim flush */
+#define FLUSH_NOCOMMIT		32	/* Don't send the NFSv3/v4 COMMIT */
+#define FLUSH_INVALIDATE	64	/* Invalidate the page cache */
+#define FLUSH_NOWRITEPAGE	128	/* Don't call writepage() */
+
+
+/*
+ * NFS debug flags
+ */
+#define NFSDBG_VFS		0x0001
+#define NFSDBG_DIRCACHE		0x0002
+#define NFSDBG_LOOKUPCACHE	0x0004
+#define NFSDBG_PAGECACHE	0x0008
+#define NFSDBG_PROC		0x0010
+#define NFSDBG_XDR		0x0020
+#define NFSDBG_FILE		0x0040
+#define NFSDBG_ROOT		0x0080
+#define NFSDBG_CALLBACK		0x0100
+#define NFSDBG_CLIENT		0x0200
+#define NFSDBG_MOUNT		0x0400
+#define NFSDBG_FSCACHE		0x0800
+#define NFSDBG_ALL		0xFFFF
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/nfs.h clean_modified/linux-2.6.32/usr/include/linux/nfs.h
--- linux-2.6.32/usr/include/linux/nfs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,129 @@
+/*
+ * NFS protocol definitions
+ *
+ * This file contains constants mostly for Version 2 of the protocol,
+ * but also has a couple of NFSv3 bits in (notably the error codes).
+ */
+#ifndef _LINUX_NFS_H
+#define _LINUX_NFS_H
+
+#define NFS_PROGRAM	100003
+#define NFS_PORT	2049
+#define NFS_MAXDATA	8192
+#define NFS_MAXPATHLEN	1024
+#define NFS_MAXNAMLEN	255
+#define NFS_MAXGROUPS	16
+#define NFS_FHSIZE	32
+#define NFS_COOKIESIZE	4
+#define NFS_FIFO_DEV	(-1)
+#define NFSMODE_FMT	0170000
+#define NFSMODE_DIR	0040000
+#define NFSMODE_CHR	0020000
+#define NFSMODE_BLK	0060000
+#define NFSMODE_REG	0100000
+#define NFSMODE_LNK	0120000
+#define NFSMODE_SOCK	0140000
+#define NFSMODE_FIFO	0010000
+
+#define NFS_MNT_PROGRAM		100005
+#define NFS_MNT_VERSION		1
+#define NFS_MNT3_VERSION	3
+
+/*
+ * NFS stats. The good thing with these values is that NFSv3 errors are
+ * a superset of NFSv2 errors (with the exception of NFSERR_WFLUSH which
+ * no-one uses anyway), so we can happily mix code as long as we make sure
+ * no NFSv3 errors are returned to NFSv2 clients.
+ * Error codes that have a `--' in the v2 column are not part of the
+ * standard, but seem to be widely used nevertheless.
+ */
+ enum nfs_stat {
+	NFS_OK = 0,			/* v2 v3 v4 */
+	NFSERR_PERM = 1,		/* v2 v3 v4 */
+	NFSERR_NOENT = 2,		/* v2 v3 v4 */
+	NFSERR_IO = 5,			/* v2 v3 v4 */
+	NFSERR_NXIO = 6,		/* v2 v3 v4 */
+	NFSERR_EAGAIN = 11,		/* v2 v3 */
+	NFSERR_ACCES = 13,		/* v2 v3 v4 */
+	NFSERR_EXIST = 17,		/* v2 v3 v4 */
+	NFSERR_XDEV = 18,		/*    v3 v4 */
+	NFSERR_NODEV = 19,		/* v2 v3 v4 */
+	NFSERR_NOTDIR = 20,		/* v2 v3 v4 */
+	NFSERR_ISDIR = 21,		/* v2 v3 v4 */
+	NFSERR_INVAL = 22,		/* v2 v3 v4 */
+	NFSERR_FBIG = 27,		/* v2 v3 v4 */
+	NFSERR_NOSPC = 28,		/* v2 v3 v4 */
+	NFSERR_ROFS = 30,		/* v2 v3 v4 */
+	NFSERR_MLINK = 31,		/*    v3 v4 */
+	NFSERR_OPNOTSUPP = 45,		/* v2 v3 */
+	NFSERR_NAMETOOLONG = 63,	/* v2 v3 v4 */
+	NFSERR_NOTEMPTY = 66,		/* v2 v3 v4 */
+	NFSERR_DQUOT = 69,		/* v2 v3 v4 */
+	NFSERR_STALE = 70,		/* v2 v3 v4 */
+	NFSERR_REMOTE = 71,		/* v2 v3 */
+	NFSERR_WFLUSH = 99,		/* v2    */
+	NFSERR_BADHANDLE = 10001,	/*    v3 v4 */
+	NFSERR_NOT_SYNC = 10002,	/*    v3 */
+	NFSERR_BAD_COOKIE = 10003,	/*    v3 v4 */
+	NFSERR_NOTSUPP = 10004,		/*    v3 v4 */
+	NFSERR_TOOSMALL = 10005,	/*    v3 v4 */
+	NFSERR_SERVERFAULT = 10006,	/*    v3 v4 */
+	NFSERR_BADTYPE = 10007,		/*    v3 v4 */
+	NFSERR_JUKEBOX = 10008,		/*    v3 v4 */
+	NFSERR_SAME = 10009,		/*       v4 */
+	NFSERR_DENIED = 10010,		/*       v4 */
+	NFSERR_EXPIRED = 10011,		/*       v4 */
+	NFSERR_LOCKED = 10012,		/*       v4 */
+	NFSERR_GRACE = 10013,		/*       v4 */
+	NFSERR_FHEXPIRED = 10014,	/*       v4 */
+	NFSERR_SHARE_DENIED = 10015,	/*       v4 */
+	NFSERR_WRONGSEC = 10016,	/*       v4 */
+	NFSERR_CLID_INUSE = 10017,	/*       v4 */
+	NFSERR_RESOURCE = 10018,	/*       v4 */
+	NFSERR_MOVED = 10019,		/*       v4 */
+	NFSERR_NOFILEHANDLE = 10020,	/*       v4 */
+	NFSERR_MINOR_VERS_MISMATCH = 10021,   /* v4 */
+	NFSERR_STALE_CLIENTID = 10022,	/*       v4 */
+	NFSERR_STALE_STATEID = 10023,   /*       v4 */
+	NFSERR_OLD_STATEID = 10024,     /*       v4 */
+	NFSERR_BAD_STATEID = 10025,     /*       v4 */  
+	NFSERR_BAD_SEQID = 10026,	/*       v4 */
+	NFSERR_NOT_SAME = 10027,	/*       v4 */
+	NFSERR_LOCK_RANGE = 10028,	/*       v4 */
+	NFSERR_SYMLINK = 10029,		/*       v4 */
+	NFSERR_RESTOREFH = 10030,	/*       v4 */
+	NFSERR_LEASE_MOVED = 10031,	/*       v4 */
+	NFSERR_ATTRNOTSUPP = 10032,	/*       v4 */
+	NFSERR_NO_GRACE = 10033,	/*       v4 */
+	NFSERR_RECLAIM_BAD = 10034,	/*       v4 */
+	NFSERR_RECLAIM_CONFLICT = 10035,/*       v4 */
+	NFSERR_BAD_XDR = 10036,		/*       v4 */
+	NFSERR_LOCKS_HELD = 10037,	/*       v4 */
+	NFSERR_OPENMODE = 10038,       /*       v4 */
+	NFSERR_BADOWNER = 10039,       /*       v4 */
+	NFSERR_BADCHAR = 10040,        /*       v4 */
+	NFSERR_BADNAME = 10041,        /*       v4 */
+	NFSERR_BAD_RANGE = 10042,      /*       v4 */
+	NFSERR_LOCK_NOTSUPP = 10043,   /*       v4 */
+	NFSERR_OP_ILLEGAL = 10044,     /*       v4 */
+	NFSERR_DEADLOCK = 10045,       /*       v4 */
+	NFSERR_FILE_OPEN = 10046,      /*       v4 */
+	NFSERR_ADMIN_REVOKED = 10047,  /*       v4 */
+	NFSERR_CB_PATH_DOWN = 10048,   /*       v4 */
+};
+
+/* NFSv2 file types - beware, these are not the same in NFSv3 */
+
+enum nfs_ftype {
+	NFNON = 0,
+	NFREG = 1,
+	NFDIR = 2,
+	NFBLK = 3,
+	NFCHR = 4,
+	NFLNK = 5,
+	NFSOCK = 6,
+	NFBAD = 7,
+	NFFIFO = 8
+};
+
+#endif /* _LINUX_NFS_H */
diff -uNr linux-2.6.32/usr/include/linux/nfs_idmap.h clean_modified/linux-2.6.32/usr/include/linux/nfs_idmap.h
--- linux-2.6.32/usr/include/linux/nfs_idmap.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs_idmap.h	2019-04-14 13:24:03.090783561 -0500
@@ -0,0 +1,65 @@
+/*
+ * include/linux/nfs_idmap.h
+ *
+ *  UID and GID to name mapping for clients.
+ *
+ *  Copyright (c) 2002 The Regents of the University of Michigan.
+ *  All rights reserved.
+ *
+ *  Marius Aamodt Eriksen <marius@umich.edu>
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the University nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef NFS_IDMAP_H
+#define NFS_IDMAP_H
+
+#include <linux/types.h>
+
+/* XXX from bits/utmp.h  */
+#define IDMAP_NAMESZ  128
+
+#define IDMAP_TYPE_USER  0
+#define IDMAP_TYPE_GROUP 1
+
+#define IDMAP_CONV_IDTONAME 0
+#define IDMAP_CONV_NAMETOID 1
+
+#define IDMAP_STATUS_INVALIDMSG 0x01
+#define IDMAP_STATUS_AGAIN      0x02
+#define IDMAP_STATUS_LOOKUPFAIL 0x04
+#define IDMAP_STATUS_SUCCESS    0x08
+
+struct idmap_msg {
+	__u8  im_type;
+	__u8  im_conv;
+	char  im_name[IDMAP_NAMESZ];
+	__u32 im_id;
+	__u8  im_status;
+};
+
+
+#endif /* NFS_IDMAP_H */
diff -uNr linux-2.6.32/usr/include/linux/nfs_mount.h clean_modified/linux-2.6.32/usr/include/linux/nfs_mount.h
--- linux-2.6.32/usr/include/linux/nfs_mount.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nfs_mount.h	2019-04-14 13:24:03.092738354 -0500
@@ -0,0 +1,73 @@
+#ifndef _LINUX_NFS_MOUNT_H
+#define _LINUX_NFS_MOUNT_H
+
+/*
+ *  linux/include/linux/nfs_mount.h
+ *
+ *  Copyright (C) 1992  Rick Sladkey
+ *
+ *  structure passed from user-space to kernel-space during an nfs mount
+ */
+#include <linux/in.h>
+#include <linux/nfs.h>
+#include <linux/nfs2.h>
+#include <linux/nfs3.h>
+
+/*
+ * WARNING!  Do not delete or change the order of these fields.  If
+ * a new field is required then add it to the end.  The version field
+ * tracks which fields are present.  This will ensure some measure of
+ * mount-to-kernel version compatibility.  Some of these aren't used yet
+ * but here they are anyway.
+ */
+#define NFS_MOUNT_VERSION	6
+#define NFS_MAX_CONTEXT_LEN	256
+
+struct nfs_mount_data {
+	int		version;		/* 1 */
+	int		fd;			/* 1 */
+	struct nfs2_fh	old_root;		/* 1 */
+	int		flags;			/* 1 */
+	int		rsize;			/* 1 */
+	int		wsize;			/* 1 */
+	int		timeo;			/* 1 */
+	int		retrans;		/* 1 */
+	int		acregmin;		/* 1 */
+	int		acregmax;		/* 1 */
+	int		acdirmin;		/* 1 */
+	int		acdirmax;		/* 1 */
+	struct sockaddr_in addr;		/* 1 */
+	char		hostname[NFS_MAXNAMLEN + 1];		/* 1 */
+	int		namlen;			/* 2 */
+	unsigned int	bsize;			/* 3 */
+	struct nfs3_fh	root;			/* 4 */
+	int		pseudoflavor;		/* 5 */
+	char		context[NFS_MAX_CONTEXT_LEN + 1];	/* 6 */
+};
+
+/* bits in the flags field visible to user space */
+
+#define NFS_MOUNT_SOFT		0x0001	/* 1 */
+#define NFS_MOUNT_INTR		0x0002	/* 1 */ /* now unused, but ABI */
+#define NFS_MOUNT_SECURE	0x0004	/* 1 */
+#define NFS_MOUNT_POSIX		0x0008	/* 1 */
+#define NFS_MOUNT_NOCTO		0x0010	/* 1 */
+#define NFS_MOUNT_NOAC		0x0020	/* 1 */
+#define NFS_MOUNT_TCP		0x0040	/* 2 */
+#define NFS_MOUNT_VER3		0x0080	/* 3 */
+#define NFS_MOUNT_KERBEROS	0x0100	/* 3 */
+#define NFS_MOUNT_NONLM		0x0200	/* 3 */
+#define NFS_MOUNT_BROKEN_SUID	0x0400	/* 4 */
+#define NFS_MOUNT_NOACL		0x0800	/* 4 */
+#define NFS_MOUNT_STRICTLOCK	0x1000	/* reserved for NFSv4 */
+#define NFS_MOUNT_SECFLAVOUR	0x2000	/* 5 */
+#define NFS_MOUNT_NORDIRPLUS	0x4000	/* 5 */
+#define NFS_MOUNT_UNSHARED	0x8000	/* 5 */
+#define NFS_MOUNT_FLAGMASK	0xFFFF
+
+/* The following are for internal use only */
+#define NFS_MOUNT_LOOKUP_CACHE_NONEG	0x10000
+#define NFS_MOUNT_LOOKUP_CACHE_NONE	0x20000
+#define NFS_MOUNT_NORESVPORT		0x40000
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/nl80211.h clean_modified/linux-2.6.32/usr/include/linux/nl80211.h
--- linux-2.6.32/usr/include/linux/nl80211.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nl80211.h	2019-04-14 13:24:03.094681911 -0500
@@ -0,0 +1,1391 @@
+#ifndef __LINUX_NL80211_H
+#define __LINUX_NL80211_H
+/*
+ * 802.11 netlink interface public header
+ *
+ * Copyright 2006, 2007, 2008 Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
+ * Copyright 2008 Michael Buesch <mb@bu3sch.de>
+ * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
+ * Copyright 2008 Colin McCabe <colin@cozybit.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/types.h>
+
+/**
+ * DOC: Station handling
+ *
+ * Stations are added per interface, but a special case exists with VLAN
+ * interfaces. When a station is bound to an AP interface, it may be moved
+ * into a VLAN identified by a VLAN interface index (%NL80211_ATTR_STA_VLAN).
+ * The station is still assumed to belong to the AP interface it was added
+ * to.
+ *
+ * TODO: need more info?
+ */
+
+/**
+ * enum nl80211_commands - supported nl80211 commands
+ *
+ * @NL80211_CMD_UNSPEC: unspecified command to catch errors
+ *
+ * @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request
+ *	to get a list of all present wiphys.
+ * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
+ *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE, %NL80211_ATTR_WIPHY_RETRY_SHORT,
+ *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+ *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
+ * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
+ *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
+ *	%NL80211_ATTR_WIPHY_NAME.
+ * @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME.
+ *
+ * @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;
+ *	either a dump request on a %NL80211_ATTR_WIPHY or a specific get
+ *	on an %NL80211_ATTR_IFINDEX is supported.
+ * @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE.
+ * @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response
+ *	to %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also
+ *	be sent from userspace to request creation of a new virtual interface,
+ *	then requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and
+ *	%NL80211_ATTR_IFNAME.
+ * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
+ *	userspace to request deletion of a virtual interface, then requires
+ *	attribute %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
+ *	by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
+ * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
+ *	%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
+ * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
+ *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
+ *	and %NL80211_ATTR_KEY_SEQ attributes.
+ * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
+ *	or %NL80211_ATTR_MAC.
+ *
+ * @NL80211_CMD_GET_BEACON: retrieve beacon information (returned in a
+ *	%NL80222_CMD_NEW_BEACON message)
+ * @NL80211_CMD_SET_BEACON: set the beacon on an access point interface
+ *	using the %NL80211_ATTR_BEACON_INTERVAL, %NL80211_ATTR_DTIM_PERIOD,
+ *	%NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL attributes.
+ * @NL80211_CMD_NEW_BEACON: add a new beacon to an access point interface,
+ *	parameters are like for %NL80211_CMD_SET_BEACON.
+ * @NL80211_CMD_DEL_BEACON: remove the beacon, stop sending it
+ *
+ * @NL80211_CMD_GET_STATION: Get station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all stations, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all mesh paths, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
+ * 	regulatory domain.
+ * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
+ *	after being queried by the kernel. CRDA replies by sending a regulatory
+ *	domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
+ *	current alpha2 if it found a match. It also provides
+ * 	NL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each
+ * 	regulatory rule is a nested set of attributes  given by
+ * 	%NL80211_ATTR_REG_RULE_FREQ_[START|END] and
+ * 	%NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_EIRP.
+ * @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain
+ * 	to the the specified ISO/IEC 3166-1 alpha2 country code. The core will
+ * 	store this as a valid request and then query userspace for it.
+ *
+ * @NL80211_CMD_GET_MESH_PARAMS: Get mesh networking properties for the
+ *	interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MESH_PARAMS: Set mesh networking properties for the
+ *      interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
+ *	interface is identified with %NL80211_ATTR_IFINDEX and the management
+ *	frame subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be
+ *	added to the end of the specified management frame is specified with
+ *	%NL80211_ATTR_IE. If the command succeeds, the requested data will be
+ *	added to all specified management frames generated by
+ *	kernel/firmware/driver.
+ *	Note: This command has been removed and it is only reserved at this
+ *	point to avoid re-using existing command number. The functionality this
+ *	command was planned for has been provided with cleaner design with the
+ *	option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
+ *	NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_CMD_GET_SCAN: get scan results
+ * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
+ *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
+ * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
+ *	partial scan results may be available
+ *
+ * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
+ * 	has been changed and provides details of the request information
+ * 	that caused the change such as who initiated the regulatory request
+ * 	(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
+ * 	(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
+ * 	the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
+ * 	%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
+ * 	set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
+ * 	%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
+ * 	to (%NL80211_ATTR_REG_ALPHA2).
+ * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
+ * 	has been found while world roaming thus enabling active scan or
+ * 	any mode of operation that initiates TX (beacons) on a channel
+ * 	where we would not have been able to do either before. As an example
+ * 	if you are world roaming (regulatory domain set to world or if your
+ * 	driver is using a custom world roaming regulatory domain) and while
+ * 	doing a passive scan on the 5 GHz band you find an AP there (if not
+ * 	on a DFS channel) you will now be able to actively scan for that AP
+ * 	or use AP mode on your card on that same channel. Note that this will
+ * 	never be used for channels 1-11 on the 2 GHz band as they are always
+ * 	enabled world wide. This beacon hint is only sent if your device had
+ * 	either disabled active scanning or beaconing on a channel. We send to
+ * 	userspace the wiphy on which we removed a restriction from
+ * 	(%NL80211_ATTR_WIPHY) and the channel on which this occurred
+ * 	before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
+ * 	the beacon hint was processed.
+ *
+ * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
+ *	This command is used both as a command (request to authenticate) and
+ *	as an event on the "mlme" multicast group indicating completion of the
+ *	authentication process.
+ *	When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
+ *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
+ *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
+ *	the SSID (mainly for association, but is included in authentication
+ *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
+ *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
+ *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
+ *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
+ *	to be added to the frame.
+ *	When used as an event, this reports reception of an Authentication
+ *	frame in station and IBSS modes when the local MLME processed the
+ *	frame, i.e., it was for the local STA and was received in correct
+ *	state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
+ *	MLME SAP interface (kernel providing MLME, userspace SME). The
+ *	included %NL80211_ATTR_FRAME attribute contains the management frame
+ *	(including both the header and frame body, but not FCS). This event is
+ *	also used to indicate if the authentication attempt timed out. In that
+ *	case the %NL80211_ATTR_FRAME attribute is replaced with a
+ *	%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
+ *	pending authentication timed out).
+ * @NL80211_CMD_ASSOCIATE: association request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Association and Reassociation
+ *	(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
+ *	MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives).
+ * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
+ *	MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
+ *	primitives).
+ * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
+ *	MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
+ *
+ * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
+ *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
+ *	event includes %NL80211_ATTR_MAC to describe the source MAC address of
+ *	the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
+ *	type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
+ *	%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
+ *	event matches with MLME-MICHAELMICFAILURE.indication() primitive
+ *
+ * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
+ *	FREQ attribute (for the initial frequency if no peer can be found)
+ *	and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
+ *	should be fixed rather than automatically determined. Can only be
+ *	executed on a network interface that is UP, and fixed BSSID/FREQ
+ *	may be rejected. Another optional parameter is the beacon interval,
+ *	given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
+ *	given defaults to 100 TU (102.4ms).
+ * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
+ *	determined by the network interface.
+ *
+ * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
+ *	to identify the device, and the TESTDATA blob attribute to pass through
+ *	to the driver.
+ *
+ * @NL80211_CMD_CONNECT: connection request and notification; this command
+ *	requests to connect to a specified network but without separating
+ *	auth and assoc steps. For this, you need to specify the SSID in a
+ *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_MAC,
+ *	%NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_CONTROL_PORT.
+ *	It is also sent as an event, with the BSSID and response IEs when the
+ *	connection is established or failed to be established. This can be
+ *	determined by the STATUS_CODE attribute.
+ * @NL80211_CMD_ROAM: request that the card roam (currently not implemented),
+ *	sent as an event when the card/driver roamed by itself.
+ * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
+ *	userspace that a connection was dropped by the AP or due to other
+ *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
+ *	%NL80211_ATTR_REASON_CODE attributes are used.
+ *
+ * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
+ *	associated with this wiphy must be down and will follow.
+ *
+ * @NL80211_CMD_MAX: highest used command number
+ * @__NL80211_CMD_AFTER_LAST: internal use
+ */
+enum nl80211_commands {
+/* don't change the order or add anything inbetween, this is ABI! */
+	NL80211_CMD_UNSPEC,
+
+	NL80211_CMD_GET_WIPHY,		/* can dump */
+	NL80211_CMD_SET_WIPHY,
+	NL80211_CMD_NEW_WIPHY,
+	NL80211_CMD_DEL_WIPHY,
+
+	NL80211_CMD_GET_INTERFACE,	/* can dump */
+	NL80211_CMD_SET_INTERFACE,
+	NL80211_CMD_NEW_INTERFACE,
+	NL80211_CMD_DEL_INTERFACE,
+
+	NL80211_CMD_GET_KEY,
+	NL80211_CMD_SET_KEY,
+	NL80211_CMD_NEW_KEY,
+	NL80211_CMD_DEL_KEY,
+
+	NL80211_CMD_GET_BEACON,
+	NL80211_CMD_SET_BEACON,
+	NL80211_CMD_NEW_BEACON,
+	NL80211_CMD_DEL_BEACON,
+
+	NL80211_CMD_GET_STATION,
+	NL80211_CMD_SET_STATION,
+	NL80211_CMD_NEW_STATION,
+	NL80211_CMD_DEL_STATION,
+
+	NL80211_CMD_GET_MPATH,
+	NL80211_CMD_SET_MPATH,
+	NL80211_CMD_NEW_MPATH,
+	NL80211_CMD_DEL_MPATH,
+
+	NL80211_CMD_SET_BSS,
+
+	NL80211_CMD_SET_REG,
+	NL80211_CMD_REQ_SET_REG,
+
+	NL80211_CMD_GET_MESH_PARAMS,
+	NL80211_CMD_SET_MESH_PARAMS,
+
+	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
+
+	NL80211_CMD_GET_REG,
+
+	NL80211_CMD_GET_SCAN,
+	NL80211_CMD_TRIGGER_SCAN,
+	NL80211_CMD_NEW_SCAN_RESULTS,
+	NL80211_CMD_SCAN_ABORTED,
+
+	NL80211_CMD_REG_CHANGE,
+
+	NL80211_CMD_AUTHENTICATE,
+	NL80211_CMD_ASSOCIATE,
+	NL80211_CMD_DEAUTHENTICATE,
+	NL80211_CMD_DISASSOCIATE,
+
+	NL80211_CMD_MICHAEL_MIC_FAILURE,
+
+	NL80211_CMD_REG_BEACON_HINT,
+
+	NL80211_CMD_JOIN_IBSS,
+	NL80211_CMD_LEAVE_IBSS,
+
+	NL80211_CMD_TESTMODE,
+
+	NL80211_CMD_CONNECT,
+	NL80211_CMD_ROAM,
+	NL80211_CMD_DISCONNECT,
+
+	NL80211_CMD_SET_WIPHY_NETNS,
+
+	/* add new commands above here */
+
+	/* used to define NL80211_CMD_MAX below */
+	__NL80211_CMD_AFTER_LAST,
+	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
+};
+
+/*
+ * Allow user space programs to use #ifdef on new commands by defining them
+ * here
+ */
+#define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
+#define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
+#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
+#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
+#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
+#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
+#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
+#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
+
+/**
+ * enum nl80211_attrs - nl80211 netlink attributes
+ *
+ * @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors
+ *
+ * @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf.
+ *	/sys/class/ieee80211/<phyname>/index
+ * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
+ * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
+ * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz
+ * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
+ *	if HT20 or HT40 are allowed (i.e., 802.11n disabled if not included):
+ *	NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
+ *		this attribute)
+ *	NL80211_CHAN_HT20 = HT20 only
+ *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
+ *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
+ * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
+ *	less than or equal to the RTS threshold; allowed range: 1..255;
+ *	dot11ShortRetryLimit; u8
+ * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
+ *	greater than the RTS threshold; allowed range: 1..255;
+ *	dot11ShortLongLimit; u8
+ * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
+ *	length in octets for frames; allowed range: 256..8000, disable
+ *	fragmentation with (u32)-1; dot11FragmentationThreshold; u32
+ * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
+ *	larger than or equal to this use RTS/CTS handshake); allowed range:
+ *	0..65536, disable with (u32)-1; dot11RTSThreshold; u32
+ *
+ * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
+ * @NL80211_ATTR_IFNAME: network interface name
+ * @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype
+ *
+ * @NL80211_ATTR_MAC: MAC address (various uses)
+ *
+ * @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ *
+ * @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU
+ * @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing
+ * @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE
+ * @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE
+ *
+ * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
+ * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *	&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
+ * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
+ *	IEEE 802.11 7.3.1.6 (u16).
+ * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
+ *	rates as defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
+ *	to, or the AP interface the station was originally added to to.
+ * @NL80211_ATTR_STA_INFO: information about a station, part of station info
+ *	given for %NL80211_CMD_GET_STATION, nested attribute containing
+ *	info as possible, see &enum nl80211_sta_info.
+ *
+ * @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,
+ *	consisting of a nested array.
+ *
+ * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
+ * @NL80211_ATTR_PLINK_ACTION: action to perform on the mesh peer link.
+ * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
+ * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
+ * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
+ *	&enum nl80211_mpath_info.
+ *
+ * @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *      &enum nl80211_mntr_flags.
+ *
+ * @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the
+ * 	current regulatory domain should be set to or is already set to.
+ * 	For example, 'CR', for Costa Rica. This attribute is used by the kernel
+ * 	to query the CRDA to retrieve one regulatory domain. This attribute can
+ * 	also be used by userspace to query the kernel for the currently set
+ * 	regulatory domain. We chose an alpha2 as that is also used by the
+ * 	IEEE-802.11d country information element to identify a country.
+ * 	Users can also simply ask the wireless core to set regulatory domain
+ * 	to a specific alpha2.
+ * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
+ *	rules.
+ *
+ * @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic
+ *	rates in format defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all
+ *	supported interface types, each a flag attribute with the number
+ *	of the interface mode.
+ *
+ * @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE.
+ *
+ * @NL80211_ATTR_IE: Information element(s) data (used, e.g., with
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE).
+ *
+ * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
+ *	a single scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
+ *	that can be added to a scan request
+ *
+ * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
+ * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
+ *	scanning and include a zero-length SSID (wildcard) for wildcard scan
+ * @NL80211_ATTR_BSS: scan result BSS
+ *
+ * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
+ * 	currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
+ * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
+ * 	set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
+ *
+ * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
+ *	an array of command numbers (i.e. a mapping index to command number)
+ *	that the driver for the given wiphy supports.
+ *
+ * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
+ *	and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
+ *	NL80211_CMD_ASSOCIATE events
+ * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
+ * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
+ *	represented as a u32
+ * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
+ *	%NL80211_CMD_DISASSOCIATE, u16
+ *
+ * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
+ *	a u32
+ *
+ * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _before_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _after_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ *
+ * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
+ *	cipher suites
+ *
+ * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
+ *	for other networks on different channels
+ *
+ * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
+ *	is used, e.g., with %NL80211_CMD_AUTHENTICATE event
+ *
+ * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
+ *	used for the association (&enum nl80211_mfp, represented as a u32);
+ *	this attribute can be used
+ *	with %NL80211_CMD_ASSOCIATE request
+ *
+ * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
+ *	&struct nl80211_sta_flag_update.
+ *
+ * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
+ *	IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
+ *	station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
+ *	request, the driver will assume that the port is unauthorized until
+ *	authorized by user space. Otherwise, port is marked authorized by
+ *	default in station mode.
+ *
+ * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
+ *	We recommend using nested, driver-specific attributes within this.
+ *
+ * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
+ *	event was due to the AP disconnecting the station, and not due to
+ *	a local disconnect request.
+ * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
+ *	event (u16)
+ * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
+ *	that protected APs should be used.
+ *
+ * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT and ASSOCIATE to
+ *	indicate which unicast key ciphers will be used with the connection
+ *	(an array of u32).
+ * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT and ASSOCIATE to indicate
+ *	which group key cipher will be used with the connection (a u32).
+ * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT and ASSOCIATE to indicate
+ *	which WPA version(s) the AP we want to associate with is using
+ *	(a u32 with flags from &enum nl80211_wpa_versions).
+ * @NL80211_ATTR_AKM_SUITES: Used with CONNECT and ASSOCIATE to indicate
+ *	which key management algorithm(s) to use (an array of u32).
+ *
+ * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
+ *	sent out by the card, for ROAM and successful CONNECT events.
+ * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
+ *	sent by peer, for ROAM and successful CONNECT events.
+ *
+ * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used by in ASSOCIATE
+ *	commands to specify using a reassociate frame
+ *
+ * @NL80211_ATTR_KEY: key information in a nested attribute with
+ *	%NL80211_KEY_* sub-attributes
+ * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
+ *	and join_ibss(), key information is in a nested attribute each
+ *	with %NL80211_KEY_* sub-attributes
+ *
+ * @NL80211_ATTR_PID: Process ID of a network namespace.
+ *
+ * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
+ *	dumps. This number increases whenever the object list being
+ *	dumped changes, and as such userspace can verify that it has
+ *	obtained a complete and consistent snapshot by verifying that
+ *	all dump messages contain the same generation number. If it
+ *	changed then the list changed and the dump should be repeated
+ *	completely from scratch.
+ *
+ * @NL80211_ATTR_MAX: highest attribute number currently defined
+ * @__NL80211_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_attrs {
+/* don't change the order or add anything inbetween, this is ABI! */
+	NL80211_ATTR_UNSPEC,
+
+	NL80211_ATTR_WIPHY,
+	NL80211_ATTR_WIPHY_NAME,
+
+	NL80211_ATTR_IFINDEX,
+	NL80211_ATTR_IFNAME,
+	NL80211_ATTR_IFTYPE,
+
+	NL80211_ATTR_MAC,
+
+	NL80211_ATTR_KEY_DATA,
+	NL80211_ATTR_KEY_IDX,
+	NL80211_ATTR_KEY_CIPHER,
+	NL80211_ATTR_KEY_SEQ,
+	NL80211_ATTR_KEY_DEFAULT,
+
+	NL80211_ATTR_BEACON_INTERVAL,
+	NL80211_ATTR_DTIM_PERIOD,
+	NL80211_ATTR_BEACON_HEAD,
+	NL80211_ATTR_BEACON_TAIL,
+
+	NL80211_ATTR_STA_AID,
+	NL80211_ATTR_STA_FLAGS,
+	NL80211_ATTR_STA_LISTEN_INTERVAL,
+	NL80211_ATTR_STA_SUPPORTED_RATES,
+	NL80211_ATTR_STA_VLAN,
+	NL80211_ATTR_STA_INFO,
+
+	NL80211_ATTR_WIPHY_BANDS,
+
+	NL80211_ATTR_MNTR_FLAGS,
+
+	NL80211_ATTR_MESH_ID,
+	NL80211_ATTR_STA_PLINK_ACTION,
+	NL80211_ATTR_MPATH_NEXT_HOP,
+	NL80211_ATTR_MPATH_INFO,
+
+	NL80211_ATTR_BSS_CTS_PROT,
+	NL80211_ATTR_BSS_SHORT_PREAMBLE,
+	NL80211_ATTR_BSS_SHORT_SLOT_TIME,
+
+	NL80211_ATTR_HT_CAPABILITY,
+
+	NL80211_ATTR_SUPPORTED_IFTYPES,
+
+	NL80211_ATTR_REG_ALPHA2,
+	NL80211_ATTR_REG_RULES,
+
+	NL80211_ATTR_MESH_PARAMS,
+
+	NL80211_ATTR_BSS_BASIC_RATES,
+
+	NL80211_ATTR_WIPHY_TXQ_PARAMS,
+	NL80211_ATTR_WIPHY_FREQ,
+	NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+
+	NL80211_ATTR_KEY_DEFAULT_MGMT,
+
+	NL80211_ATTR_MGMT_SUBTYPE,
+	NL80211_ATTR_IE,
+
+	NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
+
+	NL80211_ATTR_SCAN_FREQUENCIES,
+	NL80211_ATTR_SCAN_SSIDS,
+	NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_BSS,
+
+	NL80211_ATTR_REG_INITIATOR,
+	NL80211_ATTR_REG_TYPE,
+
+	NL80211_ATTR_SUPPORTED_COMMANDS,
+
+	NL80211_ATTR_FRAME,
+	NL80211_ATTR_SSID,
+	NL80211_ATTR_AUTH_TYPE,
+	NL80211_ATTR_REASON_CODE,
+
+	NL80211_ATTR_KEY_TYPE,
+
+	NL80211_ATTR_MAX_SCAN_IE_LEN,
+	NL80211_ATTR_CIPHER_SUITES,
+
+	NL80211_ATTR_FREQ_BEFORE,
+	NL80211_ATTR_FREQ_AFTER,
+
+	NL80211_ATTR_FREQ_FIXED,
+
+
+	NL80211_ATTR_WIPHY_RETRY_SHORT,
+	NL80211_ATTR_WIPHY_RETRY_LONG,
+	NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+	NL80211_ATTR_WIPHY_RTS_THRESHOLD,
+
+	NL80211_ATTR_TIMED_OUT,
+
+	NL80211_ATTR_USE_MFP,
+
+	NL80211_ATTR_STA_FLAGS2,
+
+	NL80211_ATTR_CONTROL_PORT,
+
+	NL80211_ATTR_TESTDATA,
+
+	NL80211_ATTR_PRIVACY,
+
+	NL80211_ATTR_DISCONNECTED_BY_AP,
+	NL80211_ATTR_STATUS_CODE,
+
+	NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
+	NL80211_ATTR_CIPHER_SUITE_GROUP,
+	NL80211_ATTR_WPA_VERSIONS,
+	NL80211_ATTR_AKM_SUITES,
+
+	NL80211_ATTR_REQ_IE,
+	NL80211_ATTR_RESP_IE,
+
+	NL80211_ATTR_PREV_BSSID,
+
+	NL80211_ATTR_KEY,
+	NL80211_ATTR_KEYS,
+
+	NL80211_ATTR_PID,
+
+	/* add attributes here, update the policy in nl80211.c */
+
+	__NL80211_ATTR_AFTER_LAST,
+	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
+};
+
+/* source-level API compatibility */
+#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
+
+/*
+ * Allow user space programs to use #ifdef on new attributes by defining them
+ * here
+ */
+#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
+#define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
+#define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
+#define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
+#define NL80211_ATTR_WIPHY_FREQ NL80211_ATTR_WIPHY_FREQ
+#define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
+#define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
+#define NL80211_ATTR_IE NL80211_ATTR_IE
+#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
+#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
+#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
+#define NL80211_ATTR_SSID NL80211_ATTR_SSID
+#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
+#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
+#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
+#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
+#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
+#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
+#define NL80211_ATTR_KEY NL80211_ATTR_KEY
+#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
+
+#define NL80211_MAX_SUPP_RATES			32
+#define NL80211_MAX_SUPP_REG_RULES		32
+#define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
+#define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
+#define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
+#define NL80211_HT_CAPABILITY_LEN		26
+
+#define NL80211_MAX_NR_CIPHER_SUITES		5
+#define NL80211_MAX_NR_AKM_SUITES		2
+
+/**
+ * enum nl80211_iftype - (virtual) interface types
+ *
+ * @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides
+ * @NL80211_IFTYPE_ADHOC: independent BSS member
+ * @NL80211_IFTYPE_STATION: managed BSS member
+ * @NL80211_IFTYPE_AP: access point
+ * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points
+ * @NL80211_IFTYPE_WDS: wireless distribution interface
+ * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
+ * @NL80211_IFTYPE_MESH_POINT: mesh point
+ * @NL80211_IFTYPE_MAX: highest interface type number currently defined
+ * @__NL80211_IFTYPE_AFTER_LAST: internal use
+ *
+ * These values are used with the %NL80211_ATTR_IFTYPE
+ * to set the type of an interface.
+ *
+ */
+enum nl80211_iftype {
+	NL80211_IFTYPE_UNSPECIFIED,
+	NL80211_IFTYPE_ADHOC,
+	NL80211_IFTYPE_STATION,
+	NL80211_IFTYPE_AP,
+	NL80211_IFTYPE_AP_VLAN,
+	NL80211_IFTYPE_WDS,
+	NL80211_IFTYPE_MONITOR,
+	NL80211_IFTYPE_MESH_POINT,
+
+	/* keep last */
+	__NL80211_IFTYPE_AFTER_LAST,
+	NL80211_IFTYPE_MAX = __NL80211_IFTYPE_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_flags - station flags
+ *
+ * Station flags. When a station is added to an AP interface, it is
+ * assumed to be already associated (and hence authenticated.)
+ *
+ * @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)
+ * @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames
+ *	with short barker preamble
+ * @NL80211_STA_FLAG_WME: station is WME/QoS capable
+ * @NL80211_STA_FLAG_MFP: station uses management frame protection
+ */
+enum nl80211_sta_flags {
+	__NL80211_STA_FLAG_INVALID,
+	NL80211_STA_FLAG_AUTHORIZED,
+	NL80211_STA_FLAG_SHORT_PREAMBLE,
+	NL80211_STA_FLAG_WME,
+	NL80211_STA_FLAG_MFP,
+
+	/* keep last */
+	__NL80211_STA_FLAG_AFTER_LAST,
+	NL80211_STA_FLAG_MAX = __NL80211_STA_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * struct nl80211_sta_flag_update - station flags mask/set
+ * @mask: mask of station flags to set
+ * @set: which values to set them to
+ *
+ * Both mask and set contain bits as per &enum nl80211_sta_flags.
+ */
+struct nl80211_sta_flag_update {
+	__u32 mask;
+	__u32 set;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_rate_info - bitrate information
+ *
+ * These attribute types are used with %NL80211_STA_INFO_TXRATE
+ * when getting information about the bitrate of a station.
+ *
+ * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
+ * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
+ * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 Mhz dualchannel bitrate
+ * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
+ * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
+ * @__NL80211_RATE_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_rate_info {
+	__NL80211_RATE_INFO_INVALID,
+	NL80211_RATE_INFO_BITRATE,
+	NL80211_RATE_INFO_MCS,
+	NL80211_RATE_INFO_40_MHZ_WIDTH,
+	NL80211_RATE_INFO_SHORT_GI,
+
+	/* keep last */
+	__NL80211_RATE_INFO_AFTER_LAST,
+	NL80211_RATE_INFO_MAX = __NL80211_RATE_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_info - station information
+ *
+ * These attribute types are used with %NL80211_ATTR_STA_INFO
+ * when getting information about a station.
+ *
+ * @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
+ * @NL80211_STA_INFO_RX_BYTES: total received bytes (u32, from this station)
+ * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (u32, to this station)
+ * @__NL80211_STA_INFO_AFTER_LAST: internal
+ * @NL80211_STA_INFO_MAX: highest possible station info attribute
+ * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
+ * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
+ * 	containing info as possible, see &enum nl80211_sta_info_txrate.
+ * @NL80211_STA_INFO_RX_PACKETS: total received packet (u32, from this station)
+ * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (u32, to this
+ *	station)
+ */
+enum nl80211_sta_info {
+	__NL80211_STA_INFO_INVALID,
+	NL80211_STA_INFO_INACTIVE_TIME,
+	NL80211_STA_INFO_RX_BYTES,
+	NL80211_STA_INFO_TX_BYTES,
+	NL80211_STA_INFO_LLID,
+	NL80211_STA_INFO_PLID,
+	NL80211_STA_INFO_PLINK_STATE,
+	NL80211_STA_INFO_SIGNAL,
+	NL80211_STA_INFO_TX_BITRATE,
+	NL80211_STA_INFO_RX_PACKETS,
+	NL80211_STA_INFO_TX_PACKETS,
+
+	/* keep last */
+	__NL80211_STA_INFO_AFTER_LAST,
+	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mpath_flags - nl80211 mesh path flags
+ *
+ * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
+ * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
+ * @NL80211_MPATH_FLAG_DSN_VALID: the mesh path contains a valid DSN
+ * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
+ * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
+ */
+enum nl80211_mpath_flags {
+	NL80211_MPATH_FLAG_ACTIVE =	1<<0,
+	NL80211_MPATH_FLAG_RESOLVING =	1<<1,
+	NL80211_MPATH_FLAG_DSN_VALID =	1<<2,
+	NL80211_MPATH_FLAG_FIXED =	1<<3,
+	NL80211_MPATH_FLAG_RESOLVED =	1<<4,
+};
+
+/**
+ * enum nl80211_mpath_info - mesh path information
+ *
+ * These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting
+ * information about a mesh path.
+ *
+ * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_ATTR_MPATH_FRAME_QLEN: number of queued frames for this destination
+ * @NL80211_ATTR_MPATH_DSN: destination sequence number
+ * @NL80211_ATTR_MPATH_METRIC: metric (cost) of this mesh path
+ * @NL80211_ATTR_MPATH_EXPTIME: expiration time for the path, in msec from now
+ * @NL80211_ATTR_MPATH_FLAGS: mesh path flags, enumerated in
+ * 	&enum nl80211_mpath_flags;
+ * @NL80211_ATTR_MPATH_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
+ * @NL80211_ATTR_MPATH_DISCOVERY_RETRIES: mesh path discovery retries
+ */
+enum nl80211_mpath_info {
+	__NL80211_MPATH_INFO_INVALID,
+	NL80211_MPATH_INFO_FRAME_QLEN,
+	NL80211_MPATH_INFO_DSN,
+	NL80211_MPATH_INFO_METRIC,
+	NL80211_MPATH_INFO_EXPTIME,
+	NL80211_MPATH_INFO_FLAGS,
+	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
+	NL80211_MPATH_INFO_DISCOVERY_RETRIES,
+
+	/* keep last */
+	__NL80211_MPATH_INFO_AFTER_LAST,
+	NL80211_MPATH_INFO_MAX = __NL80211_MPATH_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band_attr - band attributes
+ * @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,
+ *	an array of nested frequency attributes
+ * @NL80211_BAND_ATTR_RATES: supported bitrates in this band,
+ *	an array of nested bitrate attributes
+ * @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as
+ *	defined in 802.11n
+ * @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n
+ * @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n
+ */
+enum nl80211_band_attr {
+	__NL80211_BAND_ATTR_INVALID,
+	NL80211_BAND_ATTR_FREQS,
+	NL80211_BAND_ATTR_RATES,
+
+	NL80211_BAND_ATTR_HT_MCS_SET,
+	NL80211_BAND_ATTR_HT_CAPA,
+	NL80211_BAND_ATTR_HT_AMPDU_FACTOR,
+	NL80211_BAND_ATTR_HT_AMPDU_DENSITY,
+
+	/* keep last */
+	__NL80211_BAND_ATTR_AFTER_LAST,
+	NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_BAND_ATTR_HT_CAPA NL80211_BAND_ATTR_HT_CAPA
+
+/**
+ * enum nl80211_frequency_attr - frequency attributes
+ * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
+ * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
+ *	regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_PASSIVE_SCAN: Only passive scanning is
+ *	permitted on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_IBSS: IBSS networks are not permitted
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
+ *	(100 * dBm).
+ */
+enum nl80211_frequency_attr {
+	__NL80211_FREQUENCY_ATTR_INVALID,
+	NL80211_FREQUENCY_ATTR_FREQ,
+	NL80211_FREQUENCY_ATTR_DISABLED,
+	NL80211_FREQUENCY_ATTR_PASSIVE_SCAN,
+	NL80211_FREQUENCY_ATTR_NO_IBSS,
+	NL80211_FREQUENCY_ATTR_RADAR,
+	NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
+
+	/* keep last */
+	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
+	NL80211_FREQUENCY_ATTR_MAX = __NL80211_FREQUENCY_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
+
+/**
+ * enum nl80211_bitrate_attr - bitrate attributes
+ * @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps
+ * @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported
+ *	in 2.4 GHz band.
+ */
+enum nl80211_bitrate_attr {
+	__NL80211_BITRATE_ATTR_INVALID,
+	NL80211_BITRATE_ATTR_RATE,
+	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE,
+
+	/* keep last */
+	__NL80211_BITRATE_ATTR_AFTER_LAST,
+	NL80211_BITRATE_ATTR_MAX = __NL80211_BITRATE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_initiator - Indicates the initiator of a reg domain request
+ * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
+ * 	wireless core it thinks its knows the regulatory domain we should be in.
+ * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
+ * 	802.11 country information element with regulatory information it
+ * 	thinks we should consider.
+ */
+enum nl80211_reg_initiator {
+	NL80211_REGDOM_SET_BY_CORE,
+	NL80211_REGDOM_SET_BY_USER,
+	NL80211_REGDOM_SET_BY_DRIVER,
+	NL80211_REGDOM_SET_BY_COUNTRY_IE,
+};
+
+/**
+ * enum nl80211_reg_type - specifies the type of regulatory domain
+ * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
+ *	to a specific country. When this is set you can count on the
+ *	ISO / IEC 3166 alpha2 country code being valid.
+ * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
+ * 	domain.
+ * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
+ * 	driver specific world regulatory domain. These do not apply system-wide
+ * 	and are only applicable to the individual devices which have requested
+ * 	them to be applied.
+ * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
+ *	of an intersection between two regulatory domains -- the previously
+ *	set regulatory domain on the system and the last accepted regulatory
+ *	domain request to be processed.
+ */
+enum nl80211_reg_type {
+	NL80211_REGDOM_TYPE_COUNTRY,
+	NL80211_REGDOM_TYPE_WORLD,
+	NL80211_REGDOM_TYPE_CUSTOM_WORLD,
+	NL80211_REGDOM_TYPE_INTERSECTION,
+};
+
+/**
+ * enum nl80211_reg_rule_attr - regulatory rule attributes
+ * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
+ * 	considerations for a given frequency range. These are the
+ * 	&enum nl80211_reg_rule_flags.
+ * @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory
+ * 	rule in KHz. This is not a center of frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule
+ * 	in KHz. This is not a center a frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
+ * 	frequency range, in KHz.
+ * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
+ * 	for a given frequency range. The value is in mBi (100 * dBi).
+ * 	If you don't have one then don't send this.
+ * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
+ * 	a given frequency range. The value is in mBm (100 * dBm).
+ */
+enum nl80211_reg_rule_attr {
+	__NL80211_REG_RULE_ATTR_INVALID,
+	NL80211_ATTR_REG_RULE_FLAGS,
+
+	NL80211_ATTR_FREQ_RANGE_START,
+	NL80211_ATTR_FREQ_RANGE_END,
+	NL80211_ATTR_FREQ_RANGE_MAX_BW,
+
+	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
+	NL80211_ATTR_POWER_RULE_MAX_EIRP,
+
+	/* keep last */
+	__NL80211_REG_RULE_ATTR_AFTER_LAST,
+	NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_reg_rule_flags - regulatory rule flags
+ *
+ * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
+ * @NL80211_RRF_NO_CCK: CCK modulation not allowed
+ * @NL80211_RRF_NO_INDOOR: indoor operation not allowed
+ * @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed
+ * @NL80211_RRF_DFS: DFS support is required to be used
+ * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
+ * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
+ * @NL80211_RRF_PASSIVE_SCAN: passive scan is required
+ * @NL80211_RRF_NO_IBSS: no IBSS is allowed
+ */
+enum nl80211_reg_rule_flags {
+	NL80211_RRF_NO_OFDM		= 1<<0,
+	NL80211_RRF_NO_CCK		= 1<<1,
+	NL80211_RRF_NO_INDOOR		= 1<<2,
+	NL80211_RRF_NO_OUTDOOR		= 1<<3,
+	NL80211_RRF_DFS			= 1<<4,
+	NL80211_RRF_PTP_ONLY		= 1<<5,
+	NL80211_RRF_PTMP_ONLY		= 1<<6,
+	NL80211_RRF_PASSIVE_SCAN	= 1<<7,
+	NL80211_RRF_NO_IBSS		= 1<<8,
+};
+
+/**
+ * enum nl80211_mntr_flags - monitor configuration flags
+ *
+ * Monitor configuration flags.
+ *
+ * @__NL80211_MNTR_FLAG_INVALID: reserved
+ *
+ * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
+ * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
+ * @NL80211_MNTR_FLAG_CONTROL: pass control frames
+ * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
+ * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
+ *	overrides all other flags.
+ *
+ * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
+ * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
+ */
+enum nl80211_mntr_flags {
+	__NL80211_MNTR_FLAG_INVALID,
+	NL80211_MNTR_FLAG_FCSFAIL,
+	NL80211_MNTR_FLAG_PLCPFAIL,
+	NL80211_MNTR_FLAG_CONTROL,
+	NL80211_MNTR_FLAG_OTHER_BSS,
+	NL80211_MNTR_FLAG_COOK_FRAMES,
+
+	/* keep last */
+	__NL80211_MNTR_FLAG_AFTER_LAST,
+	NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_meshconf_params - mesh configuration parameters
+ *
+ * Mesh configuration parameters
+ *
+ * @__NL80211_MESHCONF_INVALID: internal use
+ *
+ * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
+ * millisecond units, used by the Peer Link Open message
+ *
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the inital confirm timeout, in
+ * millisecond units, used by the peer link management to close a peer link
+ *
+ * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
+ * millisecond units
+ *
+ * @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed
+ * on this mesh interface
+ *
+ * @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link
+ * open retries that can be sent to establish a new peer link instance in a
+ * mesh
+ *
+ * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
+ * point.
+ *
+ * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically
+ * open peer links when we detect compatible mesh peers.
+ *
+ * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
+ * containing a PREQ that an MP can send to a particular destination (path
+ * target)
+ *
+ * @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths
+ * (in milliseconds)
+ *
+ * @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait
+ * until giving up on a path discovery (in milliseconds)
+ *
+ * @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh
+ * points receiving a PREQ shall consider the forwarding information from the
+ * root to be valid. (TU = time unit)
+ *
+ * @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in
+ * TUs) during which an MP can send only one action frame containing a PREQ
+ * reference element
+ *
+ * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
+ * that it takes for an HWMP information element to propagate across the mesh
+ *
+ * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
+ *
+ * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_meshconf_params {
+	__NL80211_MESHCONF_INVALID,
+	NL80211_MESHCONF_RETRY_TIMEOUT,
+	NL80211_MESHCONF_CONFIRM_TIMEOUT,
+	NL80211_MESHCONF_HOLDING_TIMEOUT,
+	NL80211_MESHCONF_MAX_PEER_LINKS,
+	NL80211_MESHCONF_MAX_RETRIES,
+	NL80211_MESHCONF_TTL,
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+	NL80211_MESHCONF_PATH_REFRESH_TIME,
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+
+	/* keep last */
+	__NL80211_MESHCONF_ATTR_AFTER_LAST,
+	NL80211_MESHCONF_ATTR_MAX = __NL80211_MESHCONF_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_txq_attr - TX queue parameter attributes
+ * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
+ * @NL80211_TXQ_ATTR_QUEUE: TX queue identifier (NL80211_TXQ_Q_*)
+ * @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning
+ *	disabled
+ * @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number
+ */
+enum nl80211_txq_attr {
+	__NL80211_TXQ_ATTR_INVALID,
+	NL80211_TXQ_ATTR_QUEUE,
+	NL80211_TXQ_ATTR_TXOP,
+	NL80211_TXQ_ATTR_CWMIN,
+	NL80211_TXQ_ATTR_CWMAX,
+	NL80211_TXQ_ATTR_AIFS,
+
+	/* keep last */
+	__NL80211_TXQ_ATTR_AFTER_LAST,
+	NL80211_TXQ_ATTR_MAX = __NL80211_TXQ_ATTR_AFTER_LAST - 1
+};
+
+enum nl80211_txq_q {
+	NL80211_TXQ_Q_VO,
+	NL80211_TXQ_Q_VI,
+	NL80211_TXQ_Q_BE,
+	NL80211_TXQ_Q_BK
+};
+
+enum nl80211_channel_type {
+	NL80211_CHAN_NO_HT,
+	NL80211_CHAN_HT20,
+	NL80211_CHAN_HT40MINUS,
+	NL80211_CHAN_HT40PLUS
+};
+
+/**
+ * enum nl80211_bss - netlink attributes for a BSS
+ *
+ * @__NL80211_BSS_INVALID: invalid
+ * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
+ * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
+ * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
+ * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
+ * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
+ *	raw information elements from the probe response/beacon (bin)
+ * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
+ *	in mBm (100 * dBm) (s32)
+ * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
+ *	in unspecified units, scaled to 0..100 (u8)
+ * @NL80211_BSS_STATUS: status, if this BSS is "used"
+ * @__NL80211_BSS_AFTER_LAST: internal
+ * @NL80211_BSS_MAX: highest BSS attribute
+ */
+enum nl80211_bss {
+	__NL80211_BSS_INVALID,
+	NL80211_BSS_BSSID,
+	NL80211_BSS_FREQUENCY,
+	NL80211_BSS_TSF,
+	NL80211_BSS_BEACON_INTERVAL,
+	NL80211_BSS_CAPABILITY,
+	NL80211_BSS_INFORMATION_ELEMENTS,
+	NL80211_BSS_SIGNAL_MBM,
+	NL80211_BSS_SIGNAL_UNSPEC,
+	NL80211_BSS_STATUS,
+
+	/* keep last */
+	__NL80211_BSS_AFTER_LAST,
+	NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_bss_status - BSS "status"
+ */
+enum nl80211_bss_status {
+	NL80211_BSS_STATUS_AUTHENTICATED,
+	NL80211_BSS_STATUS_ASSOCIATED,
+	NL80211_BSS_STATUS_IBSS_JOINED,
+};
+
+/**
+ * enum nl80211_auth_type - AuthenticationType
+ *
+ * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
+ * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
+ * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
+ * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
+ * @__NL80211_AUTHTYPE_NUM: internal
+ * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
+ * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
+ *	trying multiple times); this is invalid in netlink -- leave out
+ *	the attribute for this on CONNECT commands.
+ */
+enum nl80211_auth_type {
+	NL80211_AUTHTYPE_OPEN_SYSTEM,
+	NL80211_AUTHTYPE_SHARED_KEY,
+	NL80211_AUTHTYPE_FT,
+	NL80211_AUTHTYPE_NETWORK_EAP,
+
+	/* keep last */
+	__NL80211_AUTHTYPE_NUM,
+	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
+	NL80211_AUTHTYPE_AUTOMATIC
+};
+
+/**
+ * enum nl80211_key_type - Key Type
+ * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
+ * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
+ * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
+ */
+enum nl80211_key_type {
+	NL80211_KEYTYPE_GROUP,
+	NL80211_KEYTYPE_PAIRWISE,
+	NL80211_KEYTYPE_PEERKEY,
+};
+
+/**
+ * enum nl80211_mfp - Management frame protection state
+ * @NL80211_MFP_NO: Management frame protection not used
+ * @NL80211_MFP_REQUIRED: Management frame protection required
+ */
+enum nl80211_mfp {
+	NL80211_MFP_NO,
+	NL80211_MFP_REQUIRED,
+};
+
+enum nl80211_wpa_versions {
+	NL80211_WPA_VERSION_1 = 1 << 0,
+	NL80211_WPA_VERSION_2 = 1 << 1,
+};
+
+/**
+ * enum nl80211_key_attributes - key attributes
+ * @__NL80211_KEY_INVALID: invalid
+ * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_KEY_DEFAULT: flag indicating default key
+ * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
+ * @__NL80211_KEY_AFTER_LAST: internal
+ * @NL80211_KEY_MAX: highest key attribute
+ */
+enum nl80211_key_attributes {
+	__NL80211_KEY_INVALID,
+	NL80211_KEY_DATA,
+	NL80211_KEY_IDX,
+	NL80211_KEY_CIPHER,
+	NL80211_KEY_SEQ,
+	NL80211_KEY_DEFAULT,
+	NL80211_KEY_DEFAULT_MGMT,
+
+	/* keep last */
+	__NL80211_KEY_AFTER_LAST,
+	NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
+};
+
+#endif /* __LINUX_NL80211_H */
diff -uNr linux-2.6.32/usr/include/linux/n_r3964.h clean_modified/linux-2.6.32/usr/include/linux/n_r3964.h
--- linux-2.6.32/usr/include/linux/n_r3964.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/n_r3964.h	2019-04-14 13:24:03.094681911 -0500
@@ -0,0 +1,99 @@
+/* r3964 linediscipline for linux
+ *
+ * -----------------------------------------------------------
+ * Copyright by
+ * Philips Automation Projects
+ * Kassel (Germany)
+ * http://www.pap-philips.de
+ * -----------------------------------------------------------
+ * This software may be used and distributed according to the terms of
+ * the GNU General Public License, incorporated herein by reference.
+ *
+ * Author:
+ * L. Haag
+ *
+ * $Log: r3964.h,v $
+ * Revision 1.4  2005/12/21 19:54:24  Kurt Huwig <kurt huwig de>
+ * Fixed HZ usage on 2.6 kernels
+ * Removed unnecessary include
+ *
+ * Revision 1.3  2001/03/18 13:02:24  dwmw2
+ * Fix timer usage, use spinlocks properly.
+ *
+ * Revision 1.2  2001/03/18 12:53:15  dwmw2
+ * Merge changes in 2.4.2
+ *
+ * Revision 1.1.1.1  1998/10/13 16:43:14  dwmw2
+ * This'll screw the version control
+ *
+ * Revision 1.6  1998/09/30 00:40:38  dwmw2
+ * Updated to use kernel's N_R3964 if available
+ *
+ * Revision 1.4  1998/04/02 20:29:44  lhaag
+ * select, blocking, ...
+ *
+ * Revision 1.3  1998/02/12 18:58:43  root
+ * fixed some memory leaks
+ * calculation of checksum characters
+ *
+ * Revision 1.2  1998/02/07 13:03:17  root
+ * ioctl read_telegram
+ *
+ * Revision 1.1  1998/02/06 19:19:43  root
+ * Initial revision
+ *
+ *
+ */
+
+#ifndef __LINUX_N_R3964_H__
+#define __LINUX_N_R3964_H__
+
+/* line disciplines for r3964 protocol */
+
+
+/*
+ * Ioctl-commands
+ */
+
+#define R3964_ENABLE_SIGNALS      0x5301
+#define R3964_SETPRIORITY         0x5302
+#define R3964_USE_BCC             0x5303
+#define R3964_READ_TELEGRAM       0x5304
+
+/* Options for R3964_SETPRIORITY */
+#define R3964_MASTER   0
+#define R3964_SLAVE    1
+
+/* Options for R3964_ENABLE_SIGNALS */
+#define R3964_SIG_ACK   0x0001
+#define R3964_SIG_DATA  0x0002
+#define R3964_SIG_ALL   0x000f
+#define R3964_SIG_NONE  0x0000
+#define R3964_USE_SIGIO 0x1000
+
+/*
+ * r3964 operation states:
+ */
+
+/* types for msg_id: */
+enum {R3964_MSG_ACK=1, R3964_MSG_DATA };
+
+#define R3964_MAX_MSG_COUNT 32
+
+/* error codes for client messages */
+#define R3964_OK 0        /* no error. */
+#define R3964_TX_FAIL -1  /* transmission error, block NOT sent */
+#define R3964_OVERFLOW -2 /* msg queue overflow */
+
+/* the client gets this struct when calling read(fd,...): */
+struct r3964_client_message {
+	  int     msg_id;
+	  int     arg;
+	  int     error_code;
+};
+
+#define R3964_MTU      256
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/nubus.h clean_modified/linux-2.6.32/usr/include/linux/nubus.h
--- linux-2.6.32/usr/include/linux/nubus.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nubus.h	2019-04-14 13:24:03.095797777 -0500
@@ -0,0 +1,244 @@
+/*
+  nubus.h: various definitions and prototypes for NuBus drivers to use.
+
+  Originally written by Alan Cox.
+
+  Hacked to death by C. Scott Ananian and David Huggins-Daines.
+  
+  Some of the constants in here are from the corresponding
+  NetBSD/OpenBSD header file, by Allen Briggs.  We figured out the
+  rest of them on our own. */
+
+#ifndef LINUX_NUBUS_H
+#define LINUX_NUBUS_H
+
+#include <linux/types.h>
+
+enum nubus_category {
+	NUBUS_CAT_BOARD          = 0x0001,
+	NUBUS_CAT_DISPLAY        = 0x0003,
+	NUBUS_CAT_NETWORK        = 0x0004,
+	NUBUS_CAT_COMMUNICATIONS = 0x0006,
+	NUBUS_CAT_FONT           = 0x0009,
+	NUBUS_CAT_CPU            = 0x000A,
+	/* For lack of a better name */
+	NUBUS_CAT_DUODOCK        = 0x0020
+};
+
+enum nubus_type_network {
+	NUBUS_TYPE_ETHERNET      = 0x0001,
+	NUBUS_TYPE_RS232         = 0x0002
+};
+
+enum nubus_type_display {
+	NUBUS_TYPE_VIDEO         = 0x0001
+};
+
+enum nubus_type_cpu {
+	NUBUS_TYPE_68020         = 0x0003,
+	NUBUS_TYPE_68030         = 0x0004,
+	NUBUS_TYPE_68040         = 0x0005
+};
+
+/* Known <Cat,Type,SW,HW> tuples: (according to TattleTech and Slots)
+ *  68030 motherboards: <10,4,0,24>
+ *  68040 motherboards: <10,5,0,24>
+ *  DuoDock Plus: <32,1,1,2>
+ *
+ *  Toby Frame Buffer card: <3,1,1,1>
+ *  RBV built-in video (IIci): <3,1,1,24>
+ *  Valkyrie built-in video (Q630): <3,1,1,46>
+ *  Macintosh Display Card: <3,1,1,25>
+ *  Sonora built-in video (P460): <3,1,1,34>
+ *  Jet framebuffer (DuoDock Plus): <3,1,1,41>
+ *
+ *  SONIC comm-slot/on-board and DuoDock Ethernet: <4,1,1,272>
+ *  SONIC LC-PDS Ethernet (Dayna, but like Apple 16-bit, sort of): <4,1,1,271>
+ *  Apple SONIC LC-PDS Ethernet ("Apple Ethernet LC Twisted-Pair Card"): <4,1,0,281>
+ *  Sonic Systems Ethernet A-Series Card: <4,1,268,256>
+ *  Asante MacCon NuBus-A: <4,1,260,256> (alpha-1.0,1.1 revision)
+ *   ROM on the above card: <2,1,0,0>
+ *  Cabletron ethernet card: <4,1,1,265>
+ *  Farallon ethernet card: <4,1,268,256> (identical to Sonic Systems card)
+ *  Kinetics EtherPort IIN: <4,1,259,262>
+ *  API Engineering EtherRun_LCa PDS enet card: <4,1,282,256>
+ *
+ *  Add your devices to the list!  You can obtain the "Slots" utility
+ *  from Apple's FTP site at:
+ *  ftp://dev.apple.com/devworld/Tool_Chest/Devices_-_Hardware/NuBus_Slot_Manager/
+ *
+ *  Alternately, TattleTech can be found at any Info-Mac mirror site.  
+ *  or from its distribution site: ftp://ftp.decismkr.com/dms
+ */
+
+/* DrSW: Uniquely identifies the software interface to a board.  This
+   is usually the one you want to look at when writing a driver.  It's
+   not as useful as you think, though, because as we should know by
+   now (duh), "Apple Compatible" can mean a lot of things... */
+
+/* Add known DrSW values here */
+enum nubus_drsw {
+	/* NUBUS_CAT_DISPLAY */
+	NUBUS_DRSW_APPLE        = 0x0001,
+	NUBUS_DRSW_APPLE_HIRES  = 0x0013, /* MacII HiRes card driver */
+	
+	/* NUBUS_CAT_NETWORK */
+	NUBUS_DRSW_3COM         = 0x0000,
+	NUBUS_DRSW_CABLETRON    = 0x0001,
+	NUBUS_DRSW_SONIC_LC     = 0x0001,
+	NUBUS_DRSW_KINETICS     = 0x0103,
+	NUBUS_DRSW_ASANTE       = 0x0104,
+	NUBUS_DRSW_TECHWORKS    = 0x0109,
+	NUBUS_DRSW_DAYNA        = 0x010b,
+	NUBUS_DRSW_FARALLON     = 0x010c,
+	NUBUS_DRSW_APPLE_SN     = 0x010f,
+	NUBUS_DRSW_DAYNA2       = 0x0115,
+	NUBUS_DRSW_FOCUS        = 0x011a,
+	NUBUS_DRSW_ASANTE_CS    = 0x011d, /* use asante SMC9194 driver */
+	NUBUS_DRSW_DAYNA_LC     = 0x011e,
+
+	/* NUBUS_CAT_CPU */
+	NUBUS_DRSW_NONE         = 0x0000,
+};
+
+/* DrHW: Uniquely identifies the hardware interface to a board (or at
+   least, it should...  some video cards are known to incorrectly
+   identify themselves as Toby cards) */
+
+/* Add known DrHW values here */
+enum nubus_drhw {
+	/* NUBUS_CAT_DISPLAY */
+	NUBUS_DRHW_APPLE_TFB      = 0x0001, /* Toby frame buffer card */
+	NUBUS_DRHW_APPLE_WVC      = 0x0006, /* Apple Workstation Video Card */
+	NUBUS_DRHW_SIGMA_CLRMAX   = 0x0007, /* Sigma Design ColorMax */
+	NUBUS_DRHW_APPLE_SE30     = 0x0009, /* Apple SE/30 video */
+	NUBUS_DRHW_APPLE_HRVC     = 0x0013, /* Mac II High-Res Video Card */
+	NUBUS_DRHW_APPLE_PVC      = 0x0017, /* Mac II Portrait Video Card */
+	NUBUS_DRHW_APPLE_RBV1     = 0x0018, /* IIci RBV video */
+	NUBUS_DRHW_APPLE_MDC      = 0x0019, /* Macintosh Display Card */
+	NUBUS_DRHW_APPLE_SONORA   = 0x0022, /* Sonora built-in video */
+	NUBUS_DRHW_APPLE_24AC     = 0x002b, /* Mac 24AC Video Card */
+	NUBUS_DRHW_APPLE_VALKYRIE = 0x002e,
+	NUBUS_DRHW_APPLE_JET      = 0x0029, /* Jet framebuffer (DuoDock) */
+	NUBUS_DRHW_SMAC_GFX       = 0x0105, /* SuperMac GFX */
+	NUBUS_DRHW_RASTER_CB264   = 0x013B, /* RasterOps ColorBoard 264 */
+	NUBUS_DRHW_MICRON_XCEED   = 0x0146, /* Micron Exceed color */
+	NUBUS_DRHW_RDIUS_GSC      = 0x0153, /* Radius GS/C */
+	NUBUS_DRHW_SMAC_SPEC8     = 0x017B, /* SuperMac Spectrum/8 */
+	NUBUS_DRHW_SMAC_SPEC24    = 0x017C, /* SuperMac Spectrum/24 */
+	NUBUS_DRHW_RASTER_CB364   = 0x026F, /* RasterOps ColorBoard 364 */
+	NUBUS_DRHW_RDIUS_DCGX     = 0x027C, /* Radius DirectColor/GX */
+	NUBUS_DRHW_RDIUS_PC8      = 0x0291, /* Radius PrecisionColor 8 */
+	NUBUS_DRHW_LAPIS_PCS8     = 0x0292, /* Lapis ProColorServer 8 */
+	NUBUS_DRHW_RASTER_24XLI   = 0x02A0, /* RasterOps 8/24 XLi */
+	NUBUS_DRHW_RASTER_PBPGT   = 0x02A5, /* RasterOps PaintBoard Prism GT */
+	NUBUS_DRHW_EMACH_FSX      = 0x02AE, /* E-Machines Futura SX */
+	NUBUS_DRHW_RASTER_24XLTV  = 0x02B7, /* RasterOps 24XLTV */
+	NUBUS_DRHW_SMAC_THUND24   = 0x02CB, /* SuperMac Thunder/24 */
+	NUBUS_DRHW_SMAC_THUNDLGHT = 0x03D9, /* SuperMac ThunderLight */
+	NUBUS_DRHW_RDIUS_PC24XP   = 0x0406, /* Radius PrecisionColor 24Xp */
+	NUBUS_DRHW_RDIUS_PC24X    = 0x040A, /* Radius PrecisionColor 24X */
+	NUBUS_DRHW_RDIUS_PC8XJ    = 0x040B, /* Radius PrecisionColor 8XJ */
+	
+	/* NUBUS_CAT_NETWORK */
+	NUBUS_DRHW_INTERLAN       = 0x0100,
+	NUBUS_DRHW_SMC9194        = 0x0101,
+	NUBUS_DRHW_KINETICS       = 0x0106,
+	NUBUS_DRHW_CABLETRON      = 0x0109,
+	NUBUS_DRHW_ASANTE_LC      = 0x010f,
+	NUBUS_DRHW_SONIC          = 0x0110,
+	NUBUS_DRHW_TECHWORKS      = 0x0112,
+	NUBUS_DRHW_APPLE_SONIC_NB = 0x0118,
+	NUBUS_DRHW_APPLE_SONIC_LC = 0x0119,
+	NUBUS_DRHW_FOCUS          = 0x011c,
+	NUBUS_DRHW_SONNET         = 0x011d,
+};
+
+/* Resource IDs: These are the identifiers for the various weird and
+   wonderful tidbits of information that may or may not reside in the
+   NuBus ROM directory. */
+enum nubus_res_id {
+	NUBUS_RESID_TYPE         = 0x0001,
+	NUBUS_RESID_NAME         = 0x0002,
+	NUBUS_RESID_ICON         = 0x0003,
+	NUBUS_RESID_DRVRDIR      = 0x0004,
+	NUBUS_RESID_LOADREC      = 0x0005,
+	NUBUS_RESID_BOOTREC      = 0x0006,
+	NUBUS_RESID_FLAGS        = 0x0007,
+	NUBUS_RESID_HWDEVID      = 0x0008,
+	NUBUS_RESID_MINOR_BASEOS = 0x000a,
+	NUBUS_RESID_MINOR_LENGTH = 0x000b,
+	NUBUS_RESID_MAJOR_BASEOS = 0x000c,
+	NUBUS_RESID_MAJOR_LENGTH = 0x000d,
+	NUBUS_RESID_CICN         = 0x000f,
+	NUBUS_RESID_ICL8         = 0x0010,
+	NUBUS_RESID_ICL4         = 0x0011,
+};
+
+/* Category-specific resources. */
+enum nubus_board_res_id {
+	NUBUS_RESID_BOARDID      = 0x0020,
+	NUBUS_RESID_PRAMINITDATA = 0x0021,
+	NUBUS_RESID_PRIMARYINIT  = 0x0022,
+	NUBUS_RESID_TIMEOUTCONST = 0x0023,
+	NUBUS_RESID_VENDORINFO   = 0x0024,
+	NUBUS_RESID_BOARDFLAGS   = 0x0025,
+	NUBUS_RESID_SECONDINIT   = 0x0026,
+
+	/* Not sure why Apple put these next two in here */
+	NUBUS_RESID_VIDNAMES     = 0x0041,
+	NUBUS_RESID_VIDMODES     = 0x007e
+};
+
+/* Fields within the vendor info directory */
+enum nubus_vendor_res_id {
+	NUBUS_RESID_VEND_ID     = 0x0001,
+	NUBUS_RESID_VEND_SERIAL = 0x0002,
+	NUBUS_RESID_VEND_REV    = 0x0003,
+	NUBUS_RESID_VEND_PART   = 0x0004,
+	NUBUS_RESID_VEND_DATE   = 0x0005
+};
+
+enum nubus_net_res_id {
+	NUBUS_RESID_MAC_ADDRESS  = 0x0080
+};
+
+enum nubus_cpu_res_id {
+	NUBUS_RESID_MEMINFO      = 0x0081,
+	NUBUS_RESID_ROMINFO      = 0x0082
+};
+
+enum nubus_display_res_id {
+	NUBUS_RESID_GAMMADIR    = 0x0040,
+	NUBUS_RESID_FIRSTMODE   = 0x0080,
+	NUBUS_RESID_SECONDMODE  = 0x0081,
+	NUBUS_RESID_THIRDMODE   = 0x0082,
+	NUBUS_RESID_FOURTHMODE  = 0x0083,
+	NUBUS_RESID_FIFTHMODE   = 0x0084,
+	NUBUS_RESID_SIXTHMODE   = 0x0085
+};
+
+struct nubus_dir
+{
+	unsigned char *base;
+	unsigned char *ptr;
+	int done;
+	int mask;
+};
+
+struct nubus_dirent
+{
+	unsigned char *base;
+	unsigned char type;
+	__u32 data;	/* Actually 24bits used */
+	int mask;
+};
+
+
+/* We'd like to get rid of this eventually.  Only daynaport.c uses it now. */
+static __inline__ void *nubus_slot_addr(int slot)
+{
+	return (void *)(0xF0000000|(slot<<24));
+}
+
+#endif /* LINUX_NUBUS_H */
diff -uNr linux-2.6.32/usr/include/linux/nvram.h clean_modified/linux-2.6.32/usr/include/linux/nvram.h
--- linux-2.6.32/usr/include/linux/nvram.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/nvram.h	2019-04-14 13:24:03.095797777 -0500
@@ -0,0 +1,16 @@
+#ifndef _LINUX_NVRAM_H
+#define _LINUX_NVRAM_H
+
+#include <linux/ioctl.h>
+
+/* /dev/nvram ioctls */
+#define NVRAM_INIT	_IO('p', 0x40) /* initialize NVRAM and set checksum */
+#define NVRAM_SETCKS	_IO('p', 0x41) /* recalculate checksum */
+
+/* for all current systems, this is where NVRAM starts */
+#define NVRAM_FIRST_BYTE    14
+/* all these functions expect an NVRAM offset, not an absolute */
+#define NVRAM_OFFSET(x)   ((x)-NVRAM_FIRST_BYTE)
+
+
+#endif  /* _LINUX_NVRAM_H */
diff -uNr linux-2.6.32/usr/include/linux/oom.h clean_modified/linux-2.6.32/usr/include/linux/oom.h
--- linux-2.6.32/usr/include/linux/oom.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/oom.h	2019-04-14 13:24:03.095797777 -0500
@@ -0,0 +1,10 @@
+#ifndef __INCLUDE_LINUX_OOM_H
+#define __INCLUDE_LINUX_OOM_H
+
+/* /proc/<pid>/oom_adj set to -17 protects from the oom-killer */
+#define OOM_DISABLE (-17)
+/* inclusive */
+#define OOM_ADJUST_MIN (-16)
+#define OOM_ADJUST_MAX 15
+
+#endif /* _INCLUDE_LINUX_OOM_H */
diff -uNr linux-2.6.32/usr/include/linux/param.h clean_modified/linux-2.6.32/usr/include/linux/param.h
--- linux-2.6.32/usr/include/linux/param.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/param.h	2019-04-14 13:24:03.095797777 -0500
@@ -0,0 +1,6 @@
+#ifndef _LINUX_PARAM_H
+#define _LINUX_PARAM_H
+
+#include <asm/param.h>
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/parport.h clean_modified/linux-2.6.32/usr/include/linux/parport.h
--- linux-2.6.32/usr/include/linux/parport.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/parport.h	2019-04-14 13:24:03.097634879 -0500
@@ -0,0 +1,95 @@
+/*
+ * Any part of this program may be used in documents licensed under
+ * the GNU Free Documentation License, Version 1.1 or any later version
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PARPORT_H_
+#define _PARPORT_H_
+
+/* Start off with user-visible constants */
+
+/* Maximum of 16 ports per machine */
+#define PARPORT_MAX  16
+
+/* Magic numbers */
+#define PARPORT_IRQ_NONE  -1
+#define PARPORT_DMA_NONE  -1
+#define PARPORT_IRQ_AUTO  -2
+#define PARPORT_DMA_AUTO  -2
+#define PARPORT_DMA_NOFIFO -3
+#define PARPORT_DISABLE   -2
+#define PARPORT_IRQ_PROBEONLY -3
+#define PARPORT_IOHI_AUTO -1
+
+#define PARPORT_CONTROL_STROBE    0x1
+#define PARPORT_CONTROL_AUTOFD    0x2
+#define PARPORT_CONTROL_INIT      0x4
+#define PARPORT_CONTROL_SELECT    0x8
+
+#define PARPORT_STATUS_ERROR      0x8
+#define PARPORT_STATUS_SELECT     0x10
+#define PARPORT_STATUS_PAPEROUT   0x20
+#define PARPORT_STATUS_ACK        0x40
+#define PARPORT_STATUS_BUSY       0x80
+
+/* Type classes for Plug-and-Play probe.  */
+typedef enum {
+	PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
+	PARPORT_CLASS_PRINTER,
+	PARPORT_CLASS_MODEM,
+	PARPORT_CLASS_NET,
+	PARPORT_CLASS_HDC,              /* Hard disk controller */
+	PARPORT_CLASS_PCMCIA,
+	PARPORT_CLASS_MEDIA,            /* Multimedia device */
+	PARPORT_CLASS_FDC,              /* Floppy disk controller */
+	PARPORT_CLASS_PORTS,
+	PARPORT_CLASS_SCANNER,
+	PARPORT_CLASS_DIGCAM,
+	PARPORT_CLASS_OTHER,            /* Anything else */
+	PARPORT_CLASS_UNSPEC,           /* No CLS field in ID */
+	PARPORT_CLASS_SCSIADAPTER
+} parport_device_class;
+
+/* The "modes" entry in parport is a bit field representing the
+   capabilities of the hardware. */
+#define PARPORT_MODE_PCSPP	(1<<0) /* IBM PC registers available. */
+#define PARPORT_MODE_TRISTATE	(1<<1) /* Can tristate. */
+#define PARPORT_MODE_EPP	(1<<2) /* Hardware EPP. */
+#define PARPORT_MODE_ECP	(1<<3) /* Hardware ECP. */
+#define PARPORT_MODE_COMPAT	(1<<4) /* Hardware 'printer protocol'. */
+#define PARPORT_MODE_DMA	(1<<5) /* Hardware can DMA. */
+#define PARPORT_MODE_SAFEININT	(1<<6) /* SPP registers accessible in IRQ. */
+
+/* IEEE1284 modes: 
+   Nibble mode, byte mode, ECP, ECPRLE and EPP are their own
+   'extensibility request' values.  Others are special.
+   'Real' ECP modes must have the IEEE1284_MODE_ECP bit set.  */
+#define IEEE1284_MODE_NIBBLE             0
+#define IEEE1284_MODE_BYTE              (1<<0)
+#define IEEE1284_MODE_COMPAT            (1<<8)
+#define IEEE1284_MODE_BECP              (1<<9) /* Bounded ECP mode */
+#define IEEE1284_MODE_ECP               (1<<4)
+#define IEEE1284_MODE_ECPRLE            (IEEE1284_MODE_ECP | (1<<5))
+#define IEEE1284_MODE_ECPSWE            (1<<10) /* Software-emulated */
+#define IEEE1284_MODE_EPP               (1<<6)
+#define IEEE1284_MODE_EPPSL             (1<<11) /* EPP 1.7 */
+#define IEEE1284_MODE_EPPSWE            (1<<12) /* Software-emulated */
+#define IEEE1284_DEVICEID               (1<<2)  /* This is a flag */
+#define IEEE1284_EXT_LINK               (1<<14) /* This flag causes the
+						 * extensibility link to
+						 * be requested, using
+						 * bits 0-6. */
+
+/* For the benefit of parport_read/write, you can use these with
+ * parport_negotiate to use address operations.  They have no effect
+ * other than to make parport_read/write use address transfers. */
+#define IEEE1284_ADDR			(1<<13)	/* This is a flag */
+#define IEEE1284_DATA			 0	/* So is this */
+
+/* Flags for block transfer operations. */
+#define PARPORT_EPP_FAST		(1<<0) /* Unreliable counts. */
+#define PARPORT_W91284PIC		(1<<1) /* have a Warp9 w91284pic in the device */
+
+/* The rest is for the kernel only */
+#endif /* _PARPORT_H_ */
diff -uNr linux-2.6.32/usr/include/linux/patchkey.h clean_modified/linux-2.6.32/usr/include/linux/patchkey.h
--- linux-2.6.32/usr/include/linux/patchkey.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/patchkey.h	2019-04-14 13:24:03.097634879 -0500
@@ -0,0 +1,33 @@
+/*
+ * <linux/patchkey.h> -- definition of _PATCHKEY macro
+ *
+ * Copyright (C) 2005 Stuart Brady
+ *
+ * This exists because awe_voice.h defined its own _PATCHKEY and it wasn't
+ * clear whether removing this would break anything in userspace.
+ *
+ * Do not include this file directly.  Please use <sys/soundcard.h> instead.
+ * For kernel code, use <linux/soundcard.h>
+ */
+
+#ifndef _LINUX_PATCHKEY_H_INDIRECT
+#error "patchkey.h included directly"
+#endif
+
+#ifndef _LINUX_PATCHKEY_H
+#define _LINUX_PATCHKEY_H
+
+/* Endian macros. */
+#  include <endian.h>
+
+#if   defined(__BYTE_ORDER)
+#  if __BYTE_ORDER == __BIG_ENDIAN
+#    define _PATCHKEY(id) (0xfd00|id)
+#  elif __BYTE_ORDER == __LITTLE_ENDIAN
+#    define _PATCHKEY(id) ((id<<8)|0x00fd)
+#  else
+#    error "could not determine byte order"
+#  endif
+#endif
+
+#endif /* _LINUX_PATCHKEY_H */
diff -uNr linux-2.6.32/usr/include/linux/pci.h clean_modified/linux-2.6.32/usr/include/linux/pci.h
--- linux-2.6.32/usr/include/linux/pci.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pci.h	2019-04-14 13:24:03.097634879 -0500
@@ -0,0 +1,41 @@
+/*
+ *	pci.h
+ *
+ *	PCI defines and function prototypes
+ *	Copyright 1994, Drew Eckhardt
+ *	Copyright 1997--1999 Martin Mares <mj@ucw.cz>
+ *
+ *	For more information, please consult the following manuals (look at
+ *	http://www.pcisig.com/ for how to get them):
+ *
+ *	PCI BIOS Specification
+ *	PCI Local Bus Specification
+ *	PCI to PCI Bridge Specification
+ *	PCI System Design Guide
+ */
+
+#ifndef LINUX_PCI_H
+#define LINUX_PCI_H
+
+#include <linux/pci_regs.h>	/* The pci register defines */
+
+/*
+ * The PCI interface treats multi-function devices as independent
+ * devices.  The slot/function address of each device is encoded
+ * in a single byte as follows:
+ *
+ *	7:3 = slot
+ *	2:0 = function
+ */
+#define PCI_DEVFN(slot, func)	((((slot) & 0x1f) << 3) | ((func) & 0x07))
+#define PCI_SLOT(devfn)		(((devfn) >> 3) & 0x1f)
+#define PCI_FUNC(devfn)		((devfn) & 0x07)
+
+/* Ioctls for /proc/bus/pci/X/Y nodes. */
+#define PCIIOC_BASE		('P' << 24 | 'C' << 16 | 'I' << 8)
+#define PCIIOC_CONTROLLER	(PCIIOC_BASE | 0x00)	/* Get controller for PCI device. */
+#define PCIIOC_MMAP_IS_IO	(PCIIOC_BASE | 0x01)	/* Set mmap state to I/O space. */
+#define PCIIOC_MMAP_IS_MEM	(PCIIOC_BASE | 0x02)	/* Set mmap state to MEM space. */
+#define PCIIOC_WRITE_COMBINE	(PCIIOC_BASE | 0x03)	/* Enable/disable write-combining. */
+
+#endif /* LINUX_PCI_H */
diff -uNr linux-2.6.32/usr/include/linux/pci_regs.h clean_modified/linux-2.6.32/usr/include/linux/pci_regs.h
--- linux-2.6.32/usr/include/linux/pci_regs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pci_regs.h	2019-04-14 13:24:03.099581600 -0500
@@ -0,0 +1,665 @@
+/*
+ *	pci_regs.h
+ *
+ *	PCI standard defines
+ *	Copyright 1994, Drew Eckhardt
+ *	Copyright 1997--1999 Martin Mares <mj@ucw.cz>
+ *
+ *	For more information, please consult the following manuals (look at
+ *	http://www.pcisig.com/ for how to get them):
+ *
+ *	PCI BIOS Specification
+ *	PCI Local Bus Specification
+ *	PCI to PCI Bridge Specification
+ *	PCI System Design Guide
+ *
+ * 	For hypertransport information, please consult the following manuals
+ * 	from http://www.hypertransport.org
+ *
+ *	The Hypertransport I/O Link Specification
+ */
+
+#ifndef LINUX_PCI_REGS_H
+#define LINUX_PCI_REGS_H
+
+/*
+ * Under PCI, each device has 256 bytes of configuration address space,
+ * of which the first 64 bytes are standardized as follows:
+ */
+#define PCI_VENDOR_ID		0x00	/* 16 bits */
+#define PCI_DEVICE_ID		0x02	/* 16 bits */
+#define PCI_COMMAND		0x04	/* 16 bits */
+#define  PCI_COMMAND_IO		0x1	/* Enable response in I/O space */
+#define  PCI_COMMAND_MEMORY	0x2	/* Enable response in Memory space */
+#define  PCI_COMMAND_MASTER	0x4	/* Enable bus mastering */
+#define  PCI_COMMAND_SPECIAL	0x8	/* Enable response to special cycles */
+#define  PCI_COMMAND_INVALIDATE	0x10	/* Use memory write and invalidate */
+#define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
+#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
+#define  PCI_COMMAND_INTX_DISABLE 0x400 /* INTx Emulation Disable */
+
+#define PCI_STATUS		0x06	/* 16 bits */
+#define  PCI_STATUS_INTERRUPT	0x08	/* Interrupt status */
+#define  PCI_STATUS_CAP_LIST	0x10	/* Support Capability List */
+#define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
+#define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
+#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+#define  PCI_STATUS_DEVSEL_FAST		0x000
+#define  PCI_STATUS_DEVSEL_MEDIUM	0x200
+#define  PCI_STATUS_DEVSEL_SLOW		0x400
+#define  PCI_STATUS_SIG_TARGET_ABORT	0x800 /* Set on target abort */
+#define  PCI_STATUS_REC_TARGET_ABORT	0x1000 /* Master ack of " */
+#define  PCI_STATUS_REC_MASTER_ABORT	0x2000 /* Set on master abort */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR	0x4000 /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY	0x8000 /* Set on parity error */
+
+#define PCI_CLASS_REVISION	0x08	/* High 24 bits are class, low 8 revision */
+#define PCI_REVISION_ID		0x08	/* Revision ID */
+#define PCI_CLASS_PROG		0x09	/* Reg. Level Programming Interface */
+#define PCI_CLASS_DEVICE	0x0a	/* Device class */
+
+#define PCI_CACHE_LINE_SIZE	0x0c	/* 8 bits */
+#define PCI_LATENCY_TIMER	0x0d	/* 8 bits */
+#define PCI_HEADER_TYPE		0x0e	/* 8 bits */
+#define  PCI_HEADER_TYPE_NORMAL		0
+#define  PCI_HEADER_TYPE_BRIDGE		1
+#define  PCI_HEADER_TYPE_CARDBUS	2
+
+#define PCI_BIST		0x0f	/* 8 bits */
+#define  PCI_BIST_CODE_MASK	0x0f	/* Return result */
+#define  PCI_BIST_START		0x40	/* 1 to start BIST, 2 secs or less */
+#define  PCI_BIST_CAPABLE	0x80	/* 1 if BIST capable */
+
+/*
+ * Base addresses specify locations in memory or I/O space.
+ * Decoded size can be determined by writing a value of
+ * 0xffffffff to the register, and reading it back.  Only
+ * 1 bits are decoded.
+ */
+#define PCI_BASE_ADDRESS_0	0x10	/* 32 bits */
+#define PCI_BASE_ADDRESS_1	0x14	/* 32 bits [htype 0,1 only] */
+#define PCI_BASE_ADDRESS_2	0x18	/* 32 bits [htype 0 only] */
+#define PCI_BASE_ADDRESS_3	0x1c	/* 32 bits */
+#define PCI_BASE_ADDRESS_4	0x20	/* 32 bits */
+#define PCI_BASE_ADDRESS_5	0x24	/* 32 bits */
+#define  PCI_BASE_ADDRESS_SPACE		0x01	/* 0 = memory, 1 = I/O */
+#define  PCI_BASE_ADDRESS_SPACE_IO	0x01
+#define  PCI_BASE_ADDRESS_SPACE_MEMORY	0x00
+#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK	0x06
+#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
+#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fUL)
+#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03UL)
+/* bit 1 is reserved if address_space = 1 */
+
+/* Header type 0 (normal devices) */
+#define PCI_CARDBUS_CIS		0x28
+#define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+#define PCI_SUBSYSTEM_ID	0x2e
+#define PCI_ROM_ADDRESS		0x30	/* Bits 31..11 are address, 10..1 reserved */
+#define  PCI_ROM_ADDRESS_ENABLE	0x01
+#define PCI_ROM_ADDRESS_MASK	(~0x7ffUL)
+
+#define PCI_CAPABILITY_LIST	0x34	/* Offset of first capability list entry */
+
+/* 0x35-0x3b are reserved */
+#define PCI_INTERRUPT_LINE	0x3c	/* 8 bits */
+#define PCI_INTERRUPT_PIN	0x3d	/* 8 bits */
+#define PCI_MIN_GNT		0x3e	/* 8 bits */
+#define PCI_MAX_LAT		0x3f	/* 8 bits */
+
+/* Header type 1 (PCI-to-PCI bridges) */
+#define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+#define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+#define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+#define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+#define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+#define PCI_IO_LIMIT		0x1d
+#define  PCI_IO_RANGE_TYPE_MASK	0x0fUL	/* I/O bridging type */
+#define  PCI_IO_RANGE_TYPE_16	0x00
+#define  PCI_IO_RANGE_TYPE_32	0x01
+#define  PCI_IO_RANGE_MASK	(~0x0fUL)
+#define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+#define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+#define PCI_MEMORY_LIMIT	0x22
+#define  PCI_MEMORY_RANGE_TYPE_MASK 0x0fUL
+#define  PCI_MEMORY_RANGE_MASK	(~0x0fUL)
+#define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+#define PCI_PREF_MEMORY_LIMIT	0x26
+#define  PCI_PREF_RANGE_TYPE_MASK 0x0fUL
+#define  PCI_PREF_RANGE_TYPE_32	0x00
+#define  PCI_PREF_RANGE_TYPE_64	0x01
+#define  PCI_PREF_RANGE_MASK	(~0x0fUL)
+#define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+#define PCI_PREF_LIMIT_UPPER32	0x2c
+#define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+#define PCI_IO_LIMIT_UPPER16	0x32
+/* 0x34 same as for htype 0 */
+/* 0x35-0x3b is reserved */
+#define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_BRIDGE_CONTROL	0x3e
+#define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+#define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+#define  PCI_BRIDGE_CTL_ISA	0x04	/* Enable ISA mode */
+#define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+#define  PCI_BRIDGE_CTL_MASTER_ABORT	0x20  /* Report master aborts */
+#define  PCI_BRIDGE_CTL_BUS_RESET	0x40	/* Secondary bus reset */
+#define  PCI_BRIDGE_CTL_FAST_BACK	0x80	/* Fast Back2Back enabled on secondary interface */
+
+/* Header type 2 (CardBus bridges) */
+#define PCI_CB_CAPABILITY_LIST	0x14
+/* 0x15 reserved */
+#define PCI_CB_SEC_STATUS	0x16	/* Secondary status */
+#define PCI_CB_PRIMARY_BUS	0x18	/* PCI bus number */
+#define PCI_CB_CARD_BUS		0x19	/* CardBus bus number */
+#define PCI_CB_SUBORDINATE_BUS	0x1a	/* Subordinate bus number */
+#define PCI_CB_LATENCY_TIMER	0x1b	/* CardBus latency timer */
+#define PCI_CB_MEMORY_BASE_0	0x1c
+#define PCI_CB_MEMORY_LIMIT_0	0x20
+#define PCI_CB_MEMORY_BASE_1	0x24
+#define PCI_CB_MEMORY_LIMIT_1	0x28
+#define PCI_CB_IO_BASE_0	0x2c
+#define PCI_CB_IO_BASE_0_HI	0x2e
+#define PCI_CB_IO_LIMIT_0	0x30
+#define PCI_CB_IO_LIMIT_0_HI	0x32
+#define PCI_CB_IO_BASE_1	0x34
+#define PCI_CB_IO_BASE_1_HI	0x36
+#define PCI_CB_IO_LIMIT_1	0x38
+#define PCI_CB_IO_LIMIT_1_HI	0x3a
+#define  PCI_CB_IO_RANGE_MASK	(~0x03UL)
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_CB_BRIDGE_CONTROL	0x3e
+#define  PCI_CB_BRIDGE_CTL_PARITY	0x01	/* Similar to standard bridge control register */
+#define  PCI_CB_BRIDGE_CTL_SERR		0x02
+#define  PCI_CB_BRIDGE_CTL_ISA		0x04
+#define  PCI_CB_BRIDGE_CTL_VGA		0x08
+#define  PCI_CB_BRIDGE_CTL_MASTER_ABORT	0x20
+#define  PCI_CB_BRIDGE_CTL_CB_RESET	0x40	/* CardBus reset */
+#define  PCI_CB_BRIDGE_CTL_16BIT_INT	0x80	/* Enable interrupt for 16-bit cards */
+#define  PCI_CB_BRIDGE_CTL_PREFETCH_MEM0 0x100	/* Prefetch enable for both memory regions */
+#define  PCI_CB_BRIDGE_CTL_PREFETCH_MEM1 0x200
+#define  PCI_CB_BRIDGE_CTL_POST_WRITES	0x400
+#define PCI_CB_SUBSYSTEM_VENDOR_ID	0x40
+#define PCI_CB_SUBSYSTEM_ID		0x42
+#define PCI_CB_LEGACY_MODE_BASE		0x44	/* 16-bit PC Card legacy mode base address (ExCa) */
+/* 0x48-0x7f reserved */
+
+/* Capability lists */
+
+#define PCI_CAP_LIST_ID		0	/* Capability ID */
+#define  PCI_CAP_ID_PM		0x01	/* Power Management */
+#define  PCI_CAP_ID_AGP		0x02	/* Accelerated Graphics Port */
+#define  PCI_CAP_ID_VPD		0x03	/* Vital Product Data */
+#define  PCI_CAP_ID_SLOTID	0x04	/* Slot Identification */
+#define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
+#define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
+#define  PCI_CAP_ID_PCIX	0x07	/* PCI-X */
+#define  PCI_CAP_ID_HT		0x08	/* HyperTransport */
+#define  PCI_CAP_ID_VNDR	0x09	/* Vendor specific */
+#define  PCI_CAP_ID_DBG		0x0A	/* Debug port */
+#define  PCI_CAP_ID_CCRC	0x0B	/* CompactPCI Central Resource Control */
+#define  PCI_CAP_ID_SHPC 	0x0C	/* PCI Standard Hot-Plug Controller */
+#define  PCI_CAP_ID_SSVID	0x0D	/* Bridge subsystem vendor/device ID */
+#define  PCI_CAP_ID_AGP3	0x0E	/* AGP Target PCI-PCI bridge */
+#define  PCI_CAP_ID_EXP 	0x10	/* PCI Express */
+#define  PCI_CAP_ID_MSIX	0x11	/* MSI-X */
+#define  PCI_CAP_ID_AF		0x13	/* PCI Advanced Features */
+#define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
+#define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
+#define PCI_CAP_SIZEOF		4
+
+/* Power Management Registers */
+
+#define PCI_PM_PMC		2	/* PM Capabilities Register */
+#define  PCI_PM_CAP_VER_MASK	0x0007	/* Version */
+#define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
+#define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
+#define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
+#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxilliary power support mask */
+#define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
+#define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
+#define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
+#define  PCI_PM_CAP_PME_MASK	0xF800	/* PME Mask of all supported states */
+#define  PCI_PM_CAP_PME_D0	0x0800	/* PME# from D0 */
+#define  PCI_PM_CAP_PME_D1	0x1000	/* PME# from D1 */
+#define  PCI_PM_CAP_PME_D2	0x2000	/* PME# from D2 */
+#define  PCI_PM_CAP_PME_D3	0x4000	/* PME# from D3 (hot) */
+#define  PCI_PM_CAP_PME_D3cold	0x8000	/* PME# from D3 (cold) */
+#define  PCI_PM_CAP_PME_SHIFT	11	/* Start of the PME Mask in PMC */
+#define PCI_PM_CTRL		4	/* PM control and status register */
+#define  PCI_PM_CTRL_STATE_MASK	0x0003	/* Current power state (D0 to D3) */
+#define  PCI_PM_CTRL_NO_SOFT_RESET	0x0008	/* No reset for D3hot->D0 */
+#define  PCI_PM_CTRL_PME_ENABLE	0x0100	/* PME pin enable */
+#define  PCI_PM_CTRL_DATA_SEL_MASK	0x1e00	/* Data select (??) */
+#define  PCI_PM_CTRL_DATA_SCALE_MASK	0x6000	/* Data scale (??) */
+#define  PCI_PM_CTRL_PME_STATUS	0x8000	/* PME pin status */
+#define PCI_PM_PPB_EXTENSIONS	6	/* PPB support extensions (??) */
+#define  PCI_PM_PPB_B2_B3	0x40	/* Stop clock when in D3hot (??) */
+#define  PCI_PM_BPCC_ENABLE	0x80	/* Bus power/clock control enable (??) */
+#define PCI_PM_DATA_REGISTER	7	/* (??) */
+#define PCI_PM_SIZEOF		8
+
+/* AGP registers */
+
+#define PCI_AGP_VERSION		2	/* BCD version number */
+#define PCI_AGP_RFU		3	/* Rest of capability flags */
+#define PCI_AGP_STATUS		4	/* Status register */
+#define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
+#define  PCI_AGP_STATUS_SBA	0x0200	/* Sideband addressing supported */
+#define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
+#define  PCI_AGP_STATUS_FW	0x0010	/* FW transfers supported */
+#define  PCI_AGP_STATUS_RATE4	0x0004	/* 4x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE2	0x0002	/* 2x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE1	0x0001	/* 1x transfer rate supported */
+#define PCI_AGP_COMMAND		8	/* Control register */
+#define  PCI_AGP_COMMAND_RQ_MASK 0xff000000  /* Master: Maximum number of requests */
+#define  PCI_AGP_COMMAND_SBA	0x0200	/* Sideband addressing enabled */
+#define  PCI_AGP_COMMAND_AGP	0x0100	/* Allow processing of AGP transactions */
+#define  PCI_AGP_COMMAND_64BIT	0x0020 	/* Allow processing of 64-bit addresses */
+#define  PCI_AGP_COMMAND_FW	0x0010 	/* Force FW transfers */
+#define  PCI_AGP_COMMAND_RATE4	0x0004	/* Use 4x rate */
+#define  PCI_AGP_COMMAND_RATE2	0x0002	/* Use 2x rate */
+#define  PCI_AGP_COMMAND_RATE1	0x0001	/* Use 1x rate */
+#define PCI_AGP_SIZEOF		12
+
+/* Vital Product Data */
+
+#define PCI_VPD_ADDR		2	/* Address to access (15 bits!) */
+#define  PCI_VPD_ADDR_MASK	0x7fff	/* Address mask */
+#define  PCI_VPD_ADDR_F		0x8000	/* Write 0, 1 indicates completion */
+#define PCI_VPD_DATA		4	/* 32-bits of data returned here */
+
+/* Slot Identification */
+
+#define PCI_SID_ESR		2	/* Expansion Slot Register */
+#define  PCI_SID_ESR_NSLOTS	0x1f	/* Number of expansion slots available */
+#define  PCI_SID_ESR_FIC	0x20	/* First In Chassis Flag */
+#define PCI_SID_CHASSIS_NR	3	/* Chassis Number */
+
+/* Message Signalled Interrupts registers */
+
+#define PCI_MSI_FLAGS		2	/* Various flags */
+#define  PCI_MSI_FLAGS_64BIT	0x80	/* 64-bit addresses allowed */
+#define  PCI_MSI_FLAGS_QSIZE	0x70	/* Message queue size configured */
+#define  PCI_MSI_FLAGS_QMASK	0x0e	/* Maximum queue size available */
+#define  PCI_MSI_FLAGS_ENABLE	0x01	/* MSI feature enabled */
+#define  PCI_MSI_FLAGS_MASKBIT	0x100	/* 64-bit mask bits allowed */
+#define PCI_MSI_RFU		3	/* Rest of capability flags */
+#define PCI_MSI_ADDRESS_LO	4	/* Lower 32 bits */
+#define PCI_MSI_ADDRESS_HI	8	/* Upper 32 bits (if PCI_MSI_FLAGS_64BIT set) */
+#define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
+#define PCI_MSI_MASK_32		12	/* Mask bits register for 32-bit devices */
+#define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
+#define PCI_MSI_MASK_64		16	/* Mask bits register for 64-bit devices */
+
+/* MSI-X registers (these are at offset PCI_MSIX_FLAGS) */
+#define PCI_MSIX_FLAGS		2
+#define  PCI_MSIX_FLAGS_QSIZE	0x7FF
+#define  PCI_MSIX_FLAGS_ENABLE	(1 << 15)
+#define  PCI_MSIX_FLAGS_MASKALL	(1 << 14)
+#define PCI_MSIX_FLAGS_BIRMASK	(7 << 0)
+
+/* CompactPCI Hotswap Register */
+
+#define PCI_CHSWP_CSR		2	/* Control and Status Register */
+#define  PCI_CHSWP_DHA		0x01	/* Device Hiding Arm */
+#define  PCI_CHSWP_EIM		0x02	/* ENUM# Signal Mask */
+#define  PCI_CHSWP_PIE		0x04	/* Pending Insert or Extract */
+#define  PCI_CHSWP_LOO		0x08	/* LED On / Off */
+#define  PCI_CHSWP_PI		0x30	/* Programming Interface */
+#define  PCI_CHSWP_EXT		0x40	/* ENUM# status - extraction */
+#define  PCI_CHSWP_INS		0x80	/* ENUM# status - insertion */
+
+/* PCI Advanced Feature registers */
+
+#define PCI_AF_LENGTH		2
+#define PCI_AF_CAP		3
+#define  PCI_AF_CAP_TP		0x01
+#define  PCI_AF_CAP_FLR		0x02
+#define PCI_AF_CTRL		4
+#define  PCI_AF_CTRL_FLR	0x01
+#define PCI_AF_STATUS		5
+#define  PCI_AF_STATUS_TP	0x01
+
+/* PCI-X registers */
+
+#define PCI_X_CMD		2	/* Modes & Features */
+#define  PCI_X_CMD_DPERR_E	0x0001	/* Data Parity Error Recovery Enable */
+#define  PCI_X_CMD_ERO		0x0002	/* Enable Relaxed Ordering */
+#define  PCI_X_CMD_READ_512	0x0000	/* 512 byte maximum read byte count */
+#define  PCI_X_CMD_READ_1K	0x0004	/* 1Kbyte maximum read byte count */
+#define  PCI_X_CMD_READ_2K	0x0008	/* 2Kbyte maximum read byte count */
+#define  PCI_X_CMD_READ_4K	0x000c	/* 4Kbyte maximum read byte count */
+#define  PCI_X_CMD_MAX_READ	0x000c	/* Max Memory Read Byte Count */
+				/* Max # of outstanding split transactions */
+#define  PCI_X_CMD_SPLIT_1	0x0000	/* Max 1 */
+#define  PCI_X_CMD_SPLIT_2	0x0010	/* Max 2 */
+#define  PCI_X_CMD_SPLIT_3	0x0020	/* Max 3 */
+#define  PCI_X_CMD_SPLIT_4	0x0030	/* Max 4 */
+#define  PCI_X_CMD_SPLIT_8	0x0040	/* Max 8 */
+#define  PCI_X_CMD_SPLIT_12	0x0050	/* Max 12 */
+#define  PCI_X_CMD_SPLIT_16	0x0060	/* Max 16 */
+#define  PCI_X_CMD_SPLIT_32	0x0070	/* Max 32 */
+#define  PCI_X_CMD_MAX_SPLIT	0x0070	/* Max Outstanding Split Transactions */
+#define  PCI_X_CMD_VERSION(x) 	(((x) >> 12) & 3) /* Version */
+#define PCI_X_STATUS		4	/* PCI-X capabilities */
+#define  PCI_X_STATUS_DEVFN	0x000000ff	/* A copy of devfn */
+#define  PCI_X_STATUS_BUS	0x0000ff00	/* A copy of bus nr */
+#define  PCI_X_STATUS_64BIT	0x00010000	/* 64-bit device */
+#define  PCI_X_STATUS_133MHZ	0x00020000	/* 133 MHz capable */
+#define  PCI_X_STATUS_SPL_DISC	0x00040000	/* Split Completion Discarded */
+#define  PCI_X_STATUS_UNX_SPL	0x00080000	/* Unexpected Split Completion */
+#define  PCI_X_STATUS_COMPLEX	0x00100000	/* Device Complexity */
+#define  PCI_X_STATUS_MAX_READ	0x00600000	/* Designed Max Memory Read Count */
+#define  PCI_X_STATUS_MAX_SPLIT	0x03800000	/* Designed Max Outstanding Split Transactions */
+#define  PCI_X_STATUS_MAX_CUM	0x1c000000	/* Designed Max Cumulative Read Size */
+#define  PCI_X_STATUS_SPL_ERR	0x20000000	/* Rcvd Split Completion Error Msg */
+#define  PCI_X_STATUS_266MHZ	0x40000000	/* 266 MHz capable */
+#define  PCI_X_STATUS_533MHZ	0x80000000	/* 533 MHz capable */
+
+/* PCI Express capability registers */
+
+#define PCI_EXP_FLAGS		2	/* Capabilities register */
+#define PCI_EXP_FLAGS_VERS	0x000f	/* Capability version */
+#define PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+#define  PCI_EXP_TYPE_ENDPOINT	0x0	/* Express Endpoint */
+#define  PCI_EXP_TYPE_LEG_END	0x1	/* Legacy Endpoint */
+#define  PCI_EXP_TYPE_ROOT_PORT 0x4	/* Root Port */
+#define  PCI_EXP_TYPE_UPSTREAM	0x5	/* Upstream Port */
+#define  PCI_EXP_TYPE_DOWNSTREAM 0x6	/* Downstream Port */
+#define  PCI_EXP_TYPE_PCI_BRIDGE 0x7	/* PCI/PCI-X Bridge */
+#define  PCI_EXP_TYPE_RC_END	0x9	/* Root Complex Integrated Endpoint */
+#define  PCI_EXP_TYPE_RC_EC	0x10	/* Root Complex Event Collector */
+#define PCI_EXP_FLAGS_SLOT	0x0100	/* Slot implemented */
+#define PCI_EXP_FLAGS_IRQ	0x3e00	/* Interrupt message number */
+#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+#define  PCI_EXP_DEVCAP_PAYLOAD	0x07	/* Max_Payload_Size */
+#define  PCI_EXP_DEVCAP_PHANTOM	0x18	/* Phantom functions */
+#define  PCI_EXP_DEVCAP_EXT_TAG	0x20	/* Extended tags */
+#define  PCI_EXP_DEVCAP_L0S	0x1c0	/* L0s Acceptable Latency */
+#define  PCI_EXP_DEVCAP_L1	0xe00	/* L1 Acceptable Latency */
+#define  PCI_EXP_DEVCAP_ATN_BUT	0x1000	/* Attention Button Present */
+#define  PCI_EXP_DEVCAP_ATN_IND	0x2000	/* Attention Indicator Present */
+#define  PCI_EXP_DEVCAP_PWR_IND	0x4000	/* Power Indicator Present */
+#define  PCI_EXP_DEVCAP_RBER	0x8000	/* Role-Based Error Reporting */
+#define  PCI_EXP_DEVCAP_PWR_VAL	0x3fc0000 /* Slot Power Limit Value */
+#define  PCI_EXP_DEVCAP_PWR_SCL	0xc000000 /* Slot Power Limit Scale */
+#define  PCI_EXP_DEVCAP_FLR     0x10000000 /* Function Level Reset */
+#define PCI_EXP_DEVCTL		8	/* Device Control */
+#define  PCI_EXP_DEVCTL_CERE	0x0001	/* Correctable Error Reporting En. */
+#define  PCI_EXP_DEVCTL_NFERE	0x0002	/* Non-Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_FERE	0x0004	/* Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_URRE	0x0008	/* Unsupported Request Reporting En. */
+#define  PCI_EXP_DEVCTL_RELAX_EN 0x0010 /* Enable relaxed ordering */
+#define  PCI_EXP_DEVCTL_PAYLOAD	0x00e0	/* Max_Payload_Size */
+#define  PCI_EXP_DEVCTL_EXT_TAG	0x0100	/* Extended Tag Field Enable */
+#define  PCI_EXP_DEVCTL_PHANTOM	0x0200	/* Phantom Functions Enable */
+#define  PCI_EXP_DEVCTL_AUX_PME	0x0400	/* Auxiliary Power PM Enable */
+#define  PCI_EXP_DEVCTL_NOSNOOP_EN 0x0800  /* Enable No Snoop */
+#define  PCI_EXP_DEVCTL_READRQ	0x7000	/* Max_Read_Request_Size */
+#define  PCI_EXP_DEVCTL_BCR_FLR 0x8000  /* Bridge Configuration Retry / FLR */
+#define PCI_EXP_DEVSTA		10	/* Device Status */
+#define  PCI_EXP_DEVSTA_CED	0x01	/* Correctable Error Detected */
+#define  PCI_EXP_DEVSTA_NFED	0x02	/* Non-Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_FED	0x04	/* Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_URD	0x08	/* Unsupported Request Detected */
+#define  PCI_EXP_DEVSTA_AUXPD	0x10	/* AUX Power Detected */
+#define  PCI_EXP_DEVSTA_TRPND	0x20	/* Transactions Pending */
+#define PCI_EXP_LNKCAP		12	/* Link Capabilities */
+#define  PCI_EXP_LNKCAP_SLS	0x0000000f /* Supported Link Speeds */
+#define  PCI_EXP_LNKCAP_MLW	0x000003f0 /* Maximum Link Width */
+#define  PCI_EXP_LNKCAP_ASPMS	0x00000c00 /* ASPM Support */
+#define  PCI_EXP_LNKCAP_L0SEL	0x00007000 /* L0s Exit Latency */
+#define  PCI_EXP_LNKCAP_L1EL	0x00038000 /* L1 Exit Latency */
+#define  PCI_EXP_LNKCAP_CLKPM	0x00040000 /* L1 Clock Power Management */
+#define  PCI_EXP_LNKCAP_SDERC	0x00080000 /* Suprise Down Error Reporting Capable */
+#define  PCI_EXP_LNKCAP_DLLLARC	0x00100000 /* Data Link Layer Link Active Reporting Capable */
+#define  PCI_EXP_LNKCAP_LBNC	0x00200000 /* Link Bandwidth Notification Capability */
+#define  PCI_EXP_LNKCAP_PN	0xff000000 /* Port Number */
+#define PCI_EXP_LNKCTL		16	/* Link Control */
+#define  PCI_EXP_LNKCTL_ASPMC	0x0003	/* ASPM Control */
+#define  PCI_EXP_LNKCTL_RCB	0x0008	/* Read Completion Boundary */
+#define  PCI_EXP_LNKCTL_LD	0x0010	/* Link Disable */
+#define  PCI_EXP_LNKCTL_RL	0x0020	/* Retrain Link */
+#define  PCI_EXP_LNKCTL_CCC	0x0040	/* Common Clock Configuration */
+#define  PCI_EXP_LNKCTL_ES	0x0080	/* Extended Synch */
+#define  PCI_EXP_LNKCTL_CLKREQ_EN 0x100	/* Enable clkreq */
+#define  PCI_EXP_LNKCTL_HAWD	0x0200	/* Hardware Autonomous Width Disable */
+#define  PCI_EXP_LNKCTL_LBMIE	0x0400	/* Link Bandwidth Management Interrupt Enable */
+#define  PCI_EXP_LNKCTL_LABIE	0x0800	/* Lnk Autonomous Bandwidth Interrupt Enable */
+#define PCI_EXP_LNKSTA		18	/* Link Status */
+#define  PCI_EXP_LNKSTA_CLS	0x000f	/* Current Link Speed */
+#define  PCI_EXP_LNKSTA_NLW	0x03f0	/* Nogotiated Link Width */
+#define  PCI_EXP_LNKSTA_LT	0x0800	/* Link Training */
+#define  PCI_EXP_LNKSTA_SLC	0x1000	/* Slot Clock Configuration */
+#define  PCI_EXP_LNKSTA_DLLLA	0x2000	/* Data Link Layer Link Active */
+#define  PCI_EXP_LNKSTA_LBMS	0x4000	/* Link Bandwidth Management Status */
+#define  PCI_EXP_LNKSTA_LABS	0x8000	/* Link Autonomous Bandwidth Status */
+#define PCI_EXP_SLTCAP		20	/* Slot Capabilities */
+#define  PCI_EXP_SLTCAP_ABP	0x00000001 /* Attention Button Present */
+#define  PCI_EXP_SLTCAP_PCP	0x00000002 /* Power Controller Present */
+#define  PCI_EXP_SLTCAP_MRLSP	0x00000004 /* MRL Sensor Present */
+#define  PCI_EXP_SLTCAP_AIP	0x00000008 /* Attention Indicator Present */
+#define  PCI_EXP_SLTCAP_PIP	0x00000010 /* Power Indicator Present */
+#define  PCI_EXP_SLTCAP_HPS	0x00000020 /* Hot-Plug Surprise */
+#define  PCI_EXP_SLTCAP_HPC	0x00000040 /* Hot-Plug Capable */
+#define  PCI_EXP_SLTCAP_SPLV	0x00007f80 /* Slot Power Limit Value */
+#define  PCI_EXP_SLTCAP_SPLS	0x00018000 /* Slot Power Limit Scale */
+#define  PCI_EXP_SLTCAP_EIP	0x00020000 /* Electromechanical Interlock Present */
+#define  PCI_EXP_SLTCAP_NCCS	0x00040000 /* No Command Completed Support */
+#define  PCI_EXP_SLTCAP_PSN	0xfff80000 /* Physical Slot Number */
+#define PCI_EXP_SLTCTL		24	/* Slot Control */
+#define  PCI_EXP_SLTCTL_ABPE	0x0001	/* Attention Button Pressed Enable */
+#define  PCI_EXP_SLTCTL_PFDE	0x0002	/* Power Fault Detected Enable */
+#define  PCI_EXP_SLTCTL_MRLSCE	0x0004	/* MRL Sensor Changed Enable */
+#define  PCI_EXP_SLTCTL_PDCE	0x0008	/* Presence Detect Changed Enable */
+#define  PCI_EXP_SLTCTL_CCIE	0x0010	/* Command Completed Interrupt Enable */
+#define  PCI_EXP_SLTCTL_HPIE	0x0020	/* Hot-Plug Interrupt Enable */
+#define  PCI_EXP_SLTCTL_AIC	0x00c0	/* Attention Indicator Control */
+#define  PCI_EXP_SLTCTL_PIC	0x0300	/* Power Indicator Control */
+#define  PCI_EXP_SLTCTL_PCC	0x0400	/* Power Controller Control */
+#define  PCI_EXP_SLTCTL_EIC	0x0800	/* Electromechanical Interlock Control */
+#define  PCI_EXP_SLTCTL_DLLSCE	0x1000	/* Data Link Layer State Changed Enable */
+#define PCI_EXP_SLTSTA		26	/* Slot Status */
+#define  PCI_EXP_SLTSTA_ABP	0x0001	/* Attention Button Pressed */
+#define  PCI_EXP_SLTSTA_PFD	0x0002	/* Power Fault Detected */
+#define  PCI_EXP_SLTSTA_MRLSC	0x0004	/* MRL Sensor Changed */
+#define  PCI_EXP_SLTSTA_PDC	0x0008	/* Presence Detect Changed */
+#define  PCI_EXP_SLTSTA_CC	0x0010	/* Command Completed */
+#define  PCI_EXP_SLTSTA_MRLSS	0x0020	/* MRL Sensor State */
+#define  PCI_EXP_SLTSTA_PDS	0x0040	/* Presence Detect State */
+#define  PCI_EXP_SLTSTA_EIS	0x0080	/* Electromechanical Interlock Status */
+#define  PCI_EXP_SLTSTA_DLLSC	0x0100	/* Data Link Layer State Changed */
+#define PCI_EXP_RTCTL		28	/* Root Control */
+#define  PCI_EXP_RTCTL_SECEE	0x01	/* System Error on Correctable Error */
+#define  PCI_EXP_RTCTL_SENFEE	0x02	/* System Error on Non-Fatal Error */
+#define  PCI_EXP_RTCTL_SEFEE	0x04	/* System Error on Fatal Error */
+#define  PCI_EXP_RTCTL_PMEIE	0x08	/* PME Interrupt Enable */
+#define  PCI_EXP_RTCTL_CRSSVE	0x10	/* CRS Software Visibility Enable */
+#define PCI_EXP_RTCAP		30	/* Root Capabilities */
+#define PCI_EXP_RTSTA		32	/* Root Status */
+#define PCI_EXP_DEVCAP2		36	/* Device Capabilities 2 */
+#define  PCI_EXP_DEVCAP2_ARI	0x20	/* Alternative Routing-ID */
+#define PCI_EXP_DEVCTL2		40	/* Device Control 2 */
+#define  PCI_EXP_DEVCTL2_ARI	0x20	/* Alternative Routing-ID */
+#define PCI_EXP_LNKCTL2		48	/* Link Control 2 */
+#define PCI_EXP_SLTCTL2		56	/* Slot Control 2 */
+
+/* Extended Capabilities (PCI-X 2.0 and Express) */
+#define PCI_EXT_CAP_ID(header)		(header & 0x0000ffff)
+#define PCI_EXT_CAP_VER(header)		((header >> 16) & 0xf)
+#define PCI_EXT_CAP_NEXT(header)	((header >> 20) & 0xffc)
+
+#define PCI_EXT_CAP_ID_ERR	1
+#define PCI_EXT_CAP_ID_VC	2
+#define PCI_EXT_CAP_ID_DSN	3
+#define PCI_EXT_CAP_ID_PWR	4
+#define PCI_EXT_CAP_ID_ARI	14
+#define PCI_EXT_CAP_ID_ATS	15
+#define PCI_EXT_CAP_ID_SRIOV	16
+
+/* Advanced Error Reporting */
+#define PCI_ERR_UNCOR_STATUS	4	/* Uncorrectable Error Status */
+#define  PCI_ERR_UNC_TRAIN	0x00000001	/* Training */
+#define  PCI_ERR_UNC_DLP	0x00000010	/* Data Link Protocol */
+#define  PCI_ERR_UNC_POISON_TLP	0x00001000	/* Poisoned TLP */
+#define  PCI_ERR_UNC_FCP	0x00002000	/* Flow Control Protocol */
+#define  PCI_ERR_UNC_COMP_TIME	0x00004000	/* Completion Timeout */
+#define  PCI_ERR_UNC_COMP_ABORT	0x00008000	/* Completer Abort */
+#define  PCI_ERR_UNC_UNX_COMP	0x00010000	/* Unexpected Completion */
+#define  PCI_ERR_UNC_RX_OVER	0x00020000	/* Receiver Overflow */
+#define  PCI_ERR_UNC_MALF_TLP	0x00040000	/* Malformed TLP */
+#define  PCI_ERR_UNC_ECRC	0x00080000	/* ECRC Error Status */
+#define  PCI_ERR_UNC_UNSUP	0x00100000	/* Unsupported Request */
+#define PCI_ERR_UNCOR_MASK	8	/* Uncorrectable Error Mask */
+	/* Same bits as above */
+#define PCI_ERR_UNCOR_SEVER	12	/* Uncorrectable Error Severity */
+	/* Same bits as above */
+#define PCI_ERR_COR_STATUS	16	/* Correctable Error Status */
+#define  PCI_ERR_COR_RCVR	0x00000001	/* Receiver Error Status */
+#define  PCI_ERR_COR_BAD_TLP	0x00000040	/* Bad TLP Status */
+#define  PCI_ERR_COR_BAD_DLLP	0x00000080	/* Bad DLLP Status */
+#define  PCI_ERR_COR_REP_ROLL	0x00000100	/* REPLAY_NUM Rollover */
+#define  PCI_ERR_COR_REP_TIMER	0x00001000	/* Replay Timer Timeout */
+#define PCI_ERR_COR_MASK	20	/* Correctable Error Mask */
+	/* Same bits as above */
+#define PCI_ERR_CAP		24	/* Advanced Error Capabilities */
+#define  PCI_ERR_CAP_FEP(x)	((x) & 31)	/* First Error Pointer */
+#define  PCI_ERR_CAP_ECRC_GENC	0x00000020	/* ECRC Generation Capable */
+#define  PCI_ERR_CAP_ECRC_GENE	0x00000040	/* ECRC Generation Enable */
+#define  PCI_ERR_CAP_ECRC_CHKC	0x00000080	/* ECRC Check Capable */
+#define  PCI_ERR_CAP_ECRC_CHKE	0x00000100	/* ECRC Check Enable */
+#define PCI_ERR_HEADER_LOG	28	/* Header Log Register (16 bytes) */
+#define PCI_ERR_ROOT_COMMAND	44	/* Root Error Command */
+/* Correctable Err Reporting Enable */
+#define PCI_ERR_ROOT_CMD_COR_EN		0x00000001
+/* Non-fatal Err Reporting Enable */
+#define PCI_ERR_ROOT_CMD_NONFATAL_EN	0x00000002
+/* Fatal Err Reporting Enable */
+#define PCI_ERR_ROOT_CMD_FATAL_EN	0x00000004
+#define PCI_ERR_ROOT_STATUS	48
+#define PCI_ERR_ROOT_COR_RCV		0x00000001	/* ERR_COR Received */
+/* Multi ERR_COR Received */
+#define PCI_ERR_ROOT_MULTI_COR_RCV	0x00000002
+/* ERR_FATAL/NONFATAL Recevied */
+#define PCI_ERR_ROOT_UNCOR_RCV		0x00000004
+/* Multi ERR_FATAL/NONFATAL Recevied */
+#define PCI_ERR_ROOT_MULTI_UNCOR_RCV	0x00000008
+#define PCI_ERR_ROOT_FIRST_FATAL	0x00000010	/* First Fatal */
+#define PCI_ERR_ROOT_NONFATAL_RCV	0x00000020	/* Non-Fatal Received */
+#define PCI_ERR_ROOT_FATAL_RCV		0x00000040	/* Fatal Received */
+#define PCI_ERR_ROOT_COR_SRC	52
+#define PCI_ERR_ROOT_SRC	54
+
+/* Virtual Channel */
+#define PCI_VC_PORT_REG1	4
+#define PCI_VC_PORT_REG2	8
+#define PCI_VC_PORT_CTRL	12
+#define PCI_VC_PORT_STATUS	14
+#define PCI_VC_RES_CAP		16
+#define PCI_VC_RES_CTRL		20
+#define PCI_VC_RES_STATUS	26
+
+/* Power Budgeting */
+#define PCI_PWR_DSR		4	/* Data Select Register */
+#define PCI_PWR_DATA		8	/* Data Register */
+#define  PCI_PWR_DATA_BASE(x)	((x) & 0xff)	    /* Base Power */
+#define  PCI_PWR_DATA_SCALE(x)	(((x) >> 8) & 3)    /* Data Scale */
+#define  PCI_PWR_DATA_PM_SUB(x)	(((x) >> 10) & 7)   /* PM Sub State */
+#define  PCI_PWR_DATA_PM_STATE(x) (((x) >> 13) & 3) /* PM State */
+#define  PCI_PWR_DATA_TYPE(x)	(((x) >> 15) & 7)   /* Type */
+#define  PCI_PWR_DATA_RAIL(x)	(((x) >> 18) & 7)   /* Power Rail */
+#define PCI_PWR_CAP		12	/* Capability */
+#define  PCI_PWR_CAP_BUDGET(x)	((x) & 1)	/* Included in system budget */
+
+/*
+ * Hypertransport sub capability types
+ *
+ * Unfortunately there are both 3 bit and 5 bit capability types defined
+ * in the HT spec, catering for that is a little messy. You probably don't
+ * want to use these directly, just use pci_find_ht_capability() and it
+ * will do the right thing for you.
+ */
+#define HT_3BIT_CAP_MASK	0xE0
+#define HT_CAPTYPE_SLAVE	0x00	/* Slave/Primary link configuration */
+#define HT_CAPTYPE_HOST		0x20	/* Host/Secondary link configuration */
+
+#define HT_5BIT_CAP_MASK	0xF8
+#define HT_CAPTYPE_IRQ		0x80	/* IRQ Configuration */
+#define HT_CAPTYPE_REMAPPING_40	0xA0	/* 40 bit address remapping */
+#define HT_CAPTYPE_REMAPPING_64 0xA2	/* 64 bit address remapping */
+#define HT_CAPTYPE_UNITID_CLUMP	0x90	/* Unit ID clumping */
+#define HT_CAPTYPE_EXTCONF	0x98	/* Extended Configuration Space Access */
+#define HT_CAPTYPE_MSI_MAPPING	0xA8	/* MSI Mapping Capability */
+#define  HT_MSI_FLAGS		0x02		/* Offset to flags */
+#define  HT_MSI_FLAGS_ENABLE	0x1		/* Mapping enable */
+#define  HT_MSI_FLAGS_FIXED	0x2		/* Fixed mapping only */
+#define  HT_MSI_FIXED_ADDR	0x00000000FEE00000ULL	/* Fixed addr */
+#define  HT_MSI_ADDR_LO		0x04		/* Offset to low addr bits */
+#define  HT_MSI_ADDR_LO_MASK	0xFFF00000	/* Low address bit mask */
+#define  HT_MSI_ADDR_HI		0x08		/* Offset to high addr bits */
+#define HT_CAPTYPE_DIRECT_ROUTE	0xB0	/* Direct routing configuration */
+#define HT_CAPTYPE_VCSET	0xB8	/* Virtual Channel configuration */
+#define HT_CAPTYPE_ERROR_RETRY	0xC0	/* Retry on error configuration */
+#define HT_CAPTYPE_GEN3		0xD0	/* Generation 3 hypertransport configuration */
+#define HT_CAPTYPE_PM		0xE0	/* Hypertransport powermanagement configuration */
+
+/* Alternative Routing-ID Interpretation */
+#define PCI_ARI_CAP		0x04	/* ARI Capability Register */
+#define  PCI_ARI_CAP_MFVC	0x0001	/* MFVC Function Groups Capability */
+#define  PCI_ARI_CAP_ACS	0x0002	/* ACS Function Groups Capability */
+#define  PCI_ARI_CAP_NFN(x)	(((x) >> 8) & 0xff) /* Next Function Number */
+#define PCI_ARI_CTRL		0x06	/* ARI Control Register */
+#define  PCI_ARI_CTRL_MFVC	0x0001	/* MFVC Function Groups Enable */
+#define  PCI_ARI_CTRL_ACS	0x0002	/* ACS Function Groups Enable */
+#define  PCI_ARI_CTRL_FG(x)	(((x) >> 4) & 7) /* Function Group */
+
+/* Address Translation Service */
+#define PCI_ATS_CAP		0x04	/* ATS Capability Register */
+#define  PCI_ATS_CAP_QDEP(x)	((x) & 0x1f)	/* Invalidate Queue Depth */
+#define  PCI_ATS_MAX_QDEP	32	/* Max Invalidate Queue Depth */
+#define PCI_ATS_CTRL		0x06	/* ATS Control Register */
+#define  PCI_ATS_CTRL_ENABLE	0x8000	/* ATS Enable */
+#define  PCI_ATS_CTRL_STU(x)	((x) & 0x1f)	/* Smallest Translation Unit */
+#define  PCI_ATS_MIN_STU	12	/* shift of minimum STU block */
+
+/* Single Root I/O Virtualization */
+#define PCI_SRIOV_CAP		0x04	/* SR-IOV Capabilities */
+#define  PCI_SRIOV_CAP_VFM	0x01	/* VF Migration Capable */
+#define  PCI_SRIOV_CAP_INTR(x)	((x) >> 21) /* Interrupt Message Number */
+#define PCI_SRIOV_CTRL		0x08	/* SR-IOV Control */
+#define  PCI_SRIOV_CTRL_VFE	0x01	/* VF Enable */
+#define  PCI_SRIOV_CTRL_VFM	0x02	/* VF Migration Enable */
+#define  PCI_SRIOV_CTRL_INTR	0x04	/* VF Migration Interrupt Enable */
+#define  PCI_SRIOV_CTRL_MSE	0x08	/* VF Memory Space Enable */
+#define  PCI_SRIOV_CTRL_ARI	0x10	/* ARI Capable Hierarchy */
+#define PCI_SRIOV_STATUS	0x0a	/* SR-IOV Status */
+#define  PCI_SRIOV_STATUS_VFM	0x01	/* VF Migration Status */
+#define PCI_SRIOV_INITIAL_VF	0x0c	/* Initial VFs */
+#define PCI_SRIOV_TOTAL_VF	0x0e	/* Total VFs */
+#define PCI_SRIOV_NUM_VF	0x10	/* Number of VFs */
+#define PCI_SRIOV_FUNC_LINK	0x12	/* Function Dependency Link */
+#define PCI_SRIOV_VF_OFFSET	0x14	/* First VF Offset */
+#define PCI_SRIOV_VF_STRIDE	0x16	/* Following VF Stride */
+#define PCI_SRIOV_VF_DID	0x1a	/* VF Device ID */
+#define PCI_SRIOV_SUP_PGSIZE	0x1c	/* Supported Page Sizes */
+#define PCI_SRIOV_SYS_PGSIZE	0x20	/* System Page Size */
+#define PCI_SRIOV_BAR		0x24	/* VF BAR0 */
+#define  PCI_SRIOV_NUM_BARS	6	/* Number of VF BARs */
+#define PCI_SRIOV_VFM		0x3c	/* VF Migration State Array Offset*/
+#define  PCI_SRIOV_VFM_BIR(x)	((x) & 7)	/* State BIR */
+#define  PCI_SRIOV_VFM_OFFSET(x) ((x) & ~7)	/* State Offset */
+#define  PCI_SRIOV_VFM_UA	0x0	/* Inactive.Unavailable */
+#define  PCI_SRIOV_VFM_MI	0x1	/* Dormant.MigrateIn */
+#define  PCI_SRIOV_VFM_MO	0x2	/* Active.MigrateOut */
+#define  PCI_SRIOV_VFM_AV	0x3	/* Active.Available */
+
+#endif /* LINUX_PCI_REGS_H */
diff -uNr linux-2.6.32/usr/include/linux/perf_event.h clean_modified/linux-2.6.32/usr/include/linux/perf_event.h
--- linux-2.6.32/usr/include/linux/perf_event.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/perf_event.h	2019-04-14 13:24:03.099581600 -0500
@@ -0,0 +1,428 @@
+/*
+ * Performance events:
+ *
+ *    Copyright (C) 2008-2009, Thomas Gleixner <tglx@linutronix.de>
+ *    Copyright (C) 2008-2009, Red Hat, Inc., Ingo Molnar
+ *    Copyright (C) 2008-2009, Red Hat, Inc., Peter Zijlstra
+ *
+ * Data type definitions, declarations, prototypes.
+ *
+ *    Started by: Thomas Gleixner and Ingo Molnar
+ *
+ * For licencing details see kernel-base/COPYING
+ */
+#ifndef _LINUX_PERF_EVENT_H
+#define _LINUX_PERF_EVENT_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <asm/byteorder.h>
+
+/*
+ * User-space ABI bits:
+ */
+
+/*
+ * attr.type
+ */
+enum perf_type_id {
+	PERF_TYPE_HARDWARE			= 0,
+	PERF_TYPE_SOFTWARE			= 1,
+	PERF_TYPE_TRACEPOINT			= 2,
+	PERF_TYPE_HW_CACHE			= 3,
+	PERF_TYPE_RAW				= 4,
+
+	PERF_TYPE_MAX,				/* non-ABI */
+};
+
+/*
+ * Generalized performance event event_id types, used by the
+ * attr.event_id parameter of the sys_perf_event_open()
+ * syscall:
+ */
+enum perf_hw_id {
+	/*
+	 * Common hardware events, generalized by the kernel:
+	 */
+	PERF_COUNT_HW_CPU_CYCLES		= 0,
+	PERF_COUNT_HW_INSTRUCTIONS		= 1,
+	PERF_COUNT_HW_CACHE_REFERENCES		= 2,
+	PERF_COUNT_HW_CACHE_MISSES		= 3,
+	PERF_COUNT_HW_BRANCH_INSTRUCTIONS	= 4,
+	PERF_COUNT_HW_BRANCH_MISSES		= 5,
+	PERF_COUNT_HW_BUS_CYCLES		= 6,
+
+	PERF_COUNT_HW_MAX,			/* non-ABI */
+};
+
+/*
+ * Generalized hardware cache events:
+ *
+ *       { L1-D, L1-I, LLC, ITLB, DTLB, BPU } x
+ *       { read, write, prefetch } x
+ *       { accesses, misses }
+ */
+enum perf_hw_cache_id {
+	PERF_COUNT_HW_CACHE_L1D			= 0,
+	PERF_COUNT_HW_CACHE_L1I			= 1,
+	PERF_COUNT_HW_CACHE_LL			= 2,
+	PERF_COUNT_HW_CACHE_DTLB		= 3,
+	PERF_COUNT_HW_CACHE_ITLB		= 4,
+	PERF_COUNT_HW_CACHE_BPU			= 5,
+
+	PERF_COUNT_HW_CACHE_MAX,		/* non-ABI */
+};
+
+enum perf_hw_cache_op_id {
+	PERF_COUNT_HW_CACHE_OP_READ		= 0,
+	PERF_COUNT_HW_CACHE_OP_WRITE		= 1,
+	PERF_COUNT_HW_CACHE_OP_PREFETCH		= 2,
+
+	PERF_COUNT_HW_CACHE_OP_MAX,		/* non-ABI */
+};
+
+enum perf_hw_cache_op_result_id {
+	PERF_COUNT_HW_CACHE_RESULT_ACCESS	= 0,
+	PERF_COUNT_HW_CACHE_RESULT_MISS		= 1,
+
+	PERF_COUNT_HW_CACHE_RESULT_MAX,		/* non-ABI */
+};
+
+/*
+ * Special "software" events provided by the kernel, even if the hardware
+ * does not support performance events. These events measure various
+ * physical and sw events of the kernel (and allow the profiling of them as
+ * well):
+ */
+enum perf_sw_ids {
+	PERF_COUNT_SW_CPU_CLOCK			= 0,
+	PERF_COUNT_SW_TASK_CLOCK		= 1,
+	PERF_COUNT_SW_PAGE_FAULTS		= 2,
+	PERF_COUNT_SW_CONTEXT_SWITCHES		= 3,
+	PERF_COUNT_SW_CPU_MIGRATIONS		= 4,
+	PERF_COUNT_SW_PAGE_FAULTS_MIN		= 5,
+	PERF_COUNT_SW_PAGE_FAULTS_MAJ		= 6,
+
+	PERF_COUNT_SW_MAX,			/* non-ABI */
+};
+
+/*
+ * Bits that can be set in attr.sample_type to request information
+ * in the overflow packets.
+ */
+enum perf_event_sample_format {
+	PERF_SAMPLE_IP				= 1U << 0,
+	PERF_SAMPLE_TID				= 1U << 1,
+	PERF_SAMPLE_TIME			= 1U << 2,
+	PERF_SAMPLE_ADDR			= 1U << 3,
+	PERF_SAMPLE_READ			= 1U << 4,
+	PERF_SAMPLE_CALLCHAIN			= 1U << 5,
+	PERF_SAMPLE_ID				= 1U << 6,
+	PERF_SAMPLE_CPU				= 1U << 7,
+	PERF_SAMPLE_PERIOD			= 1U << 8,
+	PERF_SAMPLE_STREAM_ID			= 1U << 9,
+	PERF_SAMPLE_RAW				= 1U << 10,
+
+	PERF_SAMPLE_MAX = 1U << 11,		/* non-ABI */
+};
+
+/*
+ * The format of the data returned by read() on a perf event fd,
+ * as specified by attr.read_format:
+ *
+ * struct read_format {
+ *	{ u64		value;
+ *	  { u64		time_enabled; } && PERF_FORMAT_ENABLED
+ *	  { u64		time_running; } && PERF_FORMAT_RUNNING
+ *	  { u64		id;           } && PERF_FORMAT_ID
+ *	} && !PERF_FORMAT_GROUP
+ *
+ *	{ u64		nr;
+ *	  { u64		time_enabled; } && PERF_FORMAT_ENABLED
+ *	  { u64		time_running; } && PERF_FORMAT_RUNNING
+ *	  { u64		value;
+ *	    { u64	id;           } && PERF_FORMAT_ID
+ *	  }		cntr[nr];
+ *	} && PERF_FORMAT_GROUP
+ * };
+ */
+enum perf_event_read_format {
+	PERF_FORMAT_TOTAL_TIME_ENABLED		= 1U << 0,
+	PERF_FORMAT_TOTAL_TIME_RUNNING		= 1U << 1,
+	PERF_FORMAT_ID				= 1U << 2,
+	PERF_FORMAT_GROUP			= 1U << 3,
+
+	PERF_FORMAT_MAX = 1U << 4,		/* non-ABI */
+};
+
+#define PERF_ATTR_SIZE_VER0	64	/* sizeof first published struct */
+
+/*
+ * Hardware event_id to monitor via a performance monitoring event:
+ */
+struct perf_event_attr {
+
+	/*
+	 * Major type: hardware/software/tracepoint/etc.
+	 */
+	__u32			type;
+
+	/*
+	 * Size of the attr structure, for fwd/bwd compat.
+	 */
+	__u32			size;
+
+	/*
+	 * Type specific configuration information.
+	 */
+	__u64			config;
+
+	union {
+		__u64		sample_period;
+		__u64		sample_freq;
+	};
+
+	__u64			sample_type;
+	__u64			read_format;
+
+	__u64			disabled       :  1, /* off by default        */
+				inherit	       :  1, /* children inherit it   */
+				pinned	       :  1, /* must always be on PMU */
+				exclusive      :  1, /* only group on PMU     */
+				exclude_user   :  1, /* don't count user      */
+				exclude_kernel :  1, /* ditto kernel          */
+				exclude_hv     :  1, /* ditto hypervisor      */
+				exclude_idle   :  1, /* don't count when idle */
+				mmap           :  1, /* include mmap data     */
+				comm	       :  1, /* include comm data     */
+				freq           :  1, /* use freq, not period  */
+				inherit_stat   :  1, /* per task counts       */
+				enable_on_exec :  1, /* next exec enables     */
+				task           :  1, /* trace fork/exit       */
+				watermark      :  1, /* wakeup_watermark      */
+
+				__reserved_1   : 49;
+
+	union {
+		__u32		wakeup_events;	  /* wakeup every n events */
+		__u32		wakeup_watermark; /* bytes before wakeup   */
+	};
+	__u32			__reserved_2;
+
+	__u64			__reserved_3;
+};
+
+/*
+ * Ioctls that can be done on a perf event fd:
+ */
+#define PERF_EVENT_IOC_ENABLE		_IO ('$', 0)
+#define PERF_EVENT_IOC_DISABLE		_IO ('$', 1)
+#define PERF_EVENT_IOC_REFRESH		_IO ('$', 2)
+#define PERF_EVENT_IOC_RESET		_IO ('$', 3)
+#define PERF_EVENT_IOC_PERIOD		_IOW('$', 4, u64)
+#define PERF_EVENT_IOC_SET_OUTPUT	_IO ('$', 5)
+
+enum perf_event_ioc_flags {
+	PERF_IOC_FLAG_GROUP		= 1U << 0,
+};
+
+/*
+ * Structure of the page that can be mapped via mmap
+ */
+struct perf_event_mmap_page {
+	__u32	version;		/* version number of this structure */
+	__u32	compat_version;		/* lowest version this is compat with */
+
+	/*
+	 * Bits needed to read the hw events in user-space.
+	 *
+	 *   u32 seq;
+	 *   s64 count;
+	 *
+	 *   do {
+	 *     seq = pc->lock;
+	 *
+	 *     barrier()
+	 *     if (pc->index) {
+	 *       count = pmc_read(pc->index - 1);
+	 *       count += pc->offset;
+	 *     } else
+	 *       goto regular_read;
+	 *
+	 *     barrier();
+	 *   } while (pc->lock != seq);
+	 *
+	 * NOTE: for obvious reason this only works on self-monitoring
+	 *       processes.
+	 */
+	__u32	lock;			/* seqlock for synchronization */
+	__u32	index;			/* hardware event identifier */
+	__s64	offset;			/* add to hardware event value */
+	__u64	time_enabled;		/* time event active */
+	__u64	time_running;		/* time event on cpu */
+
+		/*
+		 * Hole for extension of the self monitor capabilities
+		 */
+
+	__u64	__reserved[123];	/* align to 1k */
+
+	/*
+	 * Control data for the mmap() data buffer.
+	 *
+	 * User-space reading the @data_head value should issue an rmb(), on
+	 * SMP capable platforms, after reading this value -- see
+	 * perf_event_wakeup().
+	 *
+	 * When the mapping is PROT_WRITE the @data_tail value should be
+	 * written by userspace to reflect the last read data. In this case
+	 * the kernel will not over-write unread data.
+	 */
+	__u64   data_head;		/* head in the data section */
+	__u64	data_tail;		/* user-space written tail */
+};
+
+#define PERF_RECORD_MISC_CPUMODE_MASK		(3 << 0)
+#define PERF_RECORD_MISC_CPUMODE_UNKNOWN		(0 << 0)
+#define PERF_RECORD_MISC_KERNEL			(1 << 0)
+#define PERF_RECORD_MISC_USER			(2 << 0)
+#define PERF_RECORD_MISC_HYPERVISOR		(3 << 0)
+
+struct perf_event_header {
+	__u32	type;
+	__u16	misc;
+	__u16	size;
+};
+
+enum perf_event_type {
+
+	/*
+	 * The MMAP events record the PROT_EXEC mappings so that we can
+	 * correlate userspace IPs to code. They have the following structure:
+	 *
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	u32				pid, tid;
+	 *	u64				addr;
+	 *	u64				len;
+	 *	u64				pgoff;
+	 *	char				filename[];
+	 * };
+	 */
+	PERF_RECORD_MMAP			= 1,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u64				id;
+	 *	u64				lost;
+	 * };
+	 */
+	PERF_RECORD_LOST			= 2,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	u32				pid, tid;
+	 *	char				comm[];
+	 * };
+	 */
+	PERF_RECORD_COMM			= 3,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u32				pid, ppid;
+	 *	u32				tid, ptid;
+	 *	u64				time;
+	 * };
+	 */
+	PERF_RECORD_EXIT			= 4,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u64				time;
+	 *	u64				id;
+	 *	u64				stream_id;
+	 * };
+	 */
+	PERF_RECORD_THROTTLE		= 5,
+	PERF_RECORD_UNTHROTTLE		= 6,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *	u32				pid, ppid;
+	 *	u32				tid, ptid;
+	 *	u64				time;
+	 * };
+	 */
+	PERF_RECORD_FORK			= 7,
+
+	/*
+	 * struct {
+	 * 	struct perf_event_header	header;
+	 * 	u32				pid, tid;
+	 *
+	 * 	struct read_format		values;
+	 * };
+	 */
+	PERF_RECORD_READ			= 8,
+
+	/*
+	 * struct {
+	 *	struct perf_event_header	header;
+	 *
+	 *	{ u64			ip;	  } && PERF_SAMPLE_IP
+	 *	{ u32			pid, tid; } && PERF_SAMPLE_TID
+	 *	{ u64			time;     } && PERF_SAMPLE_TIME
+	 *	{ u64			addr;     } && PERF_SAMPLE_ADDR
+	 *	{ u64			id;	  } && PERF_SAMPLE_ID
+	 *	{ u64			stream_id;} && PERF_SAMPLE_STREAM_ID
+	 *	{ u32			cpu, res; } && PERF_SAMPLE_CPU
+	 *	{ u64			period;   } && PERF_SAMPLE_PERIOD
+	 *
+	 *	{ struct read_format	values;	  } && PERF_SAMPLE_READ
+	 *
+	 *	{ u64			nr,
+	 *	  u64			ips[nr];  } && PERF_SAMPLE_CALLCHAIN
+	 *
+	 *	#
+	 *	# The RAW record below is opaque data wrt the ABI
+	 *	#
+	 *	# That is, the ABI doesn't make any promises wrt to
+	 *	# the stability of its content, it may vary depending
+	 *	# on event, hardware, kernel version and phase of
+	 *	# the moon.
+	 *	#
+	 *	# In other words, PERF_SAMPLE_RAW contents are not an ABI.
+	 *	#
+	 *
+	 *	{ u32			size;
+	 *	  char                  data[size];}&& PERF_SAMPLE_RAW
+	 * };
+	 */
+	PERF_RECORD_SAMPLE		= 9,
+
+	PERF_RECORD_MAX,			/* non-ABI */
+};
+
+enum perf_callchain_context {
+	PERF_CONTEXT_HV			= (__u64)-32,
+	PERF_CONTEXT_KERNEL		= (__u64)-128,
+	PERF_CONTEXT_USER		= (__u64)-512,
+
+	PERF_CONTEXT_GUEST		= (__u64)-2048,
+	PERF_CONTEXT_GUEST_KERNEL	= (__u64)-2176,
+	PERF_CONTEXT_GUEST_USER		= (__u64)-2560,
+
+	PERF_CONTEXT_MAX		= (__u64)-4095,
+};
+
+#define PERF_FLAG_FD_NO_GROUP	(1U << 0)
+#define PERF_FLAG_FD_OUTPUT	(1U << 1)
+
+#endif /* _LINUX_PERF_EVENT_H */
diff -uNr linux-2.6.32/usr/include/linux/personality.h clean_modified/linux-2.6.32/usr/include/linux/personality.h
--- linux-2.6.32/usr/include/linux/personality.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/personality.h	2019-04-14 13:24:03.107347379 -0500
@@ -0,0 +1,68 @@
+#ifndef _LINUX_PERSONALITY_H
+#define _LINUX_PERSONALITY_H
+
+
+/*
+ * Flags for bug emulation.
+ *
+ * These occupy the top three bytes.
+ */
+enum {
+	ADDR_NO_RANDOMIZE = 	0x0040000,	/* disable randomization of VA space */
+	FDPIC_FUNCPTRS =	0x0080000,	/* userspace function ptrs point to descriptors
+						 * (signal handling)
+						 */
+	MMAP_PAGE_ZERO =	0x0100000,
+	ADDR_COMPAT_LAYOUT =	0x0200000,
+	READ_IMPLIES_EXEC =	0x0400000,
+	ADDR_LIMIT_32BIT =	0x0800000,
+	SHORT_INODE =		0x1000000,
+	WHOLE_SECONDS =		0x2000000,
+	STICKY_TIMEOUTS	=	0x4000000,
+	ADDR_LIMIT_3GB = 	0x8000000,
+};
+
+/*
+ * Security-relevant compatibility flags that must be
+ * cleared upon setuid or setgid exec:
+ */
+#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC  | \
+			    ADDR_NO_RANDOMIZE  | \
+			    ADDR_COMPAT_LAYOUT | \
+			    MMAP_PAGE_ZERO)
+
+/*
+ * Personality types.
+ *
+ * These go in the low byte.  Avoid using the top bit, it will
+ * conflict with error returns.
+ */
+enum {
+	PER_LINUX =		0x0000,
+	PER_LINUX_32BIT =	0x0000 | ADDR_LIMIT_32BIT,
+	PER_LINUX_FDPIC =	0x0000 | FDPIC_FUNCPTRS,
+	PER_SVR4 =		0x0001 | STICKY_TIMEOUTS | MMAP_PAGE_ZERO,
+	PER_SVR3 =		0x0002 | STICKY_TIMEOUTS | SHORT_INODE,
+	PER_SCOSVR3 =		0x0003 | STICKY_TIMEOUTS |
+					 WHOLE_SECONDS | SHORT_INODE,
+	PER_OSR5 =		0x0003 | STICKY_TIMEOUTS | WHOLE_SECONDS,
+	PER_WYSEV386 =		0x0004 | STICKY_TIMEOUTS | SHORT_INODE,
+	PER_ISCR4 =		0x0005 | STICKY_TIMEOUTS,
+	PER_BSD =		0x0006,
+	PER_SUNOS =		0x0006 | STICKY_TIMEOUTS,
+	PER_XENIX =		0x0007 | STICKY_TIMEOUTS | SHORT_INODE,
+	PER_LINUX32 =		0x0008,
+	PER_LINUX32_3GB =	0x0008 | ADDR_LIMIT_3GB,
+	PER_IRIX32 =		0x0009 | STICKY_TIMEOUTS,/* IRIX5 32-bit */
+	PER_IRIXN32 =		0x000a | STICKY_TIMEOUTS,/* IRIX6 new 32-bit */
+	PER_IRIX64 =		0x000b | STICKY_TIMEOUTS,/* IRIX6 64-bit */
+	PER_RISCOS =		0x000c,
+	PER_SOLARIS =		0x000d | STICKY_TIMEOUTS,
+	PER_UW7 =		0x000e | STICKY_TIMEOUTS | MMAP_PAGE_ZERO,
+	PER_OSF4 =		0x000f,			 /* OSF/1 v4 */
+	PER_HPUX =		0x0010,
+	PER_MASK =		0x00ff,
+};
+
+
+#endif /* _LINUX_PERSONALITY_H */
diff -uNr linux-2.6.32/usr/include/linux/pfkeyv2.h clean_modified/linux-2.6.32/usr/include/linux/pfkeyv2.h
--- linux-2.6.32/usr/include/linux/pfkeyv2.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pfkeyv2.h	2019-04-14 13:24:03.108370746 -0500
@@ -0,0 +1,369 @@
+/* PF_KEY user interface, this is defined by rfc2367 so
+ * do not make arbitrary modifications or else this header
+ * file will not be compliant.
+ */
+
+#ifndef _LINUX_PFKEY2_H
+#define _LINUX_PFKEY2_H
+
+#include <linux/types.h>
+
+#define PF_KEY_V2		2
+#define PFKEYV2_REVISION	199806L
+
+struct sadb_msg {
+	__u8		sadb_msg_version;
+	__u8		sadb_msg_type;
+	__u8		sadb_msg_errno;
+	__u8		sadb_msg_satype;
+	__u16	sadb_msg_len;
+	__u16	sadb_msg_reserved;
+	__u32	sadb_msg_seq;
+	__u32	sadb_msg_pid;
+} __attribute__((packed));
+/* sizeof(struct sadb_msg) == 16 */
+
+struct sadb_ext {
+	__u16	sadb_ext_len;
+	__u16	sadb_ext_type;
+} __attribute__((packed));
+/* sizeof(struct sadb_ext) == 4 */
+
+struct sadb_sa {
+	__u16	sadb_sa_len;
+	__u16	sadb_sa_exttype;
+	__be32		sadb_sa_spi;
+	__u8		sadb_sa_replay;
+	__u8		sadb_sa_state;
+	__u8		sadb_sa_auth;
+	__u8		sadb_sa_encrypt;
+	__u32	sadb_sa_flags;
+} __attribute__((packed));
+/* sizeof(struct sadb_sa) == 16 */
+
+struct sadb_lifetime {
+	__u16	sadb_lifetime_len;
+	__u16	sadb_lifetime_exttype;
+	__u32	sadb_lifetime_allocations;
+	__u64	sadb_lifetime_bytes;
+	__u64	sadb_lifetime_addtime;
+	__u64	sadb_lifetime_usetime;
+} __attribute__((packed));
+/* sizeof(struct sadb_lifetime) == 32 */
+
+struct sadb_address {
+	__u16	sadb_address_len;
+	__u16	sadb_address_exttype;
+	__u8		sadb_address_proto;
+	__u8		sadb_address_prefixlen;
+	__u16	sadb_address_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_address) == 8 */
+
+struct sadb_key {
+	__u16	sadb_key_len;
+	__u16	sadb_key_exttype;
+	__u16	sadb_key_bits;
+	__u16	sadb_key_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_key) == 8 */
+
+struct sadb_ident {
+	__u16	sadb_ident_len;
+	__u16	sadb_ident_exttype;
+	__u16	sadb_ident_type;
+	__u16	sadb_ident_reserved;
+	__u64	sadb_ident_id;
+} __attribute__((packed));
+/* sizeof(struct sadb_ident) == 16 */
+
+struct sadb_sens {
+	__u16	sadb_sens_len;
+	__u16	sadb_sens_exttype;
+	__u32	sadb_sens_dpd;
+	__u8		sadb_sens_sens_level;
+	__u8		sadb_sens_sens_len;
+	__u8		sadb_sens_integ_level;
+	__u8		sadb_sens_integ_len;
+	__u32	sadb_sens_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_sens) == 16 */
+
+/* followed by:
+	__u64	sadb_sens_bitmap[sens_len];
+	__u64	sadb_integ_bitmap[integ_len];  */
+
+struct sadb_prop {
+	__u16	sadb_prop_len;
+	__u16	sadb_prop_exttype;
+	__u8		sadb_prop_replay;
+	__u8		sadb_prop_reserved[3];
+} __attribute__((packed));
+/* sizeof(struct sadb_prop) == 8 */
+
+/* followed by:
+	struct sadb_comb sadb_combs[(sadb_prop_len +
+		sizeof(__u64) - sizeof(struct sadb_prop)) /
+		sizeof(struct sadb_comb)]; */
+
+struct sadb_comb {
+	__u8		sadb_comb_auth;
+	__u8		sadb_comb_encrypt;
+	__u16	sadb_comb_flags;
+	__u16	sadb_comb_auth_minbits;
+	__u16	sadb_comb_auth_maxbits;
+	__u16	sadb_comb_encrypt_minbits;
+	__u16	sadb_comb_encrypt_maxbits;
+	__u32	sadb_comb_reserved;
+	__u32	sadb_comb_soft_allocations;
+	__u32	sadb_comb_hard_allocations;
+	__u64	sadb_comb_soft_bytes;
+	__u64	sadb_comb_hard_bytes;
+	__u64	sadb_comb_soft_addtime;
+	__u64	sadb_comb_hard_addtime;
+	__u64	sadb_comb_soft_usetime;
+	__u64	sadb_comb_hard_usetime;
+} __attribute__((packed));
+/* sizeof(struct sadb_comb) == 72 */
+
+struct sadb_supported {
+	__u16	sadb_supported_len;
+	__u16	sadb_supported_exttype;
+	__u32	sadb_supported_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_supported) == 8 */
+
+/* followed by:
+	struct sadb_alg sadb_algs[(sadb_supported_len +
+		sizeof(__u64) - sizeof(struct sadb_supported)) /
+		sizeof(struct sadb_alg)]; */
+
+struct sadb_alg {
+	__u8		sadb_alg_id;
+	__u8		sadb_alg_ivlen;
+	__u16	sadb_alg_minbits;
+	__u16	sadb_alg_maxbits;
+	__u16	sadb_alg_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_alg) == 8 */
+
+struct sadb_spirange {
+	__u16	sadb_spirange_len;
+	__u16	sadb_spirange_exttype;
+	__u32	sadb_spirange_min;
+	__u32	sadb_spirange_max;
+	__u32	sadb_spirange_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_spirange) == 16 */
+
+struct sadb_x_kmprivate {
+	__u16	sadb_x_kmprivate_len;
+	__u16	sadb_x_kmprivate_exttype;
+	__u32	sadb_x_kmprivate_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_kmprivate) == 8 */
+
+struct sadb_x_sa2 {
+	__u16	sadb_x_sa2_len;
+	__u16	sadb_x_sa2_exttype;
+	__u8		sadb_x_sa2_mode;
+	__u8		sadb_x_sa2_reserved1;
+	__u16	sadb_x_sa2_reserved2;
+	__u32	sadb_x_sa2_sequence;
+	__u32	sadb_x_sa2_reqid;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_sa2) == 16 */
+
+struct sadb_x_policy {
+	__u16	sadb_x_policy_len;
+	__u16	sadb_x_policy_exttype;
+	__u16	sadb_x_policy_type;
+	__u8		sadb_x_policy_dir;
+	__u8		sadb_x_policy_reserved;
+	__u32	sadb_x_policy_id;
+	__u32	sadb_x_policy_priority;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_policy) == 16 */
+
+struct sadb_x_ipsecrequest {
+	__u16	sadb_x_ipsecrequest_len;
+	__u16	sadb_x_ipsecrequest_proto;
+	__u8		sadb_x_ipsecrequest_mode;
+	__u8		sadb_x_ipsecrequest_level;
+	__u16	sadb_x_ipsecrequest_reserved1;
+	__u32	sadb_x_ipsecrequest_reqid;
+	__u32	sadb_x_ipsecrequest_reserved2;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_ipsecrequest) == 16 */
+
+/* This defines the TYPE of Nat Traversal in use.  Currently only one
+ * type of NAT-T is supported, draft-ietf-ipsec-udp-encaps-06
+ */
+struct sadb_x_nat_t_type {
+	__u16	sadb_x_nat_t_type_len;
+	__u16	sadb_x_nat_t_type_exttype;
+	__u8		sadb_x_nat_t_type_type;
+	__u8		sadb_x_nat_t_type_reserved[3];
+} __attribute__((packed));
+/* sizeof(struct sadb_x_nat_t_type) == 8 */
+
+/* Pass a NAT Traversal port (Source or Dest port) */
+struct sadb_x_nat_t_port {
+	__u16	sadb_x_nat_t_port_len;
+	__u16	sadb_x_nat_t_port_exttype;
+	__be16		sadb_x_nat_t_port_port;
+	__u16	sadb_x_nat_t_port_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_nat_t_port) == 8 */
+
+/* Generic LSM security context */
+struct sadb_x_sec_ctx {
+	__u16	sadb_x_sec_len;
+	__u16	sadb_x_sec_exttype;
+	__u8		sadb_x_ctx_alg;  /* LSMs: e.g., selinux == 1 */
+	__u8		sadb_x_ctx_doi;
+	__u16	sadb_x_ctx_len;
+} __attribute__((packed));
+/* sizeof(struct sadb_sec_ctx) = 8 */
+
+/* Used by MIGRATE to pass addresses IKE will use to perform
+ * negotiation with the peer */
+struct sadb_x_kmaddress {
+	__u16	sadb_x_kmaddress_len;
+	__u16	sadb_x_kmaddress_exttype;
+	__u32	sadb_x_kmaddress_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_kmaddress) == 8 */
+
+/* Message types */
+#define SADB_RESERVED		0
+#define SADB_GETSPI		1
+#define SADB_UPDATE		2
+#define SADB_ADD		3
+#define SADB_DELETE		4
+#define SADB_GET		5
+#define SADB_ACQUIRE		6
+#define SADB_REGISTER		7
+#define SADB_EXPIRE		8
+#define SADB_FLUSH		9
+#define SADB_DUMP		10
+#define SADB_X_PROMISC		11
+#define SADB_X_PCHANGE		12
+#define SADB_X_SPDUPDATE	13
+#define SADB_X_SPDADD		14
+#define SADB_X_SPDDELETE	15
+#define SADB_X_SPDGET		16
+#define SADB_X_SPDACQUIRE	17
+#define SADB_X_SPDDUMP		18
+#define SADB_X_SPDFLUSH		19
+#define SADB_X_SPDSETIDX	20
+#define SADB_X_SPDEXPIRE	21
+#define SADB_X_SPDDELETE2	22
+#define SADB_X_NAT_T_NEW_MAPPING	23
+#define SADB_X_MIGRATE		24
+#define SADB_MAX		24
+
+/* Security Association flags */
+#define SADB_SAFLAGS_PFS	1
+#define SADB_SAFLAGS_NOPMTUDISC	0x20000000
+#define SADB_SAFLAGS_DECAP_DSCP	0x40000000
+#define SADB_SAFLAGS_NOECN	0x80000000
+
+/* Security Association states */
+#define SADB_SASTATE_LARVAL	0
+#define SADB_SASTATE_MATURE	1
+#define SADB_SASTATE_DYING	2
+#define SADB_SASTATE_DEAD	3
+#define SADB_SASTATE_MAX	3
+
+/* Security Association types */
+#define SADB_SATYPE_UNSPEC	0
+#define SADB_SATYPE_AH		2
+#define SADB_SATYPE_ESP		3
+#define SADB_SATYPE_RSVP	5
+#define SADB_SATYPE_OSPFV2	6
+#define SADB_SATYPE_RIPV2	7
+#define SADB_SATYPE_MIP		8
+#define SADB_X_SATYPE_IPCOMP	9
+#define SADB_SATYPE_MAX		9
+
+/* Authentication algorithms */
+#define SADB_AALG_NONE			0
+#define SADB_AALG_MD5HMAC		2
+#define SADB_AALG_SHA1HMAC		3
+#define SADB_X_AALG_SHA2_256HMAC	5
+#define SADB_X_AALG_SHA2_384HMAC	6
+#define SADB_X_AALG_SHA2_512HMAC	7
+#define SADB_X_AALG_RIPEMD160HMAC	8
+#define SADB_X_AALG_AES_XCBC_MAC	9
+#define SADB_X_AALG_NULL		251	/* kame */
+#define SADB_AALG_MAX			251
+
+/* Encryption algorithms */
+#define SADB_EALG_NONE			0
+#define SADB_EALG_DESCBC		2
+#define SADB_EALG_3DESCBC		3
+#define SADB_X_EALG_CASTCBC		6
+#define SADB_X_EALG_BLOWFISHCBC		7
+#define SADB_EALG_NULL			11
+#define SADB_X_EALG_AESCBC		12
+#define SADB_X_EALG_AESCTR		13
+#define SADB_X_EALG_AES_CCM_ICV8	14
+#define SADB_X_EALG_AES_CCM_ICV12	15
+#define SADB_X_EALG_AES_CCM_ICV16	16
+#define SADB_X_EALG_AES_GCM_ICV8	18
+#define SADB_X_EALG_AES_GCM_ICV12	19
+#define SADB_X_EALG_AES_GCM_ICV16	20
+#define SADB_X_EALG_CAMELLIACBC		22
+#define SADB_EALG_MAX                   253 /* last EALG */
+/* private allocations should use 249-255 (RFC2407) */
+#define SADB_X_EALG_SERPENTCBC  252     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
+#define SADB_X_EALG_TWOFISHCBC  253     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
+
+/* Compression algorithms */
+#define SADB_X_CALG_NONE		0
+#define SADB_X_CALG_OUI			1
+#define SADB_X_CALG_DEFLATE		2
+#define SADB_X_CALG_LZS			3
+#define SADB_X_CALG_LZJH		4
+#define SADB_X_CALG_MAX			4
+
+/* Extension Header values */
+#define SADB_EXT_RESERVED		0
+#define SADB_EXT_SA			1
+#define SADB_EXT_LIFETIME_CURRENT	2
+#define SADB_EXT_LIFETIME_HARD		3
+#define SADB_EXT_LIFETIME_SOFT		4
+#define SADB_EXT_ADDRESS_SRC		5
+#define SADB_EXT_ADDRESS_DST		6
+#define SADB_EXT_ADDRESS_PROXY		7
+#define SADB_EXT_KEY_AUTH		8
+#define SADB_EXT_KEY_ENCRYPT		9
+#define SADB_EXT_IDENTITY_SRC		10
+#define SADB_EXT_IDENTITY_DST		11
+#define SADB_EXT_SENSITIVITY		12
+#define SADB_EXT_PROPOSAL		13
+#define SADB_EXT_SUPPORTED_AUTH		14
+#define SADB_EXT_SUPPORTED_ENCRYPT	15
+#define SADB_EXT_SPIRANGE		16
+#define SADB_X_EXT_KMPRIVATE		17
+#define SADB_X_EXT_POLICY		18
+#define SADB_X_EXT_SA2			19
+/* The next four entries are for setting up NAT Traversal */
+#define SADB_X_EXT_NAT_T_TYPE		20
+#define SADB_X_EXT_NAT_T_SPORT		21
+#define SADB_X_EXT_NAT_T_DPORT		22
+#define SADB_X_EXT_NAT_T_OA		23
+#define SADB_X_EXT_SEC_CTX		24
+/* Used with MIGRATE to pass @ to IKE for negotiation */
+#define SADB_X_EXT_KMADDRESS		25
+#define SADB_EXT_MAX			25
+
+/* Identity Extension values */
+#define SADB_IDENTTYPE_RESERVED	0
+#define SADB_IDENTTYPE_PREFIX	1
+#define SADB_IDENTTYPE_FQDN	2
+#define SADB_IDENTTYPE_USERFQDN	3
+#define SADB_IDENTTYPE_MAX	3
+
+#endif /* !(_LINUX_PFKEY2_H) */
diff -uNr linux-2.6.32/usr/include/linux/pg.h clean_modified/linux-2.6.32/usr/include/linux/pg.h
--- linux-2.6.32/usr/include/linux/pg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pg.h	2019-04-14 13:24:03.108370746 -0500
@@ -0,0 +1,63 @@
+/* 	pg.h (c) 1998  Grant R. Guenther <grant@torque.net>
+ 		       Under the terms of the GNU General Public License
+
+
+	pg.h defines the user interface to the generic ATAPI packet
+        command driver for parallel port ATAPI devices (pg). The
+	driver is loosely modelled after the generic SCSI driver, sg,
+	although the actual interface is different.
+
+	The pg driver provides a simple character device interface for
+        sending ATAPI commands to a device.  With the exception of the
+	ATAPI reset operation, all operations are performed by a pair
+        of read and write operations to the appropriate /dev/pgN device.
+	A write operation delivers a command and any outbound data in
+        a single buffer.  Normally, the write will succeed unless the
+        device is offline or malfunctioning, or there is already another
+	command pending.  If the write succeeds, it should be followed
+        immediately by a read operation, to obtain any returned data and
+        status information.  A read will fail if there is no operation
+        in progress.
+
+	As a special case, the device can be reset with a write operation,
+        and in this case, no following read is expected, or permitted.
+
+	There are no ioctl() operations.  Any single operation
+	may transfer at most PG_MAX_DATA bytes.  Note that the driver must
+        copy the data through an internal buffer.  In keeping with all
+	current ATAPI devices, command packets are assumed to be exactly
+	12 bytes in length.
+
+	To permit future changes to this interface, the headers in the
+	read and write buffers contain a single character "magic" flag.
+        Currently this flag must be the character "P".
+
+*/
+
+#define PG_MAGIC	'P'
+#define PG_RESET	'Z'
+#define PG_COMMAND	'C'
+
+#define PG_MAX_DATA	32768
+
+struct pg_write_hdr {
+
+	char	magic;		/* == PG_MAGIC */
+	char	func;		/* PG_RESET or PG_COMMAND */
+	int     dlen;		/* number of bytes expected to transfer */
+	int     timeout;	/* number of seconds before timeout */
+	char	packet[12];	/* packet command */
+
+};
+
+struct pg_read_hdr {
+
+	char	magic;		/* == PG_MAGIC */
+	char	scsi;		/* "scsi" status == sense key */
+	int	dlen;		/* size of device transfer request */
+	int     duration;	/* time in seconds command took */
+	char    pad[12];	/* not used */
+
+};
+
+/* end of pg.h */
diff -uNr linux-2.6.32/usr/include/linux/phantom.h clean_modified/linux-2.6.32/usr/include/linux/phantom.h
--- linux-2.6.32/usr/include/linux/phantom.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/phantom.h	2019-04-14 13:24:03.109302756 -0500
@@ -0,0 +1,49 @@
+/*
+ *  Copyright (C) 2005-2007 Jiri Slaby <jirislaby@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ */
+
+#ifndef __PHANTOM_H
+#define __PHANTOM_H
+
+#include <linux/types.h>
+
+/* PHN_(G/S)ET_REG param */
+struct phm_reg {
+	__u32 reg;
+	__u32 value;
+};
+
+/* PHN_(G/S)ET_REGS param */
+struct phm_regs {
+	__u32 count;
+	__u32 mask;
+	__u32 values[8];
+};
+
+#define PH_IOC_MAGIC		'p'
+#define PHN_GET_REG		_IOWR(PH_IOC_MAGIC, 0, struct phm_reg *)
+#define PHN_SET_REG		_IOW(PH_IOC_MAGIC, 1, struct phm_reg *)
+#define PHN_GET_REGS		_IOWR(PH_IOC_MAGIC, 2, struct phm_regs *)
+#define PHN_SET_REGS		_IOW(PH_IOC_MAGIC, 3, struct phm_regs *)
+/* this ioctl tells the driver, that the caller is not OpenHaptics and might
+ * use improved registers update (no more phantom switchoffs when using
+ * libphantom) */
+#define PHN_NOT_OH		_IO(PH_IOC_MAGIC, 4)
+#define PHN_GETREG		_IOWR(PH_IOC_MAGIC, 5, struct phm_reg)
+#define PHN_SETREG		_IOW(PH_IOC_MAGIC, 6, struct phm_reg)
+#define PHN_GETREGS		_IOWR(PH_IOC_MAGIC, 7, struct phm_regs)
+#define PHN_SETREGS		_IOW(PH_IOC_MAGIC, 8, struct phm_regs)
+
+#define PHN_CONTROL		0x6     /* control byte in iaddr space */
+#define PHN_CTL_AMP		0x1     /*   switch after torques change */
+#define PHN_CTL_BUT		0x2     /*   is button switched */
+#define PHN_CTL_IRQ		0x10    /*   is irq enabled */
+
+#define PHN_ZERO_FORCE		2048	/* zero torque on motor */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/phonet.h clean_modified/linux-2.6.32/usr/include/linux/phonet.h
--- linux-2.6.32/usr/include/linux/phonet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/phonet.h	2019-04-14 13:24:03.109302756 -0500
@@ -0,0 +1,179 @@
+/**
+ * file phonet.h
+ *
+ * Phonet sockets kernel interface
+ *
+ * Copyright (C) 2008 Nokia Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef LINUX_PHONET_H
+#define LINUX_PHONET_H
+
+#include <linux/types.h>
+
+/* Automatic protocol selection */
+#define PN_PROTO_TRANSPORT	0
+/* Phonet datagram socket */
+#define PN_PROTO_PHONET		1
+/* Phonet pipe */
+#define PN_PROTO_PIPE		2
+#define PHONET_NPROTO		3
+
+/* Socket options for SOL_PNPIPE level */
+#define PNPIPE_ENCAP		1
+#define PNPIPE_IFINDEX		2
+
+#define PNADDR_ANY		0
+#define PNADDR_BROADCAST	0xFC
+#define PNPORT_RESOURCE_ROUTING	0
+
+/* Values for PNPIPE_ENCAP option */
+#define PNPIPE_ENCAP_NONE	0
+#define PNPIPE_ENCAP_IP		1
+
+/* ioctls */
+#define SIOCPNGETOBJECT		(SIOCPROTOPRIVATE + 0)
+
+/* Phonet protocol header */
+struct phonethdr {
+	__u8	pn_rdev;
+	__u8	pn_sdev;
+	__u8	pn_res;
+	__be16	pn_length;
+	__u8	pn_robj;
+	__u8	pn_sobj;
+} __attribute__((packed));
+
+/* Common Phonet payload header */
+struct phonetmsg {
+	__u8	pn_trans_id;	/* transaction ID */
+	__u8	pn_msg_id;	/* message type */
+	union {
+		struct {
+			__u8	pn_submsg_id;	/* message subtype */
+			__u8	pn_data[5];
+		} base;
+		struct {
+			__u16	pn_e_res_id;	/* extended resource ID */
+			__u8	pn_e_submsg_id;	/* message subtype */
+			__u8	pn_e_data[3];
+		} ext;
+	} pn_msg_u;
+};
+#define PN_COMMON_MESSAGE	0xF0
+#define PN_COMMGR		0x10
+#define PN_PREFIX		0xE0 /* resource for extended messages */
+#define pn_submsg_id		pn_msg_u.base.pn_submsg_id
+#define pn_e_submsg_id		pn_msg_u.ext.pn_e_submsg_id
+#define pn_e_res_id		pn_msg_u.ext.pn_e_res_id
+#define pn_data			pn_msg_u.base.pn_data
+#define pn_e_data		pn_msg_u.ext.pn_e_data
+
+/* data for unreachable errors */
+#define PN_COMM_SERVICE_NOT_IDENTIFIED_RESP	0x01
+#define PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP	0x14
+#define pn_orig_msg_id		pn_data[0]
+#define pn_status		pn_data[1]
+#define pn_e_orig_msg_id	pn_e_data[0]
+#define pn_e_status		pn_e_data[1]
+
+/* Phonet socket address structure */
+struct sockaddr_pn {
+	sa_family_t spn_family;
+	__u8 spn_obj;
+	__u8 spn_dev;
+	__u8 spn_resource;
+	__u8 spn_zero[sizeof(struct sockaddr) - sizeof(sa_family_t) - 3];
+} __attribute__ ((packed));
+
+/* Well known address */
+#define PN_DEV_PC	0x10
+
+static __inline__ __u16 pn_object(__u8 addr, __u16 port)
+{
+	return (addr << 8) | (port & 0x3ff);
+}
+
+static __inline__ __u8 pn_obj(__u16 handle)
+{
+	return handle & 0xff;
+}
+
+static __inline__ __u8 pn_dev(__u16 handle)
+{
+	return handle >> 8;
+}
+
+static __inline__ __u16 pn_port(__u16 handle)
+{
+	return handle & 0x3ff;
+}
+
+static __inline__ __u8 pn_addr(__u16 handle)
+{
+	return (handle >> 8) & 0xfc;
+}
+
+static __inline__ void pn_sockaddr_set_addr(struct sockaddr_pn *spn, __u8 addr)
+{
+	spn->spn_dev &= 0x03;
+	spn->spn_dev |= addr & 0xfc;
+}
+
+static __inline__ void pn_sockaddr_set_port(struct sockaddr_pn *spn, __u16 port)
+{
+	spn->spn_dev &= 0xfc;
+	spn->spn_dev |= (port >> 8) & 0x03;
+	spn->spn_obj = port & 0xff;
+}
+
+static __inline__ void pn_sockaddr_set_object(struct sockaddr_pn *spn,
+						__u16 handle)
+{
+	spn->spn_dev = pn_dev(handle);
+	spn->spn_obj = pn_obj(handle);
+}
+
+static __inline__ void pn_sockaddr_set_resource(struct sockaddr_pn *spn,
+						__u8 resource)
+{
+	spn->spn_resource = resource;
+}
+
+static __inline__ __u8 pn_sockaddr_get_addr(const struct sockaddr_pn *spn)
+{
+	return spn->spn_dev & 0xfc;
+}
+
+static __inline__ __u16 pn_sockaddr_get_port(const struct sockaddr_pn *spn)
+{
+	return ((spn->spn_dev & 0x03) << 8) | spn->spn_obj;
+}
+
+static __inline__ __u16 pn_sockaddr_get_object(const struct sockaddr_pn *spn)
+{
+	return pn_object(spn->spn_dev, spn->spn_obj);
+}
+
+static __inline__ __u8 pn_sockaddr_get_resource(const struct sockaddr_pn *spn)
+{
+	return spn->spn_resource;
+}
+
+/* Phonet device ioctl requests */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/pktcdvd.h clean_modified/linux-2.6.32/usr/include/linux/pktcdvd.h
--- linux-2.6.32/usr/include/linux/pktcdvd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pktcdvd.h	2019-04-14 13:24:03.109302756 -0500
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2000 Jens Axboe <axboe@suse.de>
+ * Copyright (C) 2001-2004 Peter Osterlund <petero2@telia.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Packet writing layer for ATAPI and SCSI CD-R, CD-RW, DVD-R, and
+ * DVD-RW devices.
+ *
+ */
+#ifndef __PKTCDVD_H
+#define __PKTCDVD_H
+
+#include <linux/types.h>
+
+/*
+ * 1 for normal debug messages, 2 is very verbose. 0 to turn it off.
+ */
+#define PACKET_DEBUG		1
+
+#define	MAX_WRITERS		8
+
+#define PKT_RB_POOL_SIZE	512
+
+/*
+ * How long we should hold a non-full packet before starting data gathering.
+ */
+#define PACKET_WAIT_TIME	(HZ * 5 / 1000)
+
+/*
+ * use drive write caching -- we need deferred error handling to be
+ * able to sucessfully recover with this option (drive will return good
+ * status as soon as the cdb is validated).
+ */
+#if defined(CONFIG_CDROM_PKTCDVD_WCACHE)
+#define USE_WCACHING		1
+#else
+#define USE_WCACHING		0
+#endif
+
+/*
+ * No user-servicable parts beyond this point ->
+ */
+
+/*
+ * device types
+ */
+#define PACKET_CDR		1
+#define	PACKET_CDRW		2
+#define PACKET_DVDR		3
+#define PACKET_DVDRW		4
+
+/*
+ * flags
+ */
+#define PACKET_WRITABLE		1	/* pd is writable */
+#define PACKET_NWA_VALID	2	/* next writable address valid */
+#define PACKET_LRA_VALID	3	/* last recorded address valid */
+#define PACKET_MERGE_SEGS	4	/* perform segment merging to keep */
+					/* underlying cdrom device happy */
+
+/*
+ * Disc status -- from READ_DISC_INFO
+ */
+#define PACKET_DISC_EMPTY	0
+#define PACKET_DISC_INCOMPLETE	1
+#define PACKET_DISC_COMPLETE	2
+#define PACKET_DISC_OTHER	3
+
+/*
+ * write type, and corresponding data block type
+ */
+#define PACKET_MODE1		1
+#define PACKET_MODE2		2
+#define PACKET_BLOCK_MODE1	8
+#define PACKET_BLOCK_MODE2	10
+
+/*
+ * Last session/border status
+ */
+#define PACKET_SESSION_EMPTY		0
+#define PACKET_SESSION_INCOMPLETE	1
+#define PACKET_SESSION_RESERVED		2
+#define PACKET_SESSION_COMPLETE		3
+
+#define PACKET_MCN			"4a656e734178626f65323030300000"
+
+#undef PACKET_USE_LS
+
+#define PKT_CTRL_CMD_SETUP	0
+#define PKT_CTRL_CMD_TEARDOWN	1
+#define PKT_CTRL_CMD_STATUS	2
+
+struct pkt_ctrl_command {
+	__u32 command;				/* in: Setup, teardown, status */
+	__u32 dev_index;			/* in/out: Device index */
+	__u32 dev;				/* in/out: Device nr for cdrw device */
+	__u32 pkt_dev;				/* in/out: Device nr for packet device */
+	__u32 num_devices;			/* out: Largest device index + 1 */
+	__u32 padding;				/* Not used */
+};
+
+/*
+ * packet ioctls
+ */
+#define PACKET_IOCTL_MAGIC	('X')
+#define PACKET_CTRL_CMD		_IOWR(PACKET_IOCTL_MAGIC, 1, struct pkt_ctrl_command)
+
+
+#endif /* __PKTCDVD_H */
diff -uNr linux-2.6.32/usr/include/linux/pkt_cls.h clean_modified/linux-2.6.32/usr/include/linux/pkt_cls.h
--- linux-2.6.32/usr/include/linux/pkt_cls.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pkt_cls.h	2019-04-14 13:24:03.110273904 -0500
@@ -0,0 +1,494 @@
+#ifndef __LINUX_PKT_CLS_H
+#define __LINUX_PKT_CLS_H
+
+#include <linux/types.h>
+#include <linux/pkt_sched.h>
+
+/* I think i could have done better macros ; for now this is stolen from
+ * some arch/mips code - jhs
+*/
+#define _TC_MAKE32(x) ((x))
+
+#define _TC_MAKEMASK1(n) (_TC_MAKE32(1) << _TC_MAKE32(n))
+#define _TC_MAKEMASK(v,n) (_TC_MAKE32((_TC_MAKE32(1)<<(v))-1) << _TC_MAKE32(n))
+#define _TC_MAKEVALUE(v,n) (_TC_MAKE32(v) << _TC_MAKE32(n))
+#define _TC_GETVALUE(v,n,m) ((_TC_MAKE32(v) & _TC_MAKE32(m)) >> _TC_MAKE32(n))
+
+/* verdict bit breakdown 
+ *
+bit 0: when set -> this packet has been munged already
+
+bit 1: when set -> It is ok to munge this packet
+
+bit 2,3,4,5: Reclassify counter - sort of reverse TTL - if exceeded
+assume loop
+
+bit 6,7: Where this packet was last seen 
+0: Above the transmit example at the socket level
+1: on the Ingress
+2: on the Egress
+
+bit 8: when set --> Request not to classify on ingress. 
+
+bits 9,10,11: redirect counter -  redirect TTL. Loop avoidance
+
+ *
+ * */
+
+#define TC_MUNGED          _TC_MAKEMASK1(0)
+#define SET_TC_MUNGED(v)   ( TC_MUNGED | (v & ~TC_MUNGED))
+#define CLR_TC_MUNGED(v)   ( v & ~TC_MUNGED)
+
+#define TC_OK2MUNGE        _TC_MAKEMASK1(1)
+#define SET_TC_OK2MUNGE(v)   ( TC_OK2MUNGE | (v & ~TC_OK2MUNGE))
+#define CLR_TC_OK2MUNGE(v)   ( v & ~TC_OK2MUNGE)
+
+#define S_TC_VERD          _TC_MAKE32(2)
+#define M_TC_VERD          _TC_MAKEMASK(4,S_TC_VERD)
+#define G_TC_VERD(x)       _TC_GETVALUE(x,S_TC_VERD,M_TC_VERD)
+#define V_TC_VERD(x)       _TC_MAKEVALUE(x,S_TC_VERD)
+#define SET_TC_VERD(v,n)   ((V_TC_VERD(n)) | (v & ~M_TC_VERD))
+
+#define S_TC_FROM          _TC_MAKE32(6)
+#define M_TC_FROM          _TC_MAKEMASK(2,S_TC_FROM)
+#define G_TC_FROM(x)       _TC_GETVALUE(x,S_TC_FROM,M_TC_FROM)
+#define V_TC_FROM(x)       _TC_MAKEVALUE(x,S_TC_FROM)
+#define SET_TC_FROM(v,n)   ((V_TC_FROM(n)) | (v & ~M_TC_FROM))
+#define AT_STACK	0x0
+#define AT_INGRESS	0x1
+#define AT_EGRESS	0x2
+
+#define TC_NCLS          _TC_MAKEMASK1(8)
+#define SET_TC_NCLS(v)   ( TC_NCLS | (v & ~TC_NCLS))
+#define CLR_TC_NCLS(v)   ( v & ~TC_NCLS)
+
+#define S_TC_RTTL          _TC_MAKE32(9)
+#define M_TC_RTTL          _TC_MAKEMASK(3,S_TC_RTTL)
+#define G_TC_RTTL(x)       _TC_GETVALUE(x,S_TC_RTTL,M_TC_RTTL)
+#define V_TC_RTTL(x)       _TC_MAKEVALUE(x,S_TC_RTTL)
+#define SET_TC_RTTL(v,n)   ((V_TC_RTTL(n)) | (v & ~M_TC_RTTL))
+
+#define S_TC_AT          _TC_MAKE32(12)
+#define M_TC_AT          _TC_MAKEMASK(2,S_TC_AT)
+#define G_TC_AT(x)       _TC_GETVALUE(x,S_TC_AT,M_TC_AT)
+#define V_TC_AT(x)       _TC_MAKEVALUE(x,S_TC_AT)
+#define SET_TC_AT(v,n)   ((V_TC_AT(n)) | (v & ~M_TC_AT))
+
+/* Action attributes */
+enum
+{
+	TCA_ACT_UNSPEC,
+	TCA_ACT_KIND,
+	TCA_ACT_OPTIONS,
+	TCA_ACT_INDEX,
+	TCA_ACT_STATS,
+	__TCA_ACT_MAX
+};
+
+#define TCA_ACT_MAX __TCA_ACT_MAX
+#define TCA_OLD_COMPAT (TCA_ACT_MAX+1)
+#define TCA_ACT_MAX_PRIO 32
+#define TCA_ACT_BIND	1
+#define TCA_ACT_NOBIND	0
+#define TCA_ACT_UNBIND	1
+#define TCA_ACT_NOUNBIND	0
+#define TCA_ACT_REPLACE		1
+#define TCA_ACT_NOREPLACE	0
+#define MAX_REC_LOOP 4
+#define MAX_RED_LOOP 4
+
+#define TC_ACT_UNSPEC	(-1)
+#define TC_ACT_OK		0
+#define TC_ACT_RECLASSIFY	1
+#define TC_ACT_SHOT		2
+#define TC_ACT_PIPE		3
+#define TC_ACT_STOLEN		4
+#define TC_ACT_QUEUED		5
+#define TC_ACT_REPEAT		6
+#define TC_ACT_JUMP		0x10000000
+
+/* Action type identifiers*/
+enum
+{
+	TCA_ID_UNSPEC=0,
+	TCA_ID_POLICE=1,
+	/* other actions go here */
+	__TCA_ID_MAX=255
+};
+
+#define TCA_ID_MAX __TCA_ID_MAX
+
+struct tc_police
+{
+	__u32			index;
+	int			action;
+#define TC_POLICE_UNSPEC	TC_ACT_UNSPEC
+#define TC_POLICE_OK		TC_ACT_OK
+#define TC_POLICE_RECLASSIFY	TC_ACT_RECLASSIFY
+#define TC_POLICE_SHOT		TC_ACT_SHOT
+#define TC_POLICE_PIPE		TC_ACT_PIPE
+
+	__u32			limit;
+	__u32			burst;
+	__u32			mtu;
+	struct tc_ratespec	rate;
+	struct tc_ratespec	peakrate;
+	int 			refcnt;
+	int 			bindcnt;
+	__u32			capab;
+};
+
+struct tcf_t
+{
+	__u64   install;
+	__u64   lastuse;
+	__u64   expires;
+};
+
+struct tc_cnt
+{
+	int                   refcnt; 
+	int                   bindcnt;
+};
+
+#define tc_gen \
+	__u32                 index; \
+	__u32                 capab; \
+	int                   action; \
+	int                   refcnt; \
+	int                   bindcnt
+
+enum
+{
+	TCA_POLICE_UNSPEC,
+	TCA_POLICE_TBF,
+	TCA_POLICE_RATE,
+	TCA_POLICE_PEAKRATE,
+	TCA_POLICE_AVRATE,
+	TCA_POLICE_RESULT,
+	__TCA_POLICE_MAX
+#define TCA_POLICE_RESULT TCA_POLICE_RESULT
+};
+
+#define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
+
+/* U32 filters */
+
+#define TC_U32_HTID(h) ((h)&0xFFF00000)
+#define TC_U32_USERHTID(h) (TC_U32_HTID(h)>>20)
+#define TC_U32_HASH(h) (((h)>>12)&0xFF)
+#define TC_U32_NODE(h) ((h)&0xFFF)
+#define TC_U32_KEY(h) ((h)&0xFFFFF)
+#define TC_U32_UNSPEC	0
+#define TC_U32_ROOT	(0xFFF00000)
+
+enum
+{
+	TCA_U32_UNSPEC,
+	TCA_U32_CLASSID,
+	TCA_U32_HASH,
+	TCA_U32_LINK,
+	TCA_U32_DIVISOR,
+	TCA_U32_SEL,
+	TCA_U32_POLICE,
+	TCA_U32_ACT,   
+	TCA_U32_INDEV,
+	TCA_U32_PCNT,
+	TCA_U32_MARK,
+	__TCA_U32_MAX
+};
+
+#define TCA_U32_MAX (__TCA_U32_MAX - 1)
+
+struct tc_u32_key
+{
+	__be32		mask;
+	__be32		val;
+	int		off;
+	int		offmask;
+};
+
+struct tc_u32_sel
+{
+	unsigned char		flags;
+	unsigned char		offshift;
+	unsigned char		nkeys;
+
+	__be16			offmask;
+	__u16			off;
+	short			offoff;
+
+	short			hoff;
+	__be32			hmask;
+	struct tc_u32_key	keys[0];
+};
+
+struct tc_u32_mark
+{
+	__u32		val;
+	__u32		mask;
+	__u32		success;
+};
+
+struct tc_u32_pcnt
+{
+	__u64 rcnt;
+	__u64 rhit;
+	__u64 kcnts[0];
+};
+
+/* Flags */
+
+#define TC_U32_TERMINAL		1
+#define TC_U32_OFFSET		2
+#define TC_U32_VAROFFSET	4
+#define TC_U32_EAT		8
+
+#define TC_U32_MAXDEPTH 8
+
+
+/* RSVP filter */
+
+enum
+{
+	TCA_RSVP_UNSPEC,
+	TCA_RSVP_CLASSID,
+	TCA_RSVP_DST,
+	TCA_RSVP_SRC,
+	TCA_RSVP_PINFO,
+	TCA_RSVP_POLICE,
+	TCA_RSVP_ACT,
+	__TCA_RSVP_MAX
+};
+
+#define TCA_RSVP_MAX (__TCA_RSVP_MAX - 1 )
+
+struct tc_rsvp_gpi
+{
+	__u32	key;
+	__u32	mask;
+	int	offset;
+};
+
+struct tc_rsvp_pinfo
+{
+	struct tc_rsvp_gpi dpi;
+	struct tc_rsvp_gpi spi;
+	__u8	protocol;
+	__u8	tunnelid;
+	__u8	tunnelhdr;
+	__u8	pad;
+};
+
+/* ROUTE filter */
+
+enum
+{
+	TCA_ROUTE4_UNSPEC,
+	TCA_ROUTE4_CLASSID,
+	TCA_ROUTE4_TO,
+	TCA_ROUTE4_FROM,
+	TCA_ROUTE4_IIF,
+	TCA_ROUTE4_POLICE,
+	TCA_ROUTE4_ACT,
+	__TCA_ROUTE4_MAX
+};
+
+#define TCA_ROUTE4_MAX (__TCA_ROUTE4_MAX - 1)
+
+
+/* FW filter */
+
+enum
+{
+	TCA_FW_UNSPEC,
+	TCA_FW_CLASSID,
+	TCA_FW_POLICE,
+	TCA_FW_INDEV, /*  used by CONFIG_NET_CLS_IND */
+	TCA_FW_ACT, /* used by CONFIG_NET_CLS_ACT */
+	TCA_FW_MASK,
+	__TCA_FW_MAX
+};
+
+#define TCA_FW_MAX (__TCA_FW_MAX - 1)
+
+/* TC index filter */
+
+enum
+{
+	TCA_TCINDEX_UNSPEC,
+	TCA_TCINDEX_HASH,
+	TCA_TCINDEX_MASK,
+	TCA_TCINDEX_SHIFT,
+	TCA_TCINDEX_FALL_THROUGH,
+	TCA_TCINDEX_CLASSID,
+	TCA_TCINDEX_POLICE,
+	TCA_TCINDEX_ACT,
+	__TCA_TCINDEX_MAX
+};
+
+#define TCA_TCINDEX_MAX     (__TCA_TCINDEX_MAX - 1)
+
+/* Flow filter */
+
+enum
+{
+	FLOW_KEY_SRC,
+	FLOW_KEY_DST,
+	FLOW_KEY_PROTO,
+	FLOW_KEY_PROTO_SRC,
+	FLOW_KEY_PROTO_DST,
+	FLOW_KEY_IIF,
+	FLOW_KEY_PRIORITY,
+	FLOW_KEY_MARK,
+	FLOW_KEY_NFCT,
+	FLOW_KEY_NFCT_SRC,
+	FLOW_KEY_NFCT_DST,
+	FLOW_KEY_NFCT_PROTO_SRC,
+	FLOW_KEY_NFCT_PROTO_DST,
+	FLOW_KEY_RTCLASSID,
+	FLOW_KEY_SKUID,
+	FLOW_KEY_SKGID,
+	FLOW_KEY_VLAN_TAG,
+	__FLOW_KEY_MAX,
+};
+
+#define FLOW_KEY_MAX	(__FLOW_KEY_MAX - 1)
+
+enum
+{
+	FLOW_MODE_MAP,
+	FLOW_MODE_HASH,
+};
+
+enum
+{
+	TCA_FLOW_UNSPEC,
+	TCA_FLOW_KEYS,
+	TCA_FLOW_MODE,
+	TCA_FLOW_BASECLASS,
+	TCA_FLOW_RSHIFT,
+	TCA_FLOW_ADDEND,
+	TCA_FLOW_MASK,
+	TCA_FLOW_XOR,
+	TCA_FLOW_DIVISOR,
+	TCA_FLOW_ACT,
+	TCA_FLOW_POLICE,
+	TCA_FLOW_EMATCHES,
+	TCA_FLOW_PERTURB,
+	__TCA_FLOW_MAX
+};
+
+#define TCA_FLOW_MAX	(__TCA_FLOW_MAX - 1)
+
+/* Basic filter */
+
+enum
+{
+	TCA_BASIC_UNSPEC,
+	TCA_BASIC_CLASSID,
+	TCA_BASIC_EMATCHES,
+	TCA_BASIC_ACT,
+	TCA_BASIC_POLICE,
+	__TCA_BASIC_MAX
+};
+
+#define TCA_BASIC_MAX (__TCA_BASIC_MAX - 1)
+
+
+/* Cgroup classifier */
+
+enum
+{
+	TCA_CGROUP_UNSPEC,
+	TCA_CGROUP_ACT,
+	TCA_CGROUP_POLICE,
+	TCA_CGROUP_EMATCHES,
+	__TCA_CGROUP_MAX,
+};
+
+#define TCA_CGROUP_MAX (__TCA_CGROUP_MAX - 1)
+
+/* Extended Matches */
+
+struct tcf_ematch_tree_hdr
+{
+	__u16		nmatches;
+	__u16		progid;
+};
+
+enum
+{
+	TCA_EMATCH_TREE_UNSPEC,
+	TCA_EMATCH_TREE_HDR,
+	TCA_EMATCH_TREE_LIST,
+	__TCA_EMATCH_TREE_MAX
+};
+#define TCA_EMATCH_TREE_MAX (__TCA_EMATCH_TREE_MAX - 1)
+
+struct tcf_ematch_hdr
+{
+	__u16		matchid;
+	__u16		kind;
+	__u16		flags;
+	__u16		pad; /* currently unused */
+};
+
+/*  0                   1
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+ * +-----------------------+-+-+---+
+ * |         Unused        |S|I| R |
+ * +-----------------------+-+-+---+
+ *
+ * R(2) ::= relation to next ematch
+ *          where: 0 0 END (last ematch)
+ *                 0 1 AND
+ *                 1 0 OR
+ *                 1 1 Unused (invalid)
+ * I(1) ::= invert result
+ * S(1) ::= simple payload
+ */
+#define TCF_EM_REL_END	0
+#define TCF_EM_REL_AND	(1<<0)
+#define TCF_EM_REL_OR	(1<<1)
+#define TCF_EM_INVERT	(1<<2)
+#define TCF_EM_SIMPLE	(1<<3)
+
+#define TCF_EM_REL_MASK	3
+#define TCF_EM_REL_VALID(v) (((v) & TCF_EM_REL_MASK) != TCF_EM_REL_MASK)
+
+enum
+{
+	TCF_LAYER_LINK,
+	TCF_LAYER_NETWORK,
+	TCF_LAYER_TRANSPORT,
+	__TCF_LAYER_MAX
+};
+#define TCF_LAYER_MAX (__TCF_LAYER_MAX - 1)
+
+/* Ematch type assignments
+ *   1..32767		Reserved for ematches inside kernel tree
+ *   32768..65535	Free to use, not reliable
+ */
+#define	TCF_EM_CONTAINER	0
+#define	TCF_EM_CMP		1
+#define	TCF_EM_NBYTE		2
+#define	TCF_EM_U32		3
+#define	TCF_EM_META		4
+#define	TCF_EM_TEXT		5
+#define        TCF_EM_VLAN		6
+#define	TCF_EM_MAX		6
+
+enum
+{
+	TCF_EM_PROG_TC
+};
+
+enum
+{
+	TCF_EM_OPND_EQ,
+	TCF_EM_OPND_GT,
+	TCF_EM_OPND_LT
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/pkt_sched.h clean_modified/linux-2.6.32/usr/include/linux/pkt_sched.h
--- linux-2.6.32/usr/include/linux/pkt_sched.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pkt_sched.h	2019-04-14 13:24:03.111249120 -0500
@@ -0,0 +1,521 @@
+#ifndef __LINUX_PKT_SCHED_H
+#define __LINUX_PKT_SCHED_H
+
+#include <linux/types.h>
+
+/* Logical priority bands not depending on specific packet scheduler.
+   Every scheduler will map them to real traffic classes, if it has
+   no more precise mechanism to classify packets.
+
+   These numbers have no special meaning, though their coincidence
+   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
+   preferred full anarchy inspired by diffserv group.
+
+   Note: TC_PRIO_BESTEFFORT does not mean that it is the most unhappy
+   class, actually, as rule it will be handled with more care than
+   filler or even bulk.
+ */
+
+#define TC_PRIO_BESTEFFORT		0
+#define TC_PRIO_FILLER			1
+#define TC_PRIO_BULK			2
+#define TC_PRIO_INTERACTIVE_BULK	4
+#define TC_PRIO_INTERACTIVE		6
+#define TC_PRIO_CONTROL			7
+
+#define TC_PRIO_MAX			15
+
+/* Generic queue statistics, available for all the elements.
+   Particular schedulers may have also their private records.
+ */
+
+struct tc_stats
+{
+	__u64	bytes;			/* NUmber of enqueues bytes */
+	__u32	packets;		/* Number of enqueued packets	*/
+	__u32	drops;			/* Packets dropped because of lack of resources */
+	__u32	overlimits;		/* Number of throttle events when this
+					 * flow goes out of allocated bandwidth */
+	__u32	bps;			/* Current flow byte rate */
+	__u32	pps;			/* Current flow packet rate */
+	__u32	qlen;
+	__u32	backlog;
+};
+
+struct tc_estimator
+{
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+/* "Handles"
+   ---------
+
+    All the traffic control objects have 32bit identifiers, or "handles".
+
+    They can be considered as opaque numbers from user API viewpoint,
+    but actually they always consist of two fields: major and
+    minor numbers, which are interpreted by kernel specially,
+    that may be used by applications, though not recommended.
+
+    F.e. qdisc handles always have minor number equal to zero,
+    classes (or flows) have major equal to parent qdisc major, and
+    minor uniquely identifying class inside qdisc.
+
+    Macros to manipulate handles:
+ */
+
+#define TC_H_MAJ_MASK (0xFFFF0000U)
+#define TC_H_MIN_MASK (0x0000FFFFU)
+#define TC_H_MAJ(h) ((h)&TC_H_MAJ_MASK)
+#define TC_H_MIN(h) ((h)&TC_H_MIN_MASK)
+#define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
+
+#define TC_H_UNSPEC	(0U)
+#define TC_H_ROOT	(0xFFFFFFFFU)
+#define TC_H_INGRESS    (0xFFFFFFF1U)
+
+struct tc_ratespec
+{
+	unsigned char	cell_log;
+	unsigned char	__reserved;
+	unsigned short	overhead;
+	short		cell_align;
+	unsigned short	mpu;
+	__u32		rate;
+};
+
+#define TC_RTAB_SIZE	1024
+
+struct tc_sizespec {
+	unsigned char	cell_log;
+	unsigned char	size_log;
+	short		cell_align;
+	int		overhead;
+	unsigned int	linklayer;
+	unsigned int	mpu;
+	unsigned int	mtu;
+	unsigned int	tsize;
+};
+
+enum {
+	TCA_STAB_UNSPEC,
+	TCA_STAB_BASE,
+	TCA_STAB_DATA,
+	__TCA_STAB_MAX
+};
+
+#define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
+
+/* FIFO section */
+
+struct tc_fifo_qopt
+{
+	__u32	limit;	/* Queue length: bytes for bfifo, packets for pfifo */
+};
+
+/* PRIO section */
+
+#define TCQ_PRIO_BANDS	16
+#define TCQ_MIN_PRIO_BANDS 2
+
+struct tc_prio_qopt
+{
+	int	bands;			/* Number of bands */
+	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
+};
+
+/* MULTIQ section */
+
+struct tc_multiq_qopt {
+	__u16	bands;			/* Number of bands */
+	__u16	max_bands;		/* Maximum number of queues */
+};
+
+/* TBF section */
+
+struct tc_tbf_qopt
+{
+	struct tc_ratespec rate;
+	struct tc_ratespec peakrate;
+	__u32		limit;
+	__u32		buffer;
+	__u32		mtu;
+};
+
+enum
+{
+	TCA_TBF_UNSPEC,
+	TCA_TBF_PARMS,
+	TCA_TBF_RTAB,
+	TCA_TBF_PTAB,
+	__TCA_TBF_MAX,
+};
+
+#define TCA_TBF_MAX (__TCA_TBF_MAX - 1)
+
+
+/* TEQL section */
+
+/* TEQL does not require any parameters */
+
+/* SFQ section */
+
+struct tc_sfq_qopt
+{
+	unsigned	quantum;	/* Bytes per round allocated to flow */
+	int		perturb_period;	/* Period of hash perturbation */
+	__u32		limit;		/* Maximal packets in queue */
+	unsigned	divisor;	/* Hash divisor  */
+	unsigned	flows;		/* Maximal number of flows  */
+};
+
+struct tc_sfq_xstats
+{
+	__s32		allot;
+};
+
+/*
+ *  NOTE: limit, divisor and flows are hardwired to code at the moment.
+ *
+ *	limit=flows=128, divisor=1024;
+ *
+ *	The only reason for this is efficiency, it is possible
+ *	to change these parameters in compile time.
+ */
+
+/* RED section */
+
+enum
+{
+	TCA_RED_UNSPEC,
+	TCA_RED_PARMS,
+	TCA_RED_STAB,
+	__TCA_RED_MAX,
+};
+
+#define TCA_RED_MAX (__TCA_RED_MAX - 1)
+
+struct tc_red_qopt
+{
+	__u32		limit;		/* HARD maximal queue length (bytes)	*/
+	__u32		qth_min;	/* Min average length threshold (bytes) */
+	__u32		qth_max;	/* Max average length threshold (bytes) */
+	unsigned char   Wlog;		/* log(W)		*/
+	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
+	unsigned char   Scell_log;	/* cell size for idle damping */
+	unsigned char	flags;
+#define TC_RED_ECN	1
+#define TC_RED_HARDDROP	2
+};
+
+struct tc_red_xstats
+{
+	__u32           early;          /* Early drops */
+	__u32           pdrop;          /* Drops due to queue limits */
+	__u32           other;          /* Drops due to drop() calls */
+	__u32           marked;         /* Marked packets */
+};
+
+/* GRED section */
+
+#define MAX_DPs 16
+
+enum
+{
+       TCA_GRED_UNSPEC,
+       TCA_GRED_PARMS,
+       TCA_GRED_STAB,
+       TCA_GRED_DPS,
+	   __TCA_GRED_MAX,
+};
+
+#define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
+
+struct tc_gred_qopt
+{
+	__u32		limit;        /* HARD maximal queue length (bytes)    */
+	__u32		qth_min;      /* Min average length threshold (bytes) */
+	__u32		qth_max;      /* Max average length threshold (bytes) */
+	__u32		DP;           /* upto 2^32 DPs */
+	__u32		backlog;
+	__u32		qave;
+	__u32		forced;
+	__u32		early;
+	__u32		other;
+	__u32		pdrop;
+	__u8		Wlog;         /* log(W)               */
+	__u8		Plog;         /* log(P_max/(qth_max-qth_min)) */
+	__u8		Scell_log;    /* cell size for idle damping */
+	__u8		prio;         /* prio of this VQ */
+	__u32		packets;
+	__u32		bytesin;
+};
+
+/* gred setup */
+struct tc_gred_sopt
+{
+	__u32		DPs;
+	__u32		def_DP;
+	__u8		grio;
+	__u8		flags;
+	__u16		pad1;
+};
+
+/* HTB section */
+#define TC_HTB_NUMPRIO		8
+#define TC_HTB_MAXDEPTH		8
+#define TC_HTB_PROTOVER		3 /* the same as HTB and TC's major */
+
+struct tc_htb_opt
+{
+	struct tc_ratespec 	rate;
+	struct tc_ratespec 	ceil;
+	__u32	buffer;
+	__u32	cbuffer;
+	__u32	quantum;
+	__u32	level;		/* out only */
+	__u32	prio;
+};
+struct tc_htb_glob
+{
+	__u32 version;		/* to match HTB/TC */
+    	__u32 rate2quantum;	/* bps->quantum divisor */
+    	__u32 defcls;		/* default class number */
+	__u32 debug;		/* debug flags */
+
+	/* stats */
+	__u32 direct_pkts; /* count of non shapped packets */
+};
+enum
+{
+	TCA_HTB_UNSPEC,
+	TCA_HTB_PARMS,
+	TCA_HTB_INIT,
+	TCA_HTB_CTAB,
+	TCA_HTB_RTAB,
+	__TCA_HTB_MAX,
+};
+
+#define TCA_HTB_MAX (__TCA_HTB_MAX - 1)
+
+struct tc_htb_xstats
+{
+	__u32 lends;
+	__u32 borrows;
+	__u32 giants;	/* too big packets (rate will not be accurate) */
+	__u32 tokens;
+	__u32 ctokens;
+};
+
+/* HFSC section */
+
+struct tc_hfsc_qopt
+{
+	__u16	defcls;		/* default class */
+};
+
+struct tc_service_curve
+{
+	__u32	m1;		/* slope of the first segment in bps */
+	__u32	d;		/* x-projection of the first segment in us */
+	__u32	m2;		/* slope of the second segment in bps */
+};
+
+struct tc_hfsc_stats
+{
+	__u64	work;		/* total work done */
+	__u64	rtwork;		/* work done by real-time criteria */
+	__u32	period;		/* current period */
+	__u32	level;		/* class level in hierarchy */
+};
+
+enum
+{
+	TCA_HFSC_UNSPEC,
+	TCA_HFSC_RSC,
+	TCA_HFSC_FSC,
+	TCA_HFSC_USC,
+	__TCA_HFSC_MAX,
+};
+
+#define TCA_HFSC_MAX (__TCA_HFSC_MAX - 1)
+
+
+/* CBQ section */
+
+#define TC_CBQ_MAXPRIO		8
+#define TC_CBQ_MAXLEVEL		8
+#define TC_CBQ_DEF_EWMA		5
+
+struct tc_cbq_lssopt
+{
+	unsigned char	change;
+	unsigned char	flags;
+#define TCF_CBQ_LSS_BOUNDED	1
+#define TCF_CBQ_LSS_ISOLATED	2
+	unsigned char  	ewma_log;
+	unsigned char  	level;
+#define TCF_CBQ_LSS_FLAGS	1
+#define TCF_CBQ_LSS_EWMA	2
+#define TCF_CBQ_LSS_MAXIDLE	4
+#define TCF_CBQ_LSS_MINIDLE	8
+#define TCF_CBQ_LSS_OFFTIME	0x10
+#define TCF_CBQ_LSS_AVPKT	0x20
+	__u32		maxidle;
+	__u32		minidle;
+	__u32		offtime;
+	__u32		avpkt;
+};
+
+struct tc_cbq_wrropt
+{
+	unsigned char	flags;
+	unsigned char	priority;
+	unsigned char	cpriority;
+	unsigned char	__reserved;
+	__u32		allot;
+	__u32		weight;
+};
+
+struct tc_cbq_ovl
+{
+	unsigned char	strategy;
+#define	TC_CBQ_OVL_CLASSIC	0
+#define	TC_CBQ_OVL_DELAY	1
+#define	TC_CBQ_OVL_LOWPRIO	2
+#define	TC_CBQ_OVL_DROP		3
+#define	TC_CBQ_OVL_RCLASSIC	4
+	unsigned char	priority2;
+	__u16		pad;
+	__u32		penalty;
+};
+
+struct tc_cbq_police
+{
+	unsigned char	police;
+	unsigned char	__res1;
+	unsigned short	__res2;
+};
+
+struct tc_cbq_fopt
+{
+	__u32		split;
+	__u32		defmap;
+	__u32		defchange;
+};
+
+struct tc_cbq_xstats
+{
+	__u32		borrows;
+	__u32		overactions;
+	__s32		avgidle;
+	__s32		undertime;
+};
+
+enum
+{
+	TCA_CBQ_UNSPEC,
+	TCA_CBQ_LSSOPT,
+	TCA_CBQ_WRROPT,
+	TCA_CBQ_FOPT,
+	TCA_CBQ_OVL_STRATEGY,
+	TCA_CBQ_RATE,
+	TCA_CBQ_RTAB,
+	TCA_CBQ_POLICE,
+	__TCA_CBQ_MAX,
+};
+
+#define TCA_CBQ_MAX	(__TCA_CBQ_MAX - 1)
+
+/* dsmark section */
+
+enum {
+	TCA_DSMARK_UNSPEC,
+	TCA_DSMARK_INDICES,
+	TCA_DSMARK_DEFAULT_INDEX,
+	TCA_DSMARK_SET_TC_INDEX,
+	TCA_DSMARK_MASK,
+	TCA_DSMARK_VALUE,
+	__TCA_DSMARK_MAX,
+};
+
+#define TCA_DSMARK_MAX (__TCA_DSMARK_MAX - 1)
+
+/* ATM  section */
+
+enum {
+	TCA_ATM_UNSPEC,
+	TCA_ATM_FD,		/* file/socket descriptor */
+	TCA_ATM_PTR,		/* pointer to descriptor - later */
+	TCA_ATM_HDR,		/* LL header */
+	TCA_ATM_EXCESS,		/* excess traffic class (0 for CLP)  */
+	TCA_ATM_ADDR,		/* PVC address (for output only) */
+	TCA_ATM_STATE,		/* VC state (ATM_VS_*; for output only) */
+	__TCA_ATM_MAX,
+};
+
+#define TCA_ATM_MAX	(__TCA_ATM_MAX - 1)
+
+/* Network emulator */
+
+enum
+{
+	TCA_NETEM_UNSPEC,
+	TCA_NETEM_CORR,
+	TCA_NETEM_DELAY_DIST,
+	TCA_NETEM_REORDER,
+	TCA_NETEM_CORRUPT,
+	__TCA_NETEM_MAX,
+};
+
+#define TCA_NETEM_MAX (__TCA_NETEM_MAX - 1)
+
+struct tc_netem_qopt
+{
+	__u32	latency;	/* added delay (us) */
+	__u32   limit;		/* fifo limit (packets) */
+	__u32	loss;		/* random packet loss (0=none ~0=100%) */
+	__u32	gap;		/* re-ordering gap (0 for none) */
+	__u32   duplicate;	/* random packet dup  (0=none ~0=100%) */
+	__u32	jitter;		/* random jitter in latency (us) */
+};
+
+struct tc_netem_corr
+{
+	__u32	delay_corr;	/* delay correlation */
+	__u32	loss_corr;	/* packet loss correlation */
+	__u32	dup_corr;	/* duplicate correlation  */
+};
+
+struct tc_netem_reorder
+{
+	__u32	probability;
+	__u32	correlation;
+};
+
+struct tc_netem_corrupt
+{
+	__u32	probability;
+	__u32	correlation;
+};
+
+#define NETEM_DIST_SCALE	8192
+
+/* DRR */
+
+enum
+{
+	TCA_DRR_UNSPEC,
+	TCA_DRR_QUANTUM,
+	__TCA_DRR_MAX
+};
+
+#define TCA_DRR_MAX	(__TCA_DRR_MAX - 1)
+
+struct tc_drr_stats
+{
+	__u32	deficit;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/pmu.h clean_modified/linux-2.6.32/usr/include/linux/pmu.h
--- linux-2.6.32/usr/include/linux/pmu.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pmu.h	2019-04-14 13:24:03.111249120 -0500
@@ -0,0 +1,135 @@
+/*
+ * Definitions for talking to the PMU.  The PMU is a microcontroller
+ * which controls battery charging and system power on PowerBook 3400
+ * and 2400 models as well as the RTC and various other things.
+ *
+ * Copyright (C) 1998 Paul Mackerras.
+ */
+
+
+#define PMU_DRIVER_VERSION	2
+
+/*
+ * PMU commands
+ */
+#define PMU_POWER_CTRL0		0x10	/* control power of some devices */
+#define PMU_POWER_CTRL		0x11	/* control power of some devices */
+#define PMU_ADB_CMD		0x20	/* send ADB packet */
+#define PMU_ADB_POLL_OFF	0x21	/* disable ADB auto-poll */
+#define PMU_WRITE_NVRAM		0x33	/* write non-volatile RAM */
+#define PMU_READ_NVRAM		0x3b	/* read non-volatile RAM */
+#define PMU_SET_RTC		0x30	/* set real-time clock */
+#define PMU_READ_RTC		0x38	/* read real-time clock */
+#define PMU_SET_VOLBUTTON	0x40	/* set volume up/down position */
+#define PMU_BACKLIGHT_BRIGHT	0x41	/* set backlight brightness */
+#define PMU_GET_VOLBUTTON	0x48	/* get volume up/down position */
+#define PMU_PCEJECT		0x4c	/* eject PC-card from slot */
+#define PMU_BATTERY_STATE	0x6b	/* report battery state etc. */
+#define PMU_SMART_BATTERY_STATE	0x6f	/* report battery state (new way) */
+#define PMU_SET_INTR_MASK	0x70	/* set PMU interrupt mask */
+#define PMU_INT_ACK		0x78	/* read interrupt bits */
+#define PMU_SHUTDOWN		0x7e	/* turn power off */
+#define PMU_CPU_SPEED		0x7d	/* control CPU speed on some models */
+#define PMU_SLEEP		0x7f	/* put CPU to sleep */
+#define PMU_POWER_EVENTS	0x8f	/* Send power-event commands to PMU */
+#define PMU_I2C_CMD		0x9a	/* I2C operations */
+#define PMU_RESET		0xd0	/* reset CPU */
+#define PMU_GET_BRIGHTBUTTON	0xd9	/* report brightness up/down pos */
+#define PMU_GET_COVER		0xdc	/* report cover open/closed */
+#define PMU_SYSTEM_READY	0xdf	/* tell PMU we are awake */
+#define PMU_GET_VERSION		0xea	/* read the PMU version */
+
+/* Bits to use with the PMU_POWER_CTRL0 command */
+#define PMU_POW0_ON		0x80	/* OR this to power ON the device */
+#define PMU_POW0_OFF		0x00	/* leave bit 7 to 0 to power it OFF */
+#define PMU_POW0_HARD_DRIVE	0x04	/* Hard drive power (on wallstreet/lombard ?) */
+
+/* Bits to use with the PMU_POWER_CTRL command */
+#define PMU_POW_ON		0x80	/* OR this to power ON the device */
+#define PMU_POW_OFF		0x00	/* leave bit 7 to 0 to power it OFF */
+#define PMU_POW_BACKLIGHT	0x01	/* backlight power */
+#define PMU_POW_CHARGER		0x02	/* battery charger power */
+#define PMU_POW_IRLED		0x04	/* IR led power (on wallstreet) */
+#define PMU_POW_MEDIABAY	0x08	/* media bay power (wallstreet/lombard ?) */
+
+/* Bits in PMU interrupt and interrupt mask bytes */
+#define PMU_INT_PCEJECT		0x04	/* PC-card eject buttons */
+#define PMU_INT_SNDBRT		0x08	/* sound/brightness up/down buttons */
+#define PMU_INT_ADB		0x10	/* ADB autopoll or reply data */
+#define PMU_INT_BATTERY		0x20	/* Battery state change */
+#define PMU_INT_ENVIRONMENT	0x40	/* Environment interrupts */
+#define PMU_INT_TICK		0x80	/* 1-second tick interrupt */
+
+/* Other bits in PMU interrupt valid when PMU_INT_ADB is set */
+#define PMU_INT_ADB_AUTO	0x04	/* ADB autopoll, when PMU_INT_ADB */
+#define PMU_INT_WAITING_CHARGER	0x01	/* ??? */
+#define PMU_INT_AUTO_SRQ_POLL	0x02	/* ??? */
+
+/* Bits in the environement message (either obtained via PMU_GET_COVER,
+ * or via PMU_INT_ENVIRONMENT on core99 */
+#define PMU_ENV_LID_CLOSED	0x01	/* The lid is closed */
+
+/* I2C related definitions */
+#define PMU_I2C_MODE_SIMPLE	0
+#define PMU_I2C_MODE_STDSUB	1
+#define PMU_I2C_MODE_COMBINED	2
+
+#define PMU_I2C_BUS_STATUS	0
+#define PMU_I2C_BUS_SYSCLK	1
+#define PMU_I2C_BUS_POWER	2
+
+#define PMU_I2C_STATUS_OK	0
+#define PMU_I2C_STATUS_DATAREAD	1
+#define PMU_I2C_STATUS_BUSY	0xfe
+
+
+/* Kind of PMU (model) */
+enum {
+	PMU_UNKNOWN,
+	PMU_OHARE_BASED,	/* 2400, 3400, 3500 (old G3 powerbook) */
+	PMU_HEATHROW_BASED,	/* PowerBook G3 series */
+	PMU_PADDINGTON_BASED,	/* 1999 PowerBook G3 */
+	PMU_KEYLARGO_BASED,	/* Core99 motherboard (PMU99) */
+	PMU_68K_V1,		/* 68K PMU, version 1 */
+	PMU_68K_V2, 		/* 68K PMU, version 2 */
+};
+
+/* PMU PMU_POWER_EVENTS commands */
+enum {
+	PMU_PWR_GET_POWERUP_EVENTS	= 0x00,
+	PMU_PWR_SET_POWERUP_EVENTS	= 0x01,
+	PMU_PWR_CLR_POWERUP_EVENTS	= 0x02,
+	PMU_PWR_GET_WAKEUP_EVENTS	= 0x03,
+	PMU_PWR_SET_WAKEUP_EVENTS	= 0x04,
+	PMU_PWR_CLR_WAKEUP_EVENTS	= 0x05,
+};
+
+/* Power events wakeup bits */
+enum {
+	PMU_PWR_WAKEUP_KEY		= 0x01,	/* Wake on key press */
+	PMU_PWR_WAKEUP_AC_INSERT	= 0x02, /* Wake on AC adapter plug */
+	PMU_PWR_WAKEUP_AC_CHANGE	= 0x04,
+	PMU_PWR_WAKEUP_LID_OPEN		= 0x08,
+	PMU_PWR_WAKEUP_RING		= 0x10,
+};
+	
+/*
+ * Ioctl commands for the /dev/pmu device
+ */
+#include <linux/ioctl.h>
+
+/* no param */
+#define PMU_IOC_SLEEP		_IO('B', 0)
+/* out param: u32*	backlight value: 0 to 15 */
+#define PMU_IOC_GET_BACKLIGHT	_IOR('B', 1, size_t)
+/* in param: u32	backlight value: 0 to 15 */
+#define PMU_IOC_SET_BACKLIGHT	_IOW('B', 2, size_t)
+/* out param: u32*	PMU model */
+#define PMU_IOC_GET_MODEL	_IOR('B', 3, size_t)
+/* out param: u32*	has_adb: 0 or 1 */
+#define PMU_IOC_HAS_ADB		_IOR('B', 4, size_t) 
+/* out param: u32*	can_sleep: 0 or 1 */
+#define PMU_IOC_CAN_SLEEP	_IOR('B', 5, size_t) 
+/* no param, but historically was _IOR('B', 6, 0), meaning 4 bytes */
+#define PMU_IOC_GRAB_BACKLIGHT	_IOR('B', 6, size_t) 
+
diff -uNr linux-2.6.32/usr/include/linux/poll.h clean_modified/linux-2.6.32/usr/include/linux/poll.h
--- linux-2.6.32/usr/include/linux/poll.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/poll.h	2019-04-14 13:24:03.112228679 -0500
@@ -0,0 +1,7 @@
+#ifndef _LINUX_POLL_H
+#define _LINUX_POLL_H
+
+#include <asm/poll.h>
+
+
+#endif /* _LINUX_POLL_H */
diff -uNr linux-2.6.32/usr/include/linux/posix_types.h clean_modified/linux-2.6.32/usr/include/linux/posix_types.h
--- linux-2.6.32/usr/include/linux/posix_types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/posix_types.h	2019-04-14 13:24:03.112228679 -0500
@@ -0,0 +1,49 @@
+#ifndef _LINUX_POSIX_TYPES_H
+#define _LINUX_POSIX_TYPES_H
+
+#include <linux/stddef.h>
+
+/*
+ * This allows for 1024 file descriptors: if NR_OPEN is ever grown
+ * beyond that you'll have to change this too. But 1024 fd's seem to be
+ * enough even for such "real" unices like OSF/1, so hopefully this is
+ * one limit that doesn't have to be changed [again].
+ *
+ * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
+ * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
+ * place for them. Solved by having dummy defines in <sys/time.h>.
+ */
+
+/*
+ * Those macros may have been defined in <gnu/types.h>. But we always
+ * use the ones here. 
+ */
+#undef __NFDBITS
+#define __NFDBITS	(8 * sizeof(unsigned long))
+
+#undef __FD_SETSIZE
+#define __FD_SETSIZE	1024
+
+#undef __FDSET_LONGS
+#define __FDSET_LONGS	(__FD_SETSIZE/__NFDBITS)
+
+#undef __FDELT
+#define	__FDELT(d)	((d) / __NFDBITS)
+
+#undef __FDMASK
+#define	__FDMASK(d)	(1UL << ((d) % __NFDBITS))
+
+typedef struct {
+	unsigned long fds_bits [__FDSET_LONGS];
+} __kernel_fd_set;
+
+/* Type of a signal handler.  */
+typedef void (*__kernel_sighandler_t)(int);
+
+/* Type of a SYSV IPC key.  */
+typedef int __kernel_key_t;
+typedef int __kernel_mqd_t;
+
+#include <asm/posix_types.h>
+
+#endif /* _LINUX_POSIX_TYPES_H */
diff -uNr linux-2.6.32/usr/include/linux/ppdev.h clean_modified/linux-2.6.32/usr/include/linux/ppdev.h
--- linux-2.6.32/usr/include/linux/ppdev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ppdev.h	2019-04-14 13:24:03.112228679 -0500
@@ -0,0 +1,99 @@
+/*
+ * linux/include/linux/ppdev.h
+ *
+ * User-space parallel port device driver (header file).
+ *
+ * Copyright (C) 1998-9 Tim Waugh <tim@cyberelk.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Added PPGETTIME/PPSETTIME, Fred Barnes, 1999
+ * Added PPGETMODES/PPGETMODE/PPGETPHASE, Fred Barnes <frmb2@ukc.ac.uk>, 03/01/2001
+ */
+
+#define PP_IOCTL	'p'
+
+/* Set mode for read/write (e.g. IEEE1284_MODE_EPP) */
+#define PPSETMODE	_IOW(PP_IOCTL, 0x80, int)
+
+/* Read status */
+#define PPRSTATUS	_IOR(PP_IOCTL, 0x81, unsigned char)
+#define PPWSTATUS	OBSOLETE__IOW(PP_IOCTL, 0x82, unsigned char)
+
+/* Read/write control */
+#define PPRCONTROL	_IOR(PP_IOCTL, 0x83, unsigned char)
+#define PPWCONTROL	_IOW(PP_IOCTL, 0x84, unsigned char)
+
+struct ppdev_frob_struct {
+	unsigned char mask;
+	unsigned char val;
+};
+#define PPFCONTROL      _IOW(PP_IOCTL, 0x8e, struct ppdev_frob_struct)
+
+/* Read/write data */
+#define PPRDATA		_IOR(PP_IOCTL, 0x85, unsigned char)
+#define PPWDATA		_IOW(PP_IOCTL, 0x86, unsigned char)
+
+/* Read/write econtrol (not used) */
+#define PPRECONTROL	OBSOLETE__IOR(PP_IOCTL, 0x87, unsigned char)
+#define PPWECONTROL	OBSOLETE__IOW(PP_IOCTL, 0x88, unsigned char)
+
+/* Read/write FIFO (not used) */
+#define PPRFIFO		OBSOLETE__IOR(PP_IOCTL, 0x89, unsigned char)
+#define PPWFIFO		OBSOLETE__IOW(PP_IOCTL, 0x8a, unsigned char)
+
+/* Claim the port to start using it */
+#define PPCLAIM		_IO(PP_IOCTL, 0x8b)
+
+/* Release the port when you aren't using it */
+#define PPRELEASE	_IO(PP_IOCTL, 0x8c)
+
+/* Yield the port (release it if another driver is waiting,
+ * then reclaim) */
+#define PPYIELD		_IO(PP_IOCTL, 0x8d)
+
+/* Register device exclusively (must be before PPCLAIM). */
+#define PPEXCL		_IO(PP_IOCTL, 0x8f)
+
+/* Data line direction: non-zero for input mode. */
+#define PPDATADIR	_IOW(PP_IOCTL, 0x90, int)
+
+/* Negotiate a particular IEEE 1284 mode. */
+#define PPNEGOT		_IOW(PP_IOCTL, 0x91, int)
+
+/* Set control lines when an interrupt occurs. */
+#define PPWCTLONIRQ	_IOW(PP_IOCTL, 0x92, unsigned char)
+
+/* Clear (and return) interrupt count. */
+#define PPCLRIRQ	_IOR(PP_IOCTL, 0x93, int)
+
+/* Set the IEEE 1284 phase that we're in (e.g. IEEE1284_PH_FWD_IDLE) */
+#define PPSETPHASE	_IOW(PP_IOCTL, 0x94, int)
+
+/* Set and get port timeout (struct timeval's) */
+#define PPGETTIME	_IOR(PP_IOCTL, 0x95, struct timeval)
+#define PPSETTIME	_IOW(PP_IOCTL, 0x96, struct timeval)
+
+/* Get available modes (what the hardware can do) */
+#define PPGETMODES	_IOR(PP_IOCTL, 0x97, unsigned int)
+
+/* Get the current mode and phaze */
+#define PPGETMODE	_IOR(PP_IOCTL, 0x98, int)
+#define PPGETPHASE	_IOR(PP_IOCTL, 0x99, int)
+
+/* get/set flags */
+#define PPGETFLAGS	_IOR(PP_IOCTL, 0x9a, int)
+#define PPSETFLAGS	_IOW(PP_IOCTL, 0x9b, int)
+
+/* flags visible to the world */
+#define PP_FASTWRITE	(1<<2)
+#define PP_FASTREAD	(1<<3)
+#define PP_W91284PIC	(1<<4)
+
+/* only masks user-visible flags */
+#define PP_FLAGMASK	(PP_FASTWRITE | PP_FASTREAD | PP_W91284PIC)
+
+
diff -uNr linux-2.6.32/usr/include/linux/ppp-comp.h clean_modified/linux-2.6.32/usr/include/linux/ppp-comp.h
--- linux-2.6.32/usr/include/linux/ppp-comp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ppp-comp.h	2019-04-14 13:24:03.113201134 -0500
@@ -0,0 +1,210 @@
+/*
+ * ppp-comp.h - Definitions for doing PPP packet compression.
+ *
+ * Copyright (c) 1994 The Australian National University.
+ * All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, provided that the above copyright
+ * notice appears in all copies.  This software is provided without any
+ * warranty, express or implied. The Australian National University
+ * makes no representations about the suitability of this software for
+ * any purpose.
+ *
+ * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY
+ * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+ * THE AUSTRALIAN NATIONAL UNIVERSITY HAVE BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO
+ * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
+ * OR MODIFICATIONS.
+ */
+
+/*
+ *  ==FILEVERSION 980319==
+ *
+ *  NOTE TO MAINTAINERS:
+ *     If you modify this file at all, please set the above date.
+ *     ppp-comp.h is shipped with a PPP distribution as well as with the kernel;
+ *     if everyone increases the FILEVERSION number above, then scripts
+ *     can do the right thing when deciding whether to install a new ppp-comp.h
+ *     file.  Don't change the format of that line otherwise, so the
+ *     installation script can recognize it.
+ */
+
+#ifndef _NET_PPP_COMP_H
+#define _NET_PPP_COMP_H
+
+struct module;
+
+/*
+ * The following symbols control whether we include code for
+ * various compression methods.
+ */
+
+#ifndef DO_BSD_COMPRESS
+#define DO_BSD_COMPRESS	1	/* by default, include BSD-Compress */
+#endif
+#ifndef DO_DEFLATE
+#define DO_DEFLATE	1	/* by default, include Deflate */
+#endif
+#define DO_PREDICTOR_1	0
+#define DO_PREDICTOR_2	0
+
+/*
+ * Structure giving methods for compression/decompression.
+ */
+
+struct compressor {
+	int	compress_proto;	/* CCP compression protocol number */
+
+	/* Allocate space for a compressor (transmit side) */
+	void	*(*comp_alloc) (unsigned char *options, int opt_len);
+
+	/* Free space used by a compressor */
+	void	(*comp_free) (void *state);
+
+	/* Initialize a compressor */
+	int	(*comp_init) (void *state, unsigned char *options,
+			      int opt_len, int unit, int opthdr, int debug);
+
+	/* Reset a compressor */
+	void	(*comp_reset) (void *state);
+
+	/* Compress a packet */
+	int     (*compress) (void *state, unsigned char *rptr,
+			      unsigned char *obuf, int isize, int osize);
+
+	/* Return compression statistics */
+	void	(*comp_stat) (void *state, struct compstat *stats);
+
+	/* Allocate space for a decompressor (receive side) */
+	void	*(*decomp_alloc) (unsigned char *options, int opt_len);
+
+	/* Free space used by a decompressor */
+	void	(*decomp_free) (void *state);
+
+	/* Initialize a decompressor */
+	int	(*decomp_init) (void *state, unsigned char *options,
+				int opt_len, int unit, int opthdr, int mru,
+				int debug);
+
+	/* Reset a decompressor */
+	void	(*decomp_reset) (void *state);
+
+	/* Decompress a packet. */
+	int	(*decompress) (void *state, unsigned char *ibuf, int isize,
+				unsigned char *obuf, int osize);
+
+	/* Update state for an incompressible packet received */
+	void	(*incomp) (void *state, unsigned char *ibuf, int icnt);
+
+	/* Return decompression statistics */
+	void	(*decomp_stat) (void *state, struct compstat *stats);
+
+	/* Used in locking compressor modules */
+	struct module *owner;
+	/* Extra skb space needed by the compressor algorithm */
+	unsigned int comp_extra;
+};
+
+/*
+ * The return value from decompress routine is the length of the
+ * decompressed packet if successful, otherwise DECOMP_ERROR
+ * or DECOMP_FATALERROR if an error occurred.
+ * 
+ * We need to make this distinction so that we can disable certain
+ * useful functionality, namely sending a CCP reset-request as a result
+ * of an error detected after decompression.  This is to avoid infringing
+ * a patent held by Motorola.
+ * Don't you just lurve software patents.
+ */
+
+#define DECOMP_ERROR		-1	/* error detected before decomp. */
+#define DECOMP_FATALERROR	-2	/* error detected after decomp. */
+
+/*
+ * CCP codes.
+ */
+
+#define CCP_CONFREQ	1
+#define CCP_CONFACK	2
+#define CCP_TERMREQ	5
+#define CCP_TERMACK	6
+#define CCP_RESETREQ	14
+#define CCP_RESETACK	15
+
+/*
+ * Max # bytes for a CCP option
+ */
+
+#define CCP_MAX_OPTION_LENGTH	32
+
+/*
+ * Parts of a CCP packet.
+ */
+
+#define CCP_CODE(dp)		((dp)[0])
+#define CCP_ID(dp)		((dp)[1])
+#define CCP_LENGTH(dp)		(((dp)[2] << 8) + (dp)[3])
+#define CCP_HDRLEN		4
+
+#define CCP_OPT_CODE(dp)	((dp)[0])
+#define CCP_OPT_LENGTH(dp)	((dp)[1])
+#define CCP_OPT_MINLEN		2
+
+/*
+ * Definitions for BSD-Compress.
+ */
+
+#define CI_BSD_COMPRESS		21	/* config. option for BSD-Compress */
+#define CILEN_BSD_COMPRESS	3	/* length of config. option */
+
+/* Macros for handling the 3rd byte of the BSD-Compress config option. */
+#define BSD_NBITS(x)		((x) & 0x1F)	/* number of bits requested */
+#define BSD_VERSION(x)		((x) >> 5)	/* version of option format */
+#define BSD_CURRENT_VERSION	1		/* current version number */
+#define BSD_MAKE_OPT(v, n)	(((v) << 5) | (n))
+
+#define BSD_MIN_BITS		9	/* smallest code size supported */
+#define BSD_MAX_BITS		15	/* largest code size supported */
+
+/*
+ * Definitions for Deflate.
+ */
+
+#define CI_DEFLATE		26	/* config option for Deflate */
+#define CI_DEFLATE_DRAFT	24	/* value used in original draft RFC */
+#define CILEN_DEFLATE		4	/* length of its config option */
+
+#define DEFLATE_MIN_SIZE	9
+#define DEFLATE_MAX_SIZE	15
+#define DEFLATE_METHOD_VAL	8
+#define DEFLATE_SIZE(x)		(((x) >> 4) + 8)
+#define DEFLATE_METHOD(x)	((x) & 0x0F)
+#define DEFLATE_MAKE_OPT(w)	((((w) - 8) << 4) + DEFLATE_METHOD_VAL)
+#define DEFLATE_CHK_SEQUENCE	0
+
+/*
+ * Definitions for MPPE.
+ */
+
+#define CI_MPPE                18      /* config option for MPPE */
+#define CILEN_MPPE              6      /* length of config option */
+
+/*
+ * Definitions for other, as yet unsupported, compression methods.
+ */
+
+#define CI_PREDICTOR_1		1	/* config option for Predictor-1 */
+#define CILEN_PREDICTOR_1	2	/* length of its config option */
+#define CI_PREDICTOR_2		2	/* config option for Predictor-2 */
+#define CILEN_PREDICTOR_2	2	/* length of its config option */
+
+
+#endif /* _NET_PPP_COMP_H */
diff -uNr linux-2.6.32/usr/include/linux/ppp_defs.h clean_modified/linux-2.6.32/usr/include/linux/ppp_defs.h
--- linux-2.6.32/usr/include/linux/ppp_defs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ppp_defs.h	2019-04-14 13:24:03.113880694 -0500
@@ -0,0 +1,180 @@
+/*
+ * ppp_defs.h - PPP definitions.
+ *
+ * Copyright (c) 1994 The Australian National University.
+ * All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, provided that the above copyright
+ * notice appears in all copies.  This software is provided without any
+ * warranty, express or implied. The Australian National University
+ * makes no representations about the suitability of this software for
+ * any purpose.
+ *
+ * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY
+ * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+ * THE AUSTRALIAN NATIONAL UNIVERSITY HAVE BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO
+ * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
+ * OR MODIFICATIONS.
+ */
+
+#include <linux/types.h>
+
+/*
+ *  ==FILEVERSION 20000114==
+ *
+ *  NOTE TO MAINTAINERS:
+ *     If you modify this file at all, please set the above date.
+ *     ppp_defs.h is shipped with a PPP distribution as well as with the kernel;
+ *     if everyone increases the FILEVERSION number above, then scripts
+ *     can do the right thing when deciding whether to install a new ppp_defs.h
+ *     file.  Don't change the format of that line otherwise, so the
+ *     installation script can recognize it.
+ */
+
+#ifndef _PPP_DEFS_H_
+#define _PPP_DEFS_H_
+
+/*
+ * The basic PPP frame.
+ */
+#define PPP_HDRLEN	4	/* octets for standard ppp header */
+#define PPP_FCSLEN	2	/* octets for FCS */
+#define PPP_MRU		1500	/* default MRU = max length of info field */
+
+#define PPP_ADDRESS(p)	(((__u8 *)(p))[0])
+#define PPP_CONTROL(p)	(((__u8 *)(p))[1])
+#define PPP_PROTOCOL(p)	((((__u8 *)(p))[2] << 8) + ((__u8 *)(p))[3])
+
+/*
+ * Significant octet values.
+ */
+#define	PPP_ALLSTATIONS	0xff	/* All-Stations broadcast address */
+#define	PPP_UI		0x03	/* Unnumbered Information */
+#define	PPP_FLAG	0x7e	/* Flag Sequence */
+#define	PPP_ESCAPE	0x7d	/* Asynchronous Control Escape */
+#define	PPP_TRANS	0x20	/* Asynchronous transparency modifier */
+
+/*
+ * Protocol field values.
+ */
+#define PPP_IP		0x21	/* Internet Protocol */
+#define PPP_AT		0x29	/* AppleTalk Protocol */
+#define PPP_IPX		0x2b	/* IPX protocol */
+#define	PPP_VJC_COMP	0x2d	/* VJ compressed TCP */
+#define	PPP_VJC_UNCOMP	0x2f	/* VJ uncompressed TCP */
+#define PPP_MP		0x3d	/* Multilink protocol */
+#define PPP_IPV6	0x57	/* Internet Protocol Version 6 */
+#define PPP_COMPFRAG	0xfb	/* fragment compressed below bundle */
+#define PPP_COMP	0xfd	/* compressed packet */
+#define PPP_MPLS_UC	0x0281	/* Multi Protocol Label Switching - Unicast */
+#define PPP_MPLS_MC	0x0283	/* Multi Protocol Label Switching - Multicast */
+#define PPP_IPCP	0x8021	/* IP Control Protocol */
+#define PPP_ATCP	0x8029	/* AppleTalk Control Protocol */
+#define PPP_IPXCP	0x802b	/* IPX Control Protocol */
+#define PPP_IPV6CP	0x8057	/* IPv6 Control Protocol */
+#define PPP_CCPFRAG	0x80fb	/* CCP at link level (below MP bundle) */
+#define PPP_CCP		0x80fd	/* Compression Control Protocol */
+#define PPP_MPLSCP	0x80fd	/* MPLS Control Protocol */
+#define PPP_LCP		0xc021	/* Link Control Protocol */
+#define PPP_PAP		0xc023	/* Password Authentication Protocol */
+#define PPP_LQR		0xc025	/* Link Quality Report protocol */
+#define PPP_CHAP	0xc223	/* Cryptographic Handshake Auth. Protocol */
+#define PPP_CBCP	0xc029	/* Callback Control Protocol */
+
+/*
+ * Values for FCS calculations.
+ */
+
+#define PPP_INITFCS	0xffff	/* Initial FCS value */
+#define PPP_GOODFCS	0xf0b8	/* Good final FCS value */
+
+
+/*
+ * Extended asyncmap - allows any character to be escaped.
+ */
+
+typedef __u32		ext_accm[8];
+
+/*
+ * What to do with network protocol (NP) packets.
+ */
+enum NPmode {
+    NPMODE_PASS,		/* pass the packet through */
+    NPMODE_DROP,		/* silently drop the packet */
+    NPMODE_ERROR,		/* return an error */
+    NPMODE_QUEUE		/* save it up for later. */
+};
+
+/*
+ * Statistics for LQRP and pppstats
+ */
+struct pppstat	{
+    __u32	ppp_discards;	/* # frames discarded */
+
+    __u32	ppp_ibytes;	/* bytes received */
+    __u32	ppp_ioctects;	/* bytes received not in error */
+    __u32	ppp_ipackets;	/* packets received */
+    __u32	ppp_ierrors;	/* receive errors */
+    __u32	ppp_ilqrs;	/* # LQR frames received */
+
+    __u32	ppp_obytes;	/* raw bytes sent */
+    __u32	ppp_ooctects;	/* frame bytes sent */
+    __u32	ppp_opackets;	/* packets sent */
+    __u32	ppp_oerrors;	/* transmit errors */ 
+    __u32	ppp_olqrs;	/* # LQR frames sent */
+};
+
+struct vjstat {
+    __u32	vjs_packets;	/* outbound packets */
+    __u32	vjs_compressed;	/* outbound compressed packets */
+    __u32	vjs_searches;	/* searches for connection state */
+    __u32	vjs_misses;	/* times couldn't find conn. state */
+    __u32	vjs_uncompressedin; /* inbound uncompressed packets */
+    __u32	vjs_compressedin;   /* inbound compressed packets */
+    __u32	vjs_errorin;	/* inbound unknown type packets */
+    __u32	vjs_tossed;	/* inbound packets tossed because of error */
+};
+
+struct compstat {
+    __u32	unc_bytes;	/* total uncompressed bytes */
+    __u32	unc_packets;	/* total uncompressed packets */
+    __u32	comp_bytes;	/* compressed bytes */
+    __u32	comp_packets;	/* compressed packets */
+    __u32	inc_bytes;	/* incompressible bytes */
+    __u32	inc_packets;	/* incompressible packets */
+
+    /* the compression ratio is defined as in_count / bytes_out */
+    __u32       in_count;	/* Bytes received */
+    __u32       bytes_out;	/* Bytes transmitted */
+
+    double	ratio;		/* not computed in kernel. */
+};
+
+struct ppp_stats {
+    struct pppstat	p;	/* basic PPP statistics */
+    struct vjstat	vj;	/* VJ header compression statistics */
+};
+
+struct ppp_comp_stats {
+    struct compstat	c;	/* packet compression statistics */
+    struct compstat	d;	/* packet decompression statistics */
+};
+
+/*
+ * The following structure records the time in seconds since
+ * the last NP packet was sent or received.
+ */
+struct ppp_idle {
+    __kernel_time_t xmit_idle;	/* time since last NP packet sent */
+    __kernel_time_t recv_idle;	/* time since last NP packet received */
+};
+
+#endif /* _PPP_DEFS_H_ */
diff -uNr linux-2.6.32/usr/include/linux/pps.h clean_modified/linux-2.6.32/usr/include/linux/pps.h
--- linux-2.6.32/usr/include/linux/pps.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/pps.h	2019-04-14 13:24:03.114804421 -0500
@@ -0,0 +1,124 @@
+/*
+ * PPS API header
+ *
+ * Copyright (C) 2005-2009   Rodolfo Giometti <giometti@linux.it>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef _PPS_H_
+#define _PPS_H_
+
+#include <linux/types.h>
+
+#define PPS_VERSION		"5.3.6"
+#define PPS_MAX_SOURCES		16		/* should be enough... */
+
+/* Implementation note: the logical states ``assert'' and ``clear''
+ * are implemented in terms of the chip register, i.e. ``assert''
+ * means the bit is set.  */
+
+/*
+ * 3.2 New data structures
+ */
+
+#define PPS_API_VERS_1		1
+#define PPS_API_VERS		PPS_API_VERS_1	/* we use API version 1 */
+#define PPS_MAX_NAME_LEN	32
+
+/* 32-bit vs. 64-bit compatibility.
+ *
+ * 0n i386, the alignment of a uint64_t is only 4 bytes, while on most other
+ * architectures it's 8 bytes. On i386, there will be no padding between the
+ * two consecutive 'struct pps_ktime' members of struct pps_kinfo and struct
+ * pps_kparams. But on most platforms there will be padding to ensure correct
+ * alignment.
+ *
+ * The simple fix is probably to add an explicit padding.
+ *					 		[David Woodhouse]
+ */
+struct pps_ktime {
+	__s64 sec;
+	__s32 nsec;
+	__u32 flags;
+};
+#define PPS_TIME_INVALID	(1<<0)	/* used to specify timeout==NULL */
+
+struct pps_kinfo {
+	__u32 assert_sequence;		/* seq. num. of assert event */
+	__u32 clear_sequence; 		/* seq. num. of clear event */
+	struct pps_ktime assert_tu;	/* time of assert event */
+	struct pps_ktime clear_tu;	/* time of clear event */
+	int current_mode;		/* current mode bits */
+};
+
+struct pps_kparams {
+	int api_version;		/* API version # */
+	int mode;			/* mode bits */
+	struct pps_ktime assert_off_tu;	/* offset compensation for assert */
+	struct pps_ktime clear_off_tu;	/* offset compensation for clear */
+};
+
+/*
+ * 3.3 Mode bit definitions
+ */
+
+/* Device/implementation parameters */
+#define PPS_CAPTUREASSERT	0x01	/* capture assert events */
+#define PPS_CAPTURECLEAR	0x02	/* capture clear events */
+#define PPS_CAPTUREBOTH		0x03	/* capture assert and clear events */
+
+#define PPS_OFFSETASSERT	0x10	/* apply compensation for assert ev. */
+#define PPS_OFFSETCLEAR		0x20	/* apply compensation for clear ev. */
+
+#define PPS_CANWAIT		0x100	/* can we wait for an event? */
+#define PPS_CANPOLL		0x200	/* bit reserved for future use */
+
+/* Kernel actions */
+#define PPS_ECHOASSERT		0x40	/* feed back assert event to output */
+#define PPS_ECHOCLEAR		0x80	/* feed back clear event to output */
+
+/* Timestamp formats */
+#define PPS_TSFMT_TSPEC		0x1000	/* select timespec format */
+#define PPS_TSFMT_NTPFP		0x2000	/* select NTP format */
+
+/*
+ * 3.4.4 New functions: disciplining the kernel timebase
+ */
+
+/* Kernel consumers */
+#define PPS_KC_HARDPPS		0	/* hardpps() (or equivalent) */
+#define PPS_KC_HARDPPS_PLL	1	/* hardpps() constrained to
+					   use a phase-locked loop */
+#define PPS_KC_HARDPPS_FLL	2	/* hardpps() constrained to
+					   use a frequency-locked loop */
+/*
+ * Here begins the implementation-specific part!
+ */
+
+struct pps_fdata {
+	struct pps_kinfo info;
+	struct pps_ktime timeout;
+};
+
+#include <linux/ioctl.h>
+
+#define PPS_GETPARAMS		_IOR('p', 0xa1, struct pps_kparams *)
+#define PPS_SETPARAMS		_IOW('p', 0xa2, struct pps_kparams *)
+#define PPS_GETCAP		_IOR('p', 0xa3, int *)
+#define PPS_FETCH		_IOWR('p', 0xa4, struct pps_fdata *)
+
+#endif /* _PPS_H_ */
diff -uNr linux-2.6.32/usr/include/linux/prctl.h clean_modified/linux-2.6.32/usr/include/linux/prctl.h
--- linux-2.6.32/usr/include/linux/prctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/prctl.h	2019-04-14 13:24:03.114804421 -0500
@@ -0,0 +1,105 @@
+#ifndef _LINUX_PRCTL_H
+#define _LINUX_PRCTL_H
+
+/* Values to pass as first argument to prctl() */
+
+#define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
+#define PR_GET_PDEATHSIG  2  /* Second arg is a ptr to return the signal */
+
+/* Get/set current->mm->dumpable */
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+
+/* Get/set unaligned access control bits (if meaningful) */
+#define PR_GET_UNALIGN	  5
+#define PR_SET_UNALIGN	  6
+# define PR_UNALIGN_NOPRINT	1	/* silently fix up unaligned user accesses */
+# define PR_UNALIGN_SIGBUS	2	/* generate SIGBUS on unaligned user access */
+
+/* Get/set whether or not to drop capabilities on setuid() away from
+ * uid 0 (as per security/commoncap.c) */
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+
+/* Get/set floating-point emulation control bits (if meaningful) */
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+# define PR_FPEMU_NOPRINT	1	/* silently emulate fp operations accesses */
+# define PR_FPEMU_SIGFPE	2	/* don't emulate fp operations, send SIGFPE instead */
+
+/* Get/set floating-point exception mode (if meaningful) */
+#define PR_GET_FPEXC	11
+#define PR_SET_FPEXC	12
+# define PR_FP_EXC_SW_ENABLE	0x80	/* Use FPEXC for FP exception enables */
+# define PR_FP_EXC_DIV		0x010000	/* floating point divide by zero */
+# define PR_FP_EXC_OVF		0x020000	/* floating point overflow */
+# define PR_FP_EXC_UND		0x040000	/* floating point underflow */
+# define PR_FP_EXC_RES		0x080000	/* floating point inexact result */
+# define PR_FP_EXC_INV		0x100000	/* floating point invalid operation */
+# define PR_FP_EXC_DISABLED	0	/* FP exceptions disabled */
+# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
+# define PR_FP_EXC_ASYNC	2	/* async recoverable exception mode */
+# define PR_FP_EXC_PRECISE	3	/* precise exception mode */
+
+/* Get/set whether we use statistical process timing or accurate timestamp
+ * based process timing */
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+# define PR_TIMING_STATISTICAL  0       /* Normal, traditional,
+                                                   statistical process timing */
+# define PR_TIMING_TIMESTAMP    1       /* Accurate timestamp based
+                                                   process timing */
+
+#define PR_SET_NAME    15		/* Set process name */
+#define PR_GET_NAME    16		/* Get process name */
+
+/* Get/set process endian */
+#define PR_GET_ENDIAN	19
+#define PR_SET_ENDIAN	20
+# define PR_ENDIAN_BIG		0
+# define PR_ENDIAN_LITTLE	1	/* True little endian mode */
+# define PR_ENDIAN_PPC_LITTLE	2	/* "PowerPC" pseudo little endian */
+
+/* Get/set process seccomp mode */
+#define PR_GET_SECCOMP	21
+#define PR_SET_SECCOMP	22
+
+/* Get/set the capability bounding set (as per security/commoncap.c) */
+#define PR_CAPBSET_READ 23
+#define PR_CAPBSET_DROP 24
+
+/* Get/set the process' ability to use the timestamp counter instruction */
+#define PR_GET_TSC 25
+#define PR_SET_TSC 26
+# define PR_TSC_ENABLE		1	/* allow the use of the timestamp counter */
+# define PR_TSC_SIGSEGV		2	/* throw a SIGSEGV instead of reading the TSC */
+
+/* Get/set securebits (as per security/commoncap.c) */
+#define PR_GET_SECUREBITS 27
+#define PR_SET_SECUREBITS 28
+
+/*
+ * Get/set the timerslack as used by poll/select/nanosleep
+ * A value of 0 means "use default"
+ */
+#define PR_SET_TIMERSLACK 29
+#define PR_GET_TIMERSLACK 30
+
+#define PR_TASK_PERF_EVENTS_DISABLE		31
+#define PR_TASK_PERF_EVENTS_ENABLE		32
+
+/*
+ * Set early/late kill mode for hwpoison memory corruption.
+ * This influences when the process gets killed on a memory corruption.
+ */
+#define PR_MCE_KILL	33
+# define PR_MCE_KILL_CLEAR   0
+# define PR_MCE_KILL_SET     1
+
+# define PR_MCE_KILL_LATE    0
+# define PR_MCE_KILL_EARLY   1
+# define PR_MCE_KILL_DEFAULT 2
+
+#define PR_MCE_KILL_GET 34
+
+#endif /* _LINUX_PRCTL_H */
diff -uNr linux-2.6.32/usr/include/linux/ptrace.h clean_modified/linux-2.6.32/usr/include/linux/ptrace.h
--- linux-2.6.32/usr/include/linux/ptrace.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ptrace.h	2019-04-14 13:24:03.114804421 -0500
@@ -0,0 +1,52 @@
+#ifndef _LINUX_PTRACE_H
+#define _LINUX_PTRACE_H
+/* ptrace.h */
+/* structs and defines to help the user use the ptrace system call. */
+
+/* has the defines to get at the registers. */
+
+#define PTRACE_TRACEME		   0
+#define PTRACE_PEEKTEXT		   1
+#define PTRACE_PEEKDATA		   2
+#define PTRACE_PEEKUSR		   3
+#define PTRACE_POKETEXT		   4
+#define PTRACE_POKEDATA		   5
+#define PTRACE_POKEUSR		   6
+#define PTRACE_CONT		   7
+#define PTRACE_KILL		   8
+#define PTRACE_SINGLESTEP	   9
+
+#define PTRACE_ATTACH		  16
+#define PTRACE_DETACH		  17
+
+#define PTRACE_SYSCALL		  24
+
+/* 0x4200-0x4300 are reserved for architecture-independent additions.  */
+#define PTRACE_SETOPTIONS	0x4200
+#define PTRACE_GETEVENTMSG	0x4201
+#define PTRACE_GETSIGINFO	0x4202
+#define PTRACE_SETSIGINFO	0x4203
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD	0x00000001
+#define PTRACE_O_TRACEFORK	0x00000002
+#define PTRACE_O_TRACEVFORK	0x00000004
+#define PTRACE_O_TRACECLONE	0x00000008
+#define PTRACE_O_TRACEEXEC	0x00000010
+#define PTRACE_O_TRACEVFORKDONE	0x00000020
+#define PTRACE_O_TRACEEXIT	0x00000040
+
+#define PTRACE_O_MASK		0x0000007f
+
+/* Wait extended result codes for the above trace options.  */
+#define PTRACE_EVENT_FORK	1
+#define PTRACE_EVENT_VFORK	2
+#define PTRACE_EVENT_CLONE	3
+#define PTRACE_EVENT_EXEC	4
+#define PTRACE_EVENT_VFORK_DONE	5
+#define PTRACE_EVENT_EXIT	6
+
+#include <asm/ptrace.h>
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/qnx4_fs.h clean_modified/linux-2.6.32/usr/include/linux/qnx4_fs.h
--- linux-2.6.32/usr/include/linux/qnx4_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/qnx4_fs.h	2019-04-14 13:24:03.114804421 -0500
@@ -0,0 +1,88 @@
+/*
+ *  Name                         : qnx4_fs.h
+ *  Author                       : Richard Frowijn
+ *  Function                     : qnx4 global filesystem definitions
+ *  History                      : 23-03-1998 created
+ */
+#ifndef _LINUX_QNX4_FS_H
+#define _LINUX_QNX4_FS_H
+
+#include <linux/types.h>
+#include <linux/qnxtypes.h>
+#include <linux/magic.h>
+
+#define QNX4_ROOT_INO 1
+
+#define QNX4_MAX_XTNTS_PER_XBLK	60
+/* for di_status */
+#define QNX4_FILE_USED          0x01
+#define QNX4_FILE_MODIFIED      0x02
+#define QNX4_FILE_BUSY          0x04
+#define QNX4_FILE_LINK          0x08
+#define QNX4_FILE_INODE         0x10
+#define QNX4_FILE_FSYSCLEAN     0x20
+
+#define QNX4_I_MAP_SLOTS	8
+#define QNX4_Z_MAP_SLOTS	64
+#define QNX4_VALID_FS		0x0001	/* Clean fs. */
+#define QNX4_ERROR_FS		0x0002	/* fs has errors. */
+#define QNX4_BLOCK_SIZE         0x200	/* blocksize of 512 bytes */
+#define QNX4_BLOCK_SIZE_BITS    9	/* blocksize shift */
+#define QNX4_DIR_ENTRY_SIZE     0x040	/* dir entry size of 64 bytes */
+#define QNX4_DIR_ENTRY_SIZE_BITS 6	/* dir entry size shift */
+#define QNX4_XBLK_ENTRY_SIZE    0x200	/* xblk entry size */
+#define QNX4_INODES_PER_BLOCK   0x08	/* 512 / 64 */
+
+/* for filenames */
+#define QNX4_SHORT_NAME_MAX	16
+#define QNX4_NAME_MAX		48
+
+/*
+ * This is the original qnx4 inode layout on disk.
+ */
+struct qnx4_inode_entry {
+	char		di_fname[QNX4_SHORT_NAME_MAX];
+	qnx4_off_t	di_size;
+	qnx4_xtnt_t	di_first_xtnt;
+	__le32		di_xblk;
+	__le32		di_ftime;
+	__le32		di_mtime;
+	__le32		di_atime;
+	__le32		di_ctime;
+	qnx4_nxtnt_t	di_num_xtnts;
+	qnx4_mode_t	di_mode;
+	qnx4_muid_t	di_uid;
+	qnx4_mgid_t	di_gid;
+	qnx4_nlink_t	di_nlink;
+	__u8		di_zero[4];
+	qnx4_ftype_t	di_type;
+	__u8		di_status;
+};
+
+struct qnx4_link_info {
+	char		dl_fname[QNX4_NAME_MAX];
+	__le32		dl_inode_blk;
+	__u8		dl_inode_ndx;
+	__u8		dl_spare[10];
+	__u8		dl_status;
+};
+
+struct qnx4_xblk {
+	__le32		xblk_next_xblk;
+	__le32		xblk_prev_xblk;
+	__u8		xblk_num_xtnts;
+	__u8		xblk_spare[3];
+	__le32		xblk_num_blocks;
+	qnx4_xtnt_t	xblk_xtnts[QNX4_MAX_XTNTS_PER_XBLK];
+	char		xblk_signature[8];
+	qnx4_xtnt_t	xblk_first_xtnt;
+};
+
+struct qnx4_super_block {
+	struct qnx4_inode_entry RootDir;
+	struct qnx4_inode_entry Inode;
+	struct qnx4_inode_entry Boot;
+	struct qnx4_inode_entry AltBoot;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/qnxtypes.h clean_modified/linux-2.6.32/usr/include/linux/qnxtypes.h
--- linux-2.6.32/usr/include/linux/qnxtypes.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/qnxtypes.h	2019-04-14 13:24:03.114804421 -0500
@@ -0,0 +1,28 @@
+/*
+ *  Name                         : qnxtypes.h
+ *  Author                       : Richard Frowijn
+ *  Function                     : standard qnx types
+ *  History                      : 22-03-1998 created
+ *
+ */
+
+#ifndef _QNX4TYPES_H
+#define _QNX4TYPES_H
+
+#include <linux/types.h>
+
+typedef __le16 qnx4_nxtnt_t;
+typedef __u8  qnx4_ftype_t;
+
+typedef struct {
+	__le32 xtnt_blk;
+	__le32 xtnt_size;
+} qnx4_xtnt_t;
+
+typedef __le16 qnx4_mode_t;
+typedef __le16 qnx4_muid_t;
+typedef __le16 qnx4_mgid_t;
+typedef __le32 qnx4_off_t;
+typedef __le16 qnx4_nlink_t;
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/quota.h clean_modified/linux-2.6.32/usr/include/linux/quota.h
--- linux-2.6.32/usr/include/linux/quota.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/quota.h	2019-04-14 13:24:03.116126395 -0500
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 1982, 1986 Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Robert Elz at The University of Melbourne.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_QUOTA_
+#define _LINUX_QUOTA_
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#define __DQUOT_VERSION__	"dquot_6.5.2"
+
+#define MAXQUOTAS 2
+#define USRQUOTA  0		/* element used for user quotas */
+#define GRPQUOTA  1		/* element used for group quotas */
+
+/*
+ * Definitions for the default names of the quotas files.
+ */
+#define INITQFNAMES { \
+	"user",    /* USRQUOTA */ \
+	"group",   /* GRPQUOTA */ \
+	"undefined", \
+};
+
+/*
+ * Command definitions for the 'quotactl' system call.
+ * The commands are broken into a main command defined below
+ * and a subcommand that is used to convey the type of
+ * quota that is being manipulated (see above).
+ */
+#define SUBCMDMASK  0x00ff
+#define SUBCMDSHIFT 8
+#define QCMD(cmd, type)  (((cmd) << SUBCMDSHIFT) | ((type) & SUBCMDMASK))
+
+#define Q_SYNC     0x800001	/* sync disk copy of a filesystems quotas */
+#define Q_QUOTAON  0x800002	/* turn quotas on */
+#define Q_QUOTAOFF 0x800003	/* turn quotas off */
+#define Q_GETFMT   0x800004	/* get quota format used on given filesystem */
+#define Q_GETINFO  0x800005	/* get information about quota files */
+#define Q_SETINFO  0x800006	/* set information about quota files */
+#define Q_GETQUOTA 0x800007	/* get user quota structure */
+#define Q_SETQUOTA 0x800008	/* set user quota structure */
+
+/* Quota format type IDs */
+#define	QFMT_VFS_OLD 1
+#define	QFMT_VFS_V0 2
+
+/* Size of block in which space limits are passed through the quota
+ * interface */
+#define QIF_DQBLKSIZE_BITS 10
+#define QIF_DQBLKSIZE (1 << QIF_DQBLKSIZE_BITS)
+
+/*
+ * Quota structure used for communication with userspace via quotactl
+ * Following flags are used to specify which fields are valid
+ */
+enum {
+	QIF_BLIMITS_B = 0,
+	QIF_SPACE_B,
+	QIF_ILIMITS_B,
+	QIF_INODES_B,
+	QIF_BTIME_B,
+	QIF_ITIME_B,
+};
+
+#define QIF_BLIMITS	(1 << QIF_BLIMITS_B)
+#define QIF_SPACE	(1 << QIF_SPACE_B)
+#define QIF_ILIMITS	(1 << QIF_ILIMITS_B)
+#define QIF_INODES	(1 << QIF_INODES_B)
+#define QIF_BTIME	(1 << QIF_BTIME_B)
+#define QIF_ITIME	(1 << QIF_ITIME_B)
+#define QIF_LIMITS	(QIF_BLIMITS | QIF_ILIMITS)
+#define QIF_USAGE	(QIF_SPACE | QIF_INODES)
+#define QIF_TIMES	(QIF_BTIME | QIF_ITIME)
+#define QIF_ALL		(QIF_LIMITS | QIF_USAGE | QIF_TIMES)
+
+struct if_dqblk {
+	__u64 dqb_bhardlimit;
+	__u64 dqb_bsoftlimit;
+	__u64 dqb_curspace;
+	__u64 dqb_ihardlimit;
+	__u64 dqb_isoftlimit;
+	__u64 dqb_curinodes;
+	__u64 dqb_btime;
+	__u64 dqb_itime;
+	__u32 dqb_valid;
+};
+
+/*
+ * Structure used for setting quota information about file via quotactl
+ * Following flags are used to specify which fields are valid
+ */
+#define IIF_BGRACE	1
+#define IIF_IGRACE	2
+#define IIF_FLAGS	4
+#define IIF_ALL		(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)
+
+struct if_dqinfo {
+	__u64 dqi_bgrace;
+	__u64 dqi_igrace;
+	__u32 dqi_flags;
+	__u32 dqi_valid;
+};
+
+/*
+ * Definitions for quota netlink interface
+ */
+#define QUOTA_NL_NOWARN 0
+#define QUOTA_NL_IHARDWARN 1		/* Inode hardlimit reached */
+#define QUOTA_NL_ISOFTLONGWARN 2 	/* Inode grace time expired */
+#define QUOTA_NL_ISOFTWARN 3		/* Inode softlimit reached */
+#define QUOTA_NL_BHARDWARN 4		/* Block hardlimit reached */
+#define QUOTA_NL_BSOFTLONGWARN 5	/* Block grace time expired */
+#define QUOTA_NL_BSOFTWARN 6		/* Block softlimit reached */
+#define QUOTA_NL_IHARDBELOW 7		/* Usage got below inode hardlimit */
+#define QUOTA_NL_ISOFTBELOW 8		/* Usage got below inode softlimit */
+#define QUOTA_NL_BHARDBELOW 9		/* Usage got below block hardlimit */
+#define QUOTA_NL_BSOFTBELOW 10		/* Usage got below block softlimit */
+
+enum {
+	QUOTA_NL_C_UNSPEC,
+	QUOTA_NL_C_WARNING,
+	__QUOTA_NL_C_MAX,
+};
+#define QUOTA_NL_C_MAX (__QUOTA_NL_C_MAX - 1)
+
+enum {
+	QUOTA_NL_A_UNSPEC,
+	QUOTA_NL_A_QTYPE,
+	QUOTA_NL_A_EXCESS_ID,
+	QUOTA_NL_A_WARNING,
+	QUOTA_NL_A_DEV_MAJOR,
+	QUOTA_NL_A_DEV_MINOR,
+	QUOTA_NL_A_CAUSED_ID,
+	__QUOTA_NL_A_MAX,
+};
+#define QUOTA_NL_A_MAX (__QUOTA_NL_A_MAX - 1)
+
+
+
+# /* nodep */ include <sys/cdefs.h>
+
+__BEGIN_DECLS
+long quotactl __P ((unsigned int, const char *, int, caddr_t));
+__END_DECLS
+
+#endif /* _QUOTA_ */
diff -uNr linux-2.6.32/usr/include/linux/radeonfb.h clean_modified/linux-2.6.32/usr/include/linux/radeonfb.h
--- linux-2.6.32/usr/include/linux/radeonfb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/radeonfb.h	2019-04-14 13:24:03.116126395 -0500
@@ -0,0 +1,15 @@
+#ifndef __LINUX_RADEONFB_H__
+#define __LINUX_RADEONFB_H__
+
+#include <asm/ioctl.h>
+#include <linux/types.h>
+
+#define ATY_RADEON_LCD_ON	0x00000001
+#define ATY_RADEON_CRT_ON	0x00000002
+
+
+#define FBIO_RADEON_GET_MIRROR	_IOR('@', 3, size_t)
+#define FBIO_RADEON_SET_MIRROR	_IOW('@', 4, size_t)
+
+#endif
+
diff -uNr linux-2.6.32/usr/include/linux/raid/md_p.h clean_modified/linux-2.6.32/usr/include/linux/raid/md_p.h
--- linux-2.6.32/usr/include/linux/raid/md_p.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/raid/md_p.h	2019-04-14 13:24:03.118219284 -0500
@@ -0,0 +1,277 @@
+/*
+   md_p.h : physical layout of Linux RAID devices
+          Copyright (C) 1996-98 Ingo Molnar, Gadi Oxman
+	  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+   
+   You should have received a copy of the GNU General Public License
+   (for example /usr/src/linux/COPYING); if not, write to the Free
+   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+*/
+
+#ifndef _MD_P_H
+#define _MD_P_H
+
+#include <linux/types.h>
+
+/*
+ * RAID superblock.
+ *
+ * The RAID superblock maintains some statistics on each RAID configuration.
+ * Each real device in the RAID set contains it near the end of the device.
+ * Some of the ideas are copied from the ext2fs implementation.
+ *
+ * We currently use 4096 bytes as follows:
+ *
+ *	word offset	function
+ *
+ *	   0  -    31	Constant generic RAID device information.
+ *        32  -    63   Generic state information.
+ *	  64  -   127	Personality specific information.
+ *	 128  -   511	12 32-words descriptors of the disks in the raid set.
+ *	 512  -   911	Reserved.
+ *	 912  -  1023	Disk specific descriptor.
+ */
+
+/*
+ * If x is the real device size in bytes, we return an apparent size of:
+ *
+ *	y = (x & ~(MD_RESERVED_BYTES - 1)) - MD_RESERVED_BYTES
+ *
+ * and place the 4kB superblock at offset y.
+ */
+#define MD_RESERVED_BYTES		(64 * 1024)
+#define MD_RESERVED_SECTORS		(MD_RESERVED_BYTES / 512)
+
+#define MD_NEW_SIZE_SECTORS(x)		((x & ~(MD_RESERVED_SECTORS - 1)) - MD_RESERVED_SECTORS)
+
+#define MD_SB_BYTES			4096
+#define MD_SB_WORDS			(MD_SB_BYTES / 4)
+#define MD_SB_SECTORS			(MD_SB_BYTES / 512)
+
+/*
+ * The following are counted in 32-bit words
+ */
+#define	MD_SB_GENERIC_OFFSET		0
+#define MD_SB_PERSONALITY_OFFSET	64
+#define MD_SB_DISKS_OFFSET		128
+#define MD_SB_DESCRIPTOR_OFFSET		992
+
+#define MD_SB_GENERIC_CONSTANT_WORDS	32
+#define MD_SB_GENERIC_STATE_WORDS	32
+#define MD_SB_GENERIC_WORDS		(MD_SB_GENERIC_CONSTANT_WORDS + MD_SB_GENERIC_STATE_WORDS)
+#define MD_SB_PERSONALITY_WORDS		64
+#define MD_SB_DESCRIPTOR_WORDS		32
+#define MD_SB_DISKS			27
+#define MD_SB_DISKS_WORDS		(MD_SB_DISKS*MD_SB_DESCRIPTOR_WORDS)
+#define MD_SB_RESERVED_WORDS		(1024 - MD_SB_GENERIC_WORDS - MD_SB_PERSONALITY_WORDS - MD_SB_DISKS_WORDS - MD_SB_DESCRIPTOR_WORDS)
+#define MD_SB_EQUAL_WORDS		(MD_SB_GENERIC_WORDS + MD_SB_PERSONALITY_WORDS + MD_SB_DISKS_WORDS)
+
+/*
+ * Device "operational" state bits
+ */
+#define MD_DISK_FAULTY		0 /* disk is faulty / operational */
+#define MD_DISK_ACTIVE		1 /* disk is running or spare disk */
+#define MD_DISK_SYNC		2 /* disk is in sync with the raid set */
+#define MD_DISK_REMOVED		3 /* disk is in sync with the raid set */
+
+#define	MD_DISK_WRITEMOSTLY	9 /* disk is "write-mostly" is RAID1 config.
+				   * read requests will only be sent here in
+				   * dire need
+				   */
+
+typedef struct mdp_device_descriptor_s {
+	__u32 number;		/* 0 Device number in the entire set	      */
+	__u32 major;		/* 1 Device major number		      */
+	__u32 minor;		/* 2 Device minor number		      */
+	__u32 raid_disk;	/* 3 The role of the device in the raid set   */
+	__u32 state;		/* 4 Operational state			      */
+	__u32 reserved[MD_SB_DESCRIPTOR_WORDS - 5];
+} mdp_disk_t;
+
+#define MD_SB_MAGIC		0xa92b4efc
+
+/*
+ * Superblock state bits
+ */
+#define MD_SB_CLEAN		0
+#define MD_SB_ERRORS		1
+
+#define	MD_SB_BITMAP_PRESENT	8 /* bitmap may be present nearby */
+
+/*
+ * Notes:
+ * - if an array is being reshaped (restriped) in order to change the
+ *   the number of active devices in the array, 'raid_disks' will be
+ *   the larger of the old and new numbers.  'delta_disks' will
+ *   be the "new - old".  So if +ve, raid_disks is the new value, and
+ *   "raid_disks-delta_disks" is the old.  If -ve, raid_disks is the
+ *   old value and "raid_disks+delta_disks" is the new (smaller) value.
+ */
+
+
+typedef struct mdp_superblock_s {
+	/*
+	 * Constant generic information
+	 */
+	__u32 md_magic;		/*  0 MD identifier 			      */
+	__u32 major_version;	/*  1 major version to which the set conforms */
+	__u32 minor_version;	/*  2 minor version ...			      */
+	__u32 patch_version;	/*  3 patchlevel version ...		      */
+	__u32 gvalid_words;	/*  4 Number of used words in this section    */
+	__u32 set_uuid0;	/*  5 Raid set identifier		      */
+	__u32 ctime;		/*  6 Creation time			      */
+	__u32 level;		/*  7 Raid personality			      */
+	__u32 size;		/*  8 Apparent size of each individual disk   */
+	__u32 nr_disks;		/*  9 total disks in the raid set	      */
+	__u32 raid_disks;	/* 10 disks in a fully functional raid set    */
+	__u32 md_minor;		/* 11 preferred MD minor device number	      */
+	__u32 not_persistent;	/* 12 does it have a persistent superblock    */
+	__u32 set_uuid1;	/* 13 Raid set identifier #2		      */
+	__u32 set_uuid2;	/* 14 Raid set identifier #3		      */
+	__u32 set_uuid3;	/* 15 Raid set identifier #4		      */
+	__u32 gstate_creserved[MD_SB_GENERIC_CONSTANT_WORDS - 16];
+
+	/*
+	 * Generic state information
+	 */
+	__u32 utime;		/*  0 Superblock update time		      */
+	__u32 state;		/*  1 State bits (clean, ...)		      */
+	__u32 active_disks;	/*  2 Number of currently active disks	      */
+	__u32 working_disks;	/*  3 Number of working disks		      */
+	__u32 failed_disks;	/*  4 Number of failed disks		      */
+	__u32 spare_disks;	/*  5 Number of spare disks		      */
+	__u32 sb_csum;		/*  6 checksum of the whole superblock        */
+#ifdef __BIG_ENDIAN
+	__u32 events_hi;	/*  7 high-order of superblock update count   */
+	__u32 events_lo;	/*  8 low-order of superblock update count    */
+	__u32 cp_events_hi;	/*  9 high-order of checkpoint update count   */
+	__u32 cp_events_lo;	/* 10 low-order of checkpoint update count    */
+#else
+	__u32 events_lo;	/*  7 low-order of superblock update count    */
+	__u32 events_hi;	/*  8 high-order of superblock update count   */
+	__u32 cp_events_lo;	/*  9 low-order of checkpoint update count    */
+	__u32 cp_events_hi;	/* 10 high-order of checkpoint update count   */
+#endif
+	__u32 recovery_cp;	/* 11 recovery checkpoint sector count	      */
+	/* There are only valid for minor_version > 90 */
+	__u64 reshape_position;	/* 12,13 next address in array-space for reshape */
+	__u32 new_level;	/* 14 new level we are reshaping to	      */
+	__u32 delta_disks;	/* 15 change in number of raid_disks	      */
+	__u32 new_layout;	/* 16 new layout			      */
+	__u32 new_chunk;	/* 17 new chunk size (bytes)		      */
+	__u32 gstate_sreserved[MD_SB_GENERIC_STATE_WORDS - 18];
+
+	/*
+	 * Personality information
+	 */
+	__u32 layout;		/*  0 the array's physical layout	      */
+	__u32 chunk_size;	/*  1 chunk size in bytes		      */
+	__u32 root_pv;		/*  2 LV root PV */
+	__u32 root_block;	/*  3 LV root block */
+	__u32 pstate_reserved[MD_SB_PERSONALITY_WORDS - 4];
+
+	/*
+	 * Disks information
+	 */
+	mdp_disk_t disks[MD_SB_DISKS];
+
+	/*
+	 * Reserved
+	 */
+	__u32 reserved[MD_SB_RESERVED_WORDS];
+
+	/*
+	 * Active descriptor
+	 */
+	mdp_disk_t this_disk;
+
+} mdp_super_t;
+
+static __inline__ __u64 md_event(mdp_super_t *sb) {
+	__u64 ev = sb->events_hi;
+	return (ev<<32)| sb->events_lo;
+}
+
+#define MD_SUPERBLOCK_1_TIME_SEC_MASK ((1ULL<<40) - 1)
+
+/*
+ * The version-1 superblock :
+ * All numeric fields are little-endian.
+ *
+ * total size: 256 bytes plus 2 per device.
+ *  1K allows 384 devices.
+ */
+struct mdp_superblock_1 {
+	/* constant array information - 128 bytes */
+	__le32	magic;		/* MD_SB_MAGIC: 0xa92b4efc - little endian */
+	__le32	major_version;	/* 1 */
+	__le32	feature_map;	/* bit 0 set if 'bitmap_offset' is meaningful */
+	__le32	pad0;		/* always set to 0 when writing */
+
+	__u8	set_uuid[16];	/* user-space generated. */
+	char	set_name[32];	/* set and interpreted by user-space */
+
+	__le64	ctime;		/* lo 40 bits are seconds, top 24 are microseconds or 0*/
+	__le32	level;		/* -4 (multipath), -1 (linear), 0,1,4,5 */
+	__le32	layout;		/* only for raid5 and raid10 currently */
+	__le64	size;		/* used size of component devices, in 512byte sectors */
+
+	__le32	chunksize;	/* in 512byte sectors */
+	__le32	raid_disks;
+	__le32	bitmap_offset;	/* sectors after start of superblock that bitmap starts
+				 * NOTE: signed, so bitmap can be before superblock
+				 * only meaningful of feature_map[0] is set.
+				 */
+
+	/* These are only valid with feature bit '4' */
+	__le32	new_level;	/* new level we are reshaping to		*/
+	__le64	reshape_position;	/* next address in array-space for reshape */
+	__le32	delta_disks;	/* change in number of raid_disks		*/
+	__le32	new_layout;	/* new layout					*/
+	__le32	new_chunk;	/* new chunk size (512byte sectors)		*/
+	__u8	pad1[128-124];	/* set to 0 when written */
+
+	/* constant this-device information - 64 bytes */
+	__le64	data_offset;	/* sector start of data, often 0 */
+	__le64	data_size;	/* sectors in this device that can be used for data */
+	__le64	super_offset;	/* sector start of this superblock */
+	__le64	recovery_offset;/* sectors before this offset (from data_offset) have been recovered */
+	__le32	dev_number;	/* permanent identifier of this  device - not role in raid */
+	__le32	cnt_corrected_read; /* number of read errors that were corrected by re-writing */
+	__u8	device_uuid[16]; /* user-space setable, ignored by kernel */
+	__u8	devflags;	/* per-device flags.  Only one defined...*/
+#define	WriteMostly1	1	/* mask for writemostly flag in above */
+	__u8	pad2[64-57];	/* set to 0 when writing */
+
+	/* array state information - 64 bytes */
+	__le64	utime;		/* 40 bits second, 24 btes microseconds */
+	__le64	events;		/* incremented when superblock updated */
+	__le64	resync_offset;	/* data before this offset (from data_offset) known to be in sync */
+	__le32	sb_csum;	/* checksum upto devs[max_dev] */
+	__le32	max_dev;	/* size of devs[] array to consider */
+	__u8	pad3[64-32];	/* set to 0 when writing */
+
+	/* device state information. Indexed by dev_number.
+	 * 2 bytes per device
+	 * Note there are no per-device state flags. State information is rolled
+	 * into the 'roles' value.  If a device is spare or faulty, then it doesn't
+	 * have a meaningful role.
+	 */
+	__le16	dev_roles[0];	/* role in array, or 0xffff for a spare, or 0xfffe for faulty */
+};
+
+/* feature_map bits */
+#define MD_FEATURE_BITMAP_OFFSET	1
+#define	MD_FEATURE_RECOVERY_OFFSET	2 /* recovery_offset is present and
+					   * must be honoured
+					   */
+#define	MD_FEATURE_RESHAPE_ACTIVE	4
+
+#define	MD_FEATURE_ALL			(1|2|4)
+
+#endif 
+
diff -uNr linux-2.6.32/usr/include/linux/raid/md_u.h clean_modified/linux-2.6.32/usr/include/linux/raid/md_u.h
--- linux-2.6.32/usr/include/linux/raid/md_u.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/raid/md_u.h	2019-04-14 13:24:03.119227786 -0500
@@ -0,0 +1,156 @@
+/*
+   md_u.h : user <=> kernel API between Linux raidtools and RAID drivers
+          Copyright (C) 1998 Ingo Molnar
+	  
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+   
+   You should have received a copy of the GNU General Public License
+   (for example /usr/src/linux/COPYING); if not, write to the Free
+   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+*/
+
+#ifndef _MD_U_H
+#define _MD_U_H
+
+/*
+ * Different major versions are not compatible.
+ * Different minor versions are only downward compatible.
+ * Different patchlevel versions are downward and upward compatible.
+ */
+#define MD_MAJOR_VERSION                0
+#define MD_MINOR_VERSION                90
+/*
+ * MD_PATCHLEVEL_VERSION indicates kernel functionality.
+ * >=1 means different superblock formats are selectable using SET_ARRAY_INFO
+ *     and major_version/minor_version accordingly
+ * >=2 means that Internal bitmaps are supported by setting MD_SB_BITMAP_PRESENT
+ *     in the super status byte
+ * >=3 means that bitmap superblock version 4 is supported, which uses
+ *     little-ending representation rather than host-endian
+ */
+#define MD_PATCHLEVEL_VERSION           3
+
+/* ioctls */
+
+/* status */
+#define RAID_VERSION		_IOR (MD_MAJOR, 0x10, mdu_version_t)
+#define GET_ARRAY_INFO		_IOR (MD_MAJOR, 0x11, mdu_array_info_t)
+#define GET_DISK_INFO		_IOR (MD_MAJOR, 0x12, mdu_disk_info_t)
+#define PRINT_RAID_DEBUG	_IO (MD_MAJOR, 0x13)
+#define RAID_AUTORUN		_IO (MD_MAJOR, 0x14)
+#define GET_BITMAP_FILE		_IOR (MD_MAJOR, 0x15, mdu_bitmap_file_t)
+
+/* configuration */
+#define CLEAR_ARRAY		_IO (MD_MAJOR, 0x20)
+#define ADD_NEW_DISK		_IOW (MD_MAJOR, 0x21, mdu_disk_info_t)
+#define HOT_REMOVE_DISK		_IO (MD_MAJOR, 0x22)
+#define SET_ARRAY_INFO		_IOW (MD_MAJOR, 0x23, mdu_array_info_t)
+#define SET_DISK_INFO		_IO (MD_MAJOR, 0x24)
+#define WRITE_RAID_INFO		_IO (MD_MAJOR, 0x25)
+#define UNPROTECT_ARRAY		_IO (MD_MAJOR, 0x26)
+#define PROTECT_ARRAY		_IO (MD_MAJOR, 0x27)
+#define HOT_ADD_DISK		_IO (MD_MAJOR, 0x28)
+#define SET_DISK_FAULTY		_IO (MD_MAJOR, 0x29)
+#define HOT_GENERATE_ERROR	_IO (MD_MAJOR, 0x2a)
+#define SET_BITMAP_FILE		_IOW (MD_MAJOR, 0x2b, int)
+
+/* usage */
+#define RUN_ARRAY		_IOW (MD_MAJOR, 0x30, mdu_param_t)
+/*  0x31 was START_ARRAY  */
+#define STOP_ARRAY		_IO (MD_MAJOR, 0x32)
+#define STOP_ARRAY_RO		_IO (MD_MAJOR, 0x33)
+#define RESTART_ARRAY_RW	_IO (MD_MAJOR, 0x34)
+
+/* 63 partitions with the alternate major number (mdp) */
+#define MdpMinorShift 6
+
+typedef struct mdu_version_s {
+	int major;
+	int minor;
+	int patchlevel;
+} mdu_version_t;
+
+typedef struct mdu_array_info_s {
+	/*
+	 * Generic constant information
+	 */
+	int major_version;
+	int minor_version;
+	int patch_version;
+	int ctime;
+	int level;
+	int size;
+	int nr_disks;
+	int raid_disks;
+	int md_minor;
+	int not_persistent;
+
+	/*
+	 * Generic state information
+	 */
+	int utime;		/*  0 Superblock update time		      */
+	int state;		/*  1 State bits (clean, ...)		      */
+	int active_disks;	/*  2 Number of currently active disks	      */
+	int working_disks;	/*  3 Number of working disks		      */
+	int failed_disks;	/*  4 Number of failed disks		      */
+	int spare_disks;	/*  5 Number of spare disks		      */
+
+	/*
+	 * Personality information
+	 */
+	int layout;		/*  0 the array's physical layout	      */
+	int chunk_size;	/*  1 chunk size in bytes		      */
+
+} mdu_array_info_t;
+
+/* non-obvious values for 'level' */
+#define	LEVEL_MULTIPATH		(-4)
+#define	LEVEL_LINEAR		(-1)
+#define	LEVEL_FAULTY		(-5)
+
+/* we need a value for 'no level specified' and 0
+ * means 'raid0', so we need something else.  This is
+ * for internal use only
+ */
+#define	LEVEL_NONE		(-1000000)
+
+typedef struct mdu_disk_info_s {
+	/*
+	 * configuration/status of one particular disk
+	 */
+	int number;
+	int major;
+	int minor;
+	int raid_disk;
+	int state;
+
+} mdu_disk_info_t;
+
+typedef struct mdu_start_info_s {
+	/*
+	 * configuration/status of one particular disk
+	 */
+	int major;
+	int minor;
+	int raid_disk;
+	int state;
+
+} mdu_start_info_t;
+
+typedef struct mdu_bitmap_file_s
+{
+	char pathname[4096];
+} mdu_bitmap_file_t;
+
+typedef struct mdu_param_s
+{
+	int			personality;	/* 1,2,3,4 */
+	int			chunk_size;	/* in bytes */
+	int			max_fault;	/* unused for now */
+} mdu_param_t;
+
+#endif 
+
diff -uNr linux-2.6.32/usr/include/linux/random.h clean_modified/linux-2.6.32/usr/include/linux/random.h
--- linux-2.6.32/usr/include/linux/random.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/random.h	2019-04-14 13:24:03.120112466 -0500
@@ -0,0 +1,46 @@
+/*
+ * include/linux/random.h
+ *
+ * Include file for the random number generator.
+ */
+
+#ifndef _LINUX_RANDOM_H
+#define _LINUX_RANDOM_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/irqnr.h>
+
+/* ioctl()'s for the random number generator */
+
+/* Get the entropy count. */
+#define RNDGETENTCNT	_IOR( 'R', 0x00, int )
+
+/* Add to (or subtract from) the entropy count.  (Superuser only.) */
+#define RNDADDTOENTCNT	_IOW( 'R', 0x01, int )
+
+/* Get the contents of the entropy pool.  (Superuser only.) */
+#define RNDGETPOOL	_IOR( 'R', 0x02, int [2] )
+
+/* 
+ * Write bytes into the entropy pool and add to the entropy count.
+ * (Superuser only.)
+ */
+#define RNDADDENTROPY	_IOW( 'R', 0x03, int [2] )
+
+/* Clear entropy count to 0.  (Superuser only.) */
+#define RNDZAPENTCNT	_IO( 'R', 0x04 )
+
+/* Clear the entropy pool and associated counters.  (Superuser only.) */
+#define RNDCLEARPOOL	_IO( 'R', 0x06 )
+
+struct rand_pool_info {
+	int	entropy_count;
+	int	buf_size;
+	__u32	buf[0];
+};
+
+/* Exported functions */
+
+
+#endif /* _LINUX_RANDOM_H */
diff -uNr linux-2.6.32/usr/include/linux/raw.h clean_modified/linux-2.6.32/usr/include/linux/raw.h
--- linux-2.6.32/usr/include/linux/raw.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/raw.h	2019-04-14 13:24:03.120112466 -0500
@@ -0,0 +1,18 @@
+#ifndef __LINUX_RAW_H
+#define __LINUX_RAW_H
+
+#include <linux/types.h>
+
+#define RAW_SETBIND	_IO( 0xac, 0 )
+#define RAW_GETBIND	_IO( 0xac, 1 )
+
+struct raw_config_request 
+{
+	int	raw_minor;
+	__u64	block_major;
+	__u64	block_minor;
+};
+
+#define MAX_RAW_MINORS CONFIG_MAX_RAW_DEVS
+
+#endif /* __LINUX_RAW_H */
diff -uNr linux-2.6.32/usr/include/linux/reboot.h clean_modified/linux-2.6.32/usr/include/linux/reboot.h
--- linux-2.6.32/usr/include/linux/reboot.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/reboot.h	2019-04-14 13:24:03.121058641 -0500
@@ -0,0 +1,39 @@
+#ifndef _LINUX_REBOOT_H
+#define _LINUX_REBOOT_H
+
+/*
+ * Magic values required to use _reboot() system call.
+ */
+
+#define	LINUX_REBOOT_MAGIC1	0xfee1dead
+#define	LINUX_REBOOT_MAGIC2	672274793
+#define	LINUX_REBOOT_MAGIC2A	85072278
+#define	LINUX_REBOOT_MAGIC2B	369367448
+#define	LINUX_REBOOT_MAGIC2C	537993216
+
+
+/*
+ * Commands accepted by the _reboot() system call.
+ *
+ * RESTART     Restart system using default command and mode.
+ * HALT        Stop OS and give system control to ROM monitor, if any.
+ * CAD_ON      Ctrl-Alt-Del sequence causes RESTART command.
+ * CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.
+ * POWER_OFF   Stop OS and remove all power from system, if possible.
+ * RESTART2    Restart system using given command string.
+ * SW_SUSPEND  Suspend system using software suspend if compiled in.
+ * KEXEC       Restart system using a previously loaded Linux kernel
+ */
+
+#define	LINUX_REBOOT_CMD_RESTART	0x01234567
+#define	LINUX_REBOOT_CMD_HALT		0xCDEF0123
+#define	LINUX_REBOOT_CMD_CAD_ON		0x89ABCDEF
+#define	LINUX_REBOOT_CMD_CAD_OFF	0x00000000
+#define	LINUX_REBOOT_CMD_POWER_OFF	0x4321FEDC
+#define	LINUX_REBOOT_CMD_RESTART2	0xA1B2C3D4
+#define	LINUX_REBOOT_CMD_SW_SUSPEND	0xD000FCE2
+#define	LINUX_REBOOT_CMD_KEXEC		0x45584543
+
+
+
+#endif /* _LINUX_REBOOT_H */
diff -uNr linux-2.6.32/usr/include/linux/reiserfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/reiserfs_fs.h
--- linux-2.6.32/usr/include/linux/reiserfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/reiserfs_fs.h	2019-04-14 13:24:03.121058641 -0500
@@ -0,0 +1,35 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+				/* this file has an amazingly stupid
+				   name, yura please fix it to be
+				   reiserfs.h, and merge all the rest
+				   of our .h files that are in this
+				   directory into it.  */
+
+#ifndef _LINUX_REISER_FS_H
+#define _LINUX_REISER_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+
+/*
+ *  include/linux/reiser_fs.h
+ *
+ *  Reiser File System constants and structures
+ *
+ */
+
+/* ioctl's command */
+#define REISERFS_IOC_UNPACK		_IOW(0xCD,1,long)
+/* define following flags to be the same as in ext2, so that chattr(1),
+   lsattr(1) will work with us. */
+#define REISERFS_IOC_GETFLAGS		FS_IOC_GETFLAGS
+#define REISERFS_IOC_SETFLAGS		FS_IOC_SETFLAGS
+#define REISERFS_IOC_GETVERSION		FS_IOC_GETVERSION
+#define REISERFS_IOC_SETVERSION		FS_IOC_SETVERSION
+
+
+#endif				/* _LINUX_REISER_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/reiserfs_xattr.h clean_modified/linux-2.6.32/usr/include/linux/reiserfs_xattr.h
--- linux-2.6.32/usr/include/linux/reiserfs_xattr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/reiserfs_xattr.h	2019-04-14 13:24:03.122011055 -0500
@@ -0,0 +1,25 @@
+/*
+  File: linux/reiserfs_xattr.h
+*/
+
+#ifndef _LINUX_REISERFS_XATTR_H
+#define _LINUX_REISERFS_XATTR_H
+
+#include <linux/types.h>
+
+/* Magic value in header */
+#define REISERFS_XATTR_MAGIC 0x52465841	/* "RFXA" */
+
+struct reiserfs_xattr_header {
+	__le32 h_magic;		/* magic number for identification */
+	__le32 h_hash;		/* hash of the value */
+};
+
+struct reiserfs_security_handle {
+	char *name;
+	void *value;
+	size_t length;
+};
+
+
+#endif  /*  _LINUX_REISERFS_XATTR_H  */
diff -uNr linux-2.6.32/usr/include/linux/resource.h clean_modified/linux-2.6.32/usr/include/linux/resource.h
--- linux-2.6.32/usr/include/linux/resource.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/resource.h	2019-04-14 13:24:03.122011055 -0500
@@ -0,0 +1,75 @@
+#ifndef _LINUX_RESOURCE_H
+#define _LINUX_RESOURCE_H
+
+#include <linux/time.h>
+
+struct task_struct;
+
+/*
+ * Resource control/accounting header file for linux
+ */
+
+/*
+ * Definition of struct rusage taken from BSD 4.3 Reno
+ * 
+ * We don't support all of these yet, but we might as well have them....
+ * Otherwise, each time we add new items, programs which depend on this
+ * structure will lose.  This reduces the chances of that happening.
+ */
+#define	RUSAGE_SELF	0
+#define	RUSAGE_CHILDREN	(-1)
+#define RUSAGE_BOTH	(-2)		/* sys_wait4() uses this */
+#define	RUSAGE_THREAD	1		/* only the calling thread */
+
+struct	rusage {
+	struct timeval ru_utime;	/* user time used */
+	struct timeval ru_stime;	/* system time used */
+	long	ru_maxrss;		/* maximum resident set size */
+	long	ru_ixrss;		/* integral shared memory size */
+	long	ru_idrss;		/* integral unshared data size */
+	long	ru_isrss;		/* integral unshared stack size */
+	long	ru_minflt;		/* page reclaims */
+	long	ru_majflt;		/* page faults */
+	long	ru_nswap;		/* swaps */
+	long	ru_inblock;		/* block input operations */
+	long	ru_oublock;		/* block output operations */
+	long	ru_msgsnd;		/* messages sent */
+	long	ru_msgrcv;		/* messages received */
+	long	ru_nsignals;		/* signals received */
+	long	ru_nvcsw;		/* voluntary context switches */
+	long	ru_nivcsw;		/* involuntary " */
+};
+
+struct rlimit {
+	unsigned long	rlim_cur;
+	unsigned long	rlim_max;
+};
+
+#define	PRIO_MIN	(-20)
+#define	PRIO_MAX	20
+
+#define	PRIO_PROCESS	0
+#define	PRIO_PGRP	1
+#define	PRIO_USER	2
+
+/*
+ * Limit the stack by to some sane default: root can always
+ * increase this limit if needed..  8MB seems reasonable.
+ */
+#define _STK_LIM	(8*1024*1024)
+
+/*
+ * GPG2 wants 64kB of mlocked memory, to make sure pass phrases
+ * and other sensitive information are never written to disk.
+ */
+#define MLOCK_LIMIT	((PAGE_SIZE > 64*1024) ? PAGE_SIZE : 64*1024)
+
+/*
+ * Due to binary compatibility, the actual resource numbers
+ * may be different for different linux versions..
+ */
+#include <asm/resource.h>
+
+int getrusage(struct task_struct *p, int who, struct rusage *ru);
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/rfkill.h clean_modified/linux-2.6.32/usr/include/linux/rfkill.h
--- linux-2.6.32/usr/include/linux/rfkill.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/rfkill.h	2019-04-14 13:24:03.122011055 -0500
@@ -0,0 +1,104 @@
+#ifndef __RFKILL_H
+#define __RFKILL_H
+
+/*
+ * Copyright (C) 2006 - 2007 Ivo van Doorn
+ * Copyright (C) 2007 Dmitry Torokhov
+ * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+
+/* define userspace visible states */
+#define RFKILL_STATE_SOFT_BLOCKED	0
+#define RFKILL_STATE_UNBLOCKED		1
+#define RFKILL_STATE_HARD_BLOCKED	2
+
+/**
+ * enum rfkill_type - type of rfkill switch.
+ *
+ * @RFKILL_TYPE_ALL: toggles all switches (userspace only)
+ * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.
+ * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.
+ * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.
+ * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.
+ * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.
+ * @NUM_RFKILL_TYPES: number of defined rfkill types
+ */
+enum rfkill_type {
+	RFKILL_TYPE_ALL = 0,
+	RFKILL_TYPE_WLAN,
+	RFKILL_TYPE_BLUETOOTH,
+	RFKILL_TYPE_UWB,
+	RFKILL_TYPE_WIMAX,
+	RFKILL_TYPE_WWAN,
+	RFKILL_TYPE_GPS,
+	NUM_RFKILL_TYPES,
+};
+
+/**
+ * enum rfkill_operation - operation types
+ * @RFKILL_OP_ADD: a device was added
+ * @RFKILL_OP_DEL: a device was removed
+ * @RFKILL_OP_CHANGE: a device's state changed -- userspace changes one device
+ * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)
+ */
+enum rfkill_operation {
+	RFKILL_OP_ADD = 0,
+	RFKILL_OP_DEL,
+	RFKILL_OP_CHANGE,
+	RFKILL_OP_CHANGE_ALL,
+};
+
+/**
+ * struct rfkill_event - events for userspace on /dev/rfkill
+ * @idx: index of dev rfkill
+ * @type: type of the rfkill struct
+ * @op: operation code
+ * @hard: hard state (0/1)
+ * @soft: soft state (0/1)
+ *
+ * Structure used for userspace communication on /dev/rfkill,
+ * used for events from the kernel and control to the kernel.
+ */
+struct rfkill_event {
+	__u32 idx;
+	__u8  type;
+	__u8  op;
+	__u8  soft, hard;
+} __packed;
+
+/*
+ * We are planning to be backward and forward compatible with changes
+ * to the event struct, by adding new, optional, members at the end.
+ * When reading an event (whether the kernel from userspace or vice
+ * versa) we need to accept anything that's at least as large as the
+ * version 1 event size, but might be able to accept other sizes in
+ * the future.
+ *
+ * One exception is the kernel -- we already have two event sizes in
+ * that we've made the 'hard' member optional since our only option
+ * is to ignore it anyway.
+ */
+#define RFKILL_EVENT_SIZE_V1	8
+
+/* ioctl for turning off rfkill-input (if present) */
+#define RFKILL_IOC_MAGIC	'R'
+#define RFKILL_IOC_NOINPUT	1
+#define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)
+
+/* and that's all userspace gets */
+
+#endif /* RFKILL_H */
diff -uNr linux-2.6.32/usr/include/linux/romfs_fs.h clean_modified/linux-2.6.32/usr/include/linux/romfs_fs.h
--- linux-2.6.32/usr/include/linux/romfs_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/romfs_fs.h	2019-04-14 13:24:03.122895290 -0500
@@ -0,0 +1,56 @@
+#ifndef __LINUX_ROMFS_FS_H
+#define __LINUX_ROMFS_FS_H
+
+/* The basic structures of the romfs filesystem */
+
+#define ROMBSIZE BLOCK_SIZE
+#define ROMBSBITS BLOCK_SIZE_BITS
+#define ROMBMASK (ROMBSIZE-1)
+#define ROMFS_MAGIC 0x7275
+
+#define ROMFS_MAXFN 128
+
+#define __mkw(h,l) (((h)&0x00ff)<< 8|((l)&0x00ff))
+#define __mkl(h,l) (((h)&0xffff)<<16|((l)&0xffff))
+#define __mk4(a,b,c,d) cpu_to_be32(__mkl(__mkw(a,b),__mkw(c,d)))
+#define ROMSB_WORD0 __mk4('-','r','o','m')
+#define ROMSB_WORD1 __mk4('1','f','s','-')
+
+/* On-disk "super block" */
+
+struct romfs_super_block {
+	__be32 word0;
+	__be32 word1;
+	__be32 size;
+	__be32 checksum;
+	char name[0];		/* volume name */
+};
+
+/* On disk inode */
+
+struct romfs_inode {
+	__be32 next;		/* low 4 bits see ROMFH_ */
+	__be32 spec;
+	__be32 size;
+	__be32 checksum;
+	char name[0];
+};
+
+#define ROMFH_TYPE 7
+#define ROMFH_HRD 0
+#define ROMFH_DIR 1
+#define ROMFH_REG 2
+#define ROMFH_SYM 3
+#define ROMFH_BLK 4
+#define ROMFH_CHR 5
+#define ROMFH_SCK 6
+#define ROMFH_FIF 7
+#define ROMFH_EXEC 8
+
+/* Alignment */
+
+#define ROMFH_SIZE 16
+#define ROMFH_PAD (ROMFH_SIZE-1)
+#define ROMFH_MASK (~ROMFH_PAD)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/rose.h clean_modified/linux-2.6.32/usr/include/linux/rose.h
--- linux-2.6.32/usr/include/linux/rose.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/rose.h	2019-04-14 13:24:03.122895290 -0500
@@ -0,0 +1,87 @@
+/*
+ * These are the public elements of the Linux kernel Rose implementation.
+ * For kernel AX.25 see the file ax25.h. This file requires ax25.h for the
+ * definition of the ax25_address structure.
+ */
+
+#ifndef	ROSE_KERNEL_H
+#define	ROSE_KERNEL_H
+
+#define ROSE_MTU	251
+
+#define ROSE_MAX_DIGIS 6
+
+#define	ROSE_DEFER	1
+#define ROSE_T1		2
+#define	ROSE_T2		3
+#define	ROSE_T3		4
+#define	ROSE_IDLE	5
+#define	ROSE_QBITINCL	6
+#define	ROSE_HOLDBACK	7
+
+#define	SIOCRSGCAUSE		(SIOCPROTOPRIVATE+0)
+#define	SIOCRSSCAUSE		(SIOCPROTOPRIVATE+1)
+#define	SIOCRSL2CALL		(SIOCPROTOPRIVATE+2)
+#define	SIOCRSSL2CALL		(SIOCPROTOPRIVATE+2)
+#define	SIOCRSACCEPT		(SIOCPROTOPRIVATE+3)
+#define	SIOCRSCLRRT		(SIOCPROTOPRIVATE+4)
+#define	SIOCRSGL2CALL		(SIOCPROTOPRIVATE+5)
+#define	SIOCRSGFACILITIES	(SIOCPROTOPRIVATE+6)
+
+#define	ROSE_DTE_ORIGINATED	0x00
+#define	ROSE_NUMBER_BUSY	0x01
+#define	ROSE_INVALID_FACILITY	0x03
+#define	ROSE_NETWORK_CONGESTION	0x05
+#define	ROSE_OUT_OF_ORDER	0x09
+#define	ROSE_ACCESS_BARRED	0x0B
+#define	ROSE_NOT_OBTAINABLE	0x0D
+#define	ROSE_REMOTE_PROCEDURE	0x11
+#define	ROSE_LOCAL_PROCEDURE	0x13
+#define	ROSE_SHIP_ABSENT	0x39
+
+typedef struct {
+	char		rose_addr[5];
+} rose_address;
+
+struct sockaddr_rose {
+	sa_family_t	srose_family;
+	rose_address	srose_addr;
+	ax25_address	srose_call;
+	int		srose_ndigis;
+	ax25_address	srose_digi;
+};
+
+struct full_sockaddr_rose {
+	sa_family_t	srose_family;
+	rose_address	srose_addr;
+	ax25_address	srose_call;
+	unsigned int	srose_ndigis;
+	ax25_address	srose_digis[ROSE_MAX_DIGIS];
+};
+
+struct rose_route_struct {
+	rose_address	address;
+	unsigned short	mask;
+	ax25_address	neighbour;
+	char		device[16];
+	unsigned char	ndigis;
+	ax25_address	digipeaters[AX25_MAX_DIGIS];
+};
+
+struct rose_cause_struct {
+	unsigned char	cause;
+	unsigned char	diagnostic;
+};
+
+struct rose_facilities_struct {
+	rose_address	source_addr,   dest_addr;
+	ax25_address	source_call,   dest_call;
+	unsigned char	source_ndigis, dest_ndigis;
+	ax25_address	source_digis[ROSE_MAX_DIGIS];
+	ax25_address	dest_digis[ROSE_MAX_DIGIS];
+	unsigned int	rand;
+	rose_address	fail_addr;
+	ax25_address	fail_call;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/route.h clean_modified/linux-2.6.32/usr/include/linux/route.h
--- linux-2.6.32/usr/include/linux/route.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/route.h	2019-04-14 13:24:03.122895290 -0500
@@ -0,0 +1,68 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the IP router interface.
+ *
+ * Version:	@(#)route.h	1.0.3	05/27/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+ *		for the purposes of compatibility only.
+ *
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ * Changes:
+ *              Mike McLagan    :       Routing by source
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_ROUTE_H
+#define _LINUX_ROUTE_H
+
+#include <linux/if.h>
+
+
+/* This structure gets passed by the SIOCADDRT and SIOCDELRT calls. */
+struct rtentry 
+{
+	unsigned long	rt_pad1;
+	struct sockaddr	rt_dst;		/* target address		*/
+	struct sockaddr	rt_gateway;	/* gateway addr (RTF_GATEWAY)	*/
+	struct sockaddr	rt_genmask;	/* target network mask (IP)	*/
+	unsigned short	rt_flags;
+	short		rt_pad2;
+	unsigned long	rt_pad3;
+	void		*rt_pad4;
+	short		rt_metric;	/* +1 for binary compatibility!	*/
+	char *rt_dev;	/* forcing the device at add	*/
+	unsigned long	rt_mtu;		/* per route MTU/Window 	*/
+#define rt_mss	rt_mtu			/* Compatibility :-(            */
+	unsigned long	rt_window;	/* Window clamping 		*/
+	unsigned short	rt_irtt;	/* Initial RTT			*/
+};
+
+
+#define	RTF_UP		0x0001		/* route usable		  	*/
+#define	RTF_GATEWAY	0x0002		/* destination is a gateway	*/
+#define	RTF_HOST	0x0004		/* host entry (net otherwise)	*/
+#define RTF_REINSTATE	0x0008		/* reinstate route after tmout	*/
+#define	RTF_DYNAMIC	0x0010		/* created dyn. (by redirect)	*/
+#define	RTF_MODIFIED	0x0020		/* modified dyn. (by redirect)	*/
+#define RTF_MTU		0x0040		/* specific MTU for this route	*/
+#define RTF_MSS		RTF_MTU		/* Compatibility :-(		*/
+#define RTF_WINDOW	0x0080		/* per route window clamping	*/
+#define RTF_IRTT	0x0100		/* Initial round trip time	*/
+#define RTF_REJECT	0x0200		/* Reject route			*/
+
+/*
+ *	<linux/ipv6_route.h> uses RTF values >= 64k
+ */
+
+
+
+#endif	/* _LINUX_ROUTE_H */
+
diff -uNr linux-2.6.32/usr/include/linux/rtc.h clean_modified/linux-2.6.32/usr/include/linux/rtc.h
--- linux-2.6.32/usr/include/linux/rtc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/rtc.h	2019-04-14 13:24:03.123934358 -0500
@@ -0,0 +1,101 @@
+/*
+ * Generic RTC interface.
+ * This version contains the part of the user interface to the Real Time Clock
+ * service. It is used with both the legacy mc146818 and also  EFI
+ * Struct rtc_time and first 12 ioctl by Paul Gortmaker, 1996 - separated out
+ * from <linux/mc146818rtc.h> to this file for 2.4 kernels.
+ *
+ * Copyright (C) 1999 Hewlett-Packard Co.
+ * Copyright (C) 1999 Stephane Eranian <eranian@hpl.hp.com>
+ */
+#ifndef _LINUX_RTC_H_
+#define _LINUX_RTC_H_
+
+/*
+ * The struct used to pass data via the following ioctl. Similar to the
+ * struct tm in <time.h>, but it needs to be here so that the kernel
+ * source is self contained, allowing cross-compiles, etc. etc.
+ */
+
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+};
+
+/*
+ * This data structure is inspired by the EFI (v0.92) wakeup
+ * alarm API.
+ */
+struct rtc_wkalrm {
+	unsigned char enabled;	/* 0 = alarm disabled, 1 = alarm enabled */
+	unsigned char pending;  /* 0 = alarm not pending, 1 = alarm pending */
+	struct rtc_time time;	/* time the alarm is set to */
+};
+
+/*
+ * Data structure to control PLL correction some better RTC feature
+ * pll_value is used to get or set current value of correction,
+ * the rest of the struct is used to query HW capabilities.
+ * This is modeled after the RTC used in Q40/Q60 computers but
+ * should be sufficiently flexible for other devices
+ *
+ * +ve pll_value means clock will run faster by
+ *   pll_value*pll_posmult/pll_clock
+ * -ve pll_value means clock will run slower by
+ *   pll_value*pll_negmult/pll_clock
+ */
+
+struct rtc_pll_info {
+	int pll_ctrl;       /* placeholder for fancier control */
+	int pll_value;      /* get/set correction value */
+	int pll_max;        /* max +ve (faster) adjustment value */
+	int pll_min;        /* max -ve (slower) adjustment value */
+	int pll_posmult;    /* factor for +ve correction */
+	int pll_negmult;    /* factor for -ve correction */
+	long pll_clock;     /* base PLL frequency */
+};
+
+/*
+ * ioctl calls that are permitted to the /dev/rtc interface, if
+ * any of the RTC drivers are enabled.
+ */
+
+#define RTC_AIE_ON	_IO('p', 0x01)	/* Alarm int. enable on		*/
+#define RTC_AIE_OFF	_IO('p', 0x02)	/* ... off			*/
+#define RTC_UIE_ON	_IO('p', 0x03)	/* Update int. enable on	*/
+#define RTC_UIE_OFF	_IO('p', 0x04)	/* ... off			*/
+#define RTC_PIE_ON	_IO('p', 0x05)	/* Periodic int. enable on	*/
+#define RTC_PIE_OFF	_IO('p', 0x06)	/* ... off			*/
+#define RTC_WIE_ON	_IO('p', 0x0f)  /* Watchdog int. enable on	*/
+#define RTC_WIE_OFF	_IO('p', 0x10)  /* ... off			*/
+
+#define RTC_ALM_SET	_IOW('p', 0x07, struct rtc_time) /* Set alarm time  */
+#define RTC_ALM_READ	_IOR('p', 0x08, struct rtc_time) /* Read alarm time */
+#define RTC_RD_TIME	_IOR('p', 0x09, struct rtc_time) /* Read RTC time   */
+#define RTC_SET_TIME	_IOW('p', 0x0a, struct rtc_time) /* Set RTC time    */
+#define RTC_IRQP_READ	_IOR('p', 0x0b, unsigned long)	 /* Read IRQ rate   */
+#define RTC_IRQP_SET	_IOW('p', 0x0c, unsigned long)	 /* Set IRQ rate    */
+#define RTC_EPOCH_READ	_IOR('p', 0x0d, unsigned long)	 /* Read epoch      */
+#define RTC_EPOCH_SET	_IOW('p', 0x0e, unsigned long)	 /* Set epoch       */
+
+#define RTC_WKALM_SET	_IOW('p', 0x0f, struct rtc_wkalrm)/* Set wakeup alarm*/
+#define RTC_WKALM_RD	_IOR('p', 0x10, struct rtc_wkalrm)/* Get wakeup alarm*/
+
+#define RTC_PLL_GET	_IOR('p', 0x11, struct rtc_pll_info)  /* Get PLL correction */
+#define RTC_PLL_SET	_IOW('p', 0x12, struct rtc_pll_info)  /* Set PLL correction */
+
+/* interrupt flags */
+#define RTC_IRQF 0x80 /* any of the following is active */
+#define RTC_PF 0x40
+#define RTC_AF 0x20
+#define RTC_UF 0x10
+
+
+#endif /* _LINUX_RTC_H_ */
diff -uNr linux-2.6.32/usr/include/linux/rtnetlink.h clean_modified/linux-2.6.32/usr/include/linux/rtnetlink.h
--- linux-2.6.32/usr/include/linux/rtnetlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/rtnetlink.h	2019-04-14 13:24:03.124909311 -0500
@@ -0,0 +1,614 @@
+#ifndef __LINUX_RTNETLINK_H
+#define __LINUX_RTNETLINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+#include <linux/if_link.h>
+#include <linux/if_addr.h>
+#include <linux/neighbour.h>
+
+/****
+ *		Routing/neighbour discovery messages.
+ ****/
+
+/* Types of messages */
+
+enum {
+	RTM_BASE	= 16,
+#define RTM_BASE	RTM_BASE
+
+	RTM_NEWLINK	= 16,
+#define RTM_NEWLINK	RTM_NEWLINK
+	RTM_DELLINK,
+#define RTM_DELLINK	RTM_DELLINK
+	RTM_GETLINK,
+#define RTM_GETLINK	RTM_GETLINK
+	RTM_SETLINK,
+#define RTM_SETLINK	RTM_SETLINK
+
+	RTM_NEWADDR	= 20,
+#define RTM_NEWADDR	RTM_NEWADDR
+	RTM_DELADDR,
+#define RTM_DELADDR	RTM_DELADDR
+	RTM_GETADDR,
+#define RTM_GETADDR	RTM_GETADDR
+
+	RTM_NEWROUTE	= 24,
+#define RTM_NEWROUTE	RTM_NEWROUTE
+	RTM_DELROUTE,
+#define RTM_DELROUTE	RTM_DELROUTE
+	RTM_GETROUTE,
+#define RTM_GETROUTE	RTM_GETROUTE
+
+	RTM_NEWNEIGH	= 28,
+#define RTM_NEWNEIGH	RTM_NEWNEIGH
+	RTM_DELNEIGH,
+#define RTM_DELNEIGH	RTM_DELNEIGH
+	RTM_GETNEIGH,
+#define RTM_GETNEIGH	RTM_GETNEIGH
+
+	RTM_NEWRULE	= 32,
+#define RTM_NEWRULE	RTM_NEWRULE
+	RTM_DELRULE,
+#define RTM_DELRULE	RTM_DELRULE
+	RTM_GETRULE,
+#define RTM_GETRULE	RTM_GETRULE
+
+	RTM_NEWQDISC	= 36,
+#define RTM_NEWQDISC	RTM_NEWQDISC
+	RTM_DELQDISC,
+#define RTM_DELQDISC	RTM_DELQDISC
+	RTM_GETQDISC,
+#define RTM_GETQDISC	RTM_GETQDISC
+
+	RTM_NEWTCLASS	= 40,
+#define RTM_NEWTCLASS	RTM_NEWTCLASS
+	RTM_DELTCLASS,
+#define RTM_DELTCLASS	RTM_DELTCLASS
+	RTM_GETTCLASS,
+#define RTM_GETTCLASS	RTM_GETTCLASS
+
+	RTM_NEWTFILTER	= 44,
+#define RTM_NEWTFILTER	RTM_NEWTFILTER
+	RTM_DELTFILTER,
+#define RTM_DELTFILTER	RTM_DELTFILTER
+	RTM_GETTFILTER,
+#define RTM_GETTFILTER	RTM_GETTFILTER
+
+	RTM_NEWACTION	= 48,
+#define RTM_NEWACTION   RTM_NEWACTION
+	RTM_DELACTION,
+#define RTM_DELACTION   RTM_DELACTION
+	RTM_GETACTION,
+#define RTM_GETACTION   RTM_GETACTION
+
+	RTM_NEWPREFIX	= 52,
+#define RTM_NEWPREFIX	RTM_NEWPREFIX
+
+	RTM_GETMULTICAST = 58,
+#define RTM_GETMULTICAST RTM_GETMULTICAST
+
+	RTM_GETANYCAST	= 62,
+#define RTM_GETANYCAST	RTM_GETANYCAST
+
+	RTM_NEWNEIGHTBL	= 64,
+#define RTM_NEWNEIGHTBL	RTM_NEWNEIGHTBL
+	RTM_GETNEIGHTBL	= 66,
+#define RTM_GETNEIGHTBL	RTM_GETNEIGHTBL
+	RTM_SETNEIGHTBL,
+#define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL
+
+	RTM_NEWNDUSEROPT = 68,
+#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT
+
+	RTM_NEWADDRLABEL = 72,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_DELADDRLABEL,
+#define RTM_DELADDRLABEL RTM_DELADDRLABEL
+	RTM_GETADDRLABEL,
+#define RTM_GETADDRLABEL RTM_GETADDRLABEL
+
+	RTM_GETDCB = 78,
+#define RTM_GETDCB RTM_GETDCB
+	RTM_SETDCB,
+#define RTM_SETDCB RTM_SETDCB
+
+	__RTM_MAX,
+#define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
+};
+
+#define RTM_NR_MSGTYPES	(RTM_MAX + 1 - RTM_BASE)
+#define RTM_NR_FAMILIES	(RTM_NR_MSGTYPES >> 2)
+#define RTM_FAM(cmd)	(((cmd) - RTM_BASE) >> 2)
+
+/* 
+   Generic structure for encapsulation of optional route information.
+   It is reminiscent of sockaddr, but with sa_family replaced
+   with attribute type.
+ */
+
+struct rtattr
+{
+	unsigned short	rta_len;
+	unsigned short	rta_type;
+};
+
+/* Macros to handle rtattributes */
+
+#define RTA_ALIGNTO	4
+#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) & ~(RTA_ALIGNTO-1) )
+#define RTA_OK(rta,len) ((len) >= (int)sizeof(struct rtattr) && \
+			 (rta)->rta_len >= sizeof(struct rtattr) && \
+			 (rta)->rta_len <= (len))
+#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)->rta_len), \
+				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)->rta_len)))
+#define RTA_LENGTH(len)	(RTA_ALIGN(sizeof(struct rtattr)) + (len))
+#define RTA_SPACE(len)	RTA_ALIGN(RTA_LENGTH(len))
+#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))
+#define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))
+
+
+
+
+/******************************************************************************
+ *		Definitions used in routing table administration.
+ ****/
+
+struct rtmsg
+{
+	unsigned char		rtm_family;
+	unsigned char		rtm_dst_len;
+	unsigned char		rtm_src_len;
+	unsigned char		rtm_tos;
+
+	unsigned char		rtm_table;	/* Routing table id */
+	unsigned char		rtm_protocol;	/* Routing protocol; see below	*/
+	unsigned char		rtm_scope;	/* See below */	
+	unsigned char		rtm_type;	/* See below	*/
+
+	unsigned		rtm_flags;
+};
+
+/* rtm_type */
+
+enum
+{
+	RTN_UNSPEC,
+	RTN_UNICAST,		/* Gateway or direct route	*/
+	RTN_LOCAL,		/* Accept locally		*/
+	RTN_BROADCAST,		/* Accept locally as broadcast,
+				   send as broadcast */
+	RTN_ANYCAST,		/* Accept locally as broadcast,
+				   but send as unicast */
+	RTN_MULTICAST,		/* Multicast route		*/
+	RTN_BLACKHOLE,		/* Drop				*/
+	RTN_UNREACHABLE,	/* Destination is unreachable   */
+	RTN_PROHIBIT,		/* Administratively prohibited	*/
+	RTN_THROW,		/* Not in this table		*/
+	RTN_NAT,		/* Translate this address	*/
+	RTN_XRESOLVE,		/* Use external resolver	*/
+	__RTN_MAX
+};
+
+#define RTN_MAX (__RTN_MAX - 1)
+
+
+/* rtm_protocol */
+
+#define RTPROT_UNSPEC	0
+#define RTPROT_REDIRECT	1	/* Route installed by ICMP redirects;
+				   not used by current IPv4 */
+#define RTPROT_KERNEL	2	/* Route installed by kernel		*/
+#define RTPROT_BOOT	3	/* Route installed during boot		*/
+#define RTPROT_STATIC	4	/* Route installed by administrator	*/
+
+/* Values of protocol >= RTPROT_STATIC are not interpreted by kernel;
+   they are just passed from user and back as is.
+   It will be used by hypothetical multiple routing daemons.
+   Note that protocol values should be standardized in order to
+   avoid conflicts.
+ */
+
+#define RTPROT_GATED	8	/* Apparently, GateD */
+#define RTPROT_RA	9	/* RDISC/ND router advertisements */
+#define RTPROT_MRT	10	/* Merit MRT */
+#define RTPROT_ZEBRA	11	/* Zebra */
+#define RTPROT_BIRD	12	/* BIRD */
+#define RTPROT_DNROUTED	13	/* DECnet routing daemon */
+#define RTPROT_XORP	14	/* XORP */
+#define RTPROT_NTK	15	/* Netsukuku */
+#define RTPROT_DHCP	16      /* DHCP client */
+
+/* rtm_scope
+
+   Really it is not scope, but sort of distance to the destination.
+   NOWHERE are reserved for not existing destinations, HOST is our
+   local addresses, LINK are destinations, located on directly attached
+   link and UNIVERSE is everywhere in the Universe.
+
+   Intermediate values are also possible f.e. interior routes
+   could be assigned a value between UNIVERSE and LINK.
+*/
+
+enum rt_scope_t
+{
+	RT_SCOPE_UNIVERSE=0,
+/* User defined values  */
+	RT_SCOPE_SITE=200,
+	RT_SCOPE_LINK=253,
+	RT_SCOPE_HOST=254,
+	RT_SCOPE_NOWHERE=255
+};
+
+/* rtm_flags */
+
+#define RTM_F_NOTIFY		0x100	/* Notify user of route change	*/
+#define RTM_F_CLONED		0x200	/* This route is cloned		*/
+#define RTM_F_EQUALIZE		0x400	/* Multipath equalizer: NI	*/
+#define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
+
+/* Reserved table identifiers */
+
+enum rt_class_t
+{
+	RT_TABLE_UNSPEC=0,
+/* User defined values */
+	RT_TABLE_COMPAT=252,
+	RT_TABLE_DEFAULT=253,
+	RT_TABLE_MAIN=254,
+	RT_TABLE_LOCAL=255,
+	RT_TABLE_MAX=0xFFFFFFFF
+};
+
+
+/* Routing message attributes */
+
+enum rtattr_type_t
+{
+	RTA_UNSPEC,
+	RTA_DST,
+	RTA_SRC,
+	RTA_IIF,
+	RTA_OIF,
+	RTA_GATEWAY,
+	RTA_PRIORITY,
+	RTA_PREFSRC,
+	RTA_METRICS,
+	RTA_MULTIPATH,
+	RTA_PROTOINFO, /* no longer used */
+	RTA_FLOW,
+	RTA_CACHEINFO,
+	RTA_SESSION, /* no longer used */
+	RTA_MP_ALGO, /* no longer used */
+	RTA_TABLE,
+	__RTA_MAX
+};
+
+#define RTA_MAX (__RTA_MAX - 1)
+
+#define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))
+#define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))
+
+/* RTM_MULTIPATH --- array of struct rtnexthop.
+ *
+ * "struct rtnexthop" describes all necessary nexthop information,
+ * i.e. parameters of path to a destination via this nexthop.
+ *
+ * At the moment it is impossible to set different prefsrc, mtu, window
+ * and rtt for different paths from multipath.
+ */
+
+struct rtnexthop
+{
+	unsigned short		rtnh_len;
+	unsigned char		rtnh_flags;
+	unsigned char		rtnh_hops;
+	int			rtnh_ifindex;
+};
+
+/* rtnh_flags */
+
+#define RTNH_F_DEAD		1	/* Nexthop is dead (used by multipath)	*/
+#define RTNH_F_PERVASIVE	2	/* Do recursive gateway lookup	*/
+#define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
+
+/* Macros to handle hexthops */
+
+#define RTNH_ALIGNTO	4
+#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) & ~(RTNH_ALIGNTO-1) )
+#define RTNH_OK(rtnh,len) ((rtnh)->rtnh_len >= sizeof(struct rtnexthop) && \
+			   ((int)(rtnh)->rtnh_len) <= (len))
+#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)->rtnh_len)))
+#define RTNH_LENGTH(len) (RTNH_ALIGN(sizeof(struct rtnexthop)) + (len))
+#define RTNH_SPACE(len)	RTNH_ALIGN(RTNH_LENGTH(len))
+#define RTNH_DATA(rtnh)   ((struct rtattr*)(((char*)(rtnh)) + RTNH_LENGTH(0)))
+
+/* RTM_CACHEINFO */
+
+struct rta_cacheinfo
+{
+	__u32	rta_clntref;
+	__u32	rta_lastuse;
+	__s32	rta_expires;
+	__u32	rta_error;
+	__u32	rta_used;
+
+#define RTNETLINK_HAVE_PEERINFO 1
+	__u32	rta_id;
+	__u32	rta_ts;
+	__u32	rta_tsage;
+};
+
+/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */
+
+enum
+{
+	RTAX_UNSPEC,
+#define RTAX_UNSPEC RTAX_UNSPEC
+	RTAX_LOCK,
+#define RTAX_LOCK RTAX_LOCK
+	RTAX_MTU,
+#define RTAX_MTU RTAX_MTU
+	RTAX_WINDOW,
+#define RTAX_WINDOW RTAX_WINDOW
+	RTAX_RTT,
+#define RTAX_RTT RTAX_RTT
+	RTAX_RTTVAR,
+#define RTAX_RTTVAR RTAX_RTTVAR
+	RTAX_SSTHRESH,
+#define RTAX_SSTHRESH RTAX_SSTHRESH
+	RTAX_CWND,
+#define RTAX_CWND RTAX_CWND
+	RTAX_ADVMSS,
+#define RTAX_ADVMSS RTAX_ADVMSS
+	RTAX_REORDERING,
+#define RTAX_REORDERING RTAX_REORDERING
+	RTAX_HOPLIMIT,
+#define RTAX_HOPLIMIT RTAX_HOPLIMIT
+	RTAX_INITCWND,
+#define RTAX_INITCWND RTAX_INITCWND
+	RTAX_FEATURES,
+#define RTAX_FEATURES RTAX_FEATURES
+	RTAX_RTO_MIN,
+#define RTAX_RTO_MIN RTAX_RTO_MIN
+	__RTAX_MAX
+};
+
+#define RTAX_MAX (__RTAX_MAX - 1)
+
+#define RTAX_FEATURE_ECN	0x00000001
+#define RTAX_FEATURE_SACK	0x00000002
+#define RTAX_FEATURE_TIMESTAMP	0x00000004
+#define RTAX_FEATURE_ALLFRAG	0x00000008
+
+struct rta_session
+{
+	__u8	proto;
+	__u8	pad1;
+	__u16	pad2;
+
+	union {
+		struct {
+			__u16	sport;
+			__u16	dport;
+		} ports;
+
+		struct {
+			__u8	type;
+			__u8	code;
+			__u16	ident;
+		} icmpt;
+
+		__u32		spi;
+	} u;
+};
+
+/****
+ *		General form of address family dependent message.
+ ****/
+
+struct rtgenmsg
+{
+	unsigned char		rtgen_family;
+};
+
+/*****************************************************************
+ *		Link layer specific messages.
+ ****/
+
+/* struct ifinfomsg
+ * passes link level specific information, not dependent
+ * on network protocol.
+ */
+
+struct ifinfomsg
+{
+	unsigned char	ifi_family;
+	unsigned char	__ifi_pad;
+	unsigned short	ifi_type;		/* ARPHRD_* */
+	int		ifi_index;		/* Link index	*/
+	unsigned	ifi_flags;		/* IFF_* flags	*/
+	unsigned	ifi_change;		/* IFF_* change mask */
+};
+
+/********************************************************************
+ *		prefix information 
+ ****/
+
+struct prefixmsg
+{
+	unsigned char	prefix_family;
+	unsigned char	prefix_pad1;
+	unsigned short	prefix_pad2;
+	int		prefix_ifindex;
+	unsigned char	prefix_type;
+	unsigned char	prefix_len;
+	unsigned char	prefix_flags;
+	unsigned char	prefix_pad3;
+};
+
+enum 
+{
+	PREFIX_UNSPEC,
+	PREFIX_ADDRESS,
+	PREFIX_CACHEINFO,
+	__PREFIX_MAX
+};
+
+#define PREFIX_MAX	(__PREFIX_MAX - 1)
+
+struct prefix_cacheinfo
+{
+	__u32	preferred_time;
+	__u32	valid_time;
+};
+
+
+/*****************************************************************
+ *		Traffic control messages.
+ ****/
+
+struct tcmsg
+{
+	unsigned char	tcm_family;
+	unsigned char	tcm__pad1;
+	unsigned short	tcm__pad2;
+	int		tcm_ifindex;
+	__u32		tcm_handle;
+	__u32		tcm_parent;
+	__u32		tcm_info;
+};
+
+enum
+{
+	TCA_UNSPEC,
+	TCA_KIND,
+	TCA_OPTIONS,
+	TCA_STATS,
+	TCA_XSTATS,
+	TCA_RATE,
+	TCA_FCNT,
+	TCA_STATS2,
+	TCA_STAB,
+	__TCA_MAX
+};
+
+#define TCA_MAX (__TCA_MAX - 1)
+
+#define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
+#define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
+
+/********************************************************************
+ *		Neighbor Discovery userland options
+ ****/
+
+struct nduseroptmsg
+{
+	unsigned char	nduseropt_family;
+	unsigned char	nduseropt_pad1;
+	unsigned short	nduseropt_opts_len;	/* Total length of options */
+	int		nduseropt_ifindex;
+	__u8		nduseropt_icmp_type;
+	__u8		nduseropt_icmp_code;
+	unsigned short	nduseropt_pad2;
+	unsigned int	nduseropt_pad3;
+	/* Followed by one or more ND options */
+};
+
+enum
+{
+	NDUSEROPT_UNSPEC,
+	NDUSEROPT_SRCADDR,
+	__NDUSEROPT_MAX
+};
+
+#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
+
+/* RTnetlink multicast groups - backwards compatibility for userspace */
+#define RTMGRP_LINK		1
+#define RTMGRP_NOTIFY		2
+#define RTMGRP_NEIGH		4
+#define RTMGRP_TC		8
+
+#define RTMGRP_IPV4_IFADDR	0x10
+#define RTMGRP_IPV4_MROUTE	0x20
+#define RTMGRP_IPV4_ROUTE	0x40
+#define RTMGRP_IPV4_RULE	0x80
+
+#define RTMGRP_IPV6_IFADDR	0x100
+#define RTMGRP_IPV6_MROUTE	0x200
+#define RTMGRP_IPV6_ROUTE	0x400
+#define RTMGRP_IPV6_IFINFO	0x800
+
+#define RTMGRP_DECnet_IFADDR    0x1000
+#define RTMGRP_DECnet_ROUTE     0x4000
+
+#define RTMGRP_IPV6_PREFIX	0x20000
+
+/* RTnetlink multicast groups */
+enum rtnetlink_groups {
+	RTNLGRP_NONE,
+#define RTNLGRP_NONE		RTNLGRP_NONE
+	RTNLGRP_LINK,
+#define RTNLGRP_LINK		RTNLGRP_LINK
+	RTNLGRP_NOTIFY,
+#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY
+	RTNLGRP_NEIGH,
+#define RTNLGRP_NEIGH		RTNLGRP_NEIGH
+	RTNLGRP_TC,
+#define RTNLGRP_TC		RTNLGRP_TC
+	RTNLGRP_IPV4_IFADDR,
+#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR
+	RTNLGRP_IPV4_MROUTE,
+#define	RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE
+	RTNLGRP_IPV4_ROUTE,
+#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE
+	RTNLGRP_IPV4_RULE,
+#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE
+	RTNLGRP_IPV6_IFADDR,
+#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR
+	RTNLGRP_IPV6_MROUTE,
+#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE
+	RTNLGRP_IPV6_ROUTE,
+#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE
+	RTNLGRP_IPV6_IFINFO,
+#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO
+	RTNLGRP_DECnet_IFADDR,
+#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR
+	RTNLGRP_NOP2,
+	RTNLGRP_DECnet_ROUTE,
+#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE
+	RTNLGRP_DECnet_RULE,
+#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE
+	RTNLGRP_NOP4,
+	RTNLGRP_IPV6_PREFIX,
+#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
+	RTNLGRP_IPV6_RULE,
+#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE
+	RTNLGRP_ND_USEROPT,
+#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT
+	RTNLGRP_PHONET_IFADDR,
+#define RTNLGRP_PHONET_IFADDR	RTNLGRP_PHONET_IFADDR
+	RTNLGRP_PHONET_ROUTE,
+#define RTNLGRP_PHONET_ROUTE	RTNLGRP_PHONET_ROUTE
+	__RTNLGRP_MAX
+};
+#define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
+
+/* TC action piece */
+struct tcamsg
+{
+	unsigned char	tca_family;
+	unsigned char	tca__pad1;
+	unsigned short	tca__pad2;
+};
+#define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))
+#define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
+#define TCA_ACT_TAB 1 /* attr type must be >=1 */	
+#define TCAA_MAX 1
+
+/* End of information exported to user level */
+
+
+
+#endif	/* __LINUX_RTNETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/scc.h clean_modified/linux-2.6.32/usr/include/linux/scc.h
--- linux-2.6.32/usr/include/linux/scc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/scc.h	2019-04-14 13:24:03.124909311 -0500
@@ -0,0 +1,172 @@
+/* $Id: scc.h,v 1.29 1997/04/02 14:56:45 jreuter Exp jreuter $ */
+
+#ifndef	_SCC_H
+#define	_SCC_H
+
+
+/* selection of hardware types */
+
+#define PA0HZP		0x00	/* hardware type for PA0HZP SCC card and compatible */
+#define EAGLE		0x01    /* hardware type for EAGLE card */
+#define PC100		0x02	/* hardware type for PC100 card */
+#define PRIMUS		0x04	/* hardware type for PRIMUS-PC (DG9BL) card */
+#define DRSI		0x08	/* hardware type for DRSI PC*Packet card */
+#define BAYCOM		0x10	/* hardware type for BayCom (U)SCC */
+
+/* DEV ioctl() commands */
+
+enum SCC_ioctl_cmds {
+	SIOCSCCRESERVED = SIOCDEVPRIVATE,
+	SIOCSCCCFG,
+	SIOCSCCINI,
+	SIOCSCCCHANINI,
+	SIOCSCCSMEM,
+	SIOCSCCGKISS,
+	SIOCSCCSKISS,
+	SIOCSCCGSTAT,
+	SIOCSCCCAL
+};
+
+/* Device parameter control (from WAMPES) */
+
+enum L1_params {
+	PARAM_DATA,
+	PARAM_TXDELAY,
+	PARAM_PERSIST,
+	PARAM_SLOTTIME,
+	PARAM_TXTAIL,
+	PARAM_FULLDUP,
+	PARAM_SOFTDCD,		/* was: PARAM_HW */
+	PARAM_MUTE,		/* ??? */
+	PARAM_DTR,
+	PARAM_RTS,
+	PARAM_SPEED,
+	PARAM_ENDDELAY,		/* ??? */
+	PARAM_GROUP,
+	PARAM_IDLE,
+	PARAM_MIN,
+	PARAM_MAXKEY,
+	PARAM_WAIT,
+	PARAM_MAXDEFER,
+	PARAM_TX,
+	PARAM_HWEVENT = 31,
+	PARAM_RETURN = 255	/* reset kiss mode */
+};
+
+/* fulldup parameter */
+
+enum FULLDUP_modes {
+	KISS_DUPLEX_HALF,	/* normal CSMA operation */
+	KISS_DUPLEX_FULL,	/* fullduplex, key down trx after transmission */
+	KISS_DUPLEX_LINK,	/* fullduplex, key down trx after 'idletime' sec */
+	KISS_DUPLEX_OPTIMA	/* fullduplex, let the protocol layer control the hw */
+};
+
+/* misc. parameters */
+
+#define TIMER_OFF	65535U	/* to switch off timers */
+#define NO_SUCH_PARAM	65534U	/* param not implemented */
+
+/* HWEVENT parameter */
+
+enum HWEVENT_opts {
+	HWEV_DCD_ON,
+	HWEV_DCD_OFF,
+	HWEV_ALL_SENT
+};
+
+/* channel grouping */
+
+#define RXGROUP		0100	/* if set, only tx when all channels clear */
+#define TXGROUP		0200	/* if set, don't transmit simultaneously */
+
+/* Tx/Rx clock sources */
+
+enum CLOCK_sources {
+	CLK_DPLL,	/* normal halfduplex operation */
+	CLK_EXTERNAL,	/* external clocking (G3RUH/DF9IC modems) */
+	CLK_DIVIDER,	/* Rx = DPLL, Tx = divider (fullduplex with */
+			/* modems without clock regeneration */
+	CLK_BRG		/* experimental fullduplex mode with DPLL/BRG for */
+			/* MODEMs without clock recovery */
+};
+
+/* Tx state */
+
+enum TX_state {
+	TXS_IDLE,	/* Transmitter off, no data pending */
+	TXS_BUSY,	/* waiting for permission to send / tailtime */
+	TXS_ACTIVE,	/* Transmitter on, sending data */
+	TXS_NEWFRAME,	/* reset CRC and send (next) frame */
+	TXS_IDLE2,	/* Transmitter on, no data pending */
+	TXS_WAIT,	/* Waiting for Mintime to expire */
+	TXS_TIMEOUT	/* We had a transmission timeout */
+};
+
+typedef unsigned long io_port;	/* type definition for an 'io port address' */
+
+/* SCC statistical information */
+
+struct scc_stat {
+        long rxints;            /* Receiver interrupts */
+        long txints;            /* Transmitter interrupts */
+        long exints;            /* External/status interrupts */
+        long spints;            /* Special receiver interrupts */
+
+        long txframes;          /* Packets sent */
+        long rxframes;          /* Number of Frames Actually Received */
+        long rxerrs;            /* CRC Errors */
+        long txerrs;		/* KISS errors */
+        
+	unsigned int nospace;	/* "Out of buffers" */
+	unsigned int rx_over;	/* Receiver Overruns */
+	unsigned int tx_under;	/* Transmitter Underruns */
+
+	unsigned int tx_state;	/* Transmitter state */
+	int tx_queued;		/* tx frames enqueued */
+
+	unsigned int maxqueue;	/* allocated tx_buffers */
+	unsigned int bufsize;	/* used buffersize */
+};
+
+struct scc_modem {
+	long speed;		/* Line speed, bps */
+	char clocksrc;		/* 0 = DPLL, 1 = external, 2 = divider */
+	char nrz;		/* NRZ instead of NRZI */	
+};
+
+struct scc_kiss_cmd {
+	int  	 command;	/* one of the KISS-Commands defined above */
+	unsigned param;		/* KISS-Param */
+};
+
+struct scc_hw_config {
+	io_port data_a;		/* data port channel A */
+	io_port ctrl_a;		/* control port channel A */
+	io_port data_b;		/* data port channel B */
+	io_port ctrl_b;		/* control port channel B */
+	io_port vector_latch;	/* INTACK-Latch (#) */
+	io_port	special;	/* special function port */
+
+	int	irq;		/* irq */
+	long	clock;		/* clock */
+	char	option;		/* command for function port */
+
+	char brand;		/* hardware type */
+	char escc;		/* use ext. features of a 8580/85180/85280 */
+};
+
+/* (#) only one INTACK latch allowed. */
+
+
+struct scc_mem_config {
+	unsigned int dummy;
+	unsigned int bufsize;
+};
+
+struct scc_calibrate {
+	unsigned int time;
+	unsigned char pattern;
+};
+
+#endif /* defined(_SCC_H) */
diff -uNr linux-2.6.32/usr/include/linux/sched.h clean_modified/linux-2.6.32/usr/include/linux/sched.h
--- linux-2.6.32/usr/include/linux/sched.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sched.h	2019-04-14 13:24:03.124909311 -0500
@@ -0,0 +1,45 @@
+#ifndef _LINUX_SCHED_H
+#define _LINUX_SCHED_H
+
+/*
+ * cloning flags:
+ */
+#define CSIGNAL		0x000000ff	/* signal mask to be sent at exit */
+#define CLONE_VM	0x00000100	/* set if VM shared between processes */
+#define CLONE_FS	0x00000200	/* set if fs info shared between processes */
+#define CLONE_FILES	0x00000400	/* set if open files shared between processes */
+#define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
+#define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */
+#define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
+#define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
+#define CLONE_THREAD	0x00010000	/* Same thread group? */
+#define CLONE_NEWNS	0x00020000	/* New namespace group? */
+#define CLONE_SYSVSEM	0x00040000	/* share system V SEM_UNDO semantics */
+#define CLONE_SETTLS	0x00080000	/* create a new TLS for the child */
+#define CLONE_PARENT_SETTID	0x00100000	/* set the TID in the parent */
+#define CLONE_CHILD_CLEARTID	0x00200000	/* clear the TID in the child */
+#define CLONE_DETACHED		0x00400000	/* Unused, ignored */
+#define CLONE_UNTRACED		0x00800000	/* set if the tracing process can't force CLONE_PTRACE on this clone */
+#define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
+#define CLONE_STOPPED		0x02000000	/* Start in stopped state */
+#define CLONE_NEWUTS		0x04000000	/* New utsname group? */
+#define CLONE_NEWIPC		0x08000000	/* New ipcs */
+#define CLONE_NEWUSER		0x10000000	/* New user namespace */
+#define CLONE_NEWPID		0x20000000	/* New pid namespace */
+#define CLONE_NEWNET		0x40000000	/* New network namespace */
+#define CLONE_IO		0x80000000	/* Clone io context */
+
+/*
+ * Scheduling policies
+ */
+#define SCHED_NORMAL		0
+#define SCHED_FIFO		1
+#define SCHED_RR		2
+#define SCHED_BATCH		3
+/* SCHED_ISO: reserved but not implemented yet */
+#define SCHED_IDLE		5
+/* Can be ORed in to make sure the process is reverted back to SCHED_NORMAL on fork */
+#define SCHED_RESET_ON_FORK     0x40000000
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/screen_info.h clean_modified/linux-2.6.32/usr/include/linux/screen_info.h
--- linux-2.6.32/usr/include/linux/screen_info.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/screen_info.h	2019-04-14 13:24:03.125886761 -0500
@@ -0,0 +1,69 @@
+#ifndef _SCREEN_INFO_H
+#define _SCREEN_INFO_H
+
+#include <linux/types.h>
+
+/*
+ * These are set up by the setup-routine at boot-time:
+ */
+
+struct screen_info {
+	__u8  orig_x;		/* 0x00 */
+	__u8  orig_y;		/* 0x01 */
+	__u16 ext_mem_k;	/* 0x02 */
+	__u16 orig_video_page;	/* 0x04 */
+	__u8  orig_video_mode;	/* 0x06 */
+	__u8  orig_video_cols;	/* 0x07 */
+	__u16 unused2;		/* 0x08 */
+	__u16 orig_video_ega_bx;/* 0x0a */
+	__u16 unused3;		/* 0x0c */
+	__u8  orig_video_lines;	/* 0x0e */
+	__u8  orig_video_isVGA;	/* 0x0f */
+	__u16 orig_video_points;/* 0x10 */
+
+	/* VESA graphic mode -- linear frame buffer */
+	__u16 lfb_width;	/* 0x12 */
+	__u16 lfb_height;	/* 0x14 */
+	__u16 lfb_depth;	/* 0x16 */
+	__u32 lfb_base;		/* 0x18 */
+	__u32 lfb_size;		/* 0x1c */
+	__u16 cl_magic, cl_offset; /* 0x20 */
+	__u16 lfb_linelength;	/* 0x24 */
+	__u8  red_size;		/* 0x26 */
+	__u8  red_pos;		/* 0x27 */
+	__u8  green_size;	/* 0x28 */
+	__u8  green_pos;	/* 0x29 */
+	__u8  blue_size;	/* 0x2a */
+	__u8  blue_pos;		/* 0x2b */
+	__u8  rsvd_size;	/* 0x2c */
+	__u8  rsvd_pos;		/* 0x2d */
+	__u16 vesapm_seg;	/* 0x2e */
+	__u16 vesapm_off;	/* 0x30 */
+	__u16 pages;		/* 0x32 */
+	__u16 vesa_attributes;	/* 0x34 */
+	__u32 capabilities;     /* 0x36 */
+	__u8  _reserved[6];	/* 0x3a */
+} __attribute__((packed));
+
+#define VIDEO_TYPE_MDA		0x10	/* Monochrome Text Display	*/
+#define VIDEO_TYPE_CGA		0x11	/* CGA Display 			*/
+#define VIDEO_TYPE_EGAM		0x20	/* EGA/VGA in Monochrome Mode	*/
+#define VIDEO_TYPE_EGAC		0x21	/* EGA in Color Mode		*/
+#define VIDEO_TYPE_VGAC		0x22	/* VGA+ in Color Mode		*/
+#define VIDEO_TYPE_VLFB		0x23	/* VESA VGA in graphic mode	*/
+
+#define VIDEO_TYPE_PICA_S3	0x30	/* ACER PICA-61 local S3 video	*/
+#define VIDEO_TYPE_MIPS_G364	0x31    /* MIPS Magnum 4000 G364 video  */
+#define VIDEO_TYPE_SGI          0x33    /* Various SGI graphics hardware */
+
+#define VIDEO_TYPE_TGAC		0x40	/* DEC TGA */
+
+#define VIDEO_TYPE_SUN          0x50    /* Sun frame buffer. */
+#define VIDEO_TYPE_SUNPCI       0x51    /* Sun PCI based frame buffer. */
+
+#define VIDEO_TYPE_PMAC		0x60	/* PowerMacintosh frame buffer. */
+
+#define VIDEO_TYPE_EFI		0x70	/* EFI graphic mode		*/
+
+
+#endif /* _SCREEN_INFO_H */
diff -uNr linux-2.6.32/usr/include/linux/sdla.h clean_modified/linux-2.6.32/usr/include/linux/sdla.h
--- linux-2.6.32/usr/include/linux/sdla.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sdla.h	2019-04-14 13:24:03.125886761 -0500
@@ -0,0 +1,119 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Frame relay interface.
+ *
+ * Version:	@(#)if_ifrad.h	0.20	13 Apr 96
+ *
+ * Author:	Mike McLagan <mike.mclagan@linux.org>
+ *
+ * Changes:
+ *		0.15	Mike McLagan	Structure packing
+ *
+ *		0.20	Mike McLagan	New flags for S508 buffer handling
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef SDLA_H
+#define SDLA_H
+
+/* adapter type */
+#define SDLA_TYPES
+#define SDLA_S502A			5020
+#define SDLA_S502E			5021
+#define SDLA_S503			5030
+#define SDLA_S507			5070
+#define SDLA_S508			5080
+#define SDLA_S509			5090
+#define SDLA_UNKNOWN			-1
+
+/* port selection flags for the S508 */
+#define SDLA_S508_PORT_V35		0x00
+#define SDLA_S508_PORT_RS232		0x02
+
+/* Z80 CPU speeds */
+#define SDLA_CPU_3M			0x00
+#define SDLA_CPU_5M			0x01
+#define SDLA_CPU_7M			0x02
+#define SDLA_CPU_8M			0x03
+#define SDLA_CPU_10M			0x04
+#define SDLA_CPU_16M			0x05
+#define SDLA_CPU_12M			0x06
+
+/* some private IOCTLs */
+#define SDLA_IDENTIFY			(FRAD_LAST_IOCTL + 1)
+#define SDLA_CPUSPEED			(FRAD_LAST_IOCTL + 2)
+#define SDLA_PROTOCOL			(FRAD_LAST_IOCTL + 3)
+
+#define SDLA_CLEARMEM			(FRAD_LAST_IOCTL + 4)
+#define SDLA_WRITEMEM			(FRAD_LAST_IOCTL + 5)
+#define SDLA_READMEM			(FRAD_LAST_IOCTL + 6)
+
+struct sdla_mem {
+   int  addr;
+   int  len;
+   void *data;
+};
+
+#define SDLA_START			(FRAD_LAST_IOCTL + 7)
+#define SDLA_STOP			(FRAD_LAST_IOCTL + 8)
+
+/* some offsets in the Z80's memory space */
+#define SDLA_NMIADDR			0x0000
+#define SDLA_CONF_ADDR			0x0010
+#define SDLA_S502A_NMIADDR		0x0066
+#define SDLA_CODE_BASEADDR		0x0100
+#define SDLA_WINDOW_SIZE		0x2000
+#define SDLA_ADDR_MASK			0x1FFF
+
+/* largest handleable block of data */
+#define SDLA_MAX_DATA			4080
+#define SDLA_MAX_MTU			4072	/* MAX_DATA - sizeof(fradhdr) */
+#define SDLA_MAX_DLCI			24
+
+/* this should be the same as frad_conf */
+struct sdla_conf {
+   short station;
+   short config;
+   short kbaud;
+   short clocking;
+   short max_frm;
+   short T391;
+   short T392;
+   short N391;
+   short N392;
+   short N393;
+   short CIR_fwd;
+   short Bc_fwd;
+   short Be_fwd;
+   short CIR_bwd;
+   short Bc_bwd;
+   short Be_bwd;
+};
+
+/* this should be the same as dlci_conf */
+struct sdla_dlci_conf {
+   short config;
+   short CIR_fwd;
+   short Bc_fwd;
+   short Be_fwd;
+   short CIR_bwd;
+   short Bc_bwd;
+   short Be_bwd; 
+   short Tc_fwd;
+   short Tc_bwd;
+   short Tf_max;
+   short Tb_max;
+};
+
+
+void sdla(void *cfg_info, char *dev, struct frad_conf *conf, int quiet);
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/selinux_netlink.h clean_modified/linux-2.6.32/usr/include/linux/selinux_netlink.h
--- linux-2.6.32/usr/include/linux/selinux_netlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/selinux_netlink.h	2019-04-14 13:24:03.125886761 -0500
@@ -0,0 +1,48 @@
+/*
+ * Netlink event notifications for SELinux.
+ *
+ * Author: James Morris <jmorris@redhat.com>
+ *
+ * Copyright (C) 2004 Red Hat, Inc., James Morris <jmorris@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2,
+ * as published by the Free Software Foundation.
+ */
+#ifndef _LINUX_SELINUX_NETLINK_H
+#define _LINUX_SELINUX_NETLINK_H
+
+#include <linux/types.h>
+
+/* Message types. */
+#define SELNL_MSG_BASE 0x10
+enum {
+	SELNL_MSG_SETENFORCE = SELNL_MSG_BASE,
+	SELNL_MSG_POLICYLOAD,
+	SELNL_MSG_MAX
+};
+
+/* Multicast groups - backwards compatiblility for userspace */
+#define SELNL_GRP_NONE		0x00000000
+#define SELNL_GRP_AVC		0x00000001	/* AVC notifications */
+#define SELNL_GRP_ALL		0xffffffff
+
+enum selinux_nlgroups {
+	SELNLGRP_NONE,
+#define SELNLGRP_NONE	SELNLGRP_NONE
+	SELNLGRP_AVC,
+#define SELNLGRP_AVC	SELNLGRP_AVC
+	__SELNLGRP_MAX
+};
+#define SELNLGRP_MAX	(__SELNLGRP_MAX - 1)
+
+/* Message structures */
+struct selnl_msg_setenforce {
+	__s32		val;
+};
+
+struct selnl_msg_policyload {
+	__u32	seqno;
+};
+
+#endif /* _LINUX_SELINUX_NETLINK_H */
diff -uNr linux-2.6.32/usr/include/linux/sem.h clean_modified/linux-2.6.32/usr/include/linux/sem.h
--- linux-2.6.32/usr/include/linux/sem.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sem.h	2019-04-14 13:24:03.125886761 -0500
@@ -0,0 +1,80 @@
+#ifndef _LINUX_SEM_H
+#define _LINUX_SEM_H
+
+#include <linux/ipc.h>
+
+/* semop flags */
+#define SEM_UNDO        0x1000  /* undo the operation on exit */
+
+/* semctl Command Definitions. */
+#define GETPID  11       /* get sempid */
+#define GETVAL  12       /* get semval */
+#define GETALL  13       /* get all semval's */
+#define GETNCNT 14       /* get semncnt */
+#define GETZCNT 15       /* get semzcnt */
+#define SETVAL  16       /* set semval */
+#define SETALL  17       /* set all semval's */
+
+/* ipcs ctl cmds */
+#define SEM_STAT 18
+#define SEM_INFO 19
+
+/* Obsolete, used only for backwards compatibility and libc5 compiles */
+struct semid_ds {
+	struct ipc_perm	sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	__kernel_time_t	sem_ctime;		/* last change time */
+	struct sem	*sem_base;		/* ptr to first semaphore in array */
+	struct sem_queue *sem_pending;		/* pending operations to be processed */
+	struct sem_queue **sem_pending_last;	/* last pending operation */
+	struct sem_undo	*undo;			/* undo requests on this array */
+	unsigned short	sem_nsems;		/* no. of semaphores in array */
+};
+
+/* Include the definition of semid64_ds */
+#include <asm/sembuf.h>
+
+/* semop system calls takes an array of these. */
+struct sembuf {
+	unsigned short  sem_num;	/* semaphore index in array */
+	short		sem_op;		/* semaphore operation */
+	short		sem_flg;	/* operation flags */
+};
+
+/* arg for semctl system calls. */
+union semun {
+	int val;			/* value for SETVAL */
+	struct semid_ds *buf;	/* buffer for IPC_STAT & IPC_SET */
+	unsigned short *array;	/* array for GETALL & SETALL */
+	struct seminfo *__buf;	/* buffer for IPC_INFO */
+	void *__pad;
+};
+
+struct  seminfo {
+	int semmap;
+	int semmni;
+	int semmns;
+	int semmnu;
+	int semmsl;
+	int semopm;
+	int semume;
+	int semusz;
+	int semvmx;
+	int semaem;
+};
+
+#define SEMMNI  128             /* <= IPCMNI  max # of semaphore identifiers */
+#define SEMMSL  250             /* <= 8 000 max num of semaphores per id */
+#define SEMMNS  (SEMMNI*SEMMSL) /* <= INT_MAX max # of semaphores in system */
+#define SEMOPM  32	        /* <= 1 000 max num of ops per semop call */
+#define SEMVMX  32767           /* <= 32767 semaphore maximum value */
+#define SEMAEM  SEMVMX          /* adjust on exit max value */
+
+/* unused */
+#define SEMUME  SEMOPM          /* max num of undo entries per process */
+#define SEMMNU  SEMMNS          /* num of undo structures system wide */
+#define SEMMAP  SEMMNS          /* # of entries in semaphore map */
+#define SEMUSZ  20		/* sizeof struct sem_undo */
+
+
+#endif /* _LINUX_SEM_H */
diff -uNr linux-2.6.32/usr/include/linux/serial_core.h clean_modified/linux-2.6.32/usr/include/linux/serial_core.h
--- linux-2.6.32/usr/include/linux/serial_core.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/serial_core.h	2019-04-14 13:24:03.126861895 -0500
@@ -0,0 +1,183 @@
+/*
+ *  linux/drivers/char/serial_core.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef LINUX_SERIAL_CORE_H
+#define LINUX_SERIAL_CORE_H
+
+#include <linux/serial.h>
+
+/*
+ * The type definitions.  These are from Ted Ts'o's serial.h
+ */
+#define PORT_UNKNOWN	0
+#define PORT_8250	1
+#define PORT_16450	2
+#define PORT_16550	3
+#define PORT_16550A	4
+#define PORT_CIRRUS	5
+#define PORT_16650	6
+#define PORT_16650V2	7
+#define PORT_16750	8
+#define PORT_STARTECH	9
+#define PORT_16C950	10
+#define PORT_16654	11
+#define PORT_16850	12
+#define PORT_RSA	13
+#define PORT_NS16550A	14
+#define PORT_XSCALE	15
+#define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
+#define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
+#define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
+#define PORT_MAX_8250	18	/* max port ID */
+
+/*
+ * ARM specific type numbers.  These are not currently guaranteed
+ * to be implemented, and will change in the future.  These are
+ * separate so any additions to the old serial.c that occur before
+ * we are merged can be easily merged here.
+ */
+#define PORT_PXA	31
+#define PORT_AMBA	32
+#define PORT_CLPS711X	33
+#define PORT_SA1100	34
+#define PORT_UART00	35
+#define PORT_21285	37
+
+/* Sparc type numbers.  */
+#define PORT_SUNZILOG	38
+#define PORT_SUNSAB	39
+
+/* DEC */
+#define PORT_DZ		46
+#define PORT_ZS		47
+
+/* Parisc type numbers. */
+#define PORT_MUX	48
+
+/* Atmel AT91 / AT32 SoC */
+#define PORT_ATMEL	49
+
+/* Macintosh Zilog type numbers */
+#define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
+#define PORT_PMAC_ZILOG	51
+
+/* SH-SCI */
+#define PORT_SCI	52
+#define PORT_SCIF	53
+#define PORT_IRDA	54
+
+/* Samsung S3C2410 SoC and derivatives thereof */
+#define PORT_S3C2410    55
+
+/* SGI IP22 aka Indy / Challenge S / Indigo 2 */
+#define PORT_IP22ZILOG	56
+
+/* Sharp LH7a40x -- an ARM9 SoC series */
+#define PORT_LH7A40X	57
+
+/* PPC CPM type number */
+#define PORT_CPM        58
+
+/* MPC52xx type numbers */
+#define PORT_MPC52xx	59
+
+/* IBM icom */
+#define PORT_ICOM	60
+
+/* Samsung S3C2440 SoC */
+#define PORT_S3C2440	61
+
+/* Motorola i.MX SoC */
+#define PORT_IMX	62
+
+/* Marvell MPSC */
+#define PORT_MPSC	63
+
+/* TXX9 type number */
+#define PORT_TXX9	64
+
+/* NEC VR4100 series SIU/DSIU */
+#define PORT_VR41XX_SIU		65
+#define PORT_VR41XX_DSIU	66
+
+/* Samsung S3C2400 SoC */
+#define PORT_S3C2400	67
+
+/* M32R SIO */
+#define PORT_M32R_SIO	68
+
+/*Digi jsm */
+#define PORT_JSM        69
+
+#define PORT_PNX8XXX	70
+
+/* Hilscher netx */
+#define PORT_NETX	71
+
+/* SUN4V Hypervisor Console */
+#define PORT_SUNHV	72
+
+#define PORT_S3C2412	73
+
+/* Xilinx uartlite */
+#define PORT_UARTLITE	74
+
+/* Blackfin bf5xx */
+#define PORT_BFIN	75
+
+/* Micrel KS8695 */
+#define PORT_KS8695	76
+
+/* Broadcom SB1250, etc. SOC */
+#define PORT_SB1250_DUART	77
+
+/* Freescale ColdFire */
+#define PORT_MCF	78
+
+/* Blackfin SPORT */
+#define PORT_BFIN_SPORT		79
+
+/* MN10300 on-chip UART numbers */
+#define PORT_MN10300		80
+#define PORT_MN10300_CTS	81
+
+#define PORT_SC26XX	82
+
+/* SH-SCI */
+#define PORT_SCIFA	83
+
+#define PORT_S3C6400	84
+
+/* NWPSERIAL */
+#define PORT_NWPSERIAL	85
+
+/* MAX3100 */
+#define PORT_MAX3100    86
+
+/* Timberdale UART */
+#define PORT_TIMBUART	87
+
+/* Qualcomm MSM SoCs */
+#define PORT_MSM	88
+
+/* BCM63xx family SoCs */
+#define PORT_BCM63XX	89
+
+
+#endif /* LINUX_SERIAL_CORE_H */
diff -uNr linux-2.6.32/usr/include/linux/serial.h clean_modified/linux-2.6.32/usr/include/linux/serial.h
--- linux-2.6.32/usr/include/linux/serial.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/serial.h	2019-04-14 13:24:03.126861895 -0500
@@ -0,0 +1,199 @@
+/*
+ * include/linux/serial.h
+ *
+ * Copyright (C) 1992 by Theodore Ts'o.
+ * 
+ * Redistribution of this file is permitted under the terms of the GNU 
+ * Public License (GPL)
+ */
+
+#ifndef _LINUX_SERIAL_H
+#define _LINUX_SERIAL_H
+
+#include <linux/types.h>
+
+
+struct serial_struct {
+	int	type;
+	int	line;
+	unsigned int	port;
+	int	irq;
+	int	flags;
+	int	xmit_fifo_size;
+	int	custom_divisor;
+	int	baud_base;
+	unsigned short	close_delay;
+	char	io_type;
+	char	reserved_char[1];
+	int	hub6;
+	unsigned short	closing_wait; /* time to wait before closing */
+	unsigned short	closing_wait2; /* no longer used... */
+	unsigned char	*iomem_base;
+	unsigned short	iomem_reg_shift;
+	unsigned int	port_high;
+	unsigned long	iomap_base;	/* cookie passed into ioremap */
+};
+
+/*
+ * For the close wait times, 0 means wait forever for serial port to
+ * flush its output.  65535 means don't wait at all.
+ */
+#define ASYNC_CLOSING_WAIT_INF	0
+#define ASYNC_CLOSING_WAIT_NONE	65535
+
+/*
+ * These are the supported serial types.
+ */
+#define PORT_UNKNOWN	0
+#define PORT_8250	1
+#define PORT_16450	2
+#define PORT_16550	3
+#define PORT_16550A	4
+#define PORT_CIRRUS     5	/* usurped by cyclades.c */
+#define PORT_16650	6
+#define PORT_16650V2	7
+#define PORT_16750	8
+#define PORT_STARTECH	9	/* usurped by cyclades.c */
+#define PORT_16C950	10	/* Oxford Semiconductor */
+#define PORT_16654	11
+#define PORT_16850	12
+#define PORT_RSA	13	/* RSA-DV II/S card */
+#define PORT_MAX	13
+
+#define SERIAL_IO_PORT	0
+#define SERIAL_IO_HUB6	1
+#define SERIAL_IO_MEM	2
+
+struct serial_uart_config {
+	char	*name;
+	int	dfl_xmit_fifo_size;
+	int	flags;
+};
+
+#define UART_CLEAR_FIFO		0x01
+#define UART_USE_FIFO		0x02
+#define UART_STARTECH		0x04
+#define UART_NATSEMI		0x08
+
+/*
+ * Definitions for async_struct (and serial_struct) flags field
+ *
+ * Define ASYNCB_* for convenient use with {test,set,clear}_bit.
+ */
+#define ASYNCB_HUP_NOTIFY	 0 /* Notify getty on hangups and closes
+				    * on the callout port */
+#define ASYNCB_FOURPORT		 1 /* Set OU1, OUT2 per AST Fourport settings */
+#define ASYNCB_SAK		 2 /* Secure Attention Key (Orange book) */
+#define ASYNCB_SPLIT_TERMIOS	 3 /* Separate termios for dialin/callout */
+#define ASYNCB_SPD_HI		 4 /* Use 56000 instead of 38400 bps */
+#define ASYNCB_SPD_VHI		 5 /* Use 115200 instead of 38400 bps */
+#define ASYNCB_SKIP_TEST	 6 /* Skip UART test during autoconfiguration */
+#define ASYNCB_AUTO_IRQ		 7 /* Do automatic IRQ during
+				    * autoconfiguration */
+#define ASYNCB_SESSION_LOCKOUT	 8 /* Lock out cua opens based on session */
+#define ASYNCB_PGRP_LOCKOUT	 9 /* Lock out cua opens based on pgrp */
+#define ASYNCB_CALLOUT_NOHUP	10 /* Don't do hangups for cua device */
+#define ASYNCB_HARDPPS_CD	11 /* Call hardpps when CD goes high  */
+#define ASYNCB_SPD_SHI		12 /* Use 230400 instead of 38400 bps */
+#define ASYNCB_LOW_LATENCY	13 /* Request low latency behaviour */
+#define ASYNCB_BUGGY_UART	14 /* This is a buggy UART, skip some safety
+				    * checks.  Note: can be dangerous! */
+#define ASYNCB_AUTOPROBE	15 /* Port was autoprobed by PCI or PNP code */
+#define ASYNCB_LAST_USER	15
+
+/* Internal flags used only by kernel */
+#define ASYNCB_INITIALIZED	31 /* Serial port was initialized */
+#define ASYNCB_SUSPENDED	30 /* Serial port is suspended */
+#define ASYNCB_NORMAL_ACTIVE	29 /* Normal device is active */
+#define ASYNCB_BOOT_AUTOCONF	28 /* Autoconfigure port on bootup */
+#define ASYNCB_CLOSING		27 /* Serial port is closing */
+#define ASYNCB_CTS_FLOW		26 /* Do CTS flow control */
+#define ASYNCB_CHECK_CD		25 /* i.e., CLOCAL */
+#define ASYNCB_SHARE_IRQ	24 /* for multifunction cards, no longer used */
+#define ASYNCB_CONS_FLOW	23 /* flow control for console  */
+#define ASYNCB_BOOT_ONLYMCA	22 /* Probe only if MCA bus */
+#define ASYNCB_FIRST_KERNEL	22
+
+#define ASYNC_HUP_NOTIFY	(1U << ASYNCB_HUP_NOTIFY)
+#define ASYNC_SUSPENDED		(1U << ASYNCB_SUSPENDED)
+#define ASYNC_FOURPORT		(1U << ASYNCB_FOURPORT)
+#define ASYNC_SAK		(1U << ASYNCB_SAK)
+#define ASYNC_SPLIT_TERMIOS	(1U << ASYNCB_SPLIT_TERMIOS)
+#define ASYNC_SPD_HI		(1U << ASYNCB_SPD_HI)
+#define ASYNC_SPD_VHI		(1U << ASYNCB_SPD_VHI)
+#define ASYNC_SKIP_TEST		(1U << ASYNCB_SKIP_TEST)
+#define ASYNC_AUTO_IRQ		(1U << ASYNCB_AUTO_IRQ)
+#define ASYNC_SESSION_LOCKOUT	(1U << ASYNCB_SESSION_LOCKOUT)
+#define ASYNC_PGRP_LOCKOUT	(1U << ASYNCB_PGRP_LOCKOUT)
+#define ASYNC_CALLOUT_NOHUP	(1U << ASYNCB_CALLOUT_NOHUP)
+#define ASYNC_HARDPPS_CD	(1U << ASYNCB_HARDPPS_CD)
+#define ASYNC_SPD_SHI		(1U << ASYNCB_SPD_SHI)
+#define ASYNC_LOW_LATENCY	(1U << ASYNCB_LOW_LATENCY)
+#define ASYNC_BUGGY_UART	(1U << ASYNCB_BUGGY_UART)
+#define ASYNC_AUTOPROBE		(1U << ASYNCB_AUTOPROBE)
+
+#define ASYNC_FLAGS		((1U << ASYNCB_LAST_USER) - 1)
+#define ASYNC_USR_MASK		(ASYNC_SPD_HI|ASYNC_SPD_VHI| \
+		ASYNC_CALLOUT_NOHUP|ASYNC_SPD_SHI|ASYNC_LOW_LATENCY)
+#define ASYNC_SPD_CUST		(ASYNC_SPD_HI|ASYNC_SPD_VHI)
+#define ASYNC_SPD_WARP		(ASYNC_SPD_HI|ASYNC_SPD_SHI)
+#define ASYNC_SPD_MASK		(ASYNC_SPD_HI|ASYNC_SPD_VHI|ASYNC_SPD_SHI)
+
+#define ASYNC_INITIALIZED	(1U << ASYNCB_INITIALIZED)
+#define ASYNC_NORMAL_ACTIVE	(1U << ASYNCB_NORMAL_ACTIVE)
+#define ASYNC_BOOT_AUTOCONF	(1U << ASYNCB_BOOT_AUTOCONF)
+#define ASYNC_CLOSING		(1U << ASYNCB_CLOSING)
+#define ASYNC_CTS_FLOW		(1U << ASYNCB_CTS_FLOW)
+#define ASYNC_CHECK_CD		(1U << ASYNCB_CHECK_CD)
+#define ASYNC_SHARE_IRQ		(1U << ASYNCB_SHARE_IRQ)
+#define ASYNC_CONS_FLOW		(1U << ASYNCB_CONS_FLOW)
+#define ASYNC_BOOT_ONLYMCA	(1U << ASYNCB_BOOT_ONLYMCA)
+#define ASYNC_INTERNAL_FLAGS	(~((1U << ASYNCB_FIRST_KERNEL) - 1))
+
+/*
+ * Multiport serial configuration structure --- external structure
+ */
+struct serial_multiport_struct {
+	int		irq;
+	int		port1;
+	unsigned char	mask1, match1;
+	int		port2;
+	unsigned char	mask2, match2;
+	int		port3;
+	unsigned char	mask3, match3;
+	int		port4;
+	unsigned char	mask4, match4;
+	int		port_monitor;
+	int	reserved[32];
+};
+
+/*
+ * Serial input interrupt line counters -- external structure
+ * Four lines can interrupt: CTS, DSR, RI, DCD
+ */
+struct serial_icounter_struct {
+	int cts, dsr, rng, dcd;
+	int rx, tx;
+	int frame, overrun, parity, brk;
+	int buf_overrun;
+	int reserved[9];
+};
+
+/*
+ * Serial interface for controlling RS485 settings on chips with suitable
+ * support. Set with TIOCSRS485 and get with TIOCGRS485 if supported by your
+ * platform. The set function returns the new state, with any unsupported bits
+ * reverted appropriately.
+ */
+
+struct serial_rs485 {
+	__u32	flags;			/* RS485 feature flags */
+#define SER_RS485_ENABLED		(1 << 0)
+#define SER_RS485_RTS_ON_SEND		(1 << 1)
+#define SER_RS485_RTS_AFTER_SEND	(1 << 2)
+	__u32	delay_rts_before_send;	/* Milliseconds */
+	__u32	padding[6];		/* Memory is cheap, new structs
+					   are a royal PITA .. */
+};
+
+#endif /* _LINUX_SERIAL_H */
diff -uNr linux-2.6.32/usr/include/linux/serial_reg.h clean_modified/linux-2.6.32/usr/include/linux/serial_reg.h
--- linux-2.6.32/usr/include/linux/serial_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/serial_reg.h	2019-04-14 13:24:03.126861895 -0500
@@ -0,0 +1,329 @@
+/*
+ * include/linux/serial_reg.h
+ *
+ * Copyright (C) 1992, 1994 by Theodore Ts'o.
+ * 
+ * Redistribution of this file is permitted under the terms of the GNU 
+ * Public License (GPL)
+ * 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#ifndef _LINUX_SERIAL_REG_H
+#define _LINUX_SERIAL_REG_H
+
+/*
+ * DLAB=0
+ */
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
+
+#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x01 /* Enable receiver data interrupt */
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_MSI		0x00 /* Modem status interrupt */
+#define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
+#define UART_IIR_RDI		0x04 /* Receiver data interrupt */
+#define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
+
+#define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
+
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_01	0x40
+#define UART_FCR_R_TRIG_10	0x80
+#define UART_FCR_R_TRIG_11	0xc0
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_01	0x10
+#define UART_FCR_T_TRIG_10	0x20
+#define UART_FCR_T_TRIG_11	0x30
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SPAR		0x20 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x10 /* Even parity select */
+#define UART_LCR_PARITY		0x08 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x20 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+#define UART_MCR_OUT2		0x08 /* Out2 complement */
+#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x02 /* RTS complement */
+#define UART_MCR_DTR		0x01 /* DTR complement */
+
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x10 /* Break interrupt indicator */
+#define UART_LSR_FE		0x08 /* Frame error indicator */
+#define UART_LSR_PE		0x04 /* Parity error indicator */
+#define UART_LSR_OE		0x02 /* Overrun error indicator */
+#define UART_LSR_DR		0x01 /* Receiver data ready */
+#define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
+
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x80 /* Data Carrier Detect */
+#define UART_MSR_RI		0x40 /* Ring Indicator */
+#define UART_MSR_DSR		0x20 /* Data Set Ready */
+#define UART_MSR_CTS		0x10 /* Clear to Send */
+#define UART_MSR_DDCD		0x08 /* Delta DCD */
+#define UART_MSR_TERI		0x04 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x02 /* Delta DSR */
+#define UART_MSR_DCTS		0x01 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO treshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO treshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO treshold = 32 */
+
+
+
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Register
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Transmitter disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+#define UART_OMAP_WER		0x17	/* Wake-up enable register */
+
+#endif /* _LINUX_SERIAL_REG_H */
+
diff -uNr linux-2.6.32/usr/include/linux/serio.h clean_modified/linux-2.6.32/usr/include/linux/serio.h
--- linux-2.6.32/usr/include/linux/serio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/serio.h	2019-04-14 13:24:03.128338110 -0500
@@ -0,0 +1,76 @@
+#ifndef _SERIO_H
+#define _SERIO_H
+
+/*
+ * Copyright (C) 1999-2002 Vojtech Pavlik
+*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/ioctl.h>
+
+#define SPIOCSTYPE	_IOW('q', 0x01, unsigned long)
+
+
+/*
+ * bit masks for use in "interrupt" flags (3rd argument)
+ */
+#define SERIO_TIMEOUT	1
+#define SERIO_PARITY	2
+#define SERIO_FRAME	4
+
+/*
+ * Serio types
+ */
+#define SERIO_XT	0x00
+#define SERIO_8042	0x01
+#define SERIO_RS232	0x02
+#define SERIO_HIL_MLC	0x03
+#define SERIO_PS_PSTHRU	0x05
+#define SERIO_8042_XL	0x06
+
+/*
+ * Serio protocols
+ */
+#define SERIO_UNKNOWN	0x00
+#define SERIO_MSC	0x01
+#define SERIO_SUN	0x02
+#define SERIO_MS	0x03
+#define SERIO_MP	0x04
+#define SERIO_MZ	0x05
+#define SERIO_MZP	0x06
+#define SERIO_MZPP	0x07
+#define SERIO_VSXXXAA	0x08
+#define SERIO_SUNKBD	0x10
+#define SERIO_WARRIOR	0x18
+#define SERIO_SPACEORB	0x19
+#define SERIO_MAGELLAN	0x1a
+#define SERIO_SPACEBALL	0x1b
+#define SERIO_GUNZE	0x1c
+#define SERIO_IFORCE	0x1d
+#define SERIO_STINGER	0x1e
+#define SERIO_NEWTON	0x1f
+#define SERIO_STOWAWAY	0x20
+#define SERIO_H3600	0x21
+#define SERIO_PS2SER	0x22
+#define SERIO_TWIDKBD	0x23
+#define SERIO_TWIDJOY	0x24
+#define SERIO_HIL	0x25
+#define SERIO_SNES232	0x26
+#define SERIO_SEMTECH	0x27
+#define SERIO_LKKBD	0x28
+#define SERIO_ELO	0x29
+#define SERIO_MICROTOUCH	0x30
+#define SERIO_PENMOUNT	0x31
+#define SERIO_TOUCHRIGHT	0x32
+#define SERIO_TOUCHWIN	0x33
+#define SERIO_TAOSEVM	0x34
+#define SERIO_FUJITSU	0x35
+#define SERIO_ZHENHUA	0x36
+#define SERIO_INEXIO	0x37
+#define SERIO_TOUCHIT213	0x38
+#define SERIO_W8001	0x39
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/shm.h clean_modified/linux-2.6.32/usr/include/linux/shm.h
--- linux-2.6.32/usr/include/linux/shm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/shm.h	2019-04-14 13:24:03.128826208 -0500
@@ -0,0 +1,75 @@
+#ifndef _LINUX_SHM_H_
+#define _LINUX_SHM_H_
+
+#include <linux/ipc.h>
+#include <linux/errno.h>
+#include <unistd.h>
+
+/*
+ * SHMMAX, SHMMNI and SHMALL are upper limits are defaults which can
+ * be increased by sysctl
+ */
+
+#define SHMMAX 0x2000000		 /* max shared seg size (bytes) */
+#define SHMMIN 1			 /* min shared seg size (bytes) */
+#define SHMMNI 4096			 /* max num of segs system wide */
+#define SHMALL (SHMMAX/getpagesize()*(SHMMNI/16))
+#define SHMSEG SHMMNI			 /* max shared segs per process */
+
+
+/* Obsolete, used only for backwards compatibility and libc5 compiles */
+struct shmid_ds {
+	struct ipc_perm		shm_perm;	/* operation perms */
+	int			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	__kernel_time_t		shm_ctime;	/* last change time */
+	__kernel_ipc_pid_t	shm_cpid;	/* pid of creator */
+	__kernel_ipc_pid_t	shm_lpid;	/* pid of last operator */
+	unsigned short		shm_nattch;	/* no. of current attaches */
+	unsigned short 		shm_unused;	/* compatibility */
+	void 			*shm_unused2;	/* ditto - used by DIPC */
+	void			*shm_unused3;	/* unused */
+};
+
+/* Include the definition of shmid64_ds and shminfo64 */
+#include <asm/shmbuf.h>
+
+/* permission flag for shmget */
+#define SHM_R		0400	/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200	/* or S_IWUGO from <linux/stat.h> */
+
+/* mode for attach */
+#define	SHM_RDONLY	010000	/* read-only access */
+#define	SHM_RND		020000	/* round attach address to SHMLBA boundary */
+#define	SHM_REMAP	040000	/* take-over region on attach */
+#define	SHM_EXEC	0100000	/* execution access */
+
+/* super user shmctl commands */
+#define SHM_LOCK 	11
+#define SHM_UNLOCK 	12
+
+/* ipcs ctl commands */
+#define SHM_STAT 	13
+#define SHM_INFO 	14
+
+/* Obsolete, used only for backwards compatibility */
+struct	shminfo {
+	int shmmax;
+	int shmmin;
+	int shmmni;
+	int shmseg;
+	int shmall;
+};
+
+struct shm_info {
+	int used_ids;
+	unsigned long shm_tot;	/* total allocated shm */
+	unsigned long shm_rss;	/* total resident shm */
+	unsigned long shm_swp;	/* total swapped shm */
+	unsigned long swap_attempts;
+	unsigned long swap_successes;
+};
+
+
+#endif /* _LINUX_SHM_H_ */
diff -uNr linux-2.6.32/usr/include/linux/signalfd.h clean_modified/linux-2.6.32/usr/include/linux/signalfd.h
--- linux-2.6.32/usr/include/linux/signalfd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/signalfd.h	2019-04-14 13:24:03.128826208 -0500
@@ -0,0 +1,52 @@
+/*
+ *  include/linux/signalfd.h
+ *
+ *  Copyright (C) 2007  Davide Libenzi <davidel@xmailserver.org>
+ *
+ */
+
+#ifndef _LINUX_SIGNALFD_H
+#define _LINUX_SIGNALFD_H
+
+#include <linux/types.h>
+/* For O_CLOEXEC and O_NONBLOCK */
+#include <linux/fcntl.h>
+
+/* Flags for signalfd4.  */
+#define SFD_CLOEXEC O_CLOEXEC
+#define SFD_NONBLOCK O_NONBLOCK
+
+struct signalfd_siginfo {
+	__u32 ssi_signo;
+	__s32 ssi_errno;
+	__s32 ssi_code;
+	__u32 ssi_pid;
+	__u32 ssi_uid;
+	__s32 ssi_fd;
+	__u32 ssi_tid;
+	__u32 ssi_band;
+	__u32 ssi_overrun;
+	__u32 ssi_trapno;
+	__s32 ssi_status;
+	__s32 ssi_int;
+	__u64 ssi_ptr;
+	__u64 ssi_utime;
+	__u64 ssi_stime;
+	__u64 ssi_addr;
+
+	/*
+	 * Pad strcture to 128 bytes. Remember to update the
+	 * pad size when you add new members. We use a fixed
+	 * size structure to avoid compatibility problems with
+	 * future versions, and we leave extra space for additional
+	 * members. We use fixed size members because this strcture
+	 * comes out of a read(2) and we really don't want to have
+	 * a compat on read(2).
+	 */
+	__u8 __pad[48];
+};
+
+
+
+#endif /* _LINUX_SIGNALFD_H */
+
diff -uNr linux-2.6.32/usr/include/linux/signal.h clean_modified/linux-2.6.32/usr/include/linux/signal.h
--- linux-2.6.32/usr/include/linux/signal.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/signal.h	2019-04-14 13:24:03.128826208 -0500
@@ -0,0 +1,8 @@
+#ifndef _LINUX_SIGNAL_H
+#define _LINUX_SIGNAL_H
+
+#include <asm/signal.h>
+#include <asm/siginfo.h>
+
+
+#endif /* _LINUX_SIGNAL_H */
diff -uNr linux-2.6.32/usr/include/linux/smb_fs.h clean_modified/linux-2.6.32/usr/include/linux/smb_fs.h
--- linux-2.6.32/usr/include/linux/smb_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/smb_fs.h	2019-04-14 13:24:03.128826208 -0500
@@ -0,0 +1,25 @@
+/*
+ *  smb_fs.h
+ *
+ *  Copyright (C) 1995 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ */
+
+#ifndef _LINUX_SMB_FS_H
+#define _LINUX_SMB_FS_H
+
+#include <linux/smb.h>
+
+/*
+ * ioctl commands
+ */
+#define	SMB_IOC_GETMOUNTUID		_IOR('u', 1, __kernel_old_uid_t)
+#define SMB_IOC_NEWCONN                 _IOW('u', 2, struct smb_conn_opt)
+
+/* __kernel_uid_t can never change, so we have to use __kernel_uid32_t */
+#define	SMB_IOC_GETMOUNTUID32		_IOR('u', 3, __kernel_uid32_t)
+
+
+
+#endif /* _LINUX_SMB_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/smb.h clean_modified/linux-2.6.32/usr/include/linux/smb.h
--- linux-2.6.32/usr/include/linux/smb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/smb.h	2019-04-14 13:24:03.128826208 -0500
@@ -0,0 +1,64 @@
+/*
+ *  smb.h
+ *
+ *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ */
+
+#ifndef _LINUX_SMB_H
+#define _LINUX_SMB_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+enum smb_protocol { 
+	SMB_PROTOCOL_NONE, 
+	SMB_PROTOCOL_CORE, 
+	SMB_PROTOCOL_COREPLUS, 
+	SMB_PROTOCOL_LANMAN1, 
+	SMB_PROTOCOL_LANMAN2, 
+	SMB_PROTOCOL_NT1 
+};
+
+enum smb_case_hndl {
+	SMB_CASE_DEFAULT,
+	SMB_CASE_LOWER,
+	SMB_CASE_UPPER
+};
+
+struct smb_dskattr {
+        __u16 total;
+        __u16 allocblocks;
+        __u16 blocksize;
+        __u16 free;
+};
+
+struct smb_conn_opt {
+
+        /* The socket */
+	unsigned int fd;
+
+	enum smb_protocol protocol;
+	enum smb_case_hndl case_handling;
+
+	/* Connection-Options */
+
+	__u32              max_xmit;
+	__u16              server_uid;
+	__u16              tid;
+
+        /* The following are LANMAN 1.0 options */
+        __u16              secmode;
+        __u16              maxmux;
+        __u16              maxvcs;
+        __u16              rawmode;
+        __u32              sesskey;
+
+	/* The following are NT LM 0.12 options */
+	__u32              maxraw;
+	__u32              capabilities;
+	__s16              serverzone;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/smb_mount.h clean_modified/linux-2.6.32/usr/include/linux/smb_mount.h
--- linux-2.6.32/usr/include/linux/smb_mount.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/smb_mount.h	2019-04-14 13:24:03.129789901 -0500
@@ -0,0 +1,27 @@
+/*
+ *  smb_mount.h
+ *
+ *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
+ *  Copyright (C) 1997 by Volker Lendecke
+ *
+ */
+
+#ifndef _LINUX_SMB_MOUNT_H
+#define _LINUX_SMB_MOUNT_H
+
+#include <linux/types.h>
+
+#define SMB_MOUNT_VERSION	6
+
+struct smb_mount_data {
+	int version;
+	__kernel_uid_t mounted_uid; /* Who may umount() this filesystem? */
+	__kernel_uid_t uid;
+	__kernel_gid_t gid;
+	__kernel_mode_t file_mode;
+	__kernel_mode_t dir_mode;
+};
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/smbno.h clean_modified/linux-2.6.32/usr/include/linux/smbno.h
--- linux-2.6.32/usr/include/linux/smbno.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/smbno.h	2019-04-14 13:24:03.129789901 -0500
@@ -0,0 +1,363 @@
+#ifndef _SMBNO_H_
+#define _SMBNO_H_
+
+/* these define the attribute byte as seen by DOS */
+#define aRONLY	(1L<<0)
+#define aHIDDEN	(1L<<1)
+#define aSYSTEM	(1L<<2)
+#define aVOLID	(1L<<3)
+#define aDIR	(1L<<4)
+#define aARCH	(1L<<5)
+
+/* error classes */
+#define SUCCESS 0  /* The request was successful. */
+#define ERRDOS 0x01 /*  Error is from the core DOS operating system set. */
+#define ERRSRV 0x02 /* Error is generated by the server network file manager.*/
+#define ERRHRD 0x03  /* Error is an hardware error. */
+#define ERRCMD 0xFF  /* Command was not in the "SMB" format. */
+
+/* SMB X/Open error codes for the ERRdos error class */
+
+#define ERRbadfunc 1            /* Invalid function (or system call) */
+#define ERRbadfile 2            /* File not found (pathname error) */
+#define ERRbadpath 3            /* Directory not found */
+#define ERRnofids 4             /* Too many open files */
+#define ERRnoaccess 5           /* Access denied */
+#define ERRbadfid 6             /* Invalid fid */
+#define ERRbadmcb 7             /* Memory control blocks destroyed */
+#define ERRnomem 8              /* Out of memory */
+#define ERRbadmem 9             /* Invalid memory block address */
+#define ERRbadenv 10            /* Invalid environment */
+#define ERRbadformat 11         /* Invalid format */
+#define ERRbadaccess 12         /* Invalid open mode */
+#define ERRbaddata 13           /* Invalid data (only from ioctl call) */
+#define ERRres 14               /* reserved */
+#define ERRbaddrive 15          /* Invalid drive */
+#define ERRremcd 16             /* Attempt to delete current directory */
+#define ERRdiffdevice 17        /* rename/move across different filesystems */
+#define ERRnofiles 18           /* no more files found in file search */
+#define ERRbadshare 32          /* Share mode on file conflict with open mode */
+#define ERRlock 33              /* Lock request conflicts with existing lock */
+#define ERRfilexists 80         /* File in operation already exists */
+#define ERRbadpipe 230          /* Named pipe invalid */
+#define ERRpipebusy 231         /* All instances of pipe are busy */
+#define ERRpipeclosing 232      /* named pipe close in progress */
+#define ERRnotconnected 233     /* No process on other end of named pipe */
+#define ERRmoredata 234         /* More data to be returned */
+
+#define ERROR_INVALID_PARAMETER	 87
+#define ERROR_DISK_FULL		112
+#define ERROR_INVALID_NAME	123
+#define ERROR_DIR_NOT_EMPTY	145
+#define ERROR_NOT_LOCKED	158
+#define ERROR_ALREADY_EXISTS	183  /* see also 80 ? */
+#define ERROR_EAS_DIDNT_FIT	275 /* Extended attributes didn't fit */
+#define ERROR_EAS_NOT_SUPPORTED	282 /* Extended attributes not supported */
+
+/* Error codes for the ERRSRV class */
+
+#define ERRerror 1              /* Non specific error code */
+#define ERRbadpw 2              /* Bad password */
+#define ERRbadtype 3            /* reserved */
+#define ERRaccess 4          /* No permissions to do the requested operation */
+#define ERRinvnid 5             /* tid invalid */
+#define ERRinvnetname 6         /* Invalid servername */
+#define ERRinvdevice 7          /* Invalid device */
+#define ERRqfull 49             /* Print queue full */
+#define ERRqtoobig 50           /* Queued item too big */
+#define ERRinvpfid 52           /* Invalid print file in smb_fid */
+#define ERRsmbcmd 64            /* Unrecognised command */
+#define ERRsrverror 65          /* smb server internal error */
+#define ERRfilespecs 67         /* fid and pathname invalid combination */
+#define ERRbadlink 68           /* reserved */
+#define ERRbadpermits 69        /* Access specified for a file is not valid */
+#define ERRbadpid 70            /* reserved */
+#define ERRsetattrmode 71       /* attribute mode invalid */
+#define ERRpaused 81            /* Message server paused */
+#define ERRmsgoff 82            /* Not receiving messages */
+#define ERRnoroom 83            /* No room for message */
+#define ERRrmuns 87             /* too many remote usernames */
+#define ERRtimeout 88           /* operation timed out */
+#define ERRnoresource  89   /* No resources currently available for request. */
+#define ERRtoomanyuids 90       /* too many userids */
+#define ERRbaduid 91            /* bad userid */
+#define ERRuseMPX 250    /* temporarily unable to use raw mode, use MPX mode */
+#define ERRuseSTD 251    /* temporarily unable to use raw mode, use std.mode */
+#define ERRcontMPX 252          /* resume MPX mode */
+#define ERRbadPW                /* reserved */
+#define ERRnosupport 0xFFFF
+
+/* Error codes for the ERRHRD class */
+
+#define ERRnowrite 19           /* read only media */
+#define ERRbadunit 20           /* Unknown device */
+#define ERRnotready 21          /* Drive not ready */
+#define ERRbadcmd 22            /* Unknown command */
+#define ERRdata 23              /* Data (CRC) error */
+#define ERRbadreq 24            /* Bad request structure length */
+#define ERRseek 25
+#define ERRbadmedia 26
+#define ERRbadsector 27
+#define ERRnopaper 28
+#define ERRwrite 29             /* write fault */
+#define ERRread 30              /* read fault */
+#define ERRgeneral 31           /* General hardware failure */
+#define ERRwrongdisk 34
+#define ERRFCBunavail 35
+#define ERRsharebufexc 36       /* share buffer exceeded */
+#define ERRdiskfull 39
+
+/*
+ * Access modes when opening a file
+ */
+#define SMB_ACCMASK	0x0003
+#define SMB_O_RDONLY	0x0000
+#define SMB_O_WRONLY	0x0001
+#define SMB_O_RDWR	0x0002
+
+/* offsets into message for common items */
+#define smb_com 8
+#define smb_rcls 9
+#define smb_reh 10
+#define smb_err 11
+#define smb_flg 13
+#define smb_flg2 14
+#define smb_reb 13
+#define smb_tid 28
+#define smb_pid 30
+#define smb_uid 32
+#define smb_mid 34
+#define smb_wct 36
+#define smb_vwv 37
+#define smb_vwv0 37
+#define smb_vwv1 39
+#define smb_vwv2 41
+#define smb_vwv3 43
+#define smb_vwv4 45
+#define smb_vwv5 47
+#define smb_vwv6 49
+#define smb_vwv7 51
+#define smb_vwv8 53
+#define smb_vwv9 55
+#define smb_vwv10 57
+#define smb_vwv11 59
+#define smb_vwv12 61
+#define smb_vwv13 63
+#define smb_vwv14 65
+
+/* these are the trans2 sub fields for primary requests */
+#define smb_tpscnt smb_vwv0
+#define smb_tdscnt smb_vwv1
+#define smb_mprcnt smb_vwv2
+#define smb_mdrcnt smb_vwv3
+#define smb_msrcnt smb_vwv4
+#define smb_flags smb_vwv5
+#define smb_timeout smb_vwv6
+#define smb_pscnt smb_vwv9
+#define smb_psoff smb_vwv10
+#define smb_dscnt smb_vwv11
+#define smb_dsoff smb_vwv12
+#define smb_suwcnt smb_vwv13
+#define smb_setup smb_vwv14
+#define smb_setup0 smb_setup
+#define smb_setup1 (smb_setup+2)
+#define smb_setup2 (smb_setup+4)
+
+/* these are for the secondary requests */
+#define smb_spscnt smb_vwv2
+#define smb_spsoff smb_vwv3
+#define smb_spsdisp smb_vwv4
+#define smb_sdscnt smb_vwv5
+#define smb_sdsoff smb_vwv6
+#define smb_sdsdisp smb_vwv7
+#define smb_sfid smb_vwv8
+
+/* and these for responses */
+#define smb_tprcnt smb_vwv0
+#define smb_tdrcnt smb_vwv1
+#define smb_prcnt smb_vwv3
+#define smb_proff smb_vwv4
+#define smb_prdisp smb_vwv5
+#define smb_drcnt smb_vwv6
+#define smb_droff smb_vwv7
+#define smb_drdisp smb_vwv8
+
+/* the complete */
+#define SMBmkdir      0x00   /* create directory */
+#define SMBrmdir      0x01   /* delete directory */
+#define SMBopen       0x02   /* open file */
+#define SMBcreate     0x03   /* create file */
+#define SMBclose      0x04   /* close file */
+#define SMBflush      0x05   /* flush file */
+#define SMBunlink     0x06   /* delete file */
+#define SMBmv         0x07   /* rename file */
+#define SMBgetatr     0x08   /* get file attributes */
+#define SMBsetatr     0x09   /* set file attributes */
+#define SMBread       0x0A   /* read from file */
+#define SMBwrite      0x0B   /* write to file */
+#define SMBlock       0x0C   /* lock byte range */
+#define SMBunlock     0x0D   /* unlock byte range */
+#define SMBctemp      0x0E   /* create temporary file */
+#define SMBmknew      0x0F   /* make new file */
+#define SMBchkpth     0x10   /* check directory path */
+#define SMBexit       0x11   /* process exit */
+#define SMBlseek      0x12   /* seek */
+#define SMBtcon       0x70   /* tree connect */
+#define SMBtconX      0x75   /* tree connect and X*/
+#define SMBtdis       0x71   /* tree disconnect */
+#define SMBnegprot    0x72   /* negotiate protocol */
+#define SMBdskattr    0x80   /* get disk attributes */
+#define SMBsearch     0x81   /* search directory */
+#define SMBsplopen    0xC0   /* open print spool file */
+#define SMBsplwr      0xC1   /* write to print spool file */
+#define SMBsplclose   0xC2   /* close print spool file */
+#define SMBsplretq    0xC3   /* return print queue */
+#define SMBsends      0xD0   /* send single block message */
+#define SMBsendb      0xD1   /* send broadcast message */
+#define SMBfwdname    0xD2   /* forward user name */
+#define SMBcancelf    0xD3   /* cancel forward */
+#define SMBgetmac     0xD4   /* get machine name */
+#define SMBsendstrt   0xD5   /* send start of multi-block message */
+#define SMBsendend    0xD6   /* send end of multi-block message */
+#define SMBsendtxt    0xD7   /* send text of multi-block message */
+
+/* Core+ protocol */
+#define SMBlockread	  0x13   /* Lock a range and read */
+#define SMBwriteunlock 0x14 /* Unlock a range then write */
+#define SMBreadbraw   0x1a  /* read a block of data with no smb header */
+#define SMBwritebraw  0x1d  /* write a block of data with no smb header */
+#define SMBwritec     0x20  /* secondary write request */
+#define SMBwriteclose 0x2c  /* write a file then close it */
+
+/* dos extended protocol */
+#define SMBreadBraw      0x1A   /* read block raw */
+#define SMBreadBmpx      0x1B   /* read block multiplexed */
+#define SMBreadBs        0x1C   /* read block (secondary response) */
+#define SMBwriteBraw     0x1D   /* write block raw */
+#define SMBwriteBmpx     0x1E   /* write block multiplexed */
+#define SMBwriteBs       0x1F   /* write block (secondary request) */
+#define SMBwriteC        0x20   /* write complete response */
+#define SMBsetattrE      0x22   /* set file attributes expanded */
+#define SMBgetattrE      0x23   /* get file attributes expanded */
+#define SMBlockingX      0x24   /* lock/unlock byte ranges and X */
+#define SMBtrans         0x25   /* transaction - name, bytes in/out */
+#define SMBtranss        0x26   /* transaction (secondary request/response) */
+#define SMBioctl         0x27   /* IOCTL */
+#define SMBioctls        0x28   /* IOCTL  (secondary request/response) */
+#define SMBcopy          0x29   /* copy */
+#define SMBmove          0x2A   /* move */
+#define SMBecho          0x2B   /* echo */
+#define SMBopenX         0x2D   /* open and X */
+#define SMBreadX         0x2E   /* read and X */
+#define SMBwriteX        0x2F   /* write and X */
+#define SMBsesssetupX    0x73   /* Session Set Up & X (including User Logon) */
+#define SMBtconX         0x75   /* tree connect and X */
+#define SMBffirst        0x82   /* find first */
+#define SMBfunique       0x83   /* find unique */
+#define SMBfclose        0x84   /* find close */
+#define SMBinvalid       0xFE   /* invalid command */
+
+
+/* Extended 2.0 protocol */
+#define SMBtrans2        0x32   /* TRANS2 protocol set */
+#define SMBtranss2       0x33   /* TRANS2 protocol set, secondary command */
+#define SMBfindclose     0x34   /* Terminate a TRANSACT2_FINDFIRST */
+#define SMBfindnclose    0x35   /* Terminate a TRANSACT2_FINDNOTIFYFIRST */
+#define SMBulogoffX      0x74   /* user logoff */
+
+/* these are the TRANS2 sub commands */
+#define TRANSACT2_OPEN          0
+#define TRANSACT2_FINDFIRST     1
+#define TRANSACT2_FINDNEXT      2
+#define TRANSACT2_QFSINFO       3
+#define TRANSACT2_SETFSINFO     4
+#define TRANSACT2_QPATHINFO     5
+#define TRANSACT2_SETPATHINFO   6
+#define TRANSACT2_QFILEINFO     7
+#define TRANSACT2_SETFILEINFO   8
+#define TRANSACT2_FSCTL         9
+#define TRANSACT2_IOCTL           10
+#define TRANSACT2_FINDNOTIFYFIRST 11
+#define TRANSACT2_FINDNOTIFYNEXT  12
+#define TRANSACT2_MKDIR           13
+
+/* Information Levels -  Shared? */
+#define SMB_INFO_STANDARD		1
+#define SMB_INFO_QUERY_EA_SIZE		2
+#define SMB_INFO_QUERY_EAS_FROM_LIST	3
+#define SMB_INFO_QUERY_ALL_EAS		4
+#define SMB_INFO_IS_NAME_VALID		6
+
+/* Information Levels -  TRANSACT2_FINDFIRST */
+#define SMB_FIND_FILE_DIRECTORY_INFO		0x101
+#define SMB_FIND_FILE_FULL_DIRECTORY_INFO	0x102
+#define SMB_FIND_FILE_NAMES_INFO		0x103
+#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO	0x104
+
+/* Information Levels -  TRANSACT2_QPATHINFO */
+#define SMB_QUERY_FILE_BASIC_INFO	0x101
+#define SMB_QUERY_FILE_STANDARD_INFO	0x102
+#define SMB_QUERY_FILE_EA_INFO		0x103
+#define SMB_QUERY_FILE_NAME_INFO	0x104
+#define SMB_QUERY_FILE_ALL_INFO		0x107
+#define SMB_QUERY_FILE_ALT_NAME_INFO	0x108
+#define SMB_QUERY_FILE_STREAM_INFO	0x109
+#define SMB_QUERY_FILE_COMPRESSION_INFO	0x10b
+
+/* Information Levels - TRANSACT2_SETFILEINFO */
+#define SMB_SET_FILE_BASIC_INFO		0x101
+#define SMB_SET_FILE_DISPOSITION_INFO	0x102
+#define SMB_SET_FILE_ALLOCATION_INFO	0x103
+#define SMB_SET_FILE_END_OF_FILE_INFO	0x104
+
+/* smb_flg field flags */
+#define SMB_FLAGS_SUPPORT_LOCKREAD	0x01
+#define SMB_FLAGS_CLIENT_BUF_AVAIL	0x02
+#define SMB_FLAGS_RESERVED		0x04
+#define SMB_FLAGS_CASELESS_PATHNAMES	0x08
+#define SMB_FLAGS_CANONICAL_PATHNAMES	0x10
+#define SMB_FLAGS_REQUEST_OPLOCK	0x20
+#define SMB_FLAGS_REQUEST_BATCH_OPLOCK	0x40
+#define SMB_FLAGS_REPLY			0x80
+
+/* smb_flg2 field flags (samba-2.2.0/source/include/smb.h) */
+#define SMB_FLAGS2_LONG_PATH_COMPONENTS		0x0001
+#define SMB_FLAGS2_EXTENDED_ATTRIBUTES		0x0002
+#define SMB_FLAGS2_DFS_PATHNAMES		0x1000
+#define SMB_FLAGS2_READ_PERMIT_NO_EXECUTE	0x2000
+#define SMB_FLAGS2_32_BIT_ERROR_CODES		0x4000 
+#define SMB_FLAGS2_UNICODE_STRINGS		0x8000
+
+
+/*
+ * UNIX stuff  (from samba trans2.h)
+ */
+#define MIN_UNIX_INFO_LEVEL		0x200
+#define MAX_UNIX_INFO_LEVEL		0x2FF
+#define SMB_FIND_FILE_UNIX		0x202
+#define SMB_QUERY_FILE_UNIX_BASIC	0x200
+#define SMB_QUERY_FILE_UNIX_LINK	0x201
+#define SMB_QUERY_FILE_UNIX_HLINK	0x202
+#define SMB_SET_FILE_UNIX_BASIC		0x200
+#define SMB_SET_FILE_UNIX_LINK		0x201
+#define SMB_SET_FILE_UNIX_HLINK		0x203
+#define SMB_QUERY_CIFS_UNIX_INFO	0x200
+
+/* values which means "don't change it" */
+#define SMB_MODE_NO_CHANGE		0xFFFFFFFF
+#define SMB_UID_NO_CHANGE		0xFFFFFFFF
+#define SMB_GID_NO_CHANGE		0xFFFFFFFF
+#define SMB_TIME_NO_CHANGE		0xFFFFFFFFFFFFFFFFULL
+#define SMB_SIZE_NO_CHANGE		0xFFFFFFFFFFFFFFFFULL
+
+/* UNIX filetype mappings. */
+#define UNIX_TYPE_FILE		0
+#define UNIX_TYPE_DIR		1
+#define UNIX_TYPE_SYMLINK	2
+#define UNIX_TYPE_CHARDEV	3
+#define UNIX_TYPE_BLKDEV	4
+#define UNIX_TYPE_FIFO		5
+#define UNIX_TYPE_SOCKET	6
+#define UNIX_TYPE_UNKNOWN	0xFFFFFFFF
+
+#endif /* _SMBNO_H_ */
diff -uNr linux-2.6.32/usr/include/linux/snmp.h clean_modified/linux-2.6.32/usr/include/linux/snmp.h
--- linux-2.6.32/usr/include/linux/snmp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/snmp.h	2019-04-14 13:24:03.129789901 -0500
@@ -0,0 +1,263 @@
+/*
+ * Definitions for MIBs
+ *
+ * Author: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
+ */
+
+#ifndef _LINUX_SNMP_H
+#define _LINUX_SNMP_H
+
+/* ipstats mib definitions */
+/*
+ * RFC 1213:  MIB-II
+ * RFC 2011 (updates 1213):  SNMPv2-MIB-IP
+ * RFC 2863:  Interfaces Group MIB
+ * RFC 2465:  IPv6 MIB: General Group
+ * draft-ietf-ipv6-rfc2011-update-10.txt: MIB for IP: IP Statistics Tables
+ */
+enum
+{
+	IPSTATS_MIB_NUM = 0,
+	IPSTATS_MIB_INPKTS,			/* InReceives */
+	IPSTATS_MIB_INHDRERRORS,		/* InHdrErrors */
+	IPSTATS_MIB_INTOOBIGERRORS,		/* InTooBigErrors */
+	IPSTATS_MIB_INNOROUTES,			/* InNoRoutes */
+	IPSTATS_MIB_INADDRERRORS,		/* InAddrErrors */
+	IPSTATS_MIB_INUNKNOWNPROTOS,		/* InUnknownProtos */
+	IPSTATS_MIB_INTRUNCATEDPKTS,		/* InTruncatedPkts */
+	IPSTATS_MIB_INDISCARDS,			/* InDiscards */
+	IPSTATS_MIB_INDELIVERS,			/* InDelivers */
+	IPSTATS_MIB_OUTFORWDATAGRAMS,		/* OutForwDatagrams */
+	IPSTATS_MIB_OUTPKTS,			/* OutRequests */
+	IPSTATS_MIB_OUTDISCARDS,		/* OutDiscards */
+	IPSTATS_MIB_OUTNOROUTES,		/* OutNoRoutes */
+	IPSTATS_MIB_REASMTIMEOUT,		/* ReasmTimeout */
+	IPSTATS_MIB_REASMREQDS,			/* ReasmReqds */
+	IPSTATS_MIB_REASMOKS,			/* ReasmOKs */
+	IPSTATS_MIB_REASMFAILS,			/* ReasmFails */
+	IPSTATS_MIB_FRAGOKS,			/* FragOKs */
+	IPSTATS_MIB_FRAGFAILS,			/* FragFails */
+	IPSTATS_MIB_FRAGCREATES,		/* FragCreates */
+	IPSTATS_MIB_INMCASTPKTS,		/* InMcastPkts */
+	IPSTATS_MIB_OUTMCASTPKTS,		/* OutMcastPkts */
+	IPSTATS_MIB_INBCASTPKTS,		/* InBcastPkts */
+	IPSTATS_MIB_OUTBCASTPKTS,		/* OutBcastPkts */
+	IPSTATS_MIB_INOCTETS,			/* InOctets */
+	IPSTATS_MIB_OUTOCTETS,			/* OutOctets */
+	IPSTATS_MIB_INMCASTOCTETS,		/* InMcastOctets */
+	IPSTATS_MIB_OUTMCASTOCTETS,		/* OutMcastOctets */
+	IPSTATS_MIB_INBCASTOCTETS,		/* InBcastOctets */
+	IPSTATS_MIB_OUTBCASTOCTETS,		/* OutBcastOctets */
+	__IPSTATS_MIB_MAX
+};
+
+/* icmp mib definitions */
+/*
+ * RFC 1213:  MIB-II ICMP Group
+ * RFC 2011 (updates 1213):  SNMPv2 MIB for IP: ICMP group
+ */
+enum
+{
+	ICMP_MIB_NUM = 0,
+	ICMP_MIB_INMSGS,			/* InMsgs */
+	ICMP_MIB_INERRORS,			/* InErrors */
+	ICMP_MIB_INDESTUNREACHS,		/* InDestUnreachs */
+	ICMP_MIB_INTIMEEXCDS,			/* InTimeExcds */
+	ICMP_MIB_INPARMPROBS,			/* InParmProbs */
+	ICMP_MIB_INSRCQUENCHS,			/* InSrcQuenchs */
+	ICMP_MIB_INREDIRECTS,			/* InRedirects */
+	ICMP_MIB_INECHOS,			/* InEchos */
+	ICMP_MIB_INECHOREPS,			/* InEchoReps */
+	ICMP_MIB_INTIMESTAMPS,			/* InTimestamps */
+	ICMP_MIB_INTIMESTAMPREPS,		/* InTimestampReps */
+	ICMP_MIB_INADDRMASKS,			/* InAddrMasks */
+	ICMP_MIB_INADDRMASKREPS,		/* InAddrMaskReps */
+	ICMP_MIB_OUTMSGS,			/* OutMsgs */
+	ICMP_MIB_OUTERRORS,			/* OutErrors */
+	ICMP_MIB_OUTDESTUNREACHS,		/* OutDestUnreachs */
+	ICMP_MIB_OUTTIMEEXCDS,			/* OutTimeExcds */
+	ICMP_MIB_OUTPARMPROBS,			/* OutParmProbs */
+	ICMP_MIB_OUTSRCQUENCHS,			/* OutSrcQuenchs */
+	ICMP_MIB_OUTREDIRECTS,			/* OutRedirects */
+	ICMP_MIB_OUTECHOS,			/* OutEchos */
+	ICMP_MIB_OUTECHOREPS,			/* OutEchoReps */
+	ICMP_MIB_OUTTIMESTAMPS,			/* OutTimestamps */
+	ICMP_MIB_OUTTIMESTAMPREPS,		/* OutTimestampReps */
+	ICMP_MIB_OUTADDRMASKS,			/* OutAddrMasks */
+	ICMP_MIB_OUTADDRMASKREPS,		/* OutAddrMaskReps */
+	__ICMP_MIB_MAX
+};
+
+#define __ICMPMSG_MIB_MAX 512	/* Out+In for all 8-bit ICMP types */
+
+/* icmp6 mib definitions */
+/*
+ * RFC 2466:  ICMPv6-MIB
+ */
+enum
+{
+	ICMP6_MIB_NUM = 0,
+	ICMP6_MIB_INMSGS,			/* InMsgs */
+	ICMP6_MIB_INERRORS,			/* InErrors */
+	ICMP6_MIB_OUTMSGS,			/* OutMsgs */
+	__ICMP6_MIB_MAX
+};
+
+#define __ICMP6MSG_MIB_MAX 512 /* Out+In for all 8-bit ICMPv6 types */
+
+/* tcp mib definitions */
+/*
+ * RFC 1213:  MIB-II TCP group
+ * RFC 2012 (updates 1213):  SNMPv2-MIB-TCP
+ */
+enum
+{
+	TCP_MIB_NUM = 0,
+	TCP_MIB_RTOALGORITHM,			/* RtoAlgorithm */
+	TCP_MIB_RTOMIN,				/* RtoMin */
+	TCP_MIB_RTOMAX,				/* RtoMax */
+	TCP_MIB_MAXCONN,			/* MaxConn */
+	TCP_MIB_ACTIVEOPENS,			/* ActiveOpens */
+	TCP_MIB_PASSIVEOPENS,			/* PassiveOpens */
+	TCP_MIB_ATTEMPTFAILS,			/* AttemptFails */
+	TCP_MIB_ESTABRESETS,			/* EstabResets */
+	TCP_MIB_CURRESTAB,			/* CurrEstab */
+	TCP_MIB_INSEGS,				/* InSegs */
+	TCP_MIB_OUTSEGS,			/* OutSegs */
+	TCP_MIB_RETRANSSEGS,			/* RetransSegs */
+	TCP_MIB_INERRS,				/* InErrs */
+	TCP_MIB_OUTRSTS,			/* OutRsts */
+	__TCP_MIB_MAX
+};
+
+/* udp mib definitions */
+/*
+ * RFC 1213:  MIB-II UDP group
+ * RFC 2013 (updates 1213):  SNMPv2-MIB-UDP
+ */
+enum
+{
+	UDP_MIB_NUM = 0,
+	UDP_MIB_INDATAGRAMS,			/* InDatagrams */
+	UDP_MIB_NOPORTS,			/* NoPorts */
+	UDP_MIB_INERRORS,			/* InErrors */
+	UDP_MIB_OUTDATAGRAMS,			/* OutDatagrams */
+	UDP_MIB_RCVBUFERRORS,			/* RcvbufErrors */
+	UDP_MIB_SNDBUFERRORS,			/* SndbufErrors */
+	__UDP_MIB_MAX
+};
+
+/* linux mib definitions */
+enum
+{
+	LINUX_MIB_NUM = 0,
+	LINUX_MIB_SYNCOOKIESSENT,		/* SyncookiesSent */
+	LINUX_MIB_SYNCOOKIESRECV,		/* SyncookiesRecv */
+	LINUX_MIB_SYNCOOKIESFAILED,		/* SyncookiesFailed */
+	LINUX_MIB_EMBRYONICRSTS,		/* EmbryonicRsts */
+	LINUX_MIB_PRUNECALLED,			/* PruneCalled */
+	LINUX_MIB_RCVPRUNED,			/* RcvPruned */
+	LINUX_MIB_OFOPRUNED,			/* OfoPruned */
+	LINUX_MIB_OUTOFWINDOWICMPS,		/* OutOfWindowIcmps */
+	LINUX_MIB_LOCKDROPPEDICMPS,		/* LockDroppedIcmps */
+	LINUX_MIB_ARPFILTER,			/* ArpFilter */
+	LINUX_MIB_TIMEWAITED,			/* TimeWaited */
+	LINUX_MIB_TIMEWAITRECYCLED,		/* TimeWaitRecycled */
+	LINUX_MIB_TIMEWAITKILLED,		/* TimeWaitKilled */
+	LINUX_MIB_PAWSPASSIVEREJECTED,		/* PAWSPassiveRejected */
+	LINUX_MIB_PAWSACTIVEREJECTED,		/* PAWSActiveRejected */
+	LINUX_MIB_PAWSESTABREJECTED,		/* PAWSEstabRejected */
+	LINUX_MIB_DELAYEDACKS,			/* DelayedACKs */
+	LINUX_MIB_DELAYEDACKLOCKED,		/* DelayedACKLocked */
+	LINUX_MIB_DELAYEDACKLOST,		/* DelayedACKLost */
+	LINUX_MIB_LISTENOVERFLOWS,		/* ListenOverflows */
+	LINUX_MIB_LISTENDROPS,			/* ListenDrops */
+	LINUX_MIB_TCPPREQUEUED,			/* TCPPrequeued */
+	LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG,	/* TCPDirectCopyFromBacklog */
+	LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE,	/* TCPDirectCopyFromPrequeue */
+	LINUX_MIB_TCPPREQUEUEDROPPED,		/* TCPPrequeueDropped */
+	LINUX_MIB_TCPHPHITS,			/* TCPHPHits */
+	LINUX_MIB_TCPHPHITSTOUSER,		/* TCPHPHitsToUser */
+	LINUX_MIB_TCPPUREACKS,			/* TCPPureAcks */
+	LINUX_MIB_TCPHPACKS,			/* TCPHPAcks */
+	LINUX_MIB_TCPRENORECOVERY,		/* TCPRenoRecovery */
+	LINUX_MIB_TCPSACKRECOVERY,		/* TCPSackRecovery */
+	LINUX_MIB_TCPSACKRENEGING,		/* TCPSACKReneging */
+	LINUX_MIB_TCPFACKREORDER,		/* TCPFACKReorder */
+	LINUX_MIB_TCPSACKREORDER,		/* TCPSACKReorder */
+	LINUX_MIB_TCPRENOREORDER,		/* TCPRenoReorder */
+	LINUX_MIB_TCPTSREORDER,			/* TCPTSReorder */
+	LINUX_MIB_TCPFULLUNDO,			/* TCPFullUndo */
+	LINUX_MIB_TCPPARTIALUNDO,		/* TCPPartialUndo */
+	LINUX_MIB_TCPDSACKUNDO,			/* TCPDSACKUndo */
+	LINUX_MIB_TCPLOSSUNDO,			/* TCPLossUndo */
+	LINUX_MIB_TCPLOSS,			/* TCPLoss */
+	LINUX_MIB_TCPLOSTRETRANSMIT,		/* TCPLostRetransmit */
+	LINUX_MIB_TCPRENOFAILURES,		/* TCPRenoFailures */
+	LINUX_MIB_TCPSACKFAILURES,		/* TCPSackFailures */
+	LINUX_MIB_TCPLOSSFAILURES,		/* TCPLossFailures */
+	LINUX_MIB_TCPFASTRETRANS,		/* TCPFastRetrans */
+	LINUX_MIB_TCPFORWARDRETRANS,		/* TCPForwardRetrans */
+	LINUX_MIB_TCPSLOWSTARTRETRANS,		/* TCPSlowStartRetrans */
+	LINUX_MIB_TCPTIMEOUTS,			/* TCPTimeouts */
+	LINUX_MIB_TCPRENORECOVERYFAIL,		/* TCPRenoRecoveryFail */
+	LINUX_MIB_TCPSACKRECOVERYFAIL,		/* TCPSackRecoveryFail */
+	LINUX_MIB_TCPSCHEDULERFAILED,		/* TCPSchedulerFailed */
+	LINUX_MIB_TCPRCVCOLLAPSED,		/* TCPRcvCollapsed */
+	LINUX_MIB_TCPDSACKOLDSENT,		/* TCPDSACKOldSent */
+	LINUX_MIB_TCPDSACKOFOSENT,		/* TCPDSACKOfoSent */
+	LINUX_MIB_TCPDSACKRECV,			/* TCPDSACKRecv */
+	LINUX_MIB_TCPDSACKOFORECV,		/* TCPDSACKOfoRecv */
+	LINUX_MIB_TCPABORTONSYN,		/* TCPAbortOnSyn */
+	LINUX_MIB_TCPABORTONDATA,		/* TCPAbortOnData */
+	LINUX_MIB_TCPABORTONCLOSE,		/* TCPAbortOnClose */
+	LINUX_MIB_TCPABORTONMEMORY,		/* TCPAbortOnMemory */
+	LINUX_MIB_TCPABORTONTIMEOUT,		/* TCPAbortOnTimeout */
+	LINUX_MIB_TCPABORTONLINGER,		/* TCPAbortOnLinger */
+	LINUX_MIB_TCPABORTFAILED,		/* TCPAbortFailed */
+	LINUX_MIB_TCPMEMORYPRESSURES,		/* TCPMemoryPressures */
+	LINUX_MIB_TCPSACKDISCARD,		/* TCPSACKDiscard */
+	LINUX_MIB_TCPDSACKIGNOREDOLD,		/* TCPSACKIgnoredOld */
+	LINUX_MIB_TCPDSACKIGNOREDNOUNDO,	/* TCPSACKIgnoredNoUndo */
+	LINUX_MIB_TCPSPURIOUSRTOS,		/* TCPSpuriousRTOs */
+	LINUX_MIB_TCPMD5NOTFOUND,		/* TCPMD5NotFound */
+	LINUX_MIB_TCPMD5UNEXPECTED,		/* TCPMD5Unexpected */
+	LINUX_MIB_SACKSHIFTED,
+	LINUX_MIB_SACKMERGED,
+	LINUX_MIB_SACKSHIFTFALLBACK,
+	__LINUX_MIB_MAX
+};
+
+/* linux Xfrm mib definitions */
+enum
+{
+	LINUX_MIB_XFRMNUM = 0,
+	LINUX_MIB_XFRMINERROR,			/* XfrmInError */
+	LINUX_MIB_XFRMINBUFFERERROR,		/* XfrmInBufferError */
+	LINUX_MIB_XFRMINHDRERROR,		/* XfrmInHdrError */
+	LINUX_MIB_XFRMINNOSTATES,		/* XfrmInNoStates */
+	LINUX_MIB_XFRMINSTATEPROTOERROR,	/* XfrmInStateProtoError */
+	LINUX_MIB_XFRMINSTATEMODEERROR,		/* XfrmInStateModeError */
+	LINUX_MIB_XFRMINSTATESEQERROR,		/* XfrmInStateSeqError */
+	LINUX_MIB_XFRMINSTATEEXPIRED,		/* XfrmInStateExpired */
+	LINUX_MIB_XFRMINSTATEMISMATCH,		/* XfrmInStateMismatch */
+	LINUX_MIB_XFRMINSTATEINVALID,		/* XfrmInStateInvalid */
+	LINUX_MIB_XFRMINTMPLMISMATCH,		/* XfrmInTmplMismatch */
+	LINUX_MIB_XFRMINNOPOLS,			/* XfrmInNoPols */
+	LINUX_MIB_XFRMINPOLBLOCK,		/* XfrmInPolBlock */
+	LINUX_MIB_XFRMINPOLERROR,		/* XfrmInPolError */
+	LINUX_MIB_XFRMOUTERROR,			/* XfrmOutError */
+	LINUX_MIB_XFRMOUTBUNDLEGENERROR,	/* XfrmOutBundleGenError */
+	LINUX_MIB_XFRMOUTBUNDLECHECKERROR,	/* XfrmOutBundleCheckError */
+	LINUX_MIB_XFRMOUTNOSTATES,		/* XfrmOutNoStates */
+	LINUX_MIB_XFRMOUTSTATEPROTOERROR,	/* XfrmOutStateProtoError */
+	LINUX_MIB_XFRMOUTSTATEMODEERROR,	/* XfrmOutStateModeError */
+	LINUX_MIB_XFRMOUTSTATESEQERROR,		/* XfrmOutStateSeqError */
+	LINUX_MIB_XFRMOUTSTATEEXPIRED,		/* XfrmOutStateExpired */
+	LINUX_MIB_XFRMOUTPOLBLOCK,		/* XfrmOutPolBlock */
+	LINUX_MIB_XFRMOUTPOLDEAD,		/* XfrmOutPolDead */
+	LINUX_MIB_XFRMOUTPOLERROR,		/* XfrmOutPolError */
+	__LINUX_MIB_XFRMMAX
+};
+
+#endif	/* _LINUX_SNMP_H */
diff -uNr linux-2.6.32/usr/include/linux/socket.h clean_modified/linux-2.6.32/usr/include/linux/socket.h
--- linux-2.6.32/usr/include/linux/socket.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/socket.h	2019-04-14 13:24:03.129789901 -0500
@@ -0,0 +1,19 @@
+#ifndef _LINUX_SOCKET_H
+#define _LINUX_SOCKET_H
+
+/*
+ * Desired design of maximum size and alignment (see RFC2553)
+ */
+#define _K_SS_MAXSIZE	128	/* Implementation specific max size */
+#define _K_SS_ALIGNSIZE	(__alignof__ (struct sockaddr *))
+				/* Implementation specific desired alignment */
+
+struct __kernel_sockaddr_storage {
+	unsigned short	ss_family;		/* address family */
+	/* Following field(s) are implementation specific */
+	char		__data[_K_SS_MAXSIZE - sizeof(unsigned short)];
+				/* space to achieve desired size, */
+				/* _SS_MAXSIZE value minus size of ss_family */
+} __attribute__ ((aligned(_K_SS_ALIGNSIZE)));	/* force desired alignment */
+
+#endif /* _LINUX_SOCKET_H */
diff -uNr linux-2.6.32/usr/include/linux/sockios.h clean_modified/linux-2.6.32/usr/include/linux/sockios.h
--- linux-2.6.32/usr/include/linux/sockios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sockios.h	2019-04-14 13:24:03.136806628 -0500
@@ -0,0 +1,146 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions of the socket-level I/O control calls.
+ *
+ * Version:	@(#)sockios.h	1.0.2	03/09/93
+ *
+ * Authors:	Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_SOCKIOS_H
+#define _LINUX_SOCKIOS_H
+
+#include <asm/sockios.h>
+
+/* Linux-specific socket ioctls */
+#define SIOCINQ		FIONREAD
+#define SIOCOUTQ	TIOCOUTQ
+
+/* Routing table calls. */
+#define SIOCADDRT	0x890B		/* add routing table entry	*/
+#define SIOCDELRT	0x890C		/* delete routing table entry	*/
+#define SIOCRTMSG	0x890D		/* call to routing system	*/
+
+/* Socket configuration controls. */
+#define SIOCGIFNAME	0x8910		/* get iface name		*/
+#define SIOCSIFLINK	0x8911		/* set iface channel		*/
+#define SIOCGIFCONF	0x8912		/* get iface list		*/
+#define SIOCGIFFLAGS	0x8913		/* get flags			*/
+#define SIOCSIFFLAGS	0x8914		/* set flags			*/
+#define SIOCGIFADDR	0x8915		/* get PA address		*/
+#define SIOCSIFADDR	0x8916		/* set PA address		*/
+#define SIOCGIFDSTADDR	0x8917		/* get remote PA address	*/
+#define SIOCSIFDSTADDR	0x8918		/* set remote PA address	*/
+#define SIOCGIFBRDADDR	0x8919		/* get broadcast PA address	*/
+#define SIOCSIFBRDADDR	0x891a		/* set broadcast PA address	*/
+#define SIOCGIFNETMASK	0x891b		/* get network PA mask		*/
+#define SIOCSIFNETMASK	0x891c		/* set network PA mask		*/
+#define SIOCGIFMETRIC	0x891d		/* get metric			*/
+#define SIOCSIFMETRIC	0x891e		/* set metric			*/
+#define SIOCGIFMEM	0x891f		/* get memory address (BSD)	*/
+#define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
+#define SIOCGIFMTU	0x8921		/* get MTU size			*/
+#define SIOCSIFMTU	0x8922		/* set MTU size			*/
+#define SIOCSIFNAME	0x8923		/* set interface name */
+#define	SIOCSIFHWADDR	0x8924		/* set hardware address 	*/
+#define SIOCGIFENCAP	0x8925		/* get/set encapsulations       */
+#define SIOCSIFENCAP	0x8926		
+#define SIOCGIFHWADDR	0x8927		/* Get hardware address		*/
+#define SIOCGIFSLAVE	0x8929		/* Driver slaving support	*/
+#define SIOCSIFSLAVE	0x8930
+#define SIOCADDMULTI	0x8931		/* Multicast address lists	*/
+#define SIOCDELMULTI	0x8932
+#define SIOCGIFINDEX	0x8933		/* name -> if_index mapping	*/
+#define SIOGIFINDEX	SIOCGIFINDEX	/* misprint compatibility :-)	*/
+#define SIOCSIFPFLAGS	0x8934		/* set/get extended flags set	*/
+#define SIOCGIFPFLAGS	0x8935
+#define SIOCDIFADDR	0x8936		/* delete PA address		*/
+#define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
+#define SIOCGIFCOUNT	0x8938		/* get number of devices */
+
+#define SIOCGIFBR	0x8940		/* Bridging support		*/
+#define SIOCSIFBR	0x8941		/* Set bridging options 	*/
+
+#define SIOCGIFTXQLEN	0x8942		/* Get the tx queue length	*/
+#define SIOCSIFTXQLEN	0x8943		/* Set the tx queue length 	*/
+
+/* SIOCGIFDIVERT was:	0x8944		Frame diversion support */
+/* SIOCSIFDIVERT was:	0x8945		Set frame diversion options */
+
+#define SIOCETHTOOL	0x8946		/* Ethtool interface		*/
+
+#define SIOCGMIIPHY	0x8947		/* Get address of MII PHY in use. */
+#define SIOCGMIIREG	0x8948		/* Read MII PHY register.	*/
+#define SIOCSMIIREG	0x8949		/* Write MII PHY register.	*/
+
+#define SIOCWANDEV	0x894A		/* get/set netdev parameters	*/
+
+/* ARP cache control calls. */
+		    /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
+#define SIOCDARP	0x8953		/* delete ARP table entry	*/
+#define SIOCGARP	0x8954		/* get ARP table entry		*/
+#define SIOCSARP	0x8955		/* set ARP table entry		*/
+
+/* RARP cache control calls. */
+#define SIOCDRARP	0x8960		/* delete RARP table entry	*/
+#define SIOCGRARP	0x8961		/* get RARP table entry		*/
+#define SIOCSRARP	0x8962		/* set RARP table entry		*/
+
+/* Driver configuration calls */
+
+#define SIOCGIFMAP	0x8970		/* Get device parameters	*/
+#define SIOCSIFMAP	0x8971		/* Set device parameters	*/
+
+/* DLCI configuration calls */
+
+#define SIOCADDDLCI	0x8980		/* Create new DLCI device	*/
+#define SIOCDELDLCI	0x8981		/* Delete DLCI device		*/
+
+#define SIOCGIFVLAN	0x8982		/* 802.1Q VLAN support		*/
+#define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options 	*/
+
+/* bonding calls */
+
+#define SIOCBONDENSLAVE	0x8990		/* enslave a device to the bond */
+#define SIOCBONDRELEASE 0x8991		/* release a slave from the bond*/
+#define SIOCBONDSETHWADDR      0x8992	/* set the hw addr of the bond  */
+#define SIOCBONDSLAVEINFOQUERY 0x8993   /* rtn info about slave state   */
+#define SIOCBONDINFOQUERY      0x8994	/* rtn info about bond state    */
+#define SIOCBONDCHANGEACTIVE   0x8995   /* update to a new active slave */
+			
+/* bridge calls */
+#define SIOCBRADDBR     0x89a0		/* create new bridge device     */
+#define SIOCBRDELBR     0x89a1		/* remove bridge device         */
+#define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
+#define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
+
+/* hardware time stamping: parameters in linux/net_tstamp.h */
+#define SIOCSHWTSTAMP   0x89b0
+
+/* Device private ioctl calls */
+
+/*
+ *	These 16 ioctls are available to devices via the do_ioctl() device
+ *	vector. Each device should include this file and redefine these names
+ *	as their own. Because these are device dependent it is a good idea
+ *	_NOT_ to issue them to random objects and hope.
+ *
+ *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM
+ */
+ 
+#define SIOCDEVPRIVATE	0x89F0	/* to 89FF */
+
+/*
+ *	These 16 ioctl calls are protocol private
+ */
+ 
+#define SIOCPROTOPRIVATE 0x89E0 /* to 89EF */
+#endif	/* _LINUX_SOCKIOS_H */
diff -uNr linux-2.6.32/usr/include/linux/som.h clean_modified/linux-2.6.32/usr/include/linux/som.h
--- linux-2.6.32/usr/include/linux/som.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/som.h	2019-04-14 13:24:03.138858340 -0500
@@ -0,0 +1,154 @@
+#ifndef _LINUX_SOM_H
+#define _LINUX_SOM_H
+
+/* File format definition for SOM executables / shared libraries */
+
+/* we need struct timespec */
+#include <linux/time.h>
+
+#define SOM_PAGESIZE 4096
+
+/* this is the SOM header */
+struct som_hdr {
+	short		system_id;		/* magic number - system */
+	short		a_magic;		/* magic number - file type */
+	unsigned int	version_id;		/* versiod ID: YYMMDDHH */
+	struct timespec	file_time;		/* system clock */
+	unsigned int	entry_space;		/* space for entry point */
+	unsigned int	entry_subspace;		/* subspace for entry point */
+	unsigned int	entry_offset;		/* offset of entry point */
+	unsigned int	aux_header_location;	/* auxiliary header location */
+	unsigned int	aux_header_size;	/* auxiliary header size */
+	unsigned int	som_length;		/* length of entire SOM */
+	unsigned int	presumed_dp;		/* compiler's DP value */
+	unsigned int	space_location;		/* space dictionary location */
+	unsigned int	space_total;		/* number of space entries */
+	unsigned int	subspace_location;	/* subspace entries location */
+	unsigned int	subspace_total;		/* number of subspace entries */
+	unsigned int	loader_fixup_location;	/* MPE/iX loader fixup */
+	unsigned int	loader_fixup_total;	/* number of fixup records */
+	unsigned int	space_strings_location;	/* (sub)space names */
+	unsigned int	space_strings_size;	/* size of strings area */
+	unsigned int	init_array_location;	/* reserved */
+	unsigned int	init_array_total;	/* reserved */
+	unsigned int	compiler_location;	/* module dictionary */
+	unsigned int	compiler_total;		/* number of modules */
+	unsigned int	symbol_location;	/* symbol dictionary */
+	unsigned int	symbol_total;		/* number of symbols */
+	unsigned int	fixup_request_location;	/* fixup requests */
+	unsigned int	fixup_request_total;	/* number of fixup requests */
+	unsigned int	symbol_strings_location;/* module & symbol names area */
+	unsigned int	symbol_strings_size;	/* size of strings area */
+	unsigned int	unloadable_sp_location;	/* unloadable spaces location */
+	unsigned int	unloadable_sp_size;	/* size of data */
+	unsigned int	checksum;
+};
+
+/* values for system_id */
+
+#define SOM_SID_PARISC_1_0	0x020b
+#define SOM_SID_PARISC_1_1	0x0210
+#define SOM_SID_PARISC_2_0	0x0214
+
+/* values for a_magic */
+
+#define SOM_LIB_EXEC		0x0104
+#define SOM_RELOCATABLE		0x0106
+#define SOM_EXEC_NONSHARE	0x0107
+#define SOM_EXEC_SHARE		0x0108
+#define SOM_EXEC_DEMAND		0x010B
+#define SOM_LIB_DYN		0x010D
+#define SOM_LIB_SHARE		0x010E
+#define SOM_LIB_RELOC		0x0619
+
+/* values for version_id.  Decimal not hex, yes.  Grr. */
+
+#define SOM_ID_OLD		85082112
+#define SOM_ID_NEW		87102412
+
+struct aux_id {
+	unsigned int	mandatory :1;	/* the linker must understand this */
+	unsigned int	copy	  :1;	/* Must be copied by the linker */
+	unsigned int	append	  :1;	/* Must be merged by the linker */
+	unsigned int	ignore	  :1;	/* Discard section if unknown */
+	unsigned int	reserved  :12;
+	unsigned int	type	  :16;	/* Header type */
+	unsigned int	length;		/* length of _following_ data */
+};
+
+/* The Exec Auxiliary Header.  Called The HP-UX Header within HP apparently. */
+struct som_exec_auxhdr {
+	struct aux_id	som_auxhdr;
+	int		exec_tsize;	/* Text size in bytes */
+	int		exec_tmem;	/* Address to load text at */
+	int		exec_tfile;	/* Location of text in file */
+	int		exec_dsize;	/* Data size in bytes */
+	int		exec_dmem;	/* Address to load data at */
+	int		exec_dfile;	/* Location of data in file */
+	int		exec_bsize;	/* Uninitialised data (bss) */
+	int		exec_entry;	/* Address to start executing */
+	int		exec_flags;	/* loader flags */
+	int		exec_bfill;	/* initialisation value for bss */
+};
+
+/* Oh, the things people do to avoid casts.  Shame it'll break with gcc's
+ * new aliasing rules really.
+ */
+union name_pt {
+	char *		n_name;
+	unsigned int	n_strx;
+};
+
+/* The Space Dictionary */
+struct space_dictionary_record {
+	union name_pt	name;			/* index to subspace name */
+	unsigned int	is_loadable	:1;	/* loadable */
+	unsigned int	is_defined	:1;	/* defined within file */
+	unsigned int	is_private	:1;	/* not sharable */
+	unsigned int	has_intermediate_code :1; /* contains intermediate code */
+	unsigned int	is_tspecific	:1;	/* thread specific */
+	unsigned int	reserved	:11;	/* for future expansion */
+	unsigned int	sort_key	:8;	/* for linker */
+	unsigned int	reserved2	:8;	/* for future expansion */
+
+	int		space_number;		/* index */
+	int		subspace_index;		/* index into subspace dict */
+	unsigned int	subspace_quantity;	/* number of subspaces */
+	int		loader_fix_index;	/* for loader */
+	unsigned int	loader_fix_quantity;	/* for loader */
+	int		init_pointer_index;	/* data pointer array index */
+	unsigned int	init_pointer_quantity;	/* number of data pointers */
+};
+
+/* The Subspace Dictionary */
+struct subspace_dictionary_record {
+	int		space_index;
+	unsigned int	access_control_bits :7;
+	unsigned int	memory_resident	:1;
+	unsigned int	dup_common	:1;
+	unsigned int	is_common	:1;
+	unsigned int	quadrant	:2;
+	unsigned int	initially_frozen :1;
+	unsigned int	is_first	:1;
+	unsigned int	code_only	:1;
+	unsigned int	sort_key	:8;
+	unsigned int	replicate_init	:1;
+	unsigned int	continuation	:1;
+	unsigned int	is_tspecific	:1;
+	unsigned int	is_comdat	:1;
+	unsigned int	reserved	:4;
+
+	int		file_loc_init_value;
+	unsigned int	initialization_length;
+	unsigned int	subspace_start;
+	unsigned int	subspace_length;
+
+	unsigned int	reserved2	:5;
+	unsigned int	alignment	:27;
+
+	union name_pt	name;
+	int		fixup_request_index;
+	unsigned int	fixup_request_quantity;
+};
+
+#endif /* _LINUX_SOM_H */
diff -uNr linux-2.6.32/usr/include/linux/sonet.h clean_modified/linux-2.6.32/usr/include/linux/sonet.h
--- linux-2.6.32/usr/include/linux/sonet.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sonet.h	2019-04-14 13:24:03.138858340 -0500
@@ -0,0 +1,60 @@
+/* sonet.h - SONET/SHD physical layer control */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_SONET_H
+#define LINUX_SONET_H
+
+#define __SONET_ITEMS \
+    __HANDLE_ITEM(section_bip); 	/* section parity errors (B1) */ \
+    __HANDLE_ITEM(line_bip);		/* line parity errors (B2) */ \
+    __HANDLE_ITEM(path_bip);		/* path parity errors (B3) */ \
+    __HANDLE_ITEM(line_febe);		/* line parity errors at remote */ \
+    __HANDLE_ITEM(path_febe);		/* path parity errors at remote */ \
+    __HANDLE_ITEM(corr_hcs);		/* correctable header errors */ \
+    __HANDLE_ITEM(uncorr_hcs);		/* uncorrectable header errors */ \
+    __HANDLE_ITEM(tx_cells);		/* cells sent */ \
+    __HANDLE_ITEM(rx_cells);		/* cells received */
+
+struct sonet_stats {
+#define __HANDLE_ITEM(i) int i
+	__SONET_ITEMS
+#undef __HANDLE_ITEM
+} __attribute__ ((packed));
+
+
+#define SONET_GETSTAT	_IOR('a',ATMIOC_PHYTYP,struct sonet_stats)
+					/* get statistics */
+#define SONET_GETSTATZ	_IOR('a',ATMIOC_PHYTYP+1,struct sonet_stats)
+					/* ... and zero counters */
+#define SONET_SETDIAG	_IOWR('a',ATMIOC_PHYTYP+2,int)
+					/* set error insertion */
+#define SONET_CLRDIAG	_IOWR('a',ATMIOC_PHYTYP+3,int)
+					/* clear error insertion */
+#define SONET_GETDIAG	_IOR('a',ATMIOC_PHYTYP+4,int)
+					/* query error insertion */
+#define SONET_SETFRAMING _IOW('a',ATMIOC_PHYTYP+5,int)
+					/* set framing mode (SONET/SDH) */
+#define SONET_GETFRAMING _IOR('a',ATMIOC_PHYTYP+6,int)
+					/* get framing mode */
+#define SONET_GETFRSENSE _IOR('a',ATMIOC_PHYTYP+7, \
+  unsigned char[SONET_FRSENSE_SIZE])	/* get framing sense information */
+
+#define SONET_INS_SBIP	  1		/* section BIP */
+#define SONET_INS_LBIP	  2		/* line BIP */
+#define SONET_INS_PBIP	  4		/* path BIP */
+#define SONET_INS_FRAME	  8		/* out of frame */
+#define SONET_INS_LOS	 16		/* set line to zero */
+#define SONET_INS_LAIS	 32		/* line alarm indication signal */
+#define SONET_INS_PAIS	 64		/* path alarm indication signal */
+#define SONET_INS_HCS	128		/* insert HCS error */
+
+#define SONET_FRAME_SONET 0		/* SONET STS-3 framing */
+#define SONET_FRAME_SDH   1		/* SDH STM-1 framing */
+
+#define SONET_FRSENSE_SIZE 6		/* C1[3],H1[3] (0xff for unknown) */
+
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/sonypi.h clean_modified/linux-2.6.32/usr/include/linux/sonypi.h
--- linux-2.6.32/usr/include/linux/sonypi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sonypi.h	2019-04-14 13:24:03.138858340 -0500
@@ -0,0 +1,143 @@
+/*
+ * Sony Programmable I/O Control Device driver for VAIO
+ *
+ * Copyright (C) 2001-2005 Stelian Pop <stelian@popies.net>
+ *
+ * Copyright (C) 2005 Narayanan R S <nars@kadamba.org>
+
+ * Copyright (C) 2001-2002 Alcôve <www.alcove.com>
+ *
+ * Copyright (C) 2001 Michael Ashley <m.ashley@unsw.edu.au>
+ *
+ * Copyright (C) 2001 Junichi Morita <jun1m@mars.dti.ne.jp>
+ *
+ * Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
+ *
+ * Copyright (C) 2000 Andrew Tridgell <tridge@valinux.com>
+ *
+ * Earlier work by Werner Almesberger, Paul `Rusty' Russell and Paul Mackerras.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _SONYPI_H_
+#define _SONYPI_H_
+
+#include <linux/types.h>
+
+/* events the user application reading /dev/sonypi can use */
+
+#define SONYPI_EVENT_JOGDIAL_DOWN		 1
+#define SONYPI_EVENT_JOGDIAL_UP			 2
+#define SONYPI_EVENT_JOGDIAL_DOWN_PRESSED	 3
+#define SONYPI_EVENT_JOGDIAL_UP_PRESSED		 4
+#define SONYPI_EVENT_JOGDIAL_PRESSED		 5
+#define SONYPI_EVENT_JOGDIAL_RELEASED		 6	/* obsolete */
+#define SONYPI_EVENT_CAPTURE_PRESSED		 7
+#define SONYPI_EVENT_CAPTURE_RELEASED		 8	/* obsolete */
+#define SONYPI_EVENT_CAPTURE_PARTIALPRESSED	 9
+#define SONYPI_EVENT_CAPTURE_PARTIALRELEASED	10
+#define SONYPI_EVENT_FNKEY_ESC			11
+#define SONYPI_EVENT_FNKEY_F1			12
+#define SONYPI_EVENT_FNKEY_F2			13
+#define SONYPI_EVENT_FNKEY_F3			14
+#define SONYPI_EVENT_FNKEY_F4			15
+#define SONYPI_EVENT_FNKEY_F5			16
+#define SONYPI_EVENT_FNKEY_F6			17
+#define SONYPI_EVENT_FNKEY_F7			18
+#define SONYPI_EVENT_FNKEY_F8			19
+#define SONYPI_EVENT_FNKEY_F9			20
+#define SONYPI_EVENT_FNKEY_F10			21
+#define SONYPI_EVENT_FNKEY_F11			22
+#define SONYPI_EVENT_FNKEY_F12			23
+#define SONYPI_EVENT_FNKEY_1			24
+#define SONYPI_EVENT_FNKEY_2			25
+#define SONYPI_EVENT_FNKEY_D			26
+#define SONYPI_EVENT_FNKEY_E			27
+#define SONYPI_EVENT_FNKEY_F			28
+#define SONYPI_EVENT_FNKEY_S			29
+#define SONYPI_EVENT_FNKEY_B			30
+#define SONYPI_EVENT_BLUETOOTH_PRESSED		31
+#define SONYPI_EVENT_PKEY_P1			32
+#define SONYPI_EVENT_PKEY_P2			33
+#define SONYPI_EVENT_PKEY_P3			34
+#define SONYPI_EVENT_BACK_PRESSED		35
+#define SONYPI_EVENT_LID_CLOSED			36
+#define SONYPI_EVENT_LID_OPENED			37
+#define SONYPI_EVENT_BLUETOOTH_ON		38
+#define SONYPI_EVENT_BLUETOOTH_OFF		39
+#define SONYPI_EVENT_HELP_PRESSED		40
+#define SONYPI_EVENT_FNKEY_ONLY			41
+#define SONYPI_EVENT_JOGDIAL_FAST_DOWN		42
+#define SONYPI_EVENT_JOGDIAL_FAST_UP		43
+#define SONYPI_EVENT_JOGDIAL_FAST_DOWN_PRESSED	44
+#define SONYPI_EVENT_JOGDIAL_FAST_UP_PRESSED	45
+#define SONYPI_EVENT_JOGDIAL_VFAST_DOWN		46
+#define SONYPI_EVENT_JOGDIAL_VFAST_UP		47
+#define SONYPI_EVENT_JOGDIAL_VFAST_DOWN_PRESSED	48
+#define SONYPI_EVENT_JOGDIAL_VFAST_UP_PRESSED	49
+#define SONYPI_EVENT_ZOOM_PRESSED		50
+#define SONYPI_EVENT_THUMBPHRASE_PRESSED	51
+#define SONYPI_EVENT_MEYE_FACE			52
+#define SONYPI_EVENT_MEYE_OPPOSITE		53
+#define SONYPI_EVENT_MEMORYSTICK_INSERT		54
+#define SONYPI_EVENT_MEMORYSTICK_EJECT		55
+#define SONYPI_EVENT_ANYBUTTON_RELEASED		56
+#define SONYPI_EVENT_BATTERY_INSERT		57
+#define SONYPI_EVENT_BATTERY_REMOVE		58
+#define SONYPI_EVENT_FNKEY_RELEASED		59
+#define SONYPI_EVENT_WIRELESS_ON		60
+#define SONYPI_EVENT_WIRELESS_OFF		61
+#define SONYPI_EVENT_ZOOM_IN_PRESSED		62
+#define SONYPI_EVENT_ZOOM_OUT_PRESSED		63
+#define SONYPI_EVENT_CD_EJECT_PRESSED		64
+#define SONYPI_EVENT_MODEKEY_PRESSED		65
+#define SONYPI_EVENT_PKEY_P4			66
+#define SONYPI_EVENT_PKEY_P5			67
+#define SONYPI_EVENT_SETTINGKEY_PRESSED		68
+#define SONYPI_EVENT_VOLUME_INC_PRESSED		69
+#define SONYPI_EVENT_VOLUME_DEC_PRESSED		70
+#define SONYPI_EVENT_BRIGHTNESS_PRESSED		71
+
+/* get/set brightness */
+#define SONYPI_IOCGBRT		_IOR('v', 0, __u8)
+#define SONYPI_IOCSBRT		_IOW('v', 0, __u8)
+
+/* get battery full capacity/remaining capacity */
+#define SONYPI_IOCGBAT1CAP	_IOR('v', 2, __u16)
+#define SONYPI_IOCGBAT1REM	_IOR('v', 3, __u16)
+#define SONYPI_IOCGBAT2CAP	_IOR('v', 4, __u16)
+#define SONYPI_IOCGBAT2REM	_IOR('v', 5, __u16)
+
+/* get battery flags: battery1/battery2/ac adapter present */
+#define SONYPI_BFLAGS_B1	0x01
+#define SONYPI_BFLAGS_B2	0x02
+#define SONYPI_BFLAGS_AC	0x04
+#define SONYPI_IOCGBATFLAGS	_IOR('v', 7, __u8)
+
+/* get/set bluetooth subsystem state on/off */
+#define SONYPI_IOCGBLUE		_IOR('v', 8, __u8)
+#define SONYPI_IOCSBLUE		_IOW('v', 9, __u8)
+
+/* get/set fan state on/off */
+#define SONYPI_IOCGFAN		_IOR('v', 10, __u8)
+#define SONYPI_IOCSFAN		_IOW('v', 11, __u8)
+
+/* get temperature (C) */
+#define SONYPI_IOCGTEMP		_IOR('v', 12, __u8)
+
+
+#endif				/* _SONYPI_H_ */
diff -uNr linux-2.6.32/usr/include/linux/soundcard.h clean_modified/linux-2.6.32/usr/include/linux/soundcard.h
--- linux-2.6.32/usr/include/linux/soundcard.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/soundcard.h	2019-04-14 13:24:03.141498667 -0500
@@ -0,0 +1,1276 @@
+#ifndef SOUNDCARD_H
+#define SOUNDCARD_H
+/*
+ * Copyright by Hannu Savolainen 1993-1997
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer. 2.
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+/*
+ * OSS interface version. With versions earlier than 3.6 this value is
+ * an integer with value less than 361. In versions 3.6 and later
+ * it's a six digit hexadecimal value. For example value
+ * of 0x030600 represents OSS version 3.6.0.
+ * Use ioctl(fd, OSS_GETVERSION, &int) to get the version number of
+ * the currently active driver.
+ */
+#define SOUND_VERSION	0x030802
+#define OPEN_SOUND_SYSTEM
+
+/* In Linux we need to be prepared for cross compiling */
+#include <linux/ioctl.h>
+
+/* Endian macros. */
+#  include <endian.h>
+
+/*
+ *	Supported card ID numbers (Should be somewhere else?)
+ */
+
+#define SNDCARD_ADLIB		1
+#define SNDCARD_SB		2
+#define SNDCARD_PAS		3
+#define SNDCARD_GUS		4
+#define SNDCARD_MPU401		5
+#define SNDCARD_SB16		6
+#define SNDCARD_SB16MIDI	7
+#define SNDCARD_UART6850	8
+#define SNDCARD_GUS16		9
+#define SNDCARD_MSS		10
+#define SNDCARD_PSS     	11
+#define SNDCARD_SSCAPE		12
+#define SNDCARD_PSS_MPU     	13
+#define SNDCARD_PSS_MSS     	14
+#define SNDCARD_SSCAPE_MSS	15
+#define SNDCARD_TRXPRO		16
+#define SNDCARD_TRXPRO_SB	17
+#define SNDCARD_TRXPRO_MPU	18
+#define SNDCARD_MAD16		19
+#define SNDCARD_MAD16_MPU	20
+#define SNDCARD_CS4232		21
+#define SNDCARD_CS4232_MPU	22
+#define SNDCARD_MAUI		23
+#define SNDCARD_PSEUDO_MSS	24
+#define SNDCARD_GUSPNP		25
+#define SNDCARD_UART401		26
+/* Sound card numbers 27 to N are reserved. Don't add more numbers here. */
+
+/***********************************
+ * IOCTL Commands for /dev/sequencer
+ */
+
+#ifndef _SIOWR
+#if defined(_IOWR) && (defined(_AIX) || (!defined(sun) && !defined(sparc) && !defined(__sparc__) && !defined(__INCioctlh) && !defined(__Lynx__)))
+/* Use already defined ioctl defines if they exist (except with Sun or Sparc) */
+#define	SIOCPARM_MASK	IOCPARM_MASK
+#define	SIOC_VOID	IOC_VOID
+#define	SIOC_OUT	IOC_OUT
+#define	SIOC_IN		IOC_IN
+#define	SIOC_INOUT	IOC_INOUT
+#define _SIOC_SIZE	_IOC_SIZE
+#define _SIOC_DIR	_IOC_DIR
+#define _SIOC_NONE	_IOC_NONE
+#define _SIOC_READ	_IOC_READ
+#define _SIOC_WRITE	_IOC_WRITE
+#define	_SIO		_IO
+#define	_SIOR		_IOR
+#define	_SIOW		_IOW
+#define	_SIOWR		_IOWR
+#else
+
+/* Ioctl's have the command encoded in the lower word,
+ * and the size of any in or out parameters in the upper
+ * word.  The high 2 bits of the upper word are used
+ * to encode the in/out status of the parameter; for now
+ * we restrict parameters to at most 8191 bytes.
+ */
+/* #define	SIOCTYPE		(0xff<<8) */
+#define	SIOCPARM_MASK	0x1fff		/* parameters must be < 8192 bytes */
+#define	SIOC_VOID	0x00000000	/* no parameters */
+#define	SIOC_OUT	0x20000000	/* copy out parameters */
+#define	SIOC_IN		0x40000000	/* copy in parameters */
+#define	SIOC_INOUT	(SIOC_IN|SIOC_OUT)
+/* the 0x20000000 is so we can distinguish new ioctl's from old */
+#define	_SIO(x,y)	((int)(SIOC_VOID|(x<<8)|y))
+#define	_SIOR(x,y,t)	((int)(SIOC_OUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+#define	_SIOW(x,y,t)	((int)(SIOC_IN|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+/* this should be _SIORW, but stdio got there first */
+#define	_SIOWR(x,y,t)	((int)(SIOC_INOUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+#define _SIOC_SIZE(x)	((x>>16)&SIOCPARM_MASK)	
+#define _SIOC_DIR(x)	(x & 0xf0000000)
+#define _SIOC_NONE	SIOC_VOID
+#define _SIOC_READ	SIOC_OUT
+#define _SIOC_WRITE	SIOC_IN
+#  endif /* _IOWR */
+#endif  /* !_SIOWR */
+
+#define SNDCTL_SEQ_RESET		_SIO  ('Q', 0)
+#define SNDCTL_SEQ_SYNC			_SIO  ('Q', 1)
+#define SNDCTL_SYNTH_INFO		_SIOWR('Q', 2, struct synth_info)
+#define SNDCTL_SEQ_CTRLRATE		_SIOWR('Q', 3, int)	/* Set/get timer resolution (HZ) */
+#define SNDCTL_SEQ_GETOUTCOUNT		_SIOR ('Q', 4, int)
+#define SNDCTL_SEQ_GETINCOUNT		_SIOR ('Q', 5, int)
+#define SNDCTL_SEQ_PERCMODE		_SIOW ('Q', 6, int)
+#define SNDCTL_FM_LOAD_INSTR		_SIOW ('Q', 7, struct sbi_instrument)	/* Obsolete. Don't use!!!!!! */
+#define SNDCTL_SEQ_TESTMIDI		_SIOW ('Q', 8, int)
+#define SNDCTL_SEQ_RESETSAMPLES		_SIOW ('Q', 9, int)
+#define SNDCTL_SEQ_NRSYNTHS		_SIOR ('Q',10, int)
+#define SNDCTL_SEQ_NRMIDIS		_SIOR ('Q',11, int)
+#define SNDCTL_MIDI_INFO		_SIOWR('Q',12, struct midi_info)
+#define SNDCTL_SEQ_THRESHOLD		_SIOW ('Q',13, int)
+#define SNDCTL_SYNTH_MEMAVL		_SIOWR('Q',14, int)	/* in=dev#, out=memsize */
+#define SNDCTL_FM_4OP_ENABLE		_SIOW ('Q',15, int)	/* in=dev# */
+#define SNDCTL_SEQ_PANIC		_SIO  ('Q',17)
+#define SNDCTL_SEQ_OUTOFBAND		_SIOW ('Q',18, struct seq_event_rec)
+#define SNDCTL_SEQ_GETTIME		_SIOR ('Q',19, int)
+#define SNDCTL_SYNTH_ID			_SIOWR('Q',20, struct synth_info)
+#define SNDCTL_SYNTH_CONTROL		_SIOWR('Q',21, struct synth_control)
+#define SNDCTL_SYNTH_REMOVESAMPLE	_SIOWR('Q',22, struct remove_sample)
+
+typedef struct synth_control
+{
+	int devno;	/* Synthesizer # */
+	char data[4000]; /* Device spesific command/data record */
+}synth_control;
+
+typedef struct remove_sample
+{
+	int devno;	/* Synthesizer # */
+	int bankno;	/* MIDI bank # (0=General MIDI) */
+	int instrno;	/* MIDI instrument number */
+} remove_sample;
+
+typedef struct seq_event_rec {
+		unsigned char arr[8];
+} seq_event_rec;
+
+#define SNDCTL_TMR_TIMEBASE		_SIOWR('T', 1, int)
+#define SNDCTL_TMR_START		_SIO  ('T', 2)
+#define SNDCTL_TMR_STOP			_SIO  ('T', 3)
+#define SNDCTL_TMR_CONTINUE		_SIO  ('T', 4)
+#define SNDCTL_TMR_TEMPO		_SIOWR('T', 5, int)
+#define SNDCTL_TMR_SOURCE		_SIOWR('T', 6, int)
+#	define TMR_INTERNAL		0x00000001
+#	define TMR_EXTERNAL		0x00000002
+#		define TMR_MODE_MIDI	0x00000010
+#		define TMR_MODE_FSK	0x00000020
+#		define TMR_MODE_CLS	0x00000040
+#		define TMR_MODE_SMPTE	0x00000080
+#define SNDCTL_TMR_METRONOME		_SIOW ('T', 7, int)
+#define SNDCTL_TMR_SELECT		_SIOW ('T', 8, int)
+
+/*
+ * Some big endian/little endian handling macros
+ */
+
+#define _LINUX_PATCHKEY_H_INDIRECT
+#include <linux/patchkey.h>
+#undef _LINUX_PATCHKEY_H_INDIRECT
+
+#if   defined(__BYTE_ORDER)
+#  if __BYTE_ORDER == __BIG_ENDIAN
+#    define AFMT_S16_NE AFMT_S16_BE
+#  elif __BYTE_ORDER == __LITTLE_ENDIAN
+#    define AFMT_S16_NE AFMT_S16_LE
+#  else
+#    error "could not determine byte order"
+#  endif
+#endif
+
+/*
+ *	Sample loading mechanism for internal synthesizers (/dev/sequencer)
+ *	The following patch_info structure has been designed to support
+ *	Gravis UltraSound. It tries to be universal format for uploading
+ *	sample based patches but is probably too limited.
+ *
+ *      (PBD) As Hannu guessed, the GUS structure is too limited for 
+ *      the WaveFront, but this is the right place for a constant definition.
+ */
+
+struct patch_info {
+		unsigned short key;		/* Use WAVE_PATCH here */
+#define WAVE_PATCH	   _PATCHKEY(0x04)
+#define GUS_PATCH	   WAVE_PATCH
+#define WAVEFRONT_PATCH    _PATCHKEY(0x06)
+
+		short device_no;	/* Synthesizer number */
+		short instr_no;		/* Midi pgm# */
+
+		unsigned int mode;
+/*
+ * The least significant byte has the same format than the GUS .PAT
+ * files
+ */
+#define WAVE_16_BITS	0x01	/* bit 0 = 8 or 16 bit wave data. */
+#define WAVE_UNSIGNED	0x02	/* bit 1 = Signed - Unsigned data. */
+#define WAVE_LOOPING	0x04	/* bit 2 = looping enabled-1. */
+#define WAVE_BIDIR_LOOP	0x08	/* bit 3 = Set is bidirectional looping. */
+#define WAVE_LOOP_BACK	0x10	/* bit 4 = Set is looping backward. */
+#define WAVE_SUSTAIN_ON	0x20	/* bit 5 = Turn sustaining on. (Env. pts. 3)*/
+#define WAVE_ENVELOPES	0x40	/* bit 6 = Enable envelopes - 1 */
+#define WAVE_FAST_RELEASE 0x80	/* bit 7 = Shut off immediately after note off */
+				/* 	(use the env_rate/env_offs fields). */
+/* Linux specific bits */
+#define WAVE_VIBRATO	0x00010000	/* The vibrato info is valid */
+#define WAVE_TREMOLO	0x00020000	/* The tremolo info is valid */
+#define WAVE_SCALE	0x00040000	/* The scaling info is valid */
+#define WAVE_FRACTIONS	0x00080000	/* Fraction information is valid */
+/* Reserved bits */
+#define WAVE_ROM	0x40000000	/* For future use */
+#define WAVE_MULAW	0x20000000	/* For future use */
+/* Other bits must be zeroed */
+
+		int len;	/* Size of the wave data in bytes */
+		int loop_start, loop_end; /* Byte offsets from the beginning */
+
+/* 
+ * The base_freq and base_note fields are used when computing the
+ * playback speed for a note. The base_note defines the tone frequency
+ * which is heard if the sample is played using the base_freq as the
+ * playback speed.
+ *
+ * The low_note and high_note fields define the minimum and maximum note
+ * frequencies for which this sample is valid. It is possible to define
+ * more than one samples for an instrument number at the same time. The
+ * low_note and high_note fields are used to select the most suitable one.
+ *
+ * The fields base_note, high_note and low_note should contain
+ * the note frequency multiplied by 1000. For example value for the
+ * middle A is 440*1000.
+ */
+
+		unsigned int base_freq;
+		unsigned int base_note;
+		unsigned int high_note;
+		unsigned int low_note;
+		int panning;	/* -128=left, 127=right */
+		int detuning;
+
+/*	New fields introduced in version 1.99.5	*/
+
+       /* Envelope. Enabled by mode bit WAVE_ENVELOPES	*/
+		unsigned char	env_rate[ 6 ];	 /* GUS HW ramping rate */
+		unsigned char	env_offset[ 6 ]; /* 255 == 100% */
+
+	/* 
+	 * The tremolo, vibrato and scale info are not supported yet.
+	 * Enable by setting the mode bits WAVE_TREMOLO, WAVE_VIBRATO or
+	 * WAVE_SCALE
+	 */
+
+		unsigned char	tremolo_sweep;
+		unsigned char	tremolo_rate;
+		unsigned char	tremolo_depth;
+	
+		unsigned char	vibrato_sweep;
+		unsigned char	vibrato_rate;
+		unsigned char	vibrato_depth;
+
+		int		scale_frequency;
+		unsigned int	scale_factor;		/* from 0 to 2048 or 0 to 2 */
+	
+	        int		volume;
+		int		fractions;
+		int		reserved1;
+	        int		spare[2];
+		char data[1];	/* The waveform data starts here */
+	};
+
+struct sysex_info {
+		short key;		/* Use SYSEX_PATCH or MAUI_PATCH here */
+#define SYSEX_PATCH	_PATCHKEY(0x05)
+#define MAUI_PATCH	_PATCHKEY(0x06)
+		short device_no;	/* Synthesizer number */
+		int len;	/* Size of the sysex data in bytes */
+		unsigned char data[1];	/* Sysex data starts here */
+	};
+
+/*
+ * /dev/sequencer input events.
+ *
+ * The data written to the /dev/sequencer is a stream of events. Events
+ * are records of 4 or 8 bytes. The first byte defines the size. 
+ * Any number of events can be written with a write call. There
+ * is a set of macros for sending these events. Use these macros if you
+ * want to maximize portability of your program.
+ *
+ * Events SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO. Are also input events.
+ * (All input events are currently 4 bytes long. Be prepared to support
+ * 8 byte events also. If you receive any event having first byte >= 128,
+ * it's a 8 byte event.
+ *
+ * The events are documented at the end of this file.
+ *
+ * Normal events (4 bytes)
+ * There is also a 8 byte version of most of the 4 byte events. The
+ * 8 byte one is recommended.
+ */
+#define SEQ_NOTEOFF		0
+#define SEQ_FMNOTEOFF		SEQ_NOTEOFF	/* Just old name */
+#define SEQ_NOTEON		1
+#define	SEQ_FMNOTEON		SEQ_NOTEON
+#define SEQ_WAIT		TMR_WAIT_ABS
+#define SEQ_PGMCHANGE		3
+#define SEQ_FMPGMCHANGE		SEQ_PGMCHANGE
+#define SEQ_SYNCTIMER		TMR_START
+#define SEQ_MIDIPUTC		5
+#define SEQ_DRUMON		6	/*** OBSOLETE ***/
+#define SEQ_DRUMOFF		7	/*** OBSOLETE ***/
+#define SEQ_ECHO		TMR_ECHO	/* For synching programs with output */
+#define SEQ_AFTERTOUCH		9
+#define SEQ_CONTROLLER		10
+
+/*******************************************
+ *	Midi controller numbers
+ *******************************************
+ * Controllers 0 to 31 (0x00 to 0x1f) and
+ * 32 to 63 (0x20 to 0x3f) are continuous
+ * controllers.
+ * In the MIDI 1.0 these controllers are sent using
+ * two messages. Controller numbers 0 to 31 are used
+ * to send the MSB and the controller numbers 32 to 63
+ * are for the LSB. Note that just 7 bits are used in MIDI bytes.
+ */
+
+#define	   CTL_BANK_SELECT		0x00
+#define	   CTL_MODWHEEL			0x01
+#define    CTL_BREATH			0x02
+/*		undefined		0x03 */
+#define    CTL_FOOT			0x04
+#define    CTL_PORTAMENTO_TIME		0x05
+#define    CTL_DATA_ENTRY		0x06
+#define    CTL_MAIN_VOLUME		0x07
+#define    CTL_BALANCE			0x08
+/*		undefined		0x09 */
+#define    CTL_PAN			0x0a
+#define    CTL_EXPRESSION		0x0b
+/*		undefined		0x0c */
+/*		undefined		0x0d */
+/*		undefined		0x0e */
+/*		undefined		0x0f */
+#define    CTL_GENERAL_PURPOSE1	0x10
+#define    CTL_GENERAL_PURPOSE2	0x11
+#define    CTL_GENERAL_PURPOSE3	0x12
+#define    CTL_GENERAL_PURPOSE4	0x13
+/*		undefined		0x14 - 0x1f */
+
+/*		undefined		0x20 */
+/* The controller numbers 0x21 to 0x3f are reserved for the */
+/* least significant bytes of the controllers 0x00 to 0x1f. */
+/* These controllers are not recognised by the driver. */
+
+/* Controllers 64 to 69 (0x40 to 0x45) are on/off switches. */
+/* 0=OFF and 127=ON (intermediate values are possible) */
+#define    CTL_DAMPER_PEDAL		0x40
+#define    CTL_SUSTAIN			0x40	/* Alias */
+#define    CTL_HOLD			0x40	/* Alias */
+#define    CTL_PORTAMENTO		0x41
+#define    CTL_SOSTENUTO		0x42
+#define    CTL_SOFT_PEDAL		0x43
+/*		undefined		0x44 */
+#define    CTL_HOLD2			0x45
+/*		undefined		0x46 - 0x4f */
+
+#define    CTL_GENERAL_PURPOSE5	0x50
+#define    CTL_GENERAL_PURPOSE6	0x51
+#define    CTL_GENERAL_PURPOSE7	0x52
+#define    CTL_GENERAL_PURPOSE8	0x53
+/*		undefined		0x54 - 0x5a */
+#define    CTL_EXT_EFF_DEPTH		0x5b
+#define    CTL_TREMOLO_DEPTH		0x5c
+#define    CTL_CHORUS_DEPTH		0x5d
+#define    CTL_DETUNE_DEPTH		0x5e
+#define    CTL_CELESTE_DEPTH		0x5e	/* Alias for the above one */
+#define    CTL_PHASER_DEPTH		0x5f
+#define    CTL_DATA_INCREMENT		0x60
+#define    CTL_DATA_DECREMENT		0x61
+#define    CTL_NONREG_PARM_NUM_LSB	0x62
+#define    CTL_NONREG_PARM_NUM_MSB	0x63
+#define    CTL_REGIST_PARM_NUM_LSB	0x64
+#define    CTL_REGIST_PARM_NUM_MSB	0x65
+/*		undefined		0x66 - 0x78 */
+/*		reserved		0x79 - 0x7f */
+
+/* Pseudo controllers (not midi compatible) */
+#define    CTRL_PITCH_BENDER		255
+#define    CTRL_PITCH_BENDER_RANGE	254
+#define    CTRL_EXPRESSION		253	/* Obsolete */
+#define    CTRL_MAIN_VOLUME		252	/* Obsolete */
+#define SEQ_BALANCE		11
+#define SEQ_VOLMODE             12
+
+/*
+ * Volume mode decides how volumes are used
+ */
+
+#define VOL_METHOD_ADAGIO	1
+#define VOL_METHOD_LINEAR	2
+
+/*
+ * Note! SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO are used also as
+ *	 input events.
+ */
+
+/*
+ * Event codes 0xf0 to 0xfc are reserved for future extensions.
+ */
+
+#define SEQ_FULLSIZE		0xfd	/* Long events */
+/*
+ *	SEQ_FULLSIZE events are used for loading patches/samples to the
+ *	synthesizer devices. These events are passed directly to the driver
+ *	of the associated synthesizer device. There is no limit to the size
+ *	of the extended events. These events are not queued but executed
+ *	immediately when the write() is called (execution can take several
+ *	seconds of time). 
+ *
+ *	When a SEQ_FULLSIZE message is written to the device, it must
+ *	be written using exactly one write() call. Other events cannot
+ *	be mixed to the same write.
+ *	
+ *	For FM synths (YM3812/OPL3) use struct sbi_instrument and write it to the 
+ *	/dev/sequencer. Don't write other data together with the instrument structure
+ *	Set the key field of the structure to FM_PATCH. The device field is used to
+ *	route the patch to the corresponding device.
+ *
+ *	For wave table use struct patch_info. Initialize the key field
+ *      to WAVE_PATCH.
+ */
+#define SEQ_PRIVATE		0xfe	/* Low level HW dependent events (8 bytes) */
+#define SEQ_EXTENDED		0xff	/* Extended events (8 bytes) OBSOLETE */
+
+/*
+ * Record for FM patches
+ */
+
+typedef unsigned char sbi_instr_data[32];
+
+struct sbi_instrument {
+		unsigned short	key;	/* FM_PATCH or OPL3_PATCH */
+#define FM_PATCH	_PATCHKEY(0x01)
+#define OPL3_PATCH	_PATCHKEY(0x03)
+		short		device;		/*	Synth# (0-4)	*/
+		int 		channel;	/*	Program# to be initialized 	*/
+		sbi_instr_data	operators;	/*	Register settings for operator cells (.SBI format)	*/
+	};
+
+struct synth_info {	/* Read only */
+		char	name[30];
+		int	device;		/* 0-N. INITIALIZE BEFORE CALLING */
+		int	synth_type;
+#define SYNTH_TYPE_FM			0
+#define SYNTH_TYPE_SAMPLE		1
+#define SYNTH_TYPE_MIDI			2	/* Midi interface */
+
+		int	synth_subtype;
+#define FM_TYPE_ADLIB			0x00
+#define FM_TYPE_OPL3			0x01
+#define MIDI_TYPE_MPU401		0x401
+
+#define SAMPLE_TYPE_BASIC		0x10
+#define SAMPLE_TYPE_GUS			SAMPLE_TYPE_BASIC
+#define SAMPLE_TYPE_WAVEFRONT           0x11
+
+		int	perc_mode;	/* No longer supported */
+		int	nr_voices;
+		int	nr_drums;	/* Obsolete field */
+		int	instr_bank_size;
+		unsigned int	capabilities;	
+#define SYNTH_CAP_PERCMODE		0x00000001 /* No longer used */
+#define SYNTH_CAP_OPL3			0x00000002 /* Set if OPL3 supported */
+#define SYNTH_CAP_INPUT			0x00000004 /* Input (MIDI) device */
+		int	dummies[19];	/* Reserve space */
+	};
+
+struct sound_timer_info {
+		char name[32];
+		int caps;
+	};
+
+#define MIDI_CAP_MPU401		1		/* MPU-401 intelligent mode */
+
+struct midi_info {
+		char		name[30];
+		int		device;		/* 0-N. INITIALIZE BEFORE CALLING */
+		unsigned int	capabilities;	/* To be defined later */
+		int		dev_type;
+		int		dummies[18];	/* Reserve space */
+	};
+
+/********************************************
+ * ioctl commands for the /dev/midi##
+ */
+typedef struct {
+		unsigned char cmd;
+		char nr_args, nr_returns;
+		unsigned char data[30];
+	} mpu_command_rec;
+
+#define SNDCTL_MIDI_PRETIME		_SIOWR('m', 0, int)
+#define SNDCTL_MIDI_MPUMODE		_SIOWR('m', 1, int)
+#define SNDCTL_MIDI_MPUCMD		_SIOWR('m', 2, mpu_command_rec)
+
+/********************************************
+ * IOCTL commands for /dev/dsp and /dev/audio
+ */
+
+#define SNDCTL_DSP_RESET		_SIO  ('P', 0)
+#define SNDCTL_DSP_SYNC			_SIO  ('P', 1)
+#define SNDCTL_DSP_SPEED		_SIOWR('P', 2, int)
+#define SNDCTL_DSP_STEREO		_SIOWR('P', 3, int)
+#define SNDCTL_DSP_GETBLKSIZE		_SIOWR('P', 4, int)
+#define SNDCTL_DSP_SAMPLESIZE		SNDCTL_DSP_SETFMT
+#define SNDCTL_DSP_CHANNELS		_SIOWR('P', 6, int)
+#define SOUND_PCM_WRITE_CHANNELS	SNDCTL_DSP_CHANNELS
+#define SOUND_PCM_WRITE_FILTER		_SIOWR('P', 7, int)
+#define SNDCTL_DSP_POST			_SIO  ('P', 8)
+#define SNDCTL_DSP_SUBDIVIDE		_SIOWR('P', 9, int)
+#define SNDCTL_DSP_SETFRAGMENT		_SIOWR('P',10, int)
+
+/*	Audio data formats (Note! U8=8 and S16_LE=16 for compatibility) */
+#define SNDCTL_DSP_GETFMTS		_SIOR ('P',11, int) /* Returns a mask */
+#define SNDCTL_DSP_SETFMT		_SIOWR('P',5, int) /* Selects ONE fmt*/
+#	define AFMT_QUERY		0x00000000	/* Return current fmt */
+#	define AFMT_MU_LAW		0x00000001
+#	define AFMT_A_LAW		0x00000002
+#	define AFMT_IMA_ADPCM		0x00000004
+#	define AFMT_U8			0x00000008
+#	define AFMT_S16_LE		0x00000010	/* Little endian signed 16*/
+#	define AFMT_S16_BE		0x00000020	/* Big endian signed 16 */
+#	define AFMT_S8			0x00000040
+#	define AFMT_U16_LE		0x00000080	/* Little endian U16 */
+#	define AFMT_U16_BE		0x00000100	/* Big endian U16 */
+#	define AFMT_MPEG		0x00000200	/* MPEG (2) audio */
+#	define AFMT_AC3		0x00000400	/* Dolby Digital AC3 */
+
+/*
+ * Buffer status queries.
+ */
+typedef struct audio_buf_info {
+			int fragments;	/* # of available fragments (partially usend ones not counted) */
+			int fragstotal;	/* Total # of fragments allocated */
+			int fragsize;	/* Size of a fragment in bytes */
+
+			int bytes;	/* Available space in bytes (includes partially used fragments) */
+			/* Note! 'bytes' could be more than fragments*fragsize */
+		} audio_buf_info;
+
+#define SNDCTL_DSP_GETOSPACE		_SIOR ('P',12, audio_buf_info)
+#define SNDCTL_DSP_GETISPACE		_SIOR ('P',13, audio_buf_info)
+#define SNDCTL_DSP_NONBLOCK		_SIO  ('P',14)
+#define SNDCTL_DSP_GETCAPS		_SIOR ('P',15, int)
+#	define DSP_CAP_REVISION		0x000000ff	/* Bits for revision level (0 to 255) */
+#	define DSP_CAP_DUPLEX		0x00000100	/* Full duplex record/playback */
+#	define DSP_CAP_REALTIME		0x00000200	/* Real time capability */
+#	define DSP_CAP_BATCH		0x00000400	/* Device has some kind of */
+							/* internal buffers which may */
+							/* cause some delays and */
+							/* decrease precision of timing */
+#	define DSP_CAP_COPROC		0x00000800	/* Has a coprocessor */
+							/* Sometimes it's a DSP */
+							/* but usually not */
+#	define DSP_CAP_TRIGGER		0x00001000	/* Supports SETTRIGGER */
+#	define DSP_CAP_MMAP		0x00002000	/* Supports mmap() */
+#	define DSP_CAP_MULTI		0x00004000	/* support multiple open */
+#	define DSP_CAP_BIND		0x00008000	/* channel binding to front/rear/cneter/lfe */
+
+
+#define SNDCTL_DSP_GETTRIGGER		_SIOR ('P',16, int)
+#define SNDCTL_DSP_SETTRIGGER		_SIOW ('P',16, int)
+#	define PCM_ENABLE_INPUT		0x00000001
+#	define PCM_ENABLE_OUTPUT		0x00000002
+
+typedef struct count_info {
+		int bytes;	/* Total # of bytes processed */
+		int blocks;	/* # of fragment transitions since last time */
+		int ptr;	/* Current DMA pointer value */
+	} count_info;
+
+#define SNDCTL_DSP_GETIPTR		_SIOR ('P',17, count_info)
+#define SNDCTL_DSP_GETOPTR		_SIOR ('P',18, count_info)
+
+typedef struct buffmem_desc {
+		unsigned *buffer;
+		int size;
+	} buffmem_desc;
+#define SNDCTL_DSP_MAPINBUF		_SIOR ('P', 19, buffmem_desc)
+#define SNDCTL_DSP_MAPOUTBUF		_SIOR ('P', 20, buffmem_desc)
+#define SNDCTL_DSP_SETSYNCRO		_SIO  ('P', 21)
+#define SNDCTL_DSP_SETDUPLEX		_SIO  ('P', 22)
+#define SNDCTL_DSP_GETODELAY		_SIOR ('P', 23, int)
+
+#define SNDCTL_DSP_GETCHANNELMASK		_SIOWR('P', 64, int)
+#define SNDCTL_DSP_BIND_CHANNEL		_SIOWR('P', 65, int)
+#	define DSP_BIND_QUERY		0x00000000
+#	define DSP_BIND_FRONT		0x00000001
+#	define DSP_BIND_SURR		0x00000002
+#	define DSP_BIND_CENTER_LFE	0x00000004
+#	define DSP_BIND_HANDSET		0x00000008
+#	define DSP_BIND_MIC		0x00000010
+#	define DSP_BIND_MODEM1		0x00000020
+#	define DSP_BIND_MODEM2		0x00000040
+#	define DSP_BIND_I2S		0x00000080
+#	define DSP_BIND_SPDIF		0x00000100
+
+#define SNDCTL_DSP_SETSPDIF		_SIOW ('P', 66, int)
+#define SNDCTL_DSP_GETSPDIF		_SIOR ('P', 67, int)
+#	define SPDIF_PRO	0x0001
+#	define SPDIF_N_AUD	0x0002
+#	define SPDIF_COPY	0x0004
+#	define SPDIF_PRE	0x0008
+#	define SPDIF_CC		0x07f0
+#	define SPDIF_L		0x0800
+#	define SPDIF_DRS	0x4000
+#	define SPDIF_V		0x8000
+
+/*
+ * Application's profile defines the way how playback underrun situations should be handled.
+ * 
+ *	APF_NORMAL (the default) and APF_NETWORK make the driver to cleanup the
+ *	playback buffer whenever an underrun occurs. This consumes some time
+ *	prevents looping the existing buffer.
+ *	APF_CPUINTENS is intended to be set by CPU intensive applications which
+ *	are likely to run out of time occasionally. In this mode the buffer cleanup is
+ *	disabled which saves CPU time but also let's the previous buffer content to
+ *	be played during the "pause" after the underrun.
+ */
+#define SNDCTL_DSP_PROFILE		_SIOW ('P', 23, int)
+#define	  APF_NORMAL	0	/* Normal applications */
+#define	  APF_NETWORK	1	/* Underruns probably caused by an "external" delay */
+#define   APF_CPUINTENS 2	/* Underruns probably caused by "overheating" the CPU */
+
+#define SOUND_PCM_READ_RATE		_SIOR ('P', 2, int)
+#define SOUND_PCM_READ_CHANNELS		_SIOR ('P', 6, int)
+#define SOUND_PCM_READ_BITS		_SIOR ('P', 5, int)
+#define SOUND_PCM_READ_FILTER		_SIOR ('P', 7, int)
+
+/* Some alias names */
+#define SOUND_PCM_WRITE_BITS		SNDCTL_DSP_SETFMT
+#define SOUND_PCM_WRITE_RATE		SNDCTL_DSP_SPEED
+#define SOUND_PCM_POST			SNDCTL_DSP_POST
+#define SOUND_PCM_RESET			SNDCTL_DSP_RESET
+#define SOUND_PCM_SYNC			SNDCTL_DSP_SYNC
+#define SOUND_PCM_SUBDIVIDE		SNDCTL_DSP_SUBDIVIDE
+#define SOUND_PCM_SETFRAGMENT		SNDCTL_DSP_SETFRAGMENT
+#define SOUND_PCM_GETFMTS		SNDCTL_DSP_GETFMTS
+#define SOUND_PCM_SETFMT		SNDCTL_DSP_SETFMT
+#define SOUND_PCM_GETOSPACE		SNDCTL_DSP_GETOSPACE
+#define SOUND_PCM_GETISPACE		SNDCTL_DSP_GETISPACE
+#define SOUND_PCM_NONBLOCK		SNDCTL_DSP_NONBLOCK
+#define SOUND_PCM_GETCAPS		SNDCTL_DSP_GETCAPS
+#define SOUND_PCM_GETTRIGGER		SNDCTL_DSP_GETTRIGGER
+#define SOUND_PCM_SETTRIGGER		SNDCTL_DSP_SETTRIGGER
+#define SOUND_PCM_SETSYNCRO		SNDCTL_DSP_SETSYNCRO
+#define SOUND_PCM_GETIPTR		SNDCTL_DSP_GETIPTR
+#define SOUND_PCM_GETOPTR		SNDCTL_DSP_GETOPTR
+#define SOUND_PCM_MAPINBUF		SNDCTL_DSP_MAPINBUF
+#define SOUND_PCM_MAPOUTBUF		SNDCTL_DSP_MAPOUTBUF
+
+/*
+ * ioctl calls to be used in communication with coprocessors and
+ * DSP chips.
+ */
+
+typedef struct copr_buffer {
+		int command;	/* Set to 0 if not used */
+		int flags;
+#define CPF_NONE		0x0000
+#define CPF_FIRST		0x0001	/* First block */
+#define CPF_LAST		0x0002	/* Last block */
+		int len;
+		int offs;	/* If required by the device (0 if not used) */
+
+		unsigned char data[4000]; /* NOTE! 4000 is not 4k */
+	} copr_buffer;
+
+typedef struct copr_debug_buf {
+		int command;	/* Used internally. Set to 0 */
+		int parm1;
+		int parm2;
+		int flags;	
+		int len;	/* Length of data in bytes */
+	} copr_debug_buf;
+
+typedef struct copr_msg {
+		int len;
+		unsigned char data[4000];
+	} copr_msg;
+
+#define SNDCTL_COPR_RESET             _SIO  ('C',  0)
+#define SNDCTL_COPR_LOAD	      _SIOWR('C',  1, copr_buffer)
+#define SNDCTL_COPR_RDATA	      _SIOWR('C',  2, copr_debug_buf)
+#define SNDCTL_COPR_RCODE	      _SIOWR('C',  3, copr_debug_buf)
+#define SNDCTL_COPR_WDATA	      _SIOW ('C',  4, copr_debug_buf)
+#define SNDCTL_COPR_WCODE	      _SIOW ('C',  5, copr_debug_buf)
+#define SNDCTL_COPR_RUN		      _SIOWR('C',  6, copr_debug_buf)
+#define SNDCTL_COPR_HALT	      _SIOWR('C',  7, copr_debug_buf)
+#define SNDCTL_COPR_SENDMSG	      _SIOWR('C',  8, copr_msg)
+#define SNDCTL_COPR_RCVMSG	      _SIOR ('C',  9, copr_msg)
+
+/*********************************************
+ * IOCTL commands for /dev/mixer
+ */
+	
+/* 
+ * Mixer devices
+ *
+ * There can be up to 20 different analog mixer channels. The
+ * SOUND_MIXER_NRDEVICES gives the currently supported maximum. 
+ * The SOUND_MIXER_READ_DEVMASK returns a bitmask which tells
+ * the devices supported by the particular mixer.
+ */
+
+#define SOUND_MIXER_NRDEVICES	25
+#define SOUND_MIXER_VOLUME	0
+#define SOUND_MIXER_BASS	1
+#define SOUND_MIXER_TREBLE	2
+#define SOUND_MIXER_SYNTH	3
+#define SOUND_MIXER_PCM		4
+#define SOUND_MIXER_SPEAKER	5
+#define SOUND_MIXER_LINE	6
+#define SOUND_MIXER_MIC		7
+#define SOUND_MIXER_CD		8
+#define SOUND_MIXER_IMIX	9	/*  Recording monitor  */
+#define SOUND_MIXER_ALTPCM	10
+#define SOUND_MIXER_RECLEV	11	/* Recording level */
+#define SOUND_MIXER_IGAIN	12	/* Input gain */
+#define SOUND_MIXER_OGAIN	13	/* Output gain */
+/* 
+ * The AD1848 codec and compatibles have three line level inputs
+ * (line, aux1 and aux2). Since each card manufacturer have assigned
+ * different meanings to these inputs, it's inpractical to assign
+ * specific meanings (line, cd, synth etc.) to them.
+ */
+#define SOUND_MIXER_LINE1	14	/* Input source 1  (aux1) */
+#define SOUND_MIXER_LINE2	15	/* Input source 2  (aux2) */
+#define SOUND_MIXER_LINE3	16	/* Input source 3  (line) */
+#define SOUND_MIXER_DIGITAL1	17	/* Digital (input) 1 */
+#define SOUND_MIXER_DIGITAL2	18	/* Digital (input) 2 */
+#define SOUND_MIXER_DIGITAL3	19	/* Digital (input) 3 */
+#define SOUND_MIXER_PHONEIN	20	/* Phone input */
+#define SOUND_MIXER_PHONEOUT	21	/* Phone output */
+#define SOUND_MIXER_VIDEO	22	/* Video/TV (audio) in */
+#define SOUND_MIXER_RADIO	23	/* Radio in */
+#define SOUND_MIXER_MONITOR	24	/* Monitor (usually mic) volume */
+
+/* Some on/off settings (SOUND_SPECIAL_MIN - SOUND_SPECIAL_MAX) */
+/* Not counted to SOUND_MIXER_NRDEVICES, but use the same number space */
+#define SOUND_ONOFF_MIN		28
+#define SOUND_ONOFF_MAX		30
+
+/* Note!	Number 31 cannot be used since the sign bit is reserved */
+#define SOUND_MIXER_NONE	31
+
+/*
+ * The following unsupported macros are no longer functional.
+ * Use SOUND_MIXER_PRIVATE# macros in future.
+ */
+#define SOUND_MIXER_ENHANCE	SOUND_MIXER_NONE
+#define SOUND_MIXER_MUTE	SOUND_MIXER_NONE
+#define SOUND_MIXER_LOUD	SOUND_MIXER_NONE
+
+
+#define SOUND_DEVICE_LABELS	{"Vol  ", "Bass ", "Trebl", "Synth", "Pcm  ", "Spkr ", "Line ", \
+				 "Mic  ", "CD   ", "Mix  ", "Pcm2 ", "Rec  ", "IGain", "OGain", \
+				 "Line1", "Line2", "Line3", "Digital1", "Digital2", "Digital3", \
+				 "PhoneIn", "PhoneOut", "Video", "Radio", "Monitor"}
+
+#define SOUND_DEVICE_NAMES	{"vol", "bass", "treble", "synth", "pcm", "speaker", "line", \
+				 "mic", "cd", "mix", "pcm2", "rec", "igain", "ogain", \
+				 "line1", "line2", "line3", "dig1", "dig2", "dig3", \
+				 "phin", "phout", "video", "radio", "monitor"}
+
+/*	Device bitmask identifiers	*/
+
+#define SOUND_MIXER_RECSRC	0xff	/* Arg contains a bit for each recording source */
+#define SOUND_MIXER_DEVMASK	0xfe	/* Arg contains a bit for each supported device */
+#define SOUND_MIXER_RECMASK	0xfd	/* Arg contains a bit for each supported recording source */
+#define SOUND_MIXER_CAPS	0xfc
+#	define SOUND_CAP_EXCL_INPUT	0x00000001	/* Only one recording source at a time */
+#define SOUND_MIXER_STEREODEVS	0xfb	/* Mixer channels supporting stereo */
+#define SOUND_MIXER_OUTSRC	0xfa	/* Arg contains a bit for each input source to output */
+#define SOUND_MIXER_OUTMASK	0xf9	/* Arg contains a bit for each supported input source to output */
+
+/*	Device mask bits	*/
+
+#define SOUND_MASK_VOLUME	(1 << SOUND_MIXER_VOLUME)
+#define SOUND_MASK_BASS		(1 << SOUND_MIXER_BASS)
+#define SOUND_MASK_TREBLE	(1 << SOUND_MIXER_TREBLE)
+#define SOUND_MASK_SYNTH	(1 << SOUND_MIXER_SYNTH)
+#define SOUND_MASK_PCM		(1 << SOUND_MIXER_PCM)
+#define SOUND_MASK_SPEAKER	(1 << SOUND_MIXER_SPEAKER)
+#define SOUND_MASK_LINE		(1 << SOUND_MIXER_LINE)
+#define SOUND_MASK_MIC		(1 << SOUND_MIXER_MIC)
+#define SOUND_MASK_CD		(1 << SOUND_MIXER_CD)
+#define SOUND_MASK_IMIX		(1 << SOUND_MIXER_IMIX)
+#define SOUND_MASK_ALTPCM	(1 << SOUND_MIXER_ALTPCM)
+#define SOUND_MASK_RECLEV	(1 << SOUND_MIXER_RECLEV)
+#define SOUND_MASK_IGAIN	(1 << SOUND_MIXER_IGAIN)
+#define SOUND_MASK_OGAIN	(1 << SOUND_MIXER_OGAIN)
+#define SOUND_MASK_LINE1	(1 << SOUND_MIXER_LINE1)
+#define SOUND_MASK_LINE2	(1 << SOUND_MIXER_LINE2)
+#define SOUND_MASK_LINE3	(1 << SOUND_MIXER_LINE3)
+#define SOUND_MASK_DIGITAL1	(1 << SOUND_MIXER_DIGITAL1)
+#define SOUND_MASK_DIGITAL2	(1 << SOUND_MIXER_DIGITAL2)
+#define SOUND_MASK_DIGITAL3	(1 << SOUND_MIXER_DIGITAL3)
+#define SOUND_MASK_PHONEIN	(1 << SOUND_MIXER_PHONEIN)
+#define SOUND_MASK_PHONEOUT	(1 << SOUND_MIXER_PHONEOUT)
+#define SOUND_MASK_RADIO	(1 << SOUND_MIXER_RADIO)
+#define SOUND_MASK_VIDEO	(1 << SOUND_MIXER_VIDEO)
+#define SOUND_MASK_MONITOR	(1 << SOUND_MIXER_MONITOR)
+
+/* Obsolete macros */
+#define SOUND_MASK_MUTE		(1 << SOUND_MIXER_MUTE)
+#define SOUND_MASK_ENHANCE	(1 << SOUND_MIXER_ENHANCE)
+#define SOUND_MASK_LOUD		(1 << SOUND_MIXER_LOUD)
+
+#define MIXER_READ(dev)		_SIOR('M', dev, int)
+#define SOUND_MIXER_READ_VOLUME		MIXER_READ(SOUND_MIXER_VOLUME)
+#define SOUND_MIXER_READ_BASS		MIXER_READ(SOUND_MIXER_BASS)
+#define SOUND_MIXER_READ_TREBLE		MIXER_READ(SOUND_MIXER_TREBLE)
+#define SOUND_MIXER_READ_SYNTH		MIXER_READ(SOUND_MIXER_SYNTH)
+#define SOUND_MIXER_READ_PCM		MIXER_READ(SOUND_MIXER_PCM)
+#define SOUND_MIXER_READ_SPEAKER	MIXER_READ(SOUND_MIXER_SPEAKER)
+#define SOUND_MIXER_READ_LINE		MIXER_READ(SOUND_MIXER_LINE)
+#define SOUND_MIXER_READ_MIC		MIXER_READ(SOUND_MIXER_MIC)
+#define SOUND_MIXER_READ_CD		MIXER_READ(SOUND_MIXER_CD)
+#define SOUND_MIXER_READ_IMIX		MIXER_READ(SOUND_MIXER_IMIX)
+#define SOUND_MIXER_READ_ALTPCM		MIXER_READ(SOUND_MIXER_ALTPCM)
+#define SOUND_MIXER_READ_RECLEV		MIXER_READ(SOUND_MIXER_RECLEV)
+#define SOUND_MIXER_READ_IGAIN		MIXER_READ(SOUND_MIXER_IGAIN)
+#define SOUND_MIXER_READ_OGAIN		MIXER_READ(SOUND_MIXER_OGAIN)
+#define SOUND_MIXER_READ_LINE1		MIXER_READ(SOUND_MIXER_LINE1)
+#define SOUND_MIXER_READ_LINE2		MIXER_READ(SOUND_MIXER_LINE2)
+#define SOUND_MIXER_READ_LINE3		MIXER_READ(SOUND_MIXER_LINE3)
+
+/* Obsolete macros */
+#define SOUND_MIXER_READ_MUTE		MIXER_READ(SOUND_MIXER_MUTE)
+#define SOUND_MIXER_READ_ENHANCE	MIXER_READ(SOUND_MIXER_ENHANCE)
+#define SOUND_MIXER_READ_LOUD		MIXER_READ(SOUND_MIXER_LOUD)
+
+#define SOUND_MIXER_READ_RECSRC		MIXER_READ(SOUND_MIXER_RECSRC)
+#define SOUND_MIXER_READ_DEVMASK	MIXER_READ(SOUND_MIXER_DEVMASK)
+#define SOUND_MIXER_READ_RECMASK	MIXER_READ(SOUND_MIXER_RECMASK)
+#define SOUND_MIXER_READ_STEREODEVS	MIXER_READ(SOUND_MIXER_STEREODEVS)
+#define SOUND_MIXER_READ_CAPS		MIXER_READ(SOUND_MIXER_CAPS)
+
+#define MIXER_WRITE(dev)		_SIOWR('M', dev, int)
+#define SOUND_MIXER_WRITE_VOLUME	MIXER_WRITE(SOUND_MIXER_VOLUME)
+#define SOUND_MIXER_WRITE_BASS		MIXER_WRITE(SOUND_MIXER_BASS)
+#define SOUND_MIXER_WRITE_TREBLE	MIXER_WRITE(SOUND_MIXER_TREBLE)
+#define SOUND_MIXER_WRITE_SYNTH		MIXER_WRITE(SOUND_MIXER_SYNTH)
+#define SOUND_MIXER_WRITE_PCM		MIXER_WRITE(SOUND_MIXER_PCM)
+#define SOUND_MIXER_WRITE_SPEAKER	MIXER_WRITE(SOUND_MIXER_SPEAKER)
+#define SOUND_MIXER_WRITE_LINE		MIXER_WRITE(SOUND_MIXER_LINE)
+#define SOUND_MIXER_WRITE_MIC		MIXER_WRITE(SOUND_MIXER_MIC)
+#define SOUND_MIXER_WRITE_CD		MIXER_WRITE(SOUND_MIXER_CD)
+#define SOUND_MIXER_WRITE_IMIX		MIXER_WRITE(SOUND_MIXER_IMIX)
+#define SOUND_MIXER_WRITE_ALTPCM	MIXER_WRITE(SOUND_MIXER_ALTPCM)
+#define SOUND_MIXER_WRITE_RECLEV	MIXER_WRITE(SOUND_MIXER_RECLEV)
+#define SOUND_MIXER_WRITE_IGAIN		MIXER_WRITE(SOUND_MIXER_IGAIN)
+#define SOUND_MIXER_WRITE_OGAIN		MIXER_WRITE(SOUND_MIXER_OGAIN)
+#define SOUND_MIXER_WRITE_LINE1		MIXER_WRITE(SOUND_MIXER_LINE1)
+#define SOUND_MIXER_WRITE_LINE2		MIXER_WRITE(SOUND_MIXER_LINE2)
+#define SOUND_MIXER_WRITE_LINE3		MIXER_WRITE(SOUND_MIXER_LINE3)
+
+/* Obsolete macros */
+#define SOUND_MIXER_WRITE_MUTE		MIXER_WRITE(SOUND_MIXER_MUTE)
+#define SOUND_MIXER_WRITE_ENHANCE	MIXER_WRITE(SOUND_MIXER_ENHANCE)
+#define SOUND_MIXER_WRITE_LOUD		MIXER_WRITE(SOUND_MIXER_LOUD)
+
+#define SOUND_MIXER_WRITE_RECSRC	MIXER_WRITE(SOUND_MIXER_RECSRC)
+
+typedef struct mixer_info
+{
+  char id[16];
+  char name[32];
+  int  modify_counter;
+  int fillers[10];
+} mixer_info;
+
+typedef struct _old_mixer_info /* Obsolete */
+{
+  char id[16];
+  char name[32];
+} _old_mixer_info;
+
+#define SOUND_MIXER_INFO		_SIOR ('M', 101, mixer_info)
+#define SOUND_OLD_MIXER_INFO		_SIOR ('M', 101, _old_mixer_info)
+
+/*
+ * A mechanism for accessing "proprietary" mixer features. This method
+ * permits passing 128 bytes of arbitrary data between a mixer application
+ * and the mixer driver. Interpretation of the record is defined by
+ * the particular mixer driver.
+ */
+typedef unsigned char mixer_record[128];
+
+#define SOUND_MIXER_ACCESS		_SIOWR('M', 102, mixer_record)
+
+/*
+ * Two ioctls for special souncard function
+ */
+#define SOUND_MIXER_AGC  _SIOWR('M', 103, int)
+#define SOUND_MIXER_3DSE  _SIOWR('M', 104, int)
+
+/*
+ * The SOUND_MIXER_PRIVATE# commands can be redefined by low level drivers.
+ * These features can be used when accessing device specific features.
+ */
+#define SOUND_MIXER_PRIVATE1		_SIOWR('M', 111, int)
+#define SOUND_MIXER_PRIVATE2		_SIOWR('M', 112, int)
+#define SOUND_MIXER_PRIVATE3		_SIOWR('M', 113, int)
+#define SOUND_MIXER_PRIVATE4		_SIOWR('M', 114, int)
+#define SOUND_MIXER_PRIVATE5		_SIOWR('M', 115, int)
+
+/*
+ * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used
+ * for querying current mixer settings from the driver and for loading
+ * default volume settings _prior_ activating the mixer (loading
+ * doesn't affect current state of the mixer hardware). These calls
+ * are for internal use only.
+ */
+
+typedef struct mixer_vol_table {
+  int num;	/* Index to volume table */
+  char name[32];
+  int levels[32];
+} mixer_vol_table;
+
+#define SOUND_MIXER_GETLEVELS		_SIOWR('M', 116, mixer_vol_table)
+#define SOUND_MIXER_SETLEVELS		_SIOWR('M', 117, mixer_vol_table)
+
+/* 
+ * An ioctl for identifying the driver version. It will return value
+ * of the SOUND_VERSION macro used when compiling the driver.
+ * This call was introduced in OSS version 3.6 and it will not work
+ * with earlier versions (returns EINVAL).
+ */
+#define OSS_GETVERSION			_SIOR ('M', 118, int)
+
+/*
+ * Level 2 event types for /dev/sequencer
+ */
+
+/*
+ * The 4 most significant bits of byte 0 specify the class of
+ * the event: 
+ *
+ *	0x8X = system level events,
+ *	0x9X = device/port specific events, event[1] = device/port,
+ *		The last 4 bits give the subtype:
+ *			0x02	= Channel event (event[3] = chn).
+ *			0x01	= note event (event[4] = note).
+ *			(0x01 is not used alone but always with bit 0x02).
+ *	       event[2] = MIDI message code (0x80=note off etc.)
+ *
+ */
+
+#define EV_SEQ_LOCAL		0x80
+#define EV_TIMING		0x81
+#define EV_CHN_COMMON		0x92
+#define EV_CHN_VOICE		0x93
+#define EV_SYSEX		0x94
+/*
+ * Event types 200 to 220 are reserved for application use.
+ * These numbers will not be used by the driver.
+ */
+
+/*
+ * Events for event type EV_CHN_VOICE
+ */
+
+#define MIDI_NOTEOFF		0x80
+#define MIDI_NOTEON		0x90
+#define MIDI_KEY_PRESSURE	0xA0
+
+/*
+ * Events for event type EV_CHN_COMMON
+ */
+
+#define MIDI_CTL_CHANGE		0xB0
+#define MIDI_PGM_CHANGE		0xC0
+#define MIDI_CHN_PRESSURE	0xD0
+#define MIDI_PITCH_BEND		0xE0
+
+#define MIDI_SYSTEM_PREFIX	0xF0
+
+/*
+ * Timer event types
+ */
+#define TMR_WAIT_REL		1	/* Time relative to the prev time */
+#define TMR_WAIT_ABS		2	/* Absolute time since TMR_START */
+#define TMR_STOP		3
+#define TMR_START		4
+#define TMR_CONTINUE		5
+#define TMR_TEMPO		6
+#define TMR_ECHO		8
+#define TMR_CLOCK		9	/* MIDI clock */
+#define TMR_SPP			10	/* Song position pointer */
+#define TMR_TIMESIG		11	/* Time signature */
+
+/*
+ *	Local event types
+ */
+#define LOCL_STARTAUDIO		1
+
+/*
+ *	Some convenience macros to simplify programming of the
+ *	/dev/sequencer interface
+ *
+ *	This is a legacy interface for applications written against
+ *	the OSSlib-3.8 style interface. It is no longer possible
+ *	to actually link against OSSlib with this header, but we
+ *	still provide these macros for programs using them.
+ *
+ *	If you want to use OSSlib, it is recommended that you get
+ *	the GPL version of OSS-4.x and build against that version
+ *	of the header.
+ *
+ *	We redefine the extern keyword so that make headers_check
+ *	does not complain about SEQ_USE_EXTBUF.
+ */
+#define SEQ_DECLAREBUF()		SEQ_USE_EXTBUF()
+
+void seqbuf_dump(void);	/* This function must be provided by programs */
+
+#define SEQ_PM_DEFINES int __foo_bar___
+
+#define SEQ_LOAD_GMINSTR(dev, instr)
+#define SEQ_LOAD_GMDRUM(dev, drum)
+
+#define _SEQ_EXTERN extern
+#define SEQ_USE_EXTBUF() \
+		_SEQ_EXTERN unsigned char _seqbuf[]; \
+		_SEQ_EXTERN int _seqbuflen; _SEQ_EXTERN int _seqbufptr
+
+#ifndef USE_SIMPLE_MACROS
+/* Sample seqbuf_dump() implementation:
+ *
+ *	SEQ_DEFINEBUF (2048);	-- Defines a buffer for 2048 bytes
+ *
+ *	int seqfd;		-- The file descriptor for /dev/sequencer.
+ *
+ *	void
+ *	seqbuf_dump ()
+ *	{
+ *	  if (_seqbufptr)
+ *	    if (write (seqfd, _seqbuf, _seqbufptr) == -1)
+ *	      {
+ *		perror ("write /dev/sequencer");
+ *		exit (-1);
+ *	      }
+ *	  _seqbufptr = 0;
+ *	}
+ */
+
+#define SEQ_DEFINEBUF(len)		unsigned char _seqbuf[len]; int _seqbuflen = len;int _seqbufptr = 0
+#define _SEQ_NEEDBUF(len)		if ((_seqbufptr+(len)) > _seqbuflen) seqbuf_dump()
+#define _SEQ_ADVBUF(len)		_seqbufptr += len
+#define SEQ_DUMPBUF			seqbuf_dump
+#else
+/*
+ * This variation of the sequencer macros is used just to format one event
+ * using fixed buffer.
+ * 
+ * The program using the macro library must define the following macros before
+ * using this library.
+ *
+ * #define _seqbuf 		 name of the buffer (unsigned char[]) 
+ * #define _SEQ_ADVBUF(len)	 If the applic needs to know the exact
+ *				 size of the event, this macro can be used.
+ *				 Otherwise this must be defined as empty.
+ * #define _seqbufptr		 Define the name of index variable or 0 if
+ *				 not required. 
+ */
+#define _SEQ_NEEDBUF(len)	/* empty */
+#endif
+
+#define SEQ_VOLUME_MODE(dev, mode)	{_SEQ_NEEDBUF(8);\
+					_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
+					_seqbuf[_seqbufptr+1] = SEQ_VOLMODE;\
+					_seqbuf[_seqbufptr+2] = (dev);\
+					_seqbuf[_seqbufptr+3] = (mode);\
+					_seqbuf[_seqbufptr+4] = 0;\
+					_seqbuf[_seqbufptr+5] = 0;\
+					_seqbuf[_seqbufptr+6] = 0;\
+					_seqbuf[_seqbufptr+7] = 0;\
+					_SEQ_ADVBUF(8);}
+
+/*
+ * Midi voice messages
+ */
+
+#define _CHN_VOICE(dev, event, chn, note, parm) \
+					{_SEQ_NEEDBUF(8);\
+					_seqbuf[_seqbufptr] = EV_CHN_VOICE;\
+					_seqbuf[_seqbufptr+1] = (dev);\
+					_seqbuf[_seqbufptr+2] = (event);\
+					_seqbuf[_seqbufptr+3] = (chn);\
+					_seqbuf[_seqbufptr+4] = (note);\
+					_seqbuf[_seqbufptr+5] = (parm);\
+					_seqbuf[_seqbufptr+6] = (0);\
+					_seqbuf[_seqbufptr+7] = 0;\
+					_SEQ_ADVBUF(8);}
+
+#define SEQ_START_NOTE(dev, chn, note, vol) \
+		_CHN_VOICE(dev, MIDI_NOTEON, chn, note, vol)
+
+#define SEQ_STOP_NOTE(dev, chn, note, vol) \
+		_CHN_VOICE(dev, MIDI_NOTEOFF, chn, note, vol)
+
+#define SEQ_KEY_PRESSURE(dev, chn, note, pressure) \
+		_CHN_VOICE(dev, MIDI_KEY_PRESSURE, chn, note, pressure)
+
+/*
+ * Midi channel messages
+ */
+
+#define _CHN_COMMON(dev, event, chn, p1, p2, w14) \
+					{_SEQ_NEEDBUF(8);\
+					_seqbuf[_seqbufptr] = EV_CHN_COMMON;\
+					_seqbuf[_seqbufptr+1] = (dev);\
+					_seqbuf[_seqbufptr+2] = (event);\
+					_seqbuf[_seqbufptr+3] = (chn);\
+					_seqbuf[_seqbufptr+4] = (p1);\
+					_seqbuf[_seqbufptr+5] = (p2);\
+					*(short *)&_seqbuf[_seqbufptr+6] = (w14);\
+					_SEQ_ADVBUF(8);}
+/*
+ * SEQ_SYSEX permits sending of sysex messages. (It may look that it permits
+ * sending any MIDI bytes but it's absolutely not possible. Trying to do
+ * so _will_ cause problems with MPU401 intelligent mode).
+ *
+ * Sysex messages are sent in blocks of 1 to 6 bytes. Longer messages must be 
+ * sent by calling SEQ_SYSEX() several times (there must be no other events
+ * between them). First sysex fragment must have 0xf0 in the first byte
+ * and the last byte (buf[len-1] of the last fragment must be 0xf7. No byte
+ * between these sysex start and end markers cannot be larger than 0x7f. Also
+ * lengths of each fragments (except the last one) must be 6.
+ *
+ * Breaking the above rules may work with some MIDI ports but is likely to
+ * cause fatal problems with some other devices (such as MPU401).
+ */
+#define SEQ_SYSEX(dev, buf, len) \
+					{int ii, ll=(len); \
+					 unsigned char *bufp=buf;\
+					 if (ll>6)ll=6;\
+					_SEQ_NEEDBUF(8);\
+					_seqbuf[_seqbufptr] = EV_SYSEX;\
+					_seqbuf[_seqbufptr+1] = (dev);\
+					for(ii=0;ii<ll;ii++)\
+					   _seqbuf[_seqbufptr+ii+2] = bufp[ii];\
+					for(ii=ll;ii<6;ii++)\
+					   _seqbuf[_seqbufptr+ii+2] = 0xff;\
+					_SEQ_ADVBUF(8);}
+
+#define SEQ_CHN_PRESSURE(dev, chn, pressure) \
+		_CHN_COMMON(dev, MIDI_CHN_PRESSURE, chn, pressure, 0, 0)
+
+#define SEQ_SET_PATCH SEQ_PGM_CHANGE
+#define SEQ_PGM_CHANGE(dev, chn, patch) \
+		_CHN_COMMON(dev, MIDI_PGM_CHANGE, chn, patch, 0, 0)
+
+#define SEQ_CONTROL(dev, chn, controller, value) \
+		_CHN_COMMON(dev, MIDI_CTL_CHANGE, chn, controller, 0, value)
+
+#define SEQ_BENDER(dev, chn, value) \
+		_CHN_COMMON(dev, MIDI_PITCH_BEND, chn, 0, 0, value)
+
+
+#define SEQ_V2_X_CONTROL(dev, voice, controller, value)	{_SEQ_NEEDBUF(8);\
+					_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
+					_seqbuf[_seqbufptr+1] = SEQ_CONTROLLER;\
+					_seqbuf[_seqbufptr+2] = (dev);\
+					_seqbuf[_seqbufptr+3] = (voice);\
+					_seqbuf[_seqbufptr+4] = (controller);\
+					_seqbuf[_seqbufptr+5] = ((value)&0xff);\
+					_seqbuf[_seqbufptr+6] = ((value>>8)&0xff);\
+					_seqbuf[_seqbufptr+7] = 0;\
+					_SEQ_ADVBUF(8);}
+/*
+ * The following 5 macros are incorrectly implemented and obsolete.
+ * Use SEQ_BENDER and SEQ_CONTROL (with proper controller) instead.
+ */
+#define SEQ_PITCHBEND(dev, voice, value) SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER, value)
+#define SEQ_BENDER_RANGE(dev, voice, value) SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER_RANGE, value)
+#define SEQ_EXPRESSION(dev, voice, value) SEQ_CONTROL(dev, voice, CTL_EXPRESSION, value*128)
+#define SEQ_MAIN_VOLUME(dev, voice, value) SEQ_CONTROL(dev, voice, CTL_MAIN_VOLUME, (value*16383)/100)
+#define SEQ_PANNING(dev, voice, pos) SEQ_CONTROL(dev, voice, CTL_PAN, (pos+128) / 2)
+
+/*
+ * Timing and syncronization macros
+ */
+
+#define _TIMER_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\
+				 	_seqbuf[_seqbufptr+0] = EV_TIMING; \
+				 	_seqbuf[_seqbufptr+1] = (ev); \
+					_seqbuf[_seqbufptr+2] = 0;\
+					_seqbuf[_seqbufptr+3] = 0;\
+				 	*(unsigned int *)&_seqbuf[_seqbufptr+4] = (parm); \
+					_SEQ_ADVBUF(8);}
+
+#define SEQ_START_TIMER()		_TIMER_EVENT(TMR_START, 0)
+#define SEQ_STOP_TIMER()		_TIMER_EVENT(TMR_STOP, 0)
+#define SEQ_CONTINUE_TIMER()		_TIMER_EVENT(TMR_CONTINUE, 0)
+#define SEQ_WAIT_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_ABS, ticks)
+#define SEQ_DELTA_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_REL, ticks)
+#define SEQ_ECHO_BACK(key)		_TIMER_EVENT(TMR_ECHO, key)
+#define SEQ_SET_TEMPO(value)		_TIMER_EVENT(TMR_TEMPO, value)
+#define SEQ_SONGPOS(pos)		_TIMER_EVENT(TMR_SPP, pos)
+#define SEQ_TIME_SIGNATURE(sig)		_TIMER_EVENT(TMR_TIMESIG, sig)
+
+/*
+ * Local control events
+ */
+
+#define _LOCAL_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\
+				 	_seqbuf[_seqbufptr+0] = EV_SEQ_LOCAL; \
+				 	_seqbuf[_seqbufptr+1] = (ev); \
+					_seqbuf[_seqbufptr+2] = 0;\
+					_seqbuf[_seqbufptr+3] = 0;\
+				 	*(unsigned int *)&_seqbuf[_seqbufptr+4] = (parm); \
+					_SEQ_ADVBUF(8);}
+
+#define SEQ_PLAYAUDIO(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO, devmask)
+/*
+ * Events for the level 1 interface only 
+ */
+
+#define SEQ_MIDIOUT(device, byte)	{_SEQ_NEEDBUF(4);\
+					_seqbuf[_seqbufptr] = SEQ_MIDIPUTC;\
+					_seqbuf[_seqbufptr+1] = (byte);\
+					_seqbuf[_seqbufptr+2] = (device);\
+					_seqbuf[_seqbufptr+3] = 0;\
+					_SEQ_ADVBUF(4);}
+
+/*
+ * Patch loading.
+ */
+#define SEQ_WRPATCH(patchx, len) \
+		{if (_seqbufptr) SEQ_DUMPBUF();\
+		 if (write(seqfd, (char*)(patchx), len)==-1) \
+		    perror("Write patch: /dev/sequencer");}
+#define SEQ_WRPATCH2(patchx, len) \
+		(SEQ_DUMPBUF(), write(seqfd, (char*)(patchx), len))
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/sound.h clean_modified/linux-2.6.32/usr/include/linux/sound.h
--- linux-2.6.32/usr/include/linux/sound.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sound.h	2019-04-14 13:24:03.141498667 -0500
@@ -0,0 +1,27 @@
+
+/*
+ * Minor numbers for the sound driver.
+ */
+
+#include <linux/fs.h>
+
+#define SND_DEV_CTL		0	/* Control port /dev/mixer */
+#define SND_DEV_SEQ		1	/* Sequencer output /dev/sequencer (FM
+						synthesizer and MIDI output) */
+#define SND_DEV_MIDIN		2	/* Raw midi access */
+#define SND_DEV_DSP		3	/* Digitized voice /dev/dsp */
+#define SND_DEV_AUDIO		4	/* Sparc compatible /dev/audio */
+#define SND_DEV_DSP16		5	/* Like /dev/dsp but 16 bits/sample */
+/* #define SND_DEV_STATUS	6 */	/* /dev/sndstat (obsolete) */
+#define SND_DEV_UNUSED		6
+#define SND_DEV_AWFM		7	/* Reserved */
+#define SND_DEV_SEQ2		8	/* /dev/sequencer, level 2 interface */
+/* #define SND_DEV_SNDPROC	9 */	/* /dev/sndproc for programmable devices (not used) */
+/* #define SND_DEV_DMMIDI	9 */
+#define SND_DEV_SYNTH		9	/* Raw synth access /dev/synth (same as /dev/dmfm) */
+#define SND_DEV_DMFM		10	/* Raw synth access /dev/dmfm */
+#define SND_DEV_UNKNOWN11	11
+#define SND_DEV_ADSP		12	/* Like /dev/dsp (obsolete) */
+#define SND_DEV_AMIDI		13	/* Like /dev/midi (obsolete) */
+#define SND_DEV_ADMMIDI		14	/* Like /dev/dmmidi (onsolete) */
+
diff -uNr linux-2.6.32/usr/include/linux/spi/spidev.h clean_modified/linux-2.6.32/usr/include/linux/spi/spidev.h
--- linux-2.6.32/usr/include/linux/spi/spidev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/spi/spidev.h	2019-04-14 13:24:03.143537777 -0500
@@ -0,0 +1,131 @@
+/*
+ * include/linux/spi/spidev.h
+ *
+ * Copyright (C) 2006 SWAPP
+ *	Andrea Paterniani <a.paterniani@swapp-eng.it>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+
+#ifndef SPIDEV_H
+#define SPIDEV_H
+
+#include <linux/types.h>
+
+/* User space versions of kernel symbols for SPI clocking modes,
+ * matching <linux/spi/spi.h>
+ */
+
+#define SPI_CPHA		0x01
+#define SPI_CPOL		0x02
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#define SPI_CS_HIGH		0x04
+#define SPI_LSB_FIRST		0x08
+#define SPI_3WIRE		0x10
+#define SPI_LOOP		0x20
+#define SPI_NO_CS		0x40
+#define SPI_READY		0x80
+
+/*---------------------------------------------------------------------------*/
+
+/* IOCTL commands */
+
+#define SPI_IOC_MAGIC			'k'
+
+/**
+ * struct spi_ioc_transfer - describes a single SPI transfer
+ * @tx_buf: Holds pointer to userspace buffer with transmit data, or null.
+ *	If no data is provided, zeroes are shifted out.
+ * @rx_buf: Holds pointer to userspace buffer for receive data, or null.
+ * @len: Length of tx and rx buffers, in bytes.
+ * @speed_hz: Temporary override of the device's bitrate.
+ * @bits_per_word: Temporary override of the device's wordsize.
+ * @delay_usecs: If nonzero, how long to delay after the last bit transfer
+ *	before optionally deselecting the device before the next transfer.
+ * @cs_change: True to deselect device before starting the next transfer.
+ *
+ * This structure is mapped directly to the kernel spi_transfer structure;
+ * the fields have the same meanings, except of course that the pointers
+ * are in a different address space (and may be of different sizes in some
+ * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
+ * Zero-initialize the structure, including currently unused fields, to
+ * accomodate potential future updates.
+ *
+ * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
+ * Pass it an array of related transfers, they'll execute together.
+ * Each transfer may be half duplex (either direction) or full duplex.
+ *
+ *	struct spi_ioc_transfer mesg[4];
+ *	...
+ *	status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);
+ *
+ * So for example one transfer might send a nine bit command (right aligned
+ * in a 16-bit word), the next could read a block of 8-bit data before
+ * terminating that command by temporarily deselecting the chip; the next
+ * could send a different nine bit command (re-selecting the chip), and the
+ * last transfer might write some register values.
+ */
+struct spi_ioc_transfer {
+	__u64		tx_buf;
+	__u64		rx_buf;
+
+	__u32		len;
+	__u32		speed_hz;
+
+	__u16		delay_usecs;
+	__u8		bits_per_word;
+	__u8		cs_change;
+	__u32		pad;
+
+	/* If the contents of 'struct spi_ioc_transfer' ever change
+	 * incompatibly, then the ioctl number (currently 0) must change;
+	 * ioctls with constant size fields get a bit more in the way of
+	 * error checking than ones (like this) where that field varies.
+	 *
+	 * NOTE: struct layout is the same in 64bit and 32bit userspace.
+	 */
+};
+
+/* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
+#define SPI_MSGSIZE(N) \
+	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
+		? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)
+#define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])
+
+
+/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) */
+#define SPI_IOC_RD_MODE			_IOR(SPI_IOC_MAGIC, 1, __u8)
+#define SPI_IOC_WR_MODE			_IOW(SPI_IOC_MAGIC, 1, __u8)
+
+/* Read / Write SPI bit justification */
+#define SPI_IOC_RD_LSB_FIRST		_IOR(SPI_IOC_MAGIC, 2, __u8)
+#define SPI_IOC_WR_LSB_FIRST		_IOW(SPI_IOC_MAGIC, 2, __u8)
+
+/* Read / Write SPI device word length (1..N) */
+#define SPI_IOC_RD_BITS_PER_WORD	_IOR(SPI_IOC_MAGIC, 3, __u8)
+#define SPI_IOC_WR_BITS_PER_WORD	_IOW(SPI_IOC_MAGIC, 3, __u8)
+
+/* Read / Write SPI device default max speed hz */
+#define SPI_IOC_RD_MAX_SPEED_HZ		_IOR(SPI_IOC_MAGIC, 4, __u32)
+#define SPI_IOC_WR_MAX_SPEED_HZ		_IOW(SPI_IOC_MAGIC, 4, __u32)
+
+
+
+#endif /* SPIDEV_H */
diff -uNr linux-2.6.32/usr/include/linux/stat.h clean_modified/linux-2.6.32/usr/include/linux/stat.h
--- linux-2.6.32/usr/include/linux/stat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/stat.h	2019-04-14 13:24:03.143537777 -0500
@@ -0,0 +1,45 @@
+#ifndef _LINUX_STAT_H
+#define _LINUX_STAT_H
+
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#define S_IFMT  00170000
+#define S_IFSOCK 0140000
+#define S_IFLNK	 0120000
+#define S_IFREG  0100000
+#define S_IFBLK  0060000
+#define S_IFDIR  0040000
+#define S_IFCHR  0020000
+#define S_IFIFO  0010000
+#define S_ISUID  0004000
+#define S_ISGID  0002000
+#define S_ISVTX  0001000
+
+#define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+#define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+#define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+#define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+#define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)
+
+#define S_IRWXU 00700
+#define S_IRUSR 00400
+#define S_IWUSR 00200
+#define S_IXUSR 00100
+
+#define S_IRWXG 00070
+#define S_IRGRP 00040
+#define S_IWGRP 00020
+#define S_IXGRP 00010
+
+#define S_IRWXO 00007
+#define S_IROTH 00004
+#define S_IWOTH 00002
+#define S_IXOTH 00001
+
+#endif
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/stddef.h clean_modified/linux-2.6.32/usr/include/linux/stddef.h
--- linux-2.6.32/usr/include/linux/stddef.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/stddef.h	2019-04-14 13:24:03.143537777 -0500
@@ -0,0 +1,14 @@
+#ifndef _LINUX_STDDEF_H
+#define _LINUX_STDDEF_H
+
+
+
+#undef NULL
+#if defined(__cplusplus)
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/string.h clean_modified/linux-2.6.32/usr/include/linux/string.h
--- linux-2.6.32/usr/include/linux/string.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/string.h	2019-04-14 13:24:03.143537777 -0500
@@ -0,0 +1,7 @@
+#ifndef _LINUX_STRING_H_
+#define _LINUX_STRING_H_
+
+/* We don't want strings.h stuff being used by user stuff by accident */
+
+#include <string.h>
+#endif /* _LINUX_STRING_H_ */
diff -uNr linux-2.6.32/usr/include/linux/sunrpc/debug.h clean_modified/linux-2.6.32/usr/include/linux/sunrpc/debug.h
--- linux-2.6.32/usr/include/linux/sunrpc/debug.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sunrpc/debug.h	2019-04-14 13:24:03.144433612 -0500
@@ -0,0 +1,48 @@
+/*
+ * linux/include/linux/sunrpc/debug.h
+ *
+ * Debugging support for sunrpc module
+ *
+ * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef _LINUX_SUNRPC_DEBUG_H_
+#define _LINUX_SUNRPC_DEBUG_H_
+
+/*
+ * RPC debug facilities
+ */
+#define RPCDBG_XPRT		0x0001
+#define RPCDBG_CALL		0x0002
+#define RPCDBG_DEBUG		0x0004
+#define RPCDBG_NFS		0x0008
+#define RPCDBG_AUTH		0x0010
+#define RPCDBG_BIND		0x0020
+#define RPCDBG_SCHED		0x0040
+#define RPCDBG_TRANS		0x0080
+#define RPCDBG_SVCXPRT		0x0100
+#define RPCDBG_SVCDSP		0x0200
+#define RPCDBG_MISC		0x0400
+#define RPCDBG_CACHE		0x0800
+#define RPCDBG_ALL		0x7fff
+
+
+/*
+ * Declarations for the sysctl debug interface, which allows to read or
+ * change the debug flags for rpc, nfs, nfsd, and lockd. Since the sunrpc
+ * module currently registers its sysctl table dynamically, the sysctl path
+ * for module FOO is <CTL_SUNRPC, CTL_FOODEBUG>.
+ */
+
+enum {
+	CTL_RPCDEBUG = 1,
+	CTL_NFSDEBUG,
+	CTL_NFSDDEBUG,
+	CTL_NLMDEBUG,
+	CTL_SLOTTABLE_UDP,
+	CTL_SLOTTABLE_TCP,
+	CTL_MIN_RESVPORT,
+	CTL_MAX_RESVPORT,
+};
+
+#endif /* _LINUX_SUNRPC_DEBUG_H_ */
diff -uNr linux-2.6.32/usr/include/linux/suspend_ioctls.h clean_modified/linux-2.6.32/usr/include/linux/suspend_ioctls.h
--- linux-2.6.32/usr/include/linux/suspend_ioctls.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/suspend_ioctls.h	2019-04-14 13:24:03.144433612 -0500
@@ -0,0 +1,33 @@
+#ifndef _LINUX_SUSPEND_IOCTLS_H
+#define _LINUX_SUSPEND_IOCTLS_H
+
+#include <linux/types.h>
+/*
+ * This structure is used to pass the values needed for the identification
+ * of the resume swap area from a user space to the kernel via the
+ * SNAPSHOT_SET_SWAP_AREA ioctl
+ */
+struct resume_swap_area {
+	__kernel_loff_t offset;
+	__u32 dev;
+} __attribute__((packed));
+
+#define SNAPSHOT_IOC_MAGIC	'3'
+#define SNAPSHOT_FREEZE			_IO(SNAPSHOT_IOC_MAGIC, 1)
+#define SNAPSHOT_UNFREEZE		_IO(SNAPSHOT_IOC_MAGIC, 2)
+#define SNAPSHOT_ATOMIC_RESTORE		_IO(SNAPSHOT_IOC_MAGIC, 4)
+#define SNAPSHOT_FREE			_IO(SNAPSHOT_IOC_MAGIC, 5)
+#define SNAPSHOT_FREE_SWAP_PAGES	_IO(SNAPSHOT_IOC_MAGIC, 9)
+#define SNAPSHOT_S2RAM			_IO(SNAPSHOT_IOC_MAGIC, 11)
+#define SNAPSHOT_SET_SWAP_AREA		_IOW(SNAPSHOT_IOC_MAGIC, 13, \
+							struct resume_swap_area)
+#define SNAPSHOT_GET_IMAGE_SIZE		_IOR(SNAPSHOT_IOC_MAGIC, 14, __kernel_loff_t)
+#define SNAPSHOT_PLATFORM_SUPPORT	_IO(SNAPSHOT_IOC_MAGIC, 15)
+#define SNAPSHOT_POWER_OFF		_IO(SNAPSHOT_IOC_MAGIC, 16)
+#define SNAPSHOT_CREATE_IMAGE		_IOW(SNAPSHOT_IOC_MAGIC, 17, int)
+#define SNAPSHOT_PREF_IMAGE_SIZE	_IO(SNAPSHOT_IOC_MAGIC, 18)
+#define SNAPSHOT_AVAIL_SWAP_SIZE	_IOR(SNAPSHOT_IOC_MAGIC, 19, __kernel_loff_t)
+#define SNAPSHOT_ALLOC_SWAP_PAGE	_IOR(SNAPSHOT_IOC_MAGIC, 20, __kernel_loff_t)
+#define SNAPSHOT_IOC_MAXNR	20
+
+#endif /* _LINUX_SUSPEND_IOCTLS_H */
diff -uNr linux-2.6.32/usr/include/linux/swab.h clean_modified/linux-2.6.32/usr/include/linux/swab.h
--- linux-2.6.32/usr/include/linux/swab.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/swab.h	2019-04-14 13:24:03.145407403 -0500
@@ -0,0 +1,282 @@
+#ifndef _LINUX_SWAB_H
+#define _LINUX_SWAB_H
+
+#include <linux/types.h>
+
+#include <asm/swab.h>
+
+/*
+ * casts are necessary for constants, because we never know how for sure
+ * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.
+ */
+#define ___constant_swab16(x) ((__u16)(				\
+	(((__u16)(x) & (__u16)0x00ffU) << 8) |			\
+	(((__u16)(x) & (__u16)0xff00U) >> 8)))
+
+#define ___constant_swab32(x) ((__u32)(				\
+	(((__u32)(x) & (__u32)0x000000ffUL) << 24) |		\
+	(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) |		\
+	(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) |		\
+	(((__u32)(x) & (__u32)0xff000000UL) >> 24)))
+
+#define ___constant_swab64(x) ((__u64)(				\
+	(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) |	\
+	(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) |	\
+	(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) |	\
+	(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) |	\
+	(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) |	\
+	(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) |	\
+	(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) |	\
+	(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))
+
+#define ___constant_swahw32(x) ((__u32)(			\
+	(((__u32)(x) & (__u32)0x0000ffffUL) << 16) |		\
+	(((__u32)(x) & (__u32)0xffff0000UL) >> 16)))
+
+#define ___constant_swahb32(x) ((__u32)(			\
+	(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) |		\
+	(((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))
+
+/*
+ * Implement the following as inlines, but define the interface using
+ * macros to allow constant folding when possible:
+ * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
+ */
+
+static __inline__ __u16 __fswab16(__u16 val)
+{
+#ifdef __arch_swab16
+	return __arch_swab16(val);
+#else
+	return ___constant_swab16(val);
+#endif
+}
+
+static __inline__ __u32 __fswab32(__u32 val)
+{
+#ifdef __arch_swab32
+	return __arch_swab32(val);
+#else
+	return ___constant_swab32(val);
+#endif
+}
+
+static __inline__ __u64 __fswab64(__u64 val)
+{
+#ifdef __arch_swab64
+	return __arch_swab64(val);
+#elif defined(__SWAB_64_THRU_32__)
+	__u32 h = val >> 32;
+	__u32 l = val & ((1ULL << 32) - 1);
+	return (((__u64)__fswab32(l)) << 32) | ((__u64)(__fswab32(h)));
+#else
+	return ___constant_swab64(val);
+#endif
+}
+
+static __inline__ __u32 __fswahw32(__u32 val)
+{
+#ifdef __arch_swahw32
+	return __arch_swahw32(val);
+#else
+	return ___constant_swahw32(val);
+#endif
+}
+
+static __inline__ __u32 __fswahb32(__u32 val)
+{
+#ifdef __arch_swahb32
+	return __arch_swahb32(val);
+#else
+	return ___constant_swahb32(val);
+#endif
+}
+
+/**
+ * __swab16 - return a byteswapped 16-bit value
+ * @x: value to byteswap
+ */
+#define __swab16(x)				\
+	(__builtin_constant_p((__u16)(x)) ?	\
+	___constant_swab16(x) :			\
+	__fswab16(x))
+
+/**
+ * __swab32 - return a byteswapped 32-bit value
+ * @x: value to byteswap
+ */
+#define __swab32(x)				\
+	(__builtin_constant_p((__u32)(x)) ?	\
+	___constant_swab32(x) :			\
+	__fswab32(x))
+
+/**
+ * __swab64 - return a byteswapped 64-bit value
+ * @x: value to byteswap
+ */
+#define __swab64(x)				\
+	(__builtin_constant_p((__u64)(x)) ?	\
+	___constant_swab64(x) :			\
+	__fswab64(x))
+
+/**
+ * __swahw32 - return a word-swapped 32-bit value
+ * @x: value to wordswap
+ *
+ * __swahw32(0x12340000) is 0x00001234
+ */
+#define __swahw32(x)				\
+	(__builtin_constant_p((__u32)(x)) ?	\
+	___constant_swahw32(x) :		\
+	__fswahw32(x))
+
+/**
+ * __swahb32 - return a high and low byte-swapped 32-bit value
+ * @x: value to byteswap
+ *
+ * __swahb32(0x12345678) is 0x34127856
+ */
+#define __swahb32(x)				\
+	(__builtin_constant_p((__u32)(x)) ?	\
+	___constant_swahb32(x) :		\
+	__fswahb32(x))
+
+/**
+ * __swab16p - return a byteswapped 16-bit value from a pointer
+ * @p: pointer to a naturally-aligned 16-bit value
+ */
+static __inline__ __u16 __swab16p(const __u16 *p)
+{
+#ifdef __arch_swab16p
+	return __arch_swab16p(p);
+#else
+	return __swab16(*p);
+#endif
+}
+
+/**
+ * __swab32p - return a byteswapped 32-bit value from a pointer
+ * @p: pointer to a naturally-aligned 32-bit value
+ */
+static __inline__ __u32 __swab32p(const __u32 *p)
+{
+#ifdef __arch_swab32p
+	return __arch_swab32p(p);
+#else
+	return __swab32(*p);
+#endif
+}
+
+/**
+ * __swab64p - return a byteswapped 64-bit value from a pointer
+ * @p: pointer to a naturally-aligned 64-bit value
+ */
+static __inline__ __u64 __swab64p(const __u64 *p)
+{
+#ifdef __arch_swab64p
+	return __arch_swab64p(p);
+#else
+	return __swab64(*p);
+#endif
+}
+
+/**
+ * __swahw32p - return a wordswapped 32-bit value from a pointer
+ * @p: pointer to a naturally-aligned 32-bit value
+ *
+ * See __swahw32() for details of wordswapping.
+ */
+static __inline__ __u32 __swahw32p(const __u32 *p)
+{
+#ifdef __arch_swahw32p
+	return __arch_swahw32p(p);
+#else
+	return __swahw32(*p);
+#endif
+}
+
+/**
+ * __swahb32p - return a high and low byteswapped 32-bit value from a pointer
+ * @p: pointer to a naturally-aligned 32-bit value
+ *
+ * See __swahb32() for details of high/low byteswapping.
+ */
+static __inline__ __u32 __swahb32p(const __u32 *p)
+{
+#ifdef __arch_swahb32p
+	return __arch_swahb32p(p);
+#else
+	return __swahb32(*p);
+#endif
+}
+
+/**
+ * __swab16s - byteswap a 16-bit value in-place
+ * @p: pointer to a naturally-aligned 16-bit value
+ */
+static __inline__ void __swab16s(__u16 *p)
+{
+#ifdef __arch_swab16s
+	__arch_swab16s(p);
+#else
+	*p = __swab16p(p);
+#endif
+}
+/**
+ * __swab32s - byteswap a 32-bit value in-place
+ * @p: pointer to a naturally-aligned 32-bit value
+ */
+static __inline__ void __swab32s(__u32 *p)
+{
+#ifdef __arch_swab32s
+	__arch_swab32s(p);
+#else
+	*p = __swab32p(p);
+#endif
+}
+
+/**
+ * __swab64s - byteswap a 64-bit value in-place
+ * @p: pointer to a naturally-aligned 64-bit value
+ */
+static __inline__ void __swab64s(__u64 *p)
+{
+#ifdef __arch_swab64s
+	__arch_swab64s(p);
+#else
+	*p = __swab64p(p);
+#endif
+}
+
+/**
+ * __swahw32s - wordswap a 32-bit value in-place
+ * @p: pointer to a naturally-aligned 32-bit value
+ *
+ * See __swahw32() for details of wordswapping
+ */
+static __inline__ void __swahw32s(__u32 *p)
+{
+#ifdef __arch_swahw32s
+	__arch_swahw32s(p);
+#else
+	*p = __swahw32p(p);
+#endif
+}
+
+/**
+ * __swahb32s - high and low byteswap a 32-bit value in-place
+ * @p: pointer to a naturally-aligned 32-bit value
+ *
+ * See __swahb32() for details of high and low byte swapping
+ */
+static __inline__ void __swahb32s(__u32 *p)
+{
+#ifdef __arch_swahb32s
+	__arch_swahb32s(p);
+#else
+	*p = __swahb32p(p);
+#endif
+}
+
+
+#endif /* _LINUX_SWAB_H */
diff -uNr linux-2.6.32/usr/include/linux/synclink.h clean_modified/linux-2.6.32/usr/include/linux/synclink.h
--- linux-2.6.32/usr/include/linux/synclink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/synclink.h	2019-04-14 13:24:03.146381383 -0500
@@ -0,0 +1,295 @@
+/*
+ * SyncLink Multiprotocol Serial Adapter Driver
+ *
+ * $Id: synclink.h,v 3.14 2006/07/17 20:15:43 paulkf Exp $
+ *
+ * Copyright (C) 1998-2000 by Microgate Corporation
+ *
+ * Redistribution of this file is permitted under
+ * the terms of the GNU Public License (GPL)
+ */
+
+#ifndef _SYNCLINK_H_
+#define _SYNCLINK_H_
+#define SYNCLINK_H_VERSION 3.6
+
+#include <linux/types.h>
+
+#define BIT0	0x0001
+#define BIT1	0x0002
+#define BIT2	0x0004
+#define BIT3	0x0008
+#define BIT4	0x0010
+#define BIT5	0x0020
+#define BIT6	0x0040
+#define BIT7	0x0080
+#define BIT8	0x0100
+#define BIT9	0x0200
+#define BIT10	0x0400
+#define BIT11	0x0800
+#define BIT12	0x1000
+#define BIT13	0x2000
+#define BIT14	0x4000
+#define BIT15	0x8000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+#define HDLC_MAX_FRAME_SIZE	65535
+#define MAX_ASYNC_TRANSMIT	4096
+#define MAX_ASYNC_BUFFER_SIZE	4096
+
+#define ASYNC_PARITY_NONE		0
+#define ASYNC_PARITY_EVEN		1
+#define ASYNC_PARITY_ODD		2
+#define ASYNC_PARITY_SPACE		3
+
+#define HDLC_FLAG_UNDERRUN_ABORT7	0x0000
+#define HDLC_FLAG_UNDERRUN_ABORT15	0x0001
+#define HDLC_FLAG_UNDERRUN_FLAG		0x0002
+#define HDLC_FLAG_UNDERRUN_CRC		0x0004
+#define HDLC_FLAG_SHARE_ZERO		0x0010
+#define HDLC_FLAG_AUTO_CTS		0x0020
+#define HDLC_FLAG_AUTO_DCD		0x0040
+#define HDLC_FLAG_AUTO_RTS		0x0080
+#define HDLC_FLAG_RXC_DPLL		0x0100
+#define HDLC_FLAG_RXC_BRG		0x0200
+#define HDLC_FLAG_RXC_TXCPIN		0x8000
+#define HDLC_FLAG_RXC_RXCPIN		0x0000
+#define HDLC_FLAG_TXC_DPLL		0x0400
+#define HDLC_FLAG_TXC_BRG		0x0800
+#define HDLC_FLAG_TXC_TXCPIN		0x0000
+#define HDLC_FLAG_TXC_RXCPIN		0x0008
+#define HDLC_FLAG_DPLL_DIV8		0x1000
+#define HDLC_FLAG_DPLL_DIV16		0x2000
+#define HDLC_FLAG_DPLL_DIV32		0x0000
+#define HDLC_FLAG_HDLC_LOOPMODE		0x4000
+
+#define HDLC_CRC_NONE			0
+#define HDLC_CRC_16_CCITT		1
+#define HDLC_CRC_32_CCITT		2
+#define HDLC_CRC_MASK			0x00ff
+#define HDLC_CRC_RETURN_EX		0x8000
+
+#define RX_OK				0
+#define RX_CRC_ERROR			1
+
+#define HDLC_TXIDLE_FLAGS		0
+#define HDLC_TXIDLE_ALT_ZEROS_ONES	1
+#define HDLC_TXIDLE_ZEROS		2
+#define HDLC_TXIDLE_ONES		3
+#define HDLC_TXIDLE_ALT_MARK_SPACE	4
+#define HDLC_TXIDLE_SPACE		5
+#define HDLC_TXIDLE_MARK		6
+#define HDLC_TXIDLE_CUSTOM_8            0x10000000
+#define HDLC_TXIDLE_CUSTOM_16           0x20000000
+
+#define HDLC_ENCODING_NRZ			0
+#define HDLC_ENCODING_NRZB			1
+#define HDLC_ENCODING_NRZI_MARK			2
+#define HDLC_ENCODING_NRZI_SPACE		3
+#define HDLC_ENCODING_NRZI			HDLC_ENCODING_NRZI_SPACE
+#define HDLC_ENCODING_BIPHASE_MARK		4
+#define HDLC_ENCODING_BIPHASE_SPACE		5
+#define HDLC_ENCODING_BIPHASE_LEVEL		6
+#define HDLC_ENCODING_DIFF_BIPHASE_LEVEL	7
+
+#define HDLC_PREAMBLE_LENGTH_8BITS	0
+#define HDLC_PREAMBLE_LENGTH_16BITS	1
+#define HDLC_PREAMBLE_LENGTH_32BITS	2
+#define HDLC_PREAMBLE_LENGTH_64BITS	3
+
+#define HDLC_PREAMBLE_PATTERN_NONE	0
+#define HDLC_PREAMBLE_PATTERN_ZEROS	1
+#define HDLC_PREAMBLE_PATTERN_FLAGS	2
+#define HDLC_PREAMBLE_PATTERN_10	3
+#define HDLC_PREAMBLE_PATTERN_01	4
+#define HDLC_PREAMBLE_PATTERN_ONES	5
+
+#define MGSL_MODE_ASYNC		1
+#define MGSL_MODE_HDLC		2
+#define MGSL_MODE_MONOSYNC	3
+#define MGSL_MODE_BISYNC	4
+#define MGSL_MODE_RAW		6
+#define MGSL_MODE_BASE_CLOCK    7
+
+#define MGSL_BUS_TYPE_ISA	1
+#define MGSL_BUS_TYPE_EISA	2
+#define MGSL_BUS_TYPE_PCI	5
+
+#define MGSL_INTERFACE_MASK     0xf
+#define MGSL_INTERFACE_DISABLE  0
+#define MGSL_INTERFACE_RS232    1
+#define MGSL_INTERFACE_V35      2
+#define MGSL_INTERFACE_RS422    3
+#define MGSL_INTERFACE_RTS_EN   0x10
+#define MGSL_INTERFACE_LL       0x20
+#define MGSL_INTERFACE_RL       0x40
+#define MGSL_INTERFACE_MSB_FIRST 0x80
+
+typedef struct _MGSL_PARAMS
+{
+	/* Common */
+
+	unsigned long	mode;		/* Asynchronous or HDLC */
+	unsigned char	loopback;	/* internal loopback mode */
+
+	/* HDLC Only */
+
+	unsigned short	flags;
+	unsigned char	encoding;	/* NRZ, NRZI, etc. */
+	unsigned long	clock_speed;	/* external clock speed in bits per second */
+	unsigned char	addr_filter;	/* receive HDLC address filter, 0xFF = disable */
+	unsigned short	crc_type;	/* None, CRC16-CCITT, or CRC32-CCITT */
+	unsigned char	preamble_length;
+	unsigned char	preamble;
+
+	/* Async Only */
+
+	unsigned long	data_rate;	/* bits per second */
+	unsigned char	data_bits;	/* 7 or 8 data bits */
+	unsigned char	stop_bits;	/* 1 or 2 stop bits */
+	unsigned char	parity;		/* none, even, or odd */
+
+} MGSL_PARAMS, *PMGSL_PARAMS;
+
+#define MICROGATE_VENDOR_ID 0x13c0
+#define SYNCLINK_DEVICE_ID 0x0010
+#define MGSCC_DEVICE_ID 0x0020
+#define SYNCLINK_SCA_DEVICE_ID 0x0030
+#define SYNCLINK_GT_DEVICE_ID 0x0070
+#define SYNCLINK_GT4_DEVICE_ID 0x0080
+#define SYNCLINK_AC_DEVICE_ID  0x0090
+#define SYNCLINK_GT2_DEVICE_ID 0x00A0
+#define MGSL_MAX_SERIAL_NUMBER 30
+
+/*
+** device diagnostics status
+*/
+
+#define DiagStatus_OK				0
+#define DiagStatus_AddressFailure		1
+#define DiagStatus_AddressConflict		2
+#define DiagStatus_IrqFailure			3
+#define DiagStatus_IrqConflict			4
+#define DiagStatus_DmaFailure			5
+#define DiagStatus_DmaConflict			6
+#define DiagStatus_PciAdapterNotFound		7
+#define DiagStatus_CantAssignPciResources	8
+#define DiagStatus_CantAssignPciMemAddr		9
+#define DiagStatus_CantAssignPciIoAddr		10
+#define DiagStatus_CantAssignPciIrq		11
+#define DiagStatus_MemoryError			12
+
+#define SerialSignal_DCD            0x01     /* Data Carrier Detect */
+#define SerialSignal_TXD            0x02     /* Transmit Data */
+#define SerialSignal_RI             0x04     /* Ring Indicator */
+#define SerialSignal_RXD            0x08     /* Receive Data */
+#define SerialSignal_CTS            0x10     /* Clear to Send */
+#define SerialSignal_RTS            0x20     /* Request to Send */
+#define SerialSignal_DSR            0x40     /* Data Set Ready */
+#define SerialSignal_DTR            0x80     /* Data Terminal Ready */
+
+
+/*
+ * Counters of the input lines (CTS, DSR, RI, CD) interrupts
+ */
+struct mgsl_icount {
+	__u32	cts, dsr, rng, dcd, tx, rx;
+	__u32	frame, parity, overrun, brk;
+	__u32	buf_overrun;
+	__u32	txok;
+	__u32	txunder;
+	__u32	txabort;
+	__u32	txtimeout;
+	__u32	rxshort;
+	__u32	rxlong;
+	__u32	rxabort;
+	__u32	rxover;
+	__u32	rxcrc;
+	__u32	rxok;
+	__u32	exithunt;
+	__u32	rxidle;
+};
+
+struct gpio_desc {
+	__u32 state;
+	__u32 smask;
+	__u32 dir;
+	__u32 dmask;
+};
+
+#define DEBUG_LEVEL_DATA	1
+#define DEBUG_LEVEL_ERROR 	2
+#define DEBUG_LEVEL_INFO  	3
+#define DEBUG_LEVEL_BH    	4
+#define DEBUG_LEVEL_ISR		5
+
+/*
+** Event bit flags for use with MgslWaitEvent
+*/
+
+#define MgslEvent_DsrActive	0x0001
+#define MgslEvent_DsrInactive	0x0002
+#define MgslEvent_Dsr		0x0003
+#define MgslEvent_CtsActive	0x0004
+#define MgslEvent_CtsInactive	0x0008
+#define MgslEvent_Cts		0x000c
+#define MgslEvent_DcdActive	0x0010
+#define MgslEvent_DcdInactive	0x0020
+#define MgslEvent_Dcd		0x0030
+#define MgslEvent_RiActive	0x0040
+#define MgslEvent_RiInactive	0x0080
+#define MgslEvent_Ri		0x00c0
+#define MgslEvent_ExitHuntMode	0x0100
+#define MgslEvent_IdleReceived	0x0200
+
+/* Private IOCTL codes:
+ *
+ * MGSL_IOCSPARAMS	set MGSL_PARAMS structure values
+ * MGSL_IOCGPARAMS	get current MGSL_PARAMS structure values
+ * MGSL_IOCSTXIDLE	set current transmit idle mode
+ * MGSL_IOCGTXIDLE	get current transmit idle mode
+ * MGSL_IOCTXENABLE	enable or disable transmitter
+ * MGSL_IOCRXENABLE	enable or disable receiver
+ * MGSL_IOCTXABORT	abort transmitting frame (HDLC)
+ * MGSL_IOCGSTATS	return current statistics
+ * MGSL_IOCWAITEVENT	wait for specified event to occur
+ * MGSL_LOOPTXDONE	transmit in HDLC LoopMode done
+ * MGSL_IOCSIF          set the serial interface type
+ * MGSL_IOCGIF          get the serial interface type
+ */
+#define MGSL_MAGIC_IOC	'm'
+#define MGSL_IOCSPARAMS		_IOW(MGSL_MAGIC_IOC,0,struct _MGSL_PARAMS)
+#define MGSL_IOCGPARAMS		_IOR(MGSL_MAGIC_IOC,1,struct _MGSL_PARAMS)
+#define MGSL_IOCSTXIDLE		_IO(MGSL_MAGIC_IOC,2)
+#define MGSL_IOCGTXIDLE		_IO(MGSL_MAGIC_IOC,3)
+#define MGSL_IOCTXENABLE	_IO(MGSL_MAGIC_IOC,4)
+#define MGSL_IOCRXENABLE	_IO(MGSL_MAGIC_IOC,5)
+#define MGSL_IOCTXABORT		_IO(MGSL_MAGIC_IOC,6)
+#define MGSL_IOCGSTATS		_IO(MGSL_MAGIC_IOC,7)
+#define MGSL_IOCWAITEVENT	_IOWR(MGSL_MAGIC_IOC,8,int)
+#define MGSL_IOCCLRMODCOUNT	_IO(MGSL_MAGIC_IOC,15)
+#define MGSL_IOCLOOPTXDONE	_IO(MGSL_MAGIC_IOC,9)
+#define MGSL_IOCSIF		_IO(MGSL_MAGIC_IOC,10)
+#define MGSL_IOCGIF		_IO(MGSL_MAGIC_IOC,11)
+#define MGSL_IOCSGPIO		_IOW(MGSL_MAGIC_IOC,16,struct gpio_desc)
+#define MGSL_IOCGGPIO		_IOR(MGSL_MAGIC_IOC,17,struct gpio_desc)
+#define MGSL_IOCWAITGPIO	_IOWR(MGSL_MAGIC_IOC,18,struct gpio_desc)
+
+
+#endif /* _SYNCLINK_H_ */
diff -uNr linux-2.6.32/usr/include/linux/sysctl.h clean_modified/linux-2.6.32/usr/include/linux/sysctl.h
--- linux-2.6.32/usr/include/linux/sysctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/sysctl.h	2019-04-14 13:24:03.147831034 -0500
@@ -0,0 +1,939 @@
+/*
+ * sysctl.h: General linux system control interface
+ *
+ * Begun 24 March 1995, Stephen Tweedie
+ *
+ ****************************************************************
+ ****************************************************************
+ **
+ **  WARNING:
+ **  The values in this file are exported to user space via 
+ **  the sysctl() binary interface.  Do *NOT* change the
+ **  numbering of any existing values here, and do not change
+ **  any numbers within any one set of values.  If you have to
+ **  redefine an existing interface, use a new number for it.
+ **  The kernel will then return -ENOTDIR to any application using
+ **  the old binary interface.
+ **
+ **  For new interfaces unless you really need a binary number
+ **  please use CTL_UNNUMBERED.
+ **
+ ****************************************************************
+ ****************************************************************
+ */
+
+#ifndef _LINUX_SYSCTL_H
+#define _LINUX_SYSCTL_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+
+struct completion;
+
+#define CTL_MAXNAME 10		/* how many path components do we allow in a
+				   call to sysctl?   In other words, what is
+				   the largest acceptable value for the nlen
+				   member of a struct __sysctl_args to have? */
+
+struct __sysctl_args {
+	int *name;
+	int nlen;
+	void *oldval;
+	size_t *oldlenp;
+	void *newval;
+	size_t newlen;
+	unsigned long __unused[4];
+};
+
+/* Define sysctl names first */
+
+/* Top-level names: */
+
+/* For internal pattern-matching use only: */
+
+enum
+{
+	CTL_KERN=1,		/* General kernel info and control */
+	CTL_VM=2,		/* VM management */
+	CTL_NET=3,		/* Networking */
+	CTL_PROC=4,		/* removal breaks strace(1) compilation */
+	CTL_FS=5,		/* Filesystems */
+	CTL_DEBUG=6,		/* Debugging */
+	CTL_DEV=7,		/* Devices */
+	CTL_BUS=8,		/* Busses */
+	CTL_ABI=9,		/* Binary emulation */
+	CTL_CPU=10,		/* CPU stuff (speed scaling, etc) */
+	CTL_ARLAN=254,		/* arlan wireless driver */
+	CTL_S390DBF=5677,	/* s390 debug */
+	CTL_SUNRPC=7249,	/* sunrpc debug */
+	CTL_PM=9899,		/* frv power management */
+	CTL_FRV=9898,		/* frv specific sysctls */
+};
+
+/* CTL_BUS names: */
+enum
+{
+	CTL_BUS_ISA=1		/* ISA */
+};
+
+/* /proc/sys/fs/inotify/ */
+enum
+{
+	INOTIFY_MAX_USER_INSTANCES=1,	/* max instances per user */
+	INOTIFY_MAX_USER_WATCHES=2,	/* max watches per user */
+	INOTIFY_MAX_QUEUED_EVENTS=3	/* max queued events per instance */
+};
+
+/* CTL_KERN names: */
+enum
+{
+	KERN_OSTYPE=1,		/* string: system version */
+	KERN_OSRELEASE=2,	/* string: system release */
+	KERN_OSREV=3,		/* int: system revision */
+	KERN_VERSION=4,		/* string: compile time info */
+	KERN_SECUREMASK=5,	/* struct: maximum rights mask */
+	KERN_PROF=6,		/* table: profiling information */
+	KERN_NODENAME=7,
+	KERN_DOMAINNAME=8,
+
+	KERN_PANIC=15,		/* int: panic timeout */
+	KERN_REALROOTDEV=16,	/* real root device to mount after initrd */
+
+	KERN_SPARC_REBOOT=21,	/* reboot command on Sparc */
+	KERN_CTLALTDEL=22,	/* int: allow ctl-alt-del to reboot */
+	KERN_PRINTK=23,		/* struct: control printk logging parameters */
+	KERN_NAMETRANS=24,	/* Name translation */
+	KERN_PPC_HTABRECLAIM=25, /* turn htab reclaimation on/off on PPC */
+	KERN_PPC_ZEROPAGED=26,	/* turn idle page zeroing on/off on PPC */
+	KERN_PPC_POWERSAVE_NAP=27, /* use nap mode for power saving */
+	KERN_MODPROBE=28,
+	KERN_SG_BIG_BUFF=29,
+	KERN_ACCT=30,		/* BSD process accounting parameters */
+	KERN_PPC_L2CR=31,	/* l2cr register on PPC */
+
+	KERN_RTSIGNR=32,	/* Number of rt sigs queued */
+	KERN_RTSIGMAX=33,	/* Max queuable */
+	
+	KERN_SHMMAX=34,         /* long: Maximum shared memory segment */
+	KERN_MSGMAX=35,         /* int: Maximum size of a messege */
+	KERN_MSGMNB=36,         /* int: Maximum message queue size */
+	KERN_MSGPOOL=37,        /* int: Maximum system message pool size */
+	KERN_SYSRQ=38,		/* int: Sysreq enable */
+	KERN_MAX_THREADS=39,	/* int: Maximum nr of threads in the system */
+ 	KERN_RANDOM=40,		/* Random driver */
+ 	KERN_SHMALL=41,		/* int: Maximum size of shared memory */
+ 	KERN_MSGMNI=42,		/* int: msg queue identifiers */
+ 	KERN_SEM=43,		/* struct: sysv semaphore limits */
+ 	KERN_SPARC_STOP_A=44,	/* int: Sparc Stop-A enable */
+ 	KERN_SHMMNI=45,		/* int: shm array identifiers */
+	KERN_OVERFLOWUID=46,	/* int: overflow UID */
+	KERN_OVERFLOWGID=47,	/* int: overflow GID */
+	KERN_SHMPATH=48,	/* string: path to shm fs */
+	KERN_HOTPLUG=49,	/* string: path to uevent helper (deprecated) */
+	KERN_IEEE_EMULATION_WARNINGS=50, /* int: unimplemented ieee instructions */
+	KERN_S390_USER_DEBUG_LOGGING=51,  /* int: dumps of user faults */
+	KERN_CORE_USES_PID=52,		/* int: use core or core.%pid */
+	KERN_TAINTED=53,	/* int: various kernel tainted flags */
+	KERN_CADPID=54,		/* int: PID of the process to notify on CAD */
+	KERN_PIDMAX=55,		/* int: PID # limit */
+  	KERN_CORE_PATTERN=56,	/* string: pattern for core-file names */
+	KERN_PANIC_ON_OOPS=57,  /* int: whether we will panic on an oops */
+	KERN_HPPA_PWRSW=58,	/* int: hppa soft-power enable */
+	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
+	KERN_PRINTK_RATELIMIT=60, /* int: tune printk ratelimiting */
+	KERN_PRINTK_RATELIMIT_BURST=61,	/* int: tune printk ratelimiting */
+	KERN_PTY=62,		/* dir: pty driver */
+	KERN_NGROUPS_MAX=63,	/* int: NGROUPS_MAX */
+	KERN_SPARC_SCONS_PWROFF=64, /* int: serial console power-off halt */
+	KERN_HZ_TIMER=65,	/* int: hz timer on or off */
+	KERN_UNKNOWN_NMI_PANIC=66, /* int: unknown nmi panic flag */
+	KERN_BOOTLOADER_TYPE=67, /* int: boot loader type */
+	KERN_RANDOMIZE=68, /* int: randomize virtual address space */
+	KERN_SETUID_DUMPABLE=69, /* int: behaviour of dumps for setuid core */
+	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
+	KERN_ACPI_VIDEO_FLAGS=71, /* int: flags for setting up video after ACPI sleep */
+	KERN_IA64_UNALIGNED=72, /* int: ia64 unaligned userland trap enable */
+	KERN_COMPAT_LOG=73,	/* int: print compat layer  messages */
+	KERN_MAX_LOCK_DEPTH=74,
+	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
+	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
+};
+
+
+
+/* CTL_VM names: */
+enum
+{
+	VM_UNUSED1=1,		/* was: struct: Set vm swapping control */
+	VM_UNUSED2=2,		/* was; int: Linear or sqrt() swapout for hogs */
+	VM_UNUSED3=3,		/* was: struct: Set free page thresholds */
+	VM_UNUSED4=4,		/* Spare */
+	VM_OVERCOMMIT_MEMORY=5,	/* Turn off the virtual memory safety limit */
+	VM_UNUSED5=6,		/* was: struct: Set buffer memory thresholds */
+	VM_UNUSED7=7,		/* was: struct: Set cache memory thresholds */
+	VM_UNUSED8=8,		/* was: struct: Control kswapd behaviour */
+	VM_UNUSED9=9,		/* was: struct: Set page table cache parameters */
+	VM_PAGE_CLUSTER=10,	/* int: set number of pages to swap together */
+	VM_DIRTY_BACKGROUND=11,	/* dirty_background_ratio */
+	VM_DIRTY_RATIO=12,	/* dirty_ratio */
+	VM_DIRTY_WB_CS=13,	/* dirty_writeback_centisecs */
+	VM_DIRTY_EXPIRE_CS=14,	/* dirty_expire_centisecs */
+	VM_NR_PDFLUSH_THREADS=15, /* nr_pdflush_threads */
+	VM_OVERCOMMIT_RATIO=16, /* percent of RAM to allow overcommit in */
+	VM_PAGEBUF=17,		/* struct: Control pagebuf parameters */
+	VM_HUGETLB_PAGES=18,	/* int: Number of available Huge Pages */
+	VM_SWAPPINESS=19,	/* Tendency to steal mapped memory */
+	VM_LOWMEM_RESERVE_RATIO=20,/* reservation ratio for lower memory zones */
+	VM_MIN_FREE_KBYTES=21,	/* Minimum free kilobytes to maintain */
+	VM_MAX_MAP_COUNT=22,	/* int: Maximum number of mmaps/address-space */
+	VM_LAPTOP_MODE=23,	/* vm laptop mode */
+	VM_BLOCK_DUMP=24,	/* block dump mode */
+	VM_HUGETLB_GROUP=25,	/* permitted hugetlb group */
+	VM_VFS_CACHE_PRESSURE=26, /* dcache/icache reclaim pressure */
+	VM_LEGACY_VA_LAYOUT=27, /* legacy/compatibility virtual address space layout */
+	VM_SWAP_TOKEN_TIMEOUT=28, /* default time for token time out */
+	VM_DROP_PAGECACHE=29,	/* int: nuke lots of pagecache */
+	VM_PERCPU_PAGELIST_FRACTION=30,/* int: fraction of pages in each percpu_pagelist */
+	VM_ZONE_RECLAIM_MODE=31, /* reclaim local zone memory before going off node */
+	VM_MIN_UNMAPPED=32,	/* Set min percent of unmapped pages */
+	VM_PANIC_ON_OOM=33,	/* panic at out-of-memory */
+	VM_VDSO_ENABLED=34,	/* map VDSO into new processes? */
+	VM_MIN_SLAB=35,		 /* Percent pages ignored by zone reclaim */
+};
+
+
+/* CTL_NET names: */
+enum
+{
+	NET_CORE=1,
+	NET_ETHER=2,
+	NET_802=3,
+	NET_UNIX=4,
+	NET_IPV4=5,
+	NET_IPX=6,
+	NET_ATALK=7,
+	NET_NETROM=8,
+	NET_AX25=9,
+	NET_BRIDGE=10,
+	NET_ROSE=11,
+	NET_IPV6=12,
+	NET_X25=13,
+	NET_TR=14,
+	NET_DECNET=15,
+	NET_ECONET=16,
+	NET_SCTP=17,
+	NET_LLC=18,
+	NET_NETFILTER=19,
+	NET_DCCP=20,
+	NET_IRDA=412,
+};
+
+/* /proc/sys/kernel/random */
+enum
+{
+	RANDOM_POOLSIZE=1,
+	RANDOM_ENTROPY_COUNT=2,
+	RANDOM_READ_THRESH=3,
+	RANDOM_WRITE_THRESH=4,
+	RANDOM_BOOT_ID=5,
+	RANDOM_UUID=6
+};
+
+/* /proc/sys/kernel/pty */
+enum
+{
+	PTY_MAX=1,
+	PTY_NR=2
+};
+
+/* /proc/sys/bus/isa */
+enum
+{
+	BUS_ISA_MEM_BASE=1,
+	BUS_ISA_PORT_BASE=2,
+	BUS_ISA_PORT_SHIFT=3
+};
+
+/* /proc/sys/net/core */
+enum
+{
+	NET_CORE_WMEM_MAX=1,
+	NET_CORE_RMEM_MAX=2,
+	NET_CORE_WMEM_DEFAULT=3,
+	NET_CORE_RMEM_DEFAULT=4,
+/* was	NET_CORE_DESTROY_DELAY */
+	NET_CORE_MAX_BACKLOG=6,
+	NET_CORE_FASTROUTE=7,
+	NET_CORE_MSG_COST=8,
+	NET_CORE_MSG_BURST=9,
+	NET_CORE_OPTMEM_MAX=10,
+	NET_CORE_HOT_LIST_LENGTH=11,
+	NET_CORE_DIVERT_VERSION=12,
+	NET_CORE_NO_CONG_THRESH=13,
+	NET_CORE_NO_CONG=14,
+	NET_CORE_LO_CONG=15,
+	NET_CORE_MOD_CONG=16,
+	NET_CORE_DEV_WEIGHT=17,
+	NET_CORE_SOMAXCONN=18,
+	NET_CORE_BUDGET=19,
+	NET_CORE_AEVENT_ETIME=20,
+	NET_CORE_AEVENT_RSEQTH=21,
+	NET_CORE_WARNINGS=22,
+};
+
+/* /proc/sys/net/ethernet */
+
+/* /proc/sys/net/802 */
+
+/* /proc/sys/net/unix */
+
+enum
+{
+	NET_UNIX_DESTROY_DELAY=1,
+	NET_UNIX_DELETE_DELAY=2,
+	NET_UNIX_MAX_DGRAM_QLEN=3,
+};
+
+/* /proc/sys/net/netfilter */
+enum
+{
+	NET_NF_CONNTRACK_MAX=1,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
+	NET_NF_CONNTRACK_UDP_TIMEOUT=10,
+	NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
+	NET_NF_CONNTRACK_ICMP_TIMEOUT=12,
+	NET_NF_CONNTRACK_GENERIC_TIMEOUT=13,
+	NET_NF_CONNTRACK_BUCKETS=14,
+	NET_NF_CONNTRACK_LOG_INVALID=15,
+	NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
+	NET_NF_CONNTRACK_TCP_LOOSE=17,
+	NET_NF_CONNTRACK_TCP_BE_LIBERAL=18,
+	NET_NF_CONNTRACK_TCP_MAX_RETRANS=19,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
+	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
+	NET_NF_CONNTRACK_COUNT=27,
+	NET_NF_CONNTRACK_ICMPV6_TIMEOUT=28,
+	NET_NF_CONNTRACK_FRAG6_TIMEOUT=29,
+	NET_NF_CONNTRACK_FRAG6_LOW_THRESH=30,
+	NET_NF_CONNTRACK_FRAG6_HIGH_THRESH=31,
+	NET_NF_CONNTRACK_CHECKSUM=32,
+};
+
+/* /proc/sys/net/ipv4 */
+enum
+{
+	/* v2.0 compatibile variables */
+	NET_IPV4_FORWARD=8,
+	NET_IPV4_DYNADDR=9,
+
+	NET_IPV4_CONF=16,
+	NET_IPV4_NEIGH=17,
+	NET_IPV4_ROUTE=18,
+	NET_IPV4_FIB_HASH=19,
+	NET_IPV4_NETFILTER=20,
+
+	NET_IPV4_TCP_TIMESTAMPS=33,
+	NET_IPV4_TCP_WINDOW_SCALING=34,
+	NET_IPV4_TCP_SACK=35,
+	NET_IPV4_TCP_RETRANS_COLLAPSE=36,
+	NET_IPV4_DEFAULT_TTL=37,
+	NET_IPV4_AUTOCONFIG=38,
+	NET_IPV4_NO_PMTU_DISC=39,
+	NET_IPV4_TCP_SYN_RETRIES=40,
+	NET_IPV4_IPFRAG_HIGH_THRESH=41,
+	NET_IPV4_IPFRAG_LOW_THRESH=42,
+	NET_IPV4_IPFRAG_TIME=43,
+	NET_IPV4_TCP_MAX_KA_PROBES=44,
+	NET_IPV4_TCP_KEEPALIVE_TIME=45,
+	NET_IPV4_TCP_KEEPALIVE_PROBES=46,
+	NET_IPV4_TCP_RETRIES1=47,
+	NET_IPV4_TCP_RETRIES2=48,
+	NET_IPV4_TCP_FIN_TIMEOUT=49,
+	NET_IPV4_IP_MASQ_DEBUG=50,
+	NET_TCP_SYNCOOKIES=51,
+	NET_TCP_STDURG=52,
+	NET_TCP_RFC1337=53,
+	NET_TCP_SYN_TAILDROP=54,
+	NET_TCP_MAX_SYN_BACKLOG=55,
+	NET_IPV4_LOCAL_PORT_RANGE=56,
+	NET_IPV4_ICMP_ECHO_IGNORE_ALL=57,
+	NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS=58,
+	NET_IPV4_ICMP_SOURCEQUENCH_RATE=59,
+	NET_IPV4_ICMP_DESTUNREACH_RATE=60,
+	NET_IPV4_ICMP_TIMEEXCEED_RATE=61,
+	NET_IPV4_ICMP_PARAMPROB_RATE=62,
+	NET_IPV4_ICMP_ECHOREPLY_RATE=63,
+	NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES=64,
+	NET_IPV4_IGMP_MAX_MEMBERSHIPS=65,
+	NET_TCP_TW_RECYCLE=66,
+	NET_IPV4_ALWAYS_DEFRAG=67,
+	NET_IPV4_TCP_KEEPALIVE_INTVL=68,
+	NET_IPV4_INET_PEER_THRESHOLD=69,
+	NET_IPV4_INET_PEER_MINTTL=70,
+	NET_IPV4_INET_PEER_MAXTTL=71,
+	NET_IPV4_INET_PEER_GC_MINTIME=72,
+	NET_IPV4_INET_PEER_GC_MAXTIME=73,
+	NET_TCP_ORPHAN_RETRIES=74,
+	NET_TCP_ABORT_ON_OVERFLOW=75,
+	NET_TCP_SYNACK_RETRIES=76,
+	NET_TCP_MAX_ORPHANS=77,
+	NET_TCP_MAX_TW_BUCKETS=78,
+	NET_TCP_FACK=79,
+	NET_TCP_REORDERING=80,
+	NET_TCP_ECN=81,
+	NET_TCP_DSACK=82,
+	NET_TCP_MEM=83,
+	NET_TCP_WMEM=84,
+	NET_TCP_RMEM=85,
+	NET_TCP_APP_WIN=86,
+	NET_TCP_ADV_WIN_SCALE=87,
+	NET_IPV4_NONLOCAL_BIND=88,
+	NET_IPV4_ICMP_RATELIMIT=89,
+	NET_IPV4_ICMP_RATEMASK=90,
+	NET_TCP_TW_REUSE=91,
+	NET_TCP_FRTO=92,
+	NET_TCP_LOW_LATENCY=93,
+	NET_IPV4_IPFRAG_SECRET_INTERVAL=94,
+	NET_IPV4_IGMP_MAX_MSF=96,
+	NET_TCP_NO_METRICS_SAVE=97,
+	NET_TCP_DEFAULT_WIN_SCALE=105,
+	NET_TCP_MODERATE_RCVBUF=106,
+	NET_TCP_TSO_WIN_DIVISOR=107,
+	NET_TCP_BIC_BETA=108,
+	NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR=109,
+	NET_TCP_CONG_CONTROL=110,
+	NET_TCP_ABC=111,
+	NET_IPV4_IPFRAG_MAX_DIST=112,
+ 	NET_TCP_MTU_PROBING=113,
+	NET_TCP_BASE_MSS=114,
+	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS=115,
+	NET_TCP_DMA_COPYBREAK=116,
+	NET_TCP_SLOW_START_AFTER_IDLE=117,
+	NET_CIPSOV4_CACHE_ENABLE=118,
+	NET_CIPSOV4_CACHE_BUCKET_SIZE=119,
+	NET_CIPSOV4_RBM_OPTFMT=120,
+	NET_CIPSOV4_RBM_STRICTVALID=121,
+	NET_TCP_AVAIL_CONG_CONTROL=122,
+	NET_TCP_ALLOWED_CONG_CONTROL=123,
+	NET_TCP_MAX_SSTHRESH=124,
+	NET_TCP_FRTO_RESPONSE=125,
+};
+
+enum {
+	NET_IPV4_ROUTE_FLUSH=1,
+	NET_IPV4_ROUTE_MIN_DELAY=2, /* obsolete since 2.6.25 */
+	NET_IPV4_ROUTE_MAX_DELAY=3, /* obsolete since 2.6.25 */
+	NET_IPV4_ROUTE_GC_THRESH=4,
+	NET_IPV4_ROUTE_MAX_SIZE=5,
+	NET_IPV4_ROUTE_GC_MIN_INTERVAL=6,
+	NET_IPV4_ROUTE_GC_TIMEOUT=7,
+	NET_IPV4_ROUTE_GC_INTERVAL=8,
+	NET_IPV4_ROUTE_REDIRECT_LOAD=9,
+	NET_IPV4_ROUTE_REDIRECT_NUMBER=10,
+	NET_IPV4_ROUTE_REDIRECT_SILENCE=11,
+	NET_IPV4_ROUTE_ERROR_COST=12,
+	NET_IPV4_ROUTE_ERROR_BURST=13,
+	NET_IPV4_ROUTE_GC_ELASTICITY=14,
+	NET_IPV4_ROUTE_MTU_EXPIRES=15,
+	NET_IPV4_ROUTE_MIN_PMTU=16,
+	NET_IPV4_ROUTE_MIN_ADVMSS=17,
+	NET_IPV4_ROUTE_SECRET_INTERVAL=18,
+	NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS=19,
+};
+
+enum
+{
+	NET_PROTO_CONF_ALL=-2,
+	NET_PROTO_CONF_DEFAULT=-3
+
+	/* And device ifindices ... */
+};
+
+enum
+{
+	NET_IPV4_CONF_FORWARDING=1,
+	NET_IPV4_CONF_MC_FORWARDING=2,
+	NET_IPV4_CONF_PROXY_ARP=3,
+	NET_IPV4_CONF_ACCEPT_REDIRECTS=4,
+	NET_IPV4_CONF_SECURE_REDIRECTS=5,
+	NET_IPV4_CONF_SEND_REDIRECTS=6,
+	NET_IPV4_CONF_SHARED_MEDIA=7,
+	NET_IPV4_CONF_RP_FILTER=8,
+	NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE=9,
+	NET_IPV4_CONF_BOOTP_RELAY=10,
+	NET_IPV4_CONF_LOG_MARTIANS=11,
+	NET_IPV4_CONF_TAG=12,
+	NET_IPV4_CONF_ARPFILTER=13,
+	NET_IPV4_CONF_MEDIUM_ID=14,
+	NET_IPV4_CONF_NOXFRM=15,
+	NET_IPV4_CONF_NOPOLICY=16,
+	NET_IPV4_CONF_FORCE_IGMP_VERSION=17,
+	NET_IPV4_CONF_ARP_ANNOUNCE=18,
+	NET_IPV4_CONF_ARP_IGNORE=19,
+	NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
+	NET_IPV4_CONF_ARP_ACCEPT=21,
+	NET_IPV4_CONF_ARP_NOTIFY=22,
+	__NET_IPV4_CONF_MAX
+};
+
+/* /proc/sys/net/ipv4/netfilter */
+enum
+{
+	NET_IPV4_NF_CONNTRACK_MAX=1,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT=2,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV=3,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED=4,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT=5,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT=6,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK=7,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT=8,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE=9,
+	NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT=10,
+	NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM=11,
+	NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT=12,
+	NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT=13,
+	NET_IPV4_NF_CONNTRACK_BUCKETS=14,
+	NET_IPV4_NF_CONNTRACK_LOG_INVALID=15,
+	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS=16,
+	NET_IPV4_NF_CONNTRACK_TCP_LOOSE=17,
+	NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL=18,
+	NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS=19,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED=20,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT=21,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED=22,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED=23,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT=24,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD=25,
+ 	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT=26,
+	NET_IPV4_NF_CONNTRACK_COUNT=27,
+	NET_IPV4_NF_CONNTRACK_CHECKSUM=28,
+};
+ 
+/* /proc/sys/net/ipv6 */
+enum {
+	NET_IPV6_CONF=16,
+	NET_IPV6_NEIGH=17,
+	NET_IPV6_ROUTE=18,
+	NET_IPV6_ICMP=19,
+	NET_IPV6_BINDV6ONLY=20,
+	NET_IPV6_IP6FRAG_HIGH_THRESH=21,
+	NET_IPV6_IP6FRAG_LOW_THRESH=22,
+	NET_IPV6_IP6FRAG_TIME=23,
+	NET_IPV6_IP6FRAG_SECRET_INTERVAL=24,
+	NET_IPV6_MLD_MAX_MSF=25,
+};
+
+enum {
+	NET_IPV6_ROUTE_FLUSH=1,
+	NET_IPV6_ROUTE_GC_THRESH=2,
+	NET_IPV6_ROUTE_MAX_SIZE=3,
+	NET_IPV6_ROUTE_GC_MIN_INTERVAL=4,
+	NET_IPV6_ROUTE_GC_TIMEOUT=5,
+	NET_IPV6_ROUTE_GC_INTERVAL=6,
+	NET_IPV6_ROUTE_GC_ELASTICITY=7,
+	NET_IPV6_ROUTE_MTU_EXPIRES=8,
+	NET_IPV6_ROUTE_MIN_ADVMSS=9,
+	NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS=10
+};
+
+enum {
+	NET_IPV6_FORWARDING=1,
+	NET_IPV6_HOP_LIMIT=2,
+	NET_IPV6_MTU=3,
+	NET_IPV6_ACCEPT_RA=4,
+	NET_IPV6_ACCEPT_REDIRECTS=5,
+	NET_IPV6_AUTOCONF=6,
+	NET_IPV6_DAD_TRANSMITS=7,
+	NET_IPV6_RTR_SOLICITS=8,
+	NET_IPV6_RTR_SOLICIT_INTERVAL=9,
+	NET_IPV6_RTR_SOLICIT_DELAY=10,
+	NET_IPV6_USE_TEMPADDR=11,
+	NET_IPV6_TEMP_VALID_LFT=12,
+	NET_IPV6_TEMP_PREFERED_LFT=13,
+	NET_IPV6_REGEN_MAX_RETRY=14,
+	NET_IPV6_MAX_DESYNC_FACTOR=15,
+	NET_IPV6_MAX_ADDRESSES=16,
+	NET_IPV6_FORCE_MLD_VERSION=17,
+	NET_IPV6_ACCEPT_RA_DEFRTR=18,
+	NET_IPV6_ACCEPT_RA_PINFO=19,
+	NET_IPV6_ACCEPT_RA_RTR_PREF=20,
+	NET_IPV6_RTR_PROBE_INTERVAL=21,
+	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
+	NET_IPV6_PROXY_NDP=23,
+	NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
+	__NET_IPV6_MAX
+};
+
+/* /proc/sys/net/ipv6/icmp */
+enum {
+	NET_IPV6_ICMP_RATELIMIT=1
+};
+
+/* /proc/sys/net/<protocol>/neigh/<dev> */
+enum {
+	NET_NEIGH_MCAST_SOLICIT=1,
+	NET_NEIGH_UCAST_SOLICIT=2,
+	NET_NEIGH_APP_SOLICIT=3,
+	NET_NEIGH_RETRANS_TIME=4,
+	NET_NEIGH_REACHABLE_TIME=5,
+	NET_NEIGH_DELAY_PROBE_TIME=6,
+	NET_NEIGH_GC_STALE_TIME=7,
+	NET_NEIGH_UNRES_QLEN=8,
+	NET_NEIGH_PROXY_QLEN=9,
+	NET_NEIGH_ANYCAST_DELAY=10,
+	NET_NEIGH_PROXY_DELAY=11,
+	NET_NEIGH_LOCKTIME=12,
+	NET_NEIGH_GC_INTERVAL=13,
+	NET_NEIGH_GC_THRESH1=14,
+	NET_NEIGH_GC_THRESH2=15,
+	NET_NEIGH_GC_THRESH3=16,
+	NET_NEIGH_RETRANS_TIME_MS=17,
+	NET_NEIGH_REACHABLE_TIME_MS=18,
+	__NET_NEIGH_MAX
+};
+
+/* /proc/sys/net/dccp */
+enum {
+	NET_DCCP_DEFAULT=1,
+};
+
+/* /proc/sys/net/ipx */
+enum {
+	NET_IPX_PPROP_BROADCASTING=1,
+	NET_IPX_FORWARDING=2
+};
+
+/* /proc/sys/net/llc */
+enum {
+	NET_LLC2=1,
+	NET_LLC_STATION=2,
+};
+
+/* /proc/sys/net/llc/llc2 */
+enum {
+	NET_LLC2_TIMEOUT=1,
+};
+
+/* /proc/sys/net/llc/station */
+enum {
+	NET_LLC_STATION_ACK_TIMEOUT=1,
+};
+
+/* /proc/sys/net/llc/llc2/timeout */
+enum {
+	NET_LLC2_ACK_TIMEOUT=1,
+	NET_LLC2_P_TIMEOUT=2,
+	NET_LLC2_REJ_TIMEOUT=3,
+	NET_LLC2_BUSY_TIMEOUT=4,
+};
+
+/* /proc/sys/net/appletalk */
+enum {
+	NET_ATALK_AARP_EXPIRY_TIME=1,
+	NET_ATALK_AARP_TICK_TIME=2,
+	NET_ATALK_AARP_RETRANSMIT_LIMIT=3,
+	NET_ATALK_AARP_RESOLVE_TIME=4
+};
+
+
+/* /proc/sys/net/netrom */
+enum {
+	NET_NETROM_DEFAULT_PATH_QUALITY=1,
+	NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER=2,
+	NET_NETROM_NETWORK_TTL_INITIALISER=3,
+	NET_NETROM_TRANSPORT_TIMEOUT=4,
+	NET_NETROM_TRANSPORT_MAXIMUM_TRIES=5,
+	NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY=6,
+	NET_NETROM_TRANSPORT_BUSY_DELAY=7,
+	NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE=8,
+	NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT=9,
+	NET_NETROM_ROUTING_CONTROL=10,
+	NET_NETROM_LINK_FAILS_COUNT=11,
+	NET_NETROM_RESET=12
+};
+
+/* /proc/sys/net/ax25 */
+enum {
+	NET_AX25_IP_DEFAULT_MODE=1,
+	NET_AX25_DEFAULT_MODE=2,
+	NET_AX25_BACKOFF_TYPE=3,
+	NET_AX25_CONNECT_MODE=4,
+	NET_AX25_STANDARD_WINDOW=5,
+	NET_AX25_EXTENDED_WINDOW=6,
+	NET_AX25_T1_TIMEOUT=7,
+	NET_AX25_T2_TIMEOUT=8,
+	NET_AX25_T3_TIMEOUT=9,
+	NET_AX25_IDLE_TIMEOUT=10,
+	NET_AX25_N2=11,
+	NET_AX25_PACLEN=12,
+	NET_AX25_PROTOCOL=13,
+	NET_AX25_DAMA_SLAVE_TIMEOUT=14
+};
+
+/* /proc/sys/net/rose */
+enum {
+	NET_ROSE_RESTART_REQUEST_TIMEOUT=1,
+	NET_ROSE_CALL_REQUEST_TIMEOUT=2,
+	NET_ROSE_RESET_REQUEST_TIMEOUT=3,
+	NET_ROSE_CLEAR_REQUEST_TIMEOUT=4,
+	NET_ROSE_ACK_HOLD_BACK_TIMEOUT=5,
+	NET_ROSE_ROUTING_CONTROL=6,
+	NET_ROSE_LINK_FAIL_TIMEOUT=7,
+	NET_ROSE_MAX_VCS=8,
+	NET_ROSE_WINDOW_SIZE=9,
+	NET_ROSE_NO_ACTIVITY_TIMEOUT=10
+};
+
+/* /proc/sys/net/x25 */
+enum {
+	NET_X25_RESTART_REQUEST_TIMEOUT=1,
+	NET_X25_CALL_REQUEST_TIMEOUT=2,
+	NET_X25_RESET_REQUEST_TIMEOUT=3,
+	NET_X25_CLEAR_REQUEST_TIMEOUT=4,
+	NET_X25_ACK_HOLD_BACK_TIMEOUT=5,
+	NET_X25_FORWARD=6
+};
+
+/* /proc/sys/net/token-ring */
+enum
+{
+	NET_TR_RIF_TIMEOUT=1
+};
+
+/* /proc/sys/net/decnet/ */
+enum {
+	NET_DECNET_NODE_TYPE = 1,
+	NET_DECNET_NODE_ADDRESS = 2,
+	NET_DECNET_NODE_NAME = 3,
+	NET_DECNET_DEFAULT_DEVICE = 4,
+	NET_DECNET_TIME_WAIT = 5,
+	NET_DECNET_DN_COUNT = 6,
+	NET_DECNET_DI_COUNT = 7,
+	NET_DECNET_DR_COUNT = 8,
+	NET_DECNET_DST_GC_INTERVAL = 9,
+	NET_DECNET_CONF = 10,
+	NET_DECNET_NO_FC_MAX_CWND = 11,
+	NET_DECNET_MEM = 12,
+	NET_DECNET_RMEM = 13,
+	NET_DECNET_WMEM = 14,
+	NET_DECNET_DEBUG_LEVEL = 255
+};
+
+/* /proc/sys/net/decnet/conf/<dev> */
+enum {
+	NET_DECNET_CONF_LOOPBACK = -2,
+	NET_DECNET_CONF_DDCMP = -3,
+	NET_DECNET_CONF_PPP = -4,
+	NET_DECNET_CONF_X25 = -5,
+	NET_DECNET_CONF_GRE = -6,
+	NET_DECNET_CONF_ETHER = -7
+
+	/* ... and ifindex of devices */
+};
+
+/* /proc/sys/net/decnet/conf/<dev>/ */
+enum {
+	NET_DECNET_CONF_DEV_PRIORITY = 1,
+	NET_DECNET_CONF_DEV_T1 = 2,
+	NET_DECNET_CONF_DEV_T2 = 3,
+	NET_DECNET_CONF_DEV_T3 = 4,
+	NET_DECNET_CONF_DEV_FORWARDING = 5,
+	NET_DECNET_CONF_DEV_BLKSIZE = 6,
+	NET_DECNET_CONF_DEV_STATE = 7
+};
+
+/* /proc/sys/net/sctp */
+enum {
+	NET_SCTP_RTO_INITIAL = 1,
+	NET_SCTP_RTO_MIN     = 2,
+	NET_SCTP_RTO_MAX     = 3,
+	NET_SCTP_RTO_ALPHA   = 4,
+	NET_SCTP_RTO_BETA    = 5,
+	NET_SCTP_VALID_COOKIE_LIFE       =  6,
+	NET_SCTP_ASSOCIATION_MAX_RETRANS =  7,
+	NET_SCTP_PATH_MAX_RETRANS        =  8,
+	NET_SCTP_MAX_INIT_RETRANSMITS    =  9,
+	NET_SCTP_HB_INTERVAL             = 10,
+	NET_SCTP_PRESERVE_ENABLE         = 11,
+	NET_SCTP_MAX_BURST               = 12,
+	NET_SCTP_ADDIP_ENABLE		 = 13,
+	NET_SCTP_PRSCTP_ENABLE		 = 14,
+	NET_SCTP_SNDBUF_POLICY		 = 15,
+	NET_SCTP_SACK_TIMEOUT		 = 16,
+	NET_SCTP_RCVBUF_POLICY		 = 17,
+};
+
+/* /proc/sys/net/bridge */
+enum {
+	NET_BRIDGE_NF_CALL_ARPTABLES = 1,
+	NET_BRIDGE_NF_CALL_IPTABLES = 2,
+	NET_BRIDGE_NF_CALL_IP6TABLES = 3,
+	NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
+	NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
+};
+
+/* proc/sys/net/irda */
+enum {
+	NET_IRDA_DISCOVERY=1,
+	NET_IRDA_DEVNAME=2,
+	NET_IRDA_DEBUG=3,
+	NET_IRDA_FAST_POLL=4,
+	NET_IRDA_DISCOVERY_SLOTS=5,
+	NET_IRDA_DISCOVERY_TIMEOUT=6,
+	NET_IRDA_SLOT_TIMEOUT=7,
+	NET_IRDA_MAX_BAUD_RATE=8,
+	NET_IRDA_MIN_TX_TURN_TIME=9,
+	NET_IRDA_MAX_TX_DATA_SIZE=10,
+	NET_IRDA_MAX_TX_WINDOW=11,
+	NET_IRDA_MAX_NOREPLY_TIME=12,
+	NET_IRDA_WARN_NOREPLY_TIME=13,
+	NET_IRDA_LAP_KEEPALIVE_TIME=14,
+};
+
+
+/* CTL_FS names: */
+enum
+{
+	FS_NRINODE=1,	/* int:current number of allocated inodes */
+	FS_STATINODE=2,
+	FS_MAXINODE=3,	/* int:maximum number of inodes that can be allocated */
+	FS_NRDQUOT=4,	/* int:current number of allocated dquots */
+	FS_MAXDQUOT=5,	/* int:maximum number of dquots that can be allocated */
+	FS_NRFILE=6,	/* int:current number of allocated filedescriptors */
+	FS_MAXFILE=7,	/* int:maximum number of filedescriptors that can be allocated */
+	FS_DENTRY=8,
+	FS_NRSUPER=9,	/* int:current number of allocated super_blocks */
+	FS_MAXSUPER=10,	/* int:maximum number of super_blocks that can be allocated */
+	FS_OVERFLOWUID=11,	/* int: overflow UID */
+	FS_OVERFLOWGID=12,	/* int: overflow GID */
+	FS_LEASES=13,	/* int: leases enabled */
+	FS_DIR_NOTIFY=14,	/* int: directory notification enabled */
+	FS_LEASE_TIME=15,	/* int: maximum time to wait for a lease break */
+	FS_DQSTATS=16,	/* disc quota usage statistics and control */
+	FS_XFS=17,	/* struct: control xfs parameters */
+	FS_AIO_NR=18,	/* current system-wide number of aio requests */
+	FS_AIO_MAX_NR=19,	/* system-wide maximum number of aio requests */
+	FS_INOTIFY=20,	/* inotify submenu */
+	FS_OCFS2=988,	/* ocfs2 */
+};
+
+/* /proc/sys/fs/quota/ */
+enum {
+	FS_DQ_LOOKUPS = 1,
+	FS_DQ_DROPS = 2,
+	FS_DQ_READS = 3,
+	FS_DQ_WRITES = 4,
+	FS_DQ_CACHE_HITS = 5,
+	FS_DQ_ALLOCATED = 6,
+	FS_DQ_FREE = 7,
+	FS_DQ_SYNCS = 8,
+	FS_DQ_WARNINGS = 9,
+};
+
+/* CTL_DEBUG names: */
+
+/* CTL_DEV names: */
+enum {
+	DEV_CDROM=1,
+	DEV_HWMON=2,
+	DEV_PARPORT=3,
+	DEV_RAID=4,
+	DEV_MAC_HID=5,
+	DEV_SCSI=6,
+	DEV_IPMI=7,
+};
+
+/* /proc/sys/dev/cdrom */
+enum {
+	DEV_CDROM_INFO=1,
+	DEV_CDROM_AUTOCLOSE=2,
+	DEV_CDROM_AUTOEJECT=3,
+	DEV_CDROM_DEBUG=4,
+	DEV_CDROM_LOCK=5,
+	DEV_CDROM_CHECK_MEDIA=6
+};
+
+/* /proc/sys/dev/parport */
+enum {
+	DEV_PARPORT_DEFAULT=-3
+};
+
+/* /proc/sys/dev/raid */
+enum {
+	DEV_RAID_SPEED_LIMIT_MIN=1,
+	DEV_RAID_SPEED_LIMIT_MAX=2
+};
+
+/* /proc/sys/dev/parport/default */
+enum {
+	DEV_PARPORT_DEFAULT_TIMESLICE=1,
+	DEV_PARPORT_DEFAULT_SPINTIME=2
+};
+
+/* /proc/sys/dev/parport/parport n */
+enum {
+	DEV_PARPORT_SPINTIME=1,
+	DEV_PARPORT_BASE_ADDR=2,
+	DEV_PARPORT_IRQ=3,
+	DEV_PARPORT_DMA=4,
+	DEV_PARPORT_MODES=5,
+	DEV_PARPORT_DEVICES=6,
+	DEV_PARPORT_AUTOPROBE=16
+};
+
+/* /proc/sys/dev/parport/parport n/devices/ */
+enum {
+	DEV_PARPORT_DEVICES_ACTIVE=-3,
+};
+
+/* /proc/sys/dev/parport/parport n/devices/device n */
+enum {
+	DEV_PARPORT_DEVICE_TIMESLICE=1,
+};
+
+/* /proc/sys/dev/mac_hid */
+enum {
+	DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES=1,
+	DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES=2,
+	DEV_MAC_HID_MOUSE_BUTTON_EMULATION=3,
+	DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE=4,
+	DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE=5,
+	DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES=6
+};
+
+/* /proc/sys/dev/scsi */
+enum {
+	DEV_SCSI_LOGGING_LEVEL=1,
+};
+
+/* /proc/sys/dev/ipmi */
+enum {
+	DEV_IPMI_POWEROFF_POWERCYCLE=1,
+};
+
+/* /proc/sys/abi */
+enum
+{
+	ABI_DEFHANDLER_COFF=1,	/* default handler for coff binaries */
+	ABI_DEFHANDLER_ELF=2, 	/* default handler for ELF binaries */
+	ABI_DEFHANDLER_LCALL7=3,/* default handler for procs using lcall7 */
+	ABI_DEFHANDLER_LIBCSO=4,/* default handler for an libc.so ELF interp */
+	ABI_TRACE=5,		/* tracing flags */
+	ABI_FAKE_UTSNAME=6,	/* fake target utsname information */
+};
+
+
+#endif /* _LINUX_SYSCTL_H */
diff -uNr linux-2.6.32/usr/include/linux/taskstats.h clean_modified/linux-2.6.32/usr/include/linux/taskstats.h
--- linux-2.6.32/usr/include/linux/taskstats.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/taskstats.h	2019-04-14 13:24:03.148850280 -0500
@@ -0,0 +1,212 @@
+/* taskstats.h - exporting per-task statistics
+ *
+ * Copyright (C) Shailabh Nagar, IBM Corp. 2006
+ *           (C) Balbir Singh,   IBM Corp. 2006
+ *           (C) Jay Lan,        SGI, 2006
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _LINUX_TASKSTATS_H
+#define _LINUX_TASKSTATS_H
+
+#include <linux/types.h>
+
+/* Format for per-task data returned to userland when
+ *	- a task exits
+ *	- listener requests stats for a task
+ *
+ * The struct is versioned. Newer versions should only add fields to
+ * the bottom of the struct to maintain backward compatibility.
+ *
+ *
+ * To add new fields
+ *	a) bump up TASKSTATS_VERSION
+ *	b) add comment indicating new version number at end of struct
+ *	c) add new fields after version comment; maintain 64-bit alignment
+ */
+
+
+#define TASKSTATS_VERSION	7
+#define TS_COMM_LEN		32	/* should be >= TASK_COMM_LEN
+					 * in linux/sched.h */
+
+struct taskstats {
+
+	/* The version number of this struct. This field is always set to
+	 * TAKSTATS_VERSION, which is defined in <linux/taskstats.h>.
+	 * Each time the struct is changed, the value should be incremented.
+	 */
+	__u16	version;
+	__u32	ac_exitcode;		/* Exit status */
+
+	/* The accounting flags of a task as defined in <linux/acct.h>
+	 * Defined values are AFORK, ASU, ACOMPAT, ACORE, and AXSIG.
+	 */
+	__u8	ac_flag;		/* Record flags */
+	__u8	ac_nice;		/* task_nice */
+
+	/* Delay accounting fields start
+	 *
+	 * All values, until comment "Delay accounting fields end" are
+	 * available only if delay accounting is enabled, even though the last
+	 * few fields are not delays
+	 *
+	 * xxx_count is the number of delay values recorded
+	 * xxx_delay_total is the corresponding cumulative delay in nanoseconds
+	 *
+	 * xxx_delay_total wraps around to zero on overflow
+	 * xxx_count incremented regardless of overflow
+	 */
+
+	/* Delay waiting for cpu, while runnable
+	 * count, delay_total NOT updated atomically
+	 */
+	__u64	cpu_count __attribute__((aligned(8)));
+	__u64	cpu_delay_total;
+
+	/* Following four fields atomically updated using task->delays->lock */
+
+	/* Delay waiting for synchronous block I/O to complete
+	 * does not account for delays in I/O submission
+	 */
+	__u64	blkio_count;
+	__u64	blkio_delay_total;
+
+	/* Delay waiting for page fault I/O (swap in only) */
+	__u64	swapin_count;
+	__u64	swapin_delay_total;
+
+	/* cpu "wall-clock" running time
+	 * On some architectures, value will adjust for cpu time stolen
+	 * from the kernel in involuntary waits due to virtualization.
+	 * Value is cumulative, in nanoseconds, without a corresponding count
+	 * and wraps around to zero silently on overflow
+	 */
+	__u64	cpu_run_real_total;
+
+	/* cpu "virtual" running time
+	 * Uses time intervals seen by the kernel i.e. no adjustment
+	 * for kernel's involuntary waits due to virtualization.
+	 * Value is cumulative, in nanoseconds, without a corresponding count
+	 * and wraps around to zero silently on overflow
+	 */
+	__u64	cpu_run_virtual_total;
+	/* Delay accounting fields end */
+	/* version 1 ends here */
+
+	/* Basic Accounting Fields start */
+	char	ac_comm[TS_COMM_LEN];	/* Command name */
+	__u8	ac_sched __attribute__((aligned(8)));
+					/* Scheduling discipline */
+	__u8	ac_pad[3];
+	__u32	ac_uid __attribute__((aligned(8)));
+					/* User ID */
+	__u32	ac_gid;			/* Group ID */
+	__u32	ac_pid;			/* Process ID */
+	__u32	ac_ppid;		/* Parent process ID */
+	__u32	ac_btime;		/* Begin time [sec since 1970] */
+	__u64	ac_etime __attribute__((aligned(8)));
+					/* Elapsed time [usec] */
+	__u64	ac_utime;		/* User CPU time [usec] */
+	__u64	ac_stime;		/* SYstem CPU time [usec] */
+	__u64	ac_minflt;		/* Minor Page Fault Count */
+	__u64	ac_majflt;		/* Major Page Fault Count */
+	/* Basic Accounting Fields end */
+
+	/* Extended accounting fields start */
+	/* Accumulated RSS usage in duration of a task, in MBytes-usecs.
+	 * The current rss usage is added to this counter every time
+	 * a tick is charged to a task's system time. So, at the end we
+	 * will have memory usage multiplied by system time. Thus an
+	 * average usage per system time unit can be calculated.
+	 */
+	__u64	coremem;		/* accumulated RSS usage in MB-usec */
+	/* Accumulated virtual memory usage in duration of a task.
+	 * Same as acct_rss_mem1 above except that we keep track of VM usage.
+	 */
+	__u64	virtmem;		/* accumulated VM  usage in MB-usec */
+
+	/* High watermark of RSS and virtual memory usage in duration of
+	 * a task, in KBytes.
+	 */
+	__u64	hiwater_rss;		/* High-watermark of RSS usage, in KB */
+	__u64	hiwater_vm;		/* High-water VM usage, in KB */
+
+	/* The following four fields are I/O statistics of a task. */
+	__u64	read_char;		/* bytes read */
+	__u64	write_char;		/* bytes written */
+	__u64	read_syscalls;		/* read syscalls */
+	__u64	write_syscalls;		/* write syscalls */
+	/* Extended accounting fields end */
+
+#define TASKSTATS_HAS_IO_ACCOUNTING
+	/* Per-task storage I/O accounting starts */
+	__u64	read_bytes;		/* bytes of read I/O */
+	__u64	write_bytes;		/* bytes of write I/O */
+	__u64	cancelled_write_bytes;	/* bytes of cancelled write I/O */
+
+	__u64  nvcsw;			/* voluntary_ctxt_switches */
+	__u64  nivcsw;			/* nonvoluntary_ctxt_switches */
+
+	/* time accounting for SMT machines */
+	__u64	ac_utimescaled;		/* utime scaled on frequency etc */
+	__u64	ac_stimescaled;		/* stime scaled on frequency etc */
+	__u64	cpu_scaled_run_real_total; /* scaled cpu_run_real_total */
+
+	/* Delay waiting for memory reclaim */
+	__u64	freepages_count;
+	__u64	freepages_delay_total;
+};
+
+
+/*
+ * Commands sent from userspace
+ * Not versioned. New commands should only be inserted at the enum's end
+ * prior to __TASKSTATS_CMD_MAX
+ */
+
+enum {
+	TASKSTATS_CMD_UNSPEC = 0,	/* Reserved */
+	TASKSTATS_CMD_GET,		/* user->kernel request/get-response */
+	TASKSTATS_CMD_NEW,		/* kernel->user event */
+	__TASKSTATS_CMD_MAX,
+};
+
+#define TASKSTATS_CMD_MAX (__TASKSTATS_CMD_MAX - 1)
+
+enum {
+	TASKSTATS_TYPE_UNSPEC = 0,	/* Reserved */
+	TASKSTATS_TYPE_PID,		/* Process id */
+	TASKSTATS_TYPE_TGID,		/* Thread group id */
+	TASKSTATS_TYPE_STATS,		/* taskstats structure */
+	TASKSTATS_TYPE_AGGR_PID,	/* contains pid + stats */
+	TASKSTATS_TYPE_AGGR_TGID,	/* contains tgid + stats */
+	__TASKSTATS_TYPE_MAX,
+};
+
+#define TASKSTATS_TYPE_MAX (__TASKSTATS_TYPE_MAX - 1)
+
+enum {
+	TASKSTATS_CMD_ATTR_UNSPEC = 0,
+	TASKSTATS_CMD_ATTR_PID,
+	TASKSTATS_CMD_ATTR_TGID,
+	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK,
+	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK,
+	__TASKSTATS_CMD_ATTR_MAX,
+};
+
+#define TASKSTATS_CMD_ATTR_MAX (__TASKSTATS_CMD_ATTR_MAX - 1)
+
+/* NETLINK_GENERIC related info */
+
+#define TASKSTATS_GENL_NAME	"TASKSTATS"
+#define TASKSTATS_GENL_VERSION	0x1
+
+#endif /* _LINUX_TASKSTATS_H */
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_gact.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_gact.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_gact.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_gact.h	2019-04-14 13:24:03.149826863 -0500
@@ -0,0 +1,35 @@
+#ifndef __LINUX_TC_GACT_H
+#define __LINUX_TC_GACT_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_GACT 5
+struct tc_gact
+{
+	tc_gen;
+
+};
+
+struct tc_gact_p
+{
+#define PGACT_NONE              0
+#define PGACT_NETRAND           1
+#define PGACT_DETERM            2
+#define MAX_RAND                (PGACT_DETERM + 1 )
+	__u16                 ptype;
+	__u16                 pval;
+	int                   paction;
+};
+ 
+enum
+{
+	TCA_GACT_UNSPEC,
+	TCA_GACT_TM,
+	TCA_GACT_PARMS,
+	TCA_GACT_PROB,
+	__TCA_GACT_MAX
+};
+#define TCA_GACT_MAX (__TCA_GACT_MAX - 1)
+ 
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_ipt.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_ipt.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_ipt.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_ipt.h	2019-04-14 13:24:03.149826863 -0500
@@ -0,0 +1,21 @@
+#ifndef __LINUX_TC_IPT_H
+#define __LINUX_TC_IPT_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_IPT 6
+
+enum
+{
+	TCA_IPT_UNSPEC,
+	TCA_IPT_TABLE,
+	TCA_IPT_HOOK,
+	TCA_IPT_INDEX,
+	TCA_IPT_CNT,
+	TCA_IPT_TM,
+	TCA_IPT_TARG,
+	__TCA_IPT_MAX
+};
+#define TCA_IPT_MAX (__TCA_IPT_MAX - 1)
+                                                                                
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_mirred.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_mirred.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_mirred.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_mirred.h	2019-04-14 13:24:03.149826863 -0500
@@ -0,0 +1,29 @@
+#ifndef __LINUX_TC_MIR_H
+#define __LINUX_TC_MIR_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_MIRRED 8
+#define TCA_EGRESS_REDIR 1  /* packet redirect to EGRESS*/
+#define TCA_EGRESS_MIRROR 2 /* mirror packet to EGRESS */
+#define TCA_INGRESS_REDIR 3  /* packet redirect to INGRESS*/
+#define TCA_INGRESS_MIRROR 4 /* mirror packet to INGRESS */
+                                                                                
+struct tc_mirred
+{
+	tc_gen;
+	int                     eaction;   /* one of IN/EGRESS_MIRROR/REDIR */
+	__u32                   ifindex;  /* ifindex of egress port */
+};
+                                                                                
+enum
+{
+	TCA_MIRRED_UNSPEC,
+	TCA_MIRRED_TM,
+	TCA_MIRRED_PARMS,
+	__TCA_MIRRED_MAX
+};
+#define TCA_MIRRED_MAX (__TCA_MIRRED_MAX - 1)
+                                                                                
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_nat.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_nat.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_nat.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_nat.h	2019-04-14 13:24:03.149826863 -0500
@@ -0,0 +1,29 @@
+#ifndef __LINUX_TC_NAT_H
+#define __LINUX_TC_NAT_H
+
+#include <linux/pkt_cls.h>
+#include <linux/types.h>
+
+#define TCA_ACT_NAT 9
+
+enum
+{
+	TCA_NAT_UNSPEC,
+	TCA_NAT_PARMS,
+	TCA_NAT_TM,
+	__TCA_NAT_MAX
+};
+#define TCA_NAT_MAX (__TCA_NAT_MAX - 1)
+
+#define TCA_NAT_FLAG_EGRESS 1
+
+struct tc_nat
+{
+	tc_gen;
+	__be32 old_addr;
+	__be32 new_addr;
+	__be32 mask;
+	__u32 flags;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_pedit.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_pedit.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_pedit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_pedit.h	2019-04-14 13:24:03.150786091 -0500
@@ -0,0 +1,37 @@
+#ifndef __LINUX_TC_PED_H
+#define __LINUX_TC_PED_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_PEDIT 7
+
+enum
+{
+	TCA_PEDIT_UNSPEC,
+	TCA_PEDIT_TM,
+	TCA_PEDIT_PARMS,
+	__TCA_PEDIT_MAX
+};
+#define TCA_PEDIT_MAX (__TCA_PEDIT_MAX - 1)
+                                                                                
+struct tc_pedit_key
+{
+	__u32           mask;  /* AND */
+	__u32           val;   /*XOR */
+	__u32           off;  /*offset */
+	__u32           at;
+	__u32           offmask;
+	__u32           shift;
+};
+                                                                                
+struct tc_pedit_sel
+{
+	tc_gen;
+	unsigned char           nkeys;
+	unsigned char           flags;
+	struct tc_pedit_key     keys[0];
+};
+#define tc_pedit tc_pedit_sel
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_act/tc_skbedit.h clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_skbedit.h
--- linux-2.6.32/usr/include/linux/tc_act/tc_skbedit.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_act/tc_skbedit.h	2019-04-14 13:24:03.150786091 -0500
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2008, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Author: Alexander Duyck <alexander.h.duyck@intel.com>
+ */
+
+#ifndef __LINUX_TC_SKBEDIT_H
+#define __LINUX_TC_SKBEDIT_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_SKBEDIT 11
+
+#define SKBEDIT_F_PRIORITY		0x1
+#define SKBEDIT_F_QUEUE_MAPPING		0x2
+
+struct tc_skbedit {
+	tc_gen;
+};
+
+enum {
+	TCA_SKBEDIT_UNSPEC,
+	TCA_SKBEDIT_TM,
+	TCA_SKBEDIT_PARMS,
+	TCA_SKBEDIT_PRIORITY,
+	TCA_SKBEDIT_QUEUE_MAPPING,
+	__TCA_SKBEDIT_MAX
+};
+#define TCA_SKBEDIT_MAX (__TCA_SKBEDIT_MAX - 1)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_ematch/tc_em_cmp.h clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_cmp.h
--- linux-2.6.32/usr/include/linux/tc_ematch/tc_em_cmp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_cmp.h	2019-04-14 13:24:03.150786091 -0500
@@ -0,0 +1,27 @@
+#ifndef __LINUX_TC_EM_CMP_H
+#define __LINUX_TC_EM_CMP_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+struct tcf_em_cmp
+{
+	__u32		val;
+	__u32		mask;
+	__u16		off;
+	__u8		align:4;
+	__u8		flags:4;
+	__u8		layer:4;
+	__u8		opnd:4;
+};
+
+enum
+{
+	TCF_EM_ALIGN_U8  = 1,
+	TCF_EM_ALIGN_U16 = 2,
+	TCF_EM_ALIGN_U32 = 4
+};
+
+#define TCF_EM_CMP_TRANS	1
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_ematch/tc_em_meta.h clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_meta.h
--- linux-2.6.32/usr/include/linux/tc_ematch/tc_em_meta.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_meta.h	2019-04-14 13:24:03.150786091 -0500
@@ -0,0 +1,96 @@
+#ifndef __LINUX_TC_EM_META_H
+#define __LINUX_TC_EM_META_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+enum
+{
+	TCA_EM_META_UNSPEC,
+	TCA_EM_META_HDR,
+	TCA_EM_META_LVALUE,
+	TCA_EM_META_RVALUE,
+	__TCA_EM_META_MAX
+};
+#define TCA_EM_META_MAX (__TCA_EM_META_MAX - 1)
+
+struct tcf_meta_val
+{
+	__u16			kind;
+	__u8			shift;
+	__u8			op;
+};
+
+#define TCF_META_TYPE_MASK	(0xf << 12)
+#define TCF_META_TYPE(kind)	(((kind) & TCF_META_TYPE_MASK) >> 12)
+#define TCF_META_ID_MASK	0x7ff
+#define TCF_META_ID(kind)	((kind) & TCF_META_ID_MASK)
+
+enum
+{
+	TCF_META_TYPE_VAR,
+	TCF_META_TYPE_INT,
+	__TCF_META_TYPE_MAX
+};
+#define TCF_META_TYPE_MAX (__TCF_META_TYPE_MAX - 1)
+
+enum
+{
+	TCF_META_ID_VALUE,
+	TCF_META_ID_RANDOM,
+	TCF_META_ID_LOADAVG_0,
+	TCF_META_ID_LOADAVG_1,
+	TCF_META_ID_LOADAVG_2,
+	TCF_META_ID_DEV,
+	TCF_META_ID_PRIORITY,
+	TCF_META_ID_PROTOCOL,
+	TCF_META_ID_PKTTYPE,
+	TCF_META_ID_PKTLEN,
+	TCF_META_ID_DATALEN,
+	TCF_META_ID_MACLEN,
+	TCF_META_ID_NFMARK,
+	TCF_META_ID_TCINDEX,
+	TCF_META_ID_RTCLASSID,
+	TCF_META_ID_RTIIF,
+	TCF_META_ID_SK_FAMILY,
+	TCF_META_ID_SK_STATE,
+	TCF_META_ID_SK_REUSE,
+	TCF_META_ID_SK_BOUND_IF,
+	TCF_META_ID_SK_REFCNT,
+	TCF_META_ID_SK_SHUTDOWN,
+	TCF_META_ID_SK_PROTO,
+	TCF_META_ID_SK_TYPE,
+	TCF_META_ID_SK_RCVBUF,
+	TCF_META_ID_SK_RMEM_ALLOC,
+	TCF_META_ID_SK_WMEM_ALLOC,
+	TCF_META_ID_SK_OMEM_ALLOC,
+	TCF_META_ID_SK_WMEM_QUEUED,
+	TCF_META_ID_SK_RCV_QLEN,
+	TCF_META_ID_SK_SND_QLEN,
+ 	TCF_META_ID_SK_ERR_QLEN,
+	TCF_META_ID_SK_FORWARD_ALLOCS,
+	TCF_META_ID_SK_SNDBUF,
+ 	TCF_META_ID_SK_ALLOCS,
+ 	TCF_META_ID_SK_ROUTE_CAPS,
+ 	TCF_META_ID_SK_HASH,
+ 	TCF_META_ID_SK_LINGERTIME,
+ 	TCF_META_ID_SK_ACK_BACKLOG,
+ 	TCF_META_ID_SK_MAX_ACK_BACKLOG,
+ 	TCF_META_ID_SK_PRIO,
+ 	TCF_META_ID_SK_RCVLOWAT,
+ 	TCF_META_ID_SK_RCVTIMEO,
+ 	TCF_META_ID_SK_SNDTIMEO,
+ 	TCF_META_ID_SK_SENDMSG_OFF,
+ 	TCF_META_ID_SK_WRITE_PENDING,
+	TCF_META_ID_VLAN_TAG,
+	__TCF_META_ID_MAX
+};
+#define TCF_META_ID_MAX (__TCF_META_ID_MAX - 1)
+
+struct tcf_meta_hdr
+{
+	struct tcf_meta_val	left;
+	struct tcf_meta_val	right;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_ematch/tc_em_nbyte.h clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_nbyte.h
--- linux-2.6.32/usr/include/linux/tc_ematch/tc_em_nbyte.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_nbyte.h	2019-04-14 13:24:03.150786091 -0500
@@ -0,0 +1,14 @@
+#ifndef __LINUX_TC_EM_NBYTE_H
+#define __LINUX_TC_EM_NBYTE_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+struct tcf_em_nbyte
+{
+	__u16		off;
+	__u16		len:12;
+	__u8		layer:4;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tc_ematch/tc_em_text.h clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_text.h
--- linux-2.6.32/usr/include/linux/tc_ematch/tc_em_text.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tc_ematch/tc_em_text.h	2019-04-14 13:24:03.152236575 -0500
@@ -0,0 +1,20 @@
+#ifndef __LINUX_TC_EM_TEXT_H
+#define __LINUX_TC_EM_TEXT_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TC_EM_TEXT_ALGOSIZ	16
+
+struct tcf_em_text
+{
+	char		algo[TC_EM_TEXT_ALGOSIZ];
+	__u16		from_offset;
+	__u16		to_offset;
+	__u16		pattern_len;
+	__u8		from_layer:4;
+	__u8		to_layer:4;
+	__u8		pad;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tcp.h clean_modified/linux-2.6.32/usr/include/linux/tcp.h
--- linux-2.6.32/usr/include/linux/tcp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tcp.h	2019-04-14 13:24:03.152236575 -0500
@@ -0,0 +1,174 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the TCP protocol.
+ *
+ * Version:	@(#)tcp.h	1.0.2	04/28/93
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_TCP_H
+#define _LINUX_TCP_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/socket.h>
+
+struct tcphdr {
+	__be16	source;
+	__be16	dest;
+	__be32	seq;
+	__be32	ack_seq;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u16	res1:4,
+		doff:4,
+		fin:1,
+		syn:1,
+		rst:1,
+		psh:1,
+		ack:1,
+		urg:1,
+		ece:1,
+		cwr:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u16	doff:4,
+		res1:4,
+		cwr:1,
+		ece:1,
+		urg:1,
+		ack:1,
+		psh:1,
+		rst:1,
+		syn:1,
+		fin:1;
+#else
+#error	"Adjust your <asm/byteorder.h> defines"
+#endif	
+	__be16	window;
+	__sum16	check;
+	__be16	urg_ptr;
+};
+
+/*
+ *	The union cast uses a gcc extension to avoid aliasing problems
+ *  (union is compatible to any of its members)
+ *  This means this part of the code is -fstrict-aliasing safe now.
+ */
+union tcp_word_hdr { 
+	struct tcphdr hdr;
+	__be32 		  words[5];
+}; 
+
+#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+
+enum { 
+	TCP_FLAG_CWR = __cpu_to_be32(0x00800000),
+	TCP_FLAG_ECE = __cpu_to_be32(0x00400000),
+	TCP_FLAG_URG = __cpu_to_be32(0x00200000),
+	TCP_FLAG_ACK = __cpu_to_be32(0x00100000),
+	TCP_FLAG_PSH = __cpu_to_be32(0x00080000),
+	TCP_FLAG_RST = __cpu_to_be32(0x00040000),
+	TCP_FLAG_SYN = __cpu_to_be32(0x00020000),
+	TCP_FLAG_FIN = __cpu_to_be32(0x00010000),
+	TCP_RESERVED_BITS = __cpu_to_be32(0x0F000000),
+	TCP_DATA_OFFSET = __cpu_to_be32(0xF0000000)
+}; 
+
+/* TCP socket options */
+#define TCP_NODELAY		1	/* Turn off Nagle's algorithm. */
+#define TCP_MAXSEG		2	/* Limit MSS */
+#define TCP_CORK		3	/* Never send partially complete segments */
+#define TCP_KEEPIDLE		4	/* Start keeplives after this period */
+#define TCP_KEEPINTVL		5	/* Interval between keepalives */
+#define TCP_KEEPCNT		6	/* Number of keepalives before death */
+#define TCP_SYNCNT		7	/* Number of SYN retransmits */
+#define TCP_LINGER2		8	/* Life time of orphaned FIN-WAIT-2 state */
+#define TCP_DEFER_ACCEPT	9	/* Wake up listener only when data arrive */
+#define TCP_WINDOW_CLAMP	10	/* Bound advertised window */
+#define TCP_INFO		11	/* Information about this connection. */
+#define TCP_QUICKACK		12	/* Block/reenable quick acks */
+#define TCP_CONGESTION		13	/* Congestion control algorithm */
+#define TCP_MD5SIG		14	/* TCP MD5 Signature (RFC2385) */
+
+#define TCPI_OPT_TIMESTAMPS	1
+#define TCPI_OPT_SACK		2
+#define TCPI_OPT_WSCALE		4
+#define TCPI_OPT_ECN		8
+
+enum tcp_ca_state
+{
+	TCP_CA_Open = 0,
+#define TCPF_CA_Open	(1<<TCP_CA_Open)
+	TCP_CA_Disorder = 1,
+#define TCPF_CA_Disorder (1<<TCP_CA_Disorder)
+	TCP_CA_CWR = 2,
+#define TCPF_CA_CWR	(1<<TCP_CA_CWR)
+	TCP_CA_Recovery = 3,
+#define TCPF_CA_Recovery (1<<TCP_CA_Recovery)
+	TCP_CA_Loss = 4
+#define TCPF_CA_Loss	(1<<TCP_CA_Loss)
+};
+
+struct tcp_info
+{
+	__u8	tcpi_state;
+	__u8	tcpi_ca_state;
+	__u8	tcpi_retransmits;
+	__u8	tcpi_probes;
+	__u8	tcpi_backoff;
+	__u8	tcpi_options;
+	__u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+
+	__u32	tcpi_rto;
+	__u32	tcpi_ato;
+	__u32	tcpi_snd_mss;
+	__u32	tcpi_rcv_mss;
+
+	__u32	tcpi_unacked;
+	__u32	tcpi_sacked;
+	__u32	tcpi_lost;
+	__u32	tcpi_retrans;
+	__u32	tcpi_fackets;
+
+	/* Times. */
+	__u32	tcpi_last_data_sent;
+	__u32	tcpi_last_ack_sent;     /* Not remembered, sorry. */
+	__u32	tcpi_last_data_recv;
+	__u32	tcpi_last_ack_recv;
+
+	/* Metrics. */
+	__u32	tcpi_pmtu;
+	__u32	tcpi_rcv_ssthresh;
+	__u32	tcpi_rtt;
+	__u32	tcpi_rttvar;
+	__u32	tcpi_snd_ssthresh;
+	__u32	tcpi_snd_cwnd;
+	__u32	tcpi_advmss;
+	__u32	tcpi_reordering;
+
+	__u32	tcpi_rcv_rtt;
+	__u32	tcpi_rcv_space;
+
+	__u32	tcpi_total_retrans;
+};
+
+/* for TCP_MD5SIG socket option */
+#define TCP_MD5SIG_MAXKEYLEN	80
+
+struct tcp_md5sig {
+	struct __kernel_sockaddr_storage tcpm_addr;	/* address associated */
+	__u16	__tcpm_pad1;				/* zero */
+	__u16	tcpm_keylen;				/* key length */
+	__u32	__tcpm_pad2;				/* zero */
+	__u8	tcpm_key[TCP_MD5SIG_MAXKEYLEN];		/* key (binary) */
+};
+
+
+#endif	/* _LINUX_TCP_H */
diff -uNr linux-2.6.32/usr/include/linux/telephony.h clean_modified/linux-2.6.32/usr/include/linux/telephony.h
--- linux-2.6.32/usr/include/linux/telephony.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/telephony.h	2019-04-14 13:24:03.153953634 -0500
@@ -0,0 +1,262 @@
+/******************************************************************************
+ *
+ *		telephony.h
+ *
+ *		Basic Linux Telephony Interface
+ *
+ *		(c) Copyright 1999-2001 Quicknet Technologies, Inc.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *    Authors:       Ed Okerson, <eokerson@quicknet.net>
+ *                   Greg Herlein, <gherlein@quicknet.net>
+ *
+ *    Contributors:  Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *                   David W. Erhart, <derhart@quicknet.net>
+ *
+ * IN NO EVENT SHALL QUICKNET TECHNOLOGIES, INC. BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
+ * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF QUICKNET
+ * TECHNOLOGIES, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * QUICKNET TECHNOLOGIES, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND QUICKNET TECHNOLOGIES, INC. HAS NO OBLIGATION
+ * TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ *****************************************************************************/
+
+#ifndef TELEPHONY_H
+#define TELEPHONY_H
+
+#define TELEPHONY_VERSION 3013
+
+#define PHONE_VENDOR_IXJ          1
+#define PHONE_VENDOR_QUICKNET	  PHONE_VENDOR_IXJ
+#define PHONE_VENDOR_VOICETRONIX  2
+#define PHONE_VENDOR_ACULAB       3
+#define PHONE_VENDOR_DIGI         4
+#define PHONE_VENDOR_FRANKLIN     5
+
+/******************************************************************************
+ *  Vendor Summary Information Area
+ *
+ *  Quicknet Technologies, Inc. - makes low density analog telephony cards
+ *    with audio compression, POTS and PSTN interfaces (www.quicknet.net)
+ *
+ *  (other vendors following this API shuld add a short description of
+ *  the telephony products they support under Linux)
+ *
+ *****************************************************************************/
+#define QTI_PHONEJACK		100
+#define QTI_LINEJACK		300
+#define QTI_PHONEJACK_LITE	400
+#define QTI_PHONEJACK_PCI	500
+#define QTI_PHONECARD		600
+
+/******************************************************************************
+*
+* The capabilities ioctls can inform you of the capabilities of each phone
+* device installed in your system.  The PHONECTL_CAPABILITIES ioctl
+* returns an integer value indicating the number of capabilities the   
+* device has.  The PHONECTL_CAPABILITIES_LIST will fill an array of 
+* capability structs with all of its capabilities.  The
+* PHONECTL_CAPABILITIES_CHECK takes a single capability struct and returns
+* a TRUE if the device has that capability, otherwise it returns false.
+* 
+******************************************************************************/
+typedef enum {
+	vendor = 0,
+	device,
+	port,
+	codec,
+	dsp
+} phone_cap;
+
+struct phone_capability {
+	char desc[80];
+	phone_cap captype;
+	int cap;
+	int handle;
+};
+
+typedef enum {
+	pots = 0,
+	pstn,
+	handset,
+	speaker
+} phone_ports;
+
+#define PHONE_CAPABILITIES              _IO  ('q', 0x80)
+#define PHONE_CAPABILITIES_LIST         _IOR ('q', 0x81, struct phone_capability *)
+#define PHONE_CAPABILITIES_CHECK        _IOW ('q', 0x82, struct phone_capability *)
+
+typedef struct {
+        char month[3];
+        char day[3];
+        char hour[3];
+        char min[3];
+        int numlen;
+        char number[11];
+        int namelen;
+        char name[80];
+} PHONE_CID;
+ 
+#define PHONE_RING			_IO  ('q', 0x83)
+#define PHONE_HOOKSTATE			_IO  ('q', 0x84)
+#define PHONE_MAXRINGS			_IOW ('q', 0x85, char)
+#define PHONE_RING_CADENCE		_IOW ('q', 0x86, short)
+#define OLD_PHONE_RING_START            _IO  ('q', 0x87)
+#define PHONE_RING_START		_IOW ('q', 0x87, PHONE_CID *)
+#define PHONE_RING_STOP			_IO  ('q', 0x88)
+
+#define USA_RING_CADENCE	 0xC0C0
+
+#define PHONE_REC_CODEC			_IOW ('q', 0x89, int)
+#define PHONE_REC_START			_IO  ('q', 0x8A)
+#define PHONE_REC_STOP			_IO  ('q', 0x8B)
+#define PHONE_REC_DEPTH			_IOW ('q', 0x8C, int)
+#define PHONE_FRAME			_IOW ('q', 0x8D, int)
+#define PHONE_REC_VOLUME		_IOW ('q', 0x8E, int)
+#define PHONE_REC_VOLUME_LINEAR		_IOW ('q', 0xDB, int)
+#define PHONE_REC_LEVEL			_IO  ('q', 0x8F)
+
+#define PHONE_PLAY_CODEC		_IOW ('q', 0x90, int)
+#define PHONE_PLAY_START		_IO  ('q', 0x91)
+#define PHONE_PLAY_STOP			_IO  ('q', 0x92)
+#define PHONE_PLAY_DEPTH		_IOW ('q', 0x93, int)
+#define PHONE_PLAY_VOLUME		_IOW ('q', 0x94, int)
+#define PHONE_PLAY_VOLUME_LINEAR	_IOW ('q', 0xDC, int)
+#define PHONE_PLAY_LEVEL		_IO  ('q', 0x95)
+#define PHONE_DTMF_READY		_IOR ('q', 0x96, int)
+#define PHONE_GET_DTMF			_IOR ('q', 0x97, int)
+#define PHONE_GET_DTMF_ASCII		_IOR ('q', 0x98, int)
+#define PHONE_DTMF_OOB			_IOW ('q', 0x99, int)
+#define PHONE_EXCEPTION			_IOR ('q', 0x9A, int)
+#define PHONE_PLAY_TONE			_IOW ('q', 0x9B, char)
+#define PHONE_SET_TONE_ON_TIME		_IOW ('q', 0x9C, int)
+#define PHONE_SET_TONE_OFF_TIME		_IOW ('q', 0x9D, int)
+#define PHONE_GET_TONE_ON_TIME		_IO  ('q', 0x9E)
+#define PHONE_GET_TONE_OFF_TIME		_IO  ('q', 0x9F)
+#define PHONE_GET_TONE_STATE		_IO  ('q', 0xA0)
+#define PHONE_BUSY			_IO  ('q', 0xA1)
+#define PHONE_RINGBACK			_IO  ('q', 0xA2)
+#define PHONE_DIALTONE			_IO  ('q', 0xA3)
+#define PHONE_CPT_STOP			_IO  ('q', 0xA4)
+
+#define PHONE_PSTN_SET_STATE		_IOW ('q', 0xA4, int)
+#define PHONE_PSTN_GET_STATE		_IO  ('q', 0xA5)
+
+#define PSTN_ON_HOOK		0
+#define PSTN_RINGING		1
+#define PSTN_OFF_HOOK		2
+#define PSTN_PULSE_DIAL		3
+
+/******************************************************************************
+* 
+* The wink duration is tunable with this ioctl.  The default wink duration  
+* is 320ms.  You do not need to use this ioctl if you do not require a
+* different wink duration.
+* 
+******************************************************************************/
+#define PHONE_WINK_DURATION		_IOW ('q', 0xA6, int)
+#define PHONE_WINK			_IOW ('q', 0xAA, int)
+
+/******************************************************************************
+* 
+*  Codec Definitions
+* 
+******************************************************************************/
+typedef enum {
+	G723_63 = 1,
+	G723_53 = 2,
+	TS85 = 3,
+	TS48 = 4,
+	TS41 = 5,
+	G728 = 6,
+	G729 = 7,
+	ULAW = 8,
+	ALAW = 9,
+	LINEAR16 = 10,
+	LINEAR8 = 11,
+	WSS = 12,
+	G729B = 13
+} phone_codec;
+
+struct phone_codec_data
+{
+        phone_codec type;
+        unsigned short buf_min, buf_opt, buf_max;
+};
+
+#define PHONE_QUERY_CODEC               _IOWR ('q', 0xA7, struct phone_codec_data *)
+#define PHONE_PSTN_LINETEST             _IO ('q', 0xA8)
+
+/******************************************************************************
+* 
+* This controls the VAD/CNG functionality of G.723.1.  The driver will
+* always pass full size frames, any unused bytes will be padded with zeros,
+* and frames passed to the driver should also be padded with zeros.  The
+* frame type is encoded in the least significant two bits of the first
+* WORD of the frame as follows:
+*
+* bits 1-0	Frame Type	Data Rate		Significant Words
+* 00		0		G.723.1 6.3		12
+* 01		1		G.723.1 5.3		10
+* 10		2		VAD/CNG			 2
+* 11		3		Repeat last CNG		 2 bits
+* 
+******************************************************************************/
+#define PHONE_VAD			_IOW ('q', 0xA9, int)
+
+
+/******************************************************************************
+*
+* The exception structure allows us to multiplex multiple events onto the
+* select() exception set.  If any of these flags are set select() will
+* return with a positive indication on the exception set.  The dtmf_ready
+* bit indicates if there is data waiting in the DTMF buffer.  The
+* hookstate bit is set if there is a change in hookstate status, it does not
+* indicate the current state of the hookswitch.  The pstn_ring bit
+* indicates that the DAA on a LineJACK card has detected ring voltage on
+* the PSTN port.  The caller_id bit indicates that caller_id data has been
+* received and is available.  The pstn_wink bit indicates that the DAA on
+* the LineJACK has received a wink from the telco switch.  The f0, f1, f2
+* and f3 bits indicate that the filter has been triggered by detecting the
+* frequency programmed into that filter.
+*
+* The remaining bits should be set to zero. They will become defined over time
+* for other interface cards and their needs.
+*
+******************************************************************************/
+struct phone_except
+{
+	unsigned int dtmf_ready:1;
+	unsigned int hookstate:1;
+	unsigned int pstn_ring:1;
+	unsigned int caller_id:1;
+	unsigned int pstn_wink:1;
+	unsigned int f0:1;
+	unsigned int f1:1;
+	unsigned int f2:1;
+	unsigned int f3:1;
+	unsigned int flash:1;
+	unsigned int fc0:1;
+	unsigned int fc1:1;
+	unsigned int fc2:1;
+	unsigned int fc3:1;
+	unsigned int reserved:18;
+};
+
+union telephony_exception {
+	struct phone_except bits;
+	unsigned int bytes;
+};
+
+
+#endif		/* TELEPHONY_H */
+
diff -uNr linux-2.6.32/usr/include/linux/termios.h clean_modified/linux-2.6.32/usr/include/linux/termios.h
--- linux-2.6.32/usr/include/linux/termios.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/termios.h	2019-04-14 13:24:03.153953634 -0500
@@ -0,0 +1,22 @@
+#ifndef _LINUX_TERMIOS_H
+#define _LINUX_TERMIOS_H
+
+#include <linux/types.h>
+#include <asm/termios.h>
+
+#define NFF	5
+
+struct termiox
+{
+	__u16	x_hflag;
+	__u16	x_cflag;
+	__u16	x_rflag[NFF];
+	__u16	x_sflag;
+};
+
+#define	RTSXOFF		0x0001		/* RTS flow control on input */
+#define	CTSXON		0x0002		/* CTS flow control on output */
+#define	DTRXOFF		0x0004		/* DTR flow control on input */
+#define DSRXON		0x0008		/* DCD flow control on output */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/time.h clean_modified/linux-2.6.32/usr/include/linux/time.h
--- linux-2.6.32/usr/include/linux/time.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/time.h	2019-04-14 13:24:03.153953634 -0500
@@ -0,0 +1,76 @@
+#ifndef _LINUX_TIME_H
+#define _LINUX_TIME_H
+
+#include <linux/types.h>
+
+
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC
+struct timespec {
+	__kernel_time_t	tv_sec;			/* seconds */
+	long		tv_nsec;		/* nanoseconds */
+};
+#endif
+
+struct timeval {
+	__kernel_time_t		tv_sec;		/* seconds */
+	__kernel_suseconds_t	tv_usec;	/* microseconds */
+};
+
+struct timezone {
+	int	tz_minuteswest;	/* minutes west of Greenwich */
+	int	tz_dsttime;	/* type of dst correction */
+};
+
+
+#define NFDBITS			__NFDBITS
+
+#define FD_SETSIZE		__FD_SETSIZE
+#define FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)
+#define FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)
+#define FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)
+#define FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)
+
+/*
+ * Names of the interval timers, and structure
+ * defining a timer setting:
+ */
+#define	ITIMER_REAL		0
+#define	ITIMER_VIRTUAL		1
+#define	ITIMER_PROF		2
+
+struct itimerspec {
+	struct timespec it_interval;	/* timer period */
+	struct timespec it_value;	/* timer expiration */
+};
+
+struct itimerval {
+	struct timeval it_interval;	/* timer interval */
+	struct timeval it_value;	/* current value */
+};
+
+/*
+ * The IDs of the various system clocks (for POSIX.1b interval timers):
+ */
+#define CLOCK_REALTIME			0
+#define CLOCK_MONOTONIC			1
+#define CLOCK_PROCESS_CPUTIME_ID	2
+#define CLOCK_THREAD_CPUTIME_ID		3
+#define CLOCK_MONOTONIC_RAW		4
+#define CLOCK_REALTIME_COARSE		5
+#define CLOCK_MONOTONIC_COARSE		6
+
+/*
+ * The IDs of various hardware clocks:
+ */
+#define CLOCK_SGI_CYCLE			10
+#define MAX_CLOCKS			16
+#define CLOCKS_MASK			(CLOCK_REALTIME | CLOCK_MONOTONIC)
+#define CLOCKS_MONO			CLOCK_MONOTONIC
+
+/*
+ * The various flags for setting POSIX.1b interval timers:
+ */
+#define TIMER_ABSTIME			0x01
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/times.h clean_modified/linux-2.6.32/usr/include/linux/times.h
--- linux-2.6.32/usr/include/linux/times.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/times.h	2019-04-14 13:24:03.155197498 -0500
@@ -0,0 +1,13 @@
+#ifndef _LINUX_TIMES_H
+#define _LINUX_TIMES_H
+
+#include <linux/types.h>
+
+struct tms {
+	__kernel_clock_t tms_utime;
+	__kernel_clock_t tms_stime;
+	__kernel_clock_t tms_cutime;
+	__kernel_clock_t tms_cstime;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/timex.h clean_modified/linux-2.6.32/usr/include/linux/timex.h
--- linux-2.6.32/usr/include/linux/timex.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/timex.h	2019-04-14 13:24:03.155197498 -0500
@@ -0,0 +1,160 @@
+/*****************************************************************************
+ *                                                                           *
+ * Copyright (c) David L. Mills 1993                                         *
+ *                                                                           *
+ * Permission to use, copy, modify, and distribute this software and its     *
+ * documentation for any purpose and without fee is hereby granted, provided *
+ * that the above copyright notice appears in all copies and that both the   *
+ * copyright notice and this permission notice appear in supporting          *
+ * documentation, and that the name University of Delaware not be used in    *
+ * advertising or publicity pertaining to distribution of the software       *
+ * without specific, written prior permission.  The University of Delaware   *
+ * makes no representations about the suitability this software for any      *
+ * purpose.  It is provided "as is" without express or implied warranty.     *
+ *                                                                           *
+ *****************************************************************************/
+
+/*
+ * Modification history timex.h
+ *
+ * 29 Dec 97	Russell King
+ *	Moved CLOCK_TICK_RATE, CLOCK_TICK_FACTOR and FINETUNE to asm/timex.h
+ *	for ARM machines
+ *
+ *  9 Jan 97    Adrian Sun
+ *      Shifted LATCH define to allow access to alpha machines.
+ *
+ * 26 Sep 94	David L. Mills
+ *	Added defines for hybrid phase/frequency-lock loop.
+ *
+ * 19 Mar 94	David L. Mills
+ *	Moved defines from kernel routines to header file and added new
+ *	defines for PPS phase-lock loop.
+ *
+ * 20 Feb 94	David L. Mills
+ *	Revised status codes and structures for external clock and PPS
+ *	signal discipline.
+ *
+ * 28 Nov 93	David L. Mills
+ *	Adjusted parameters to improve stability and increase poll
+ *	interval.
+ *
+ * 17 Sep 93    David L. Mills
+ *      Created file $NTP/include/sys/timex.h
+ * 07 Oct 93    Torsten Duwe
+ *      Derived linux/timex.h
+ * 1995-08-13    Torsten Duwe
+ *      kernel PLL updated to 1994-12-13 specs (rfc-1589)
+ * 1997-08-30    Ulrich Windl
+ *      Added new constant NTP_PHASE_LIMIT
+ * 2004-08-12    Christoph Lameter
+ *      Reworked time interpolation logic
+ */
+#ifndef _LINUX_TIMEX_H
+#define _LINUX_TIMEX_H
+
+#include <linux/time.h>
+
+#define NTP_API		4	/* NTP API version */
+
+/*
+ * syscall interface - used (mainly by NTP daemon)
+ * to discipline kernel clock oscillator
+ */
+struct timex {
+	unsigned int modes;	/* mode selector */
+	long offset;		/* time offset (usec) */
+	long freq;		/* frequency offset (scaled ppm) */
+	long maxerror;		/* maximum error (usec) */
+	long esterror;		/* estimated error (usec) */
+	int status;		/* clock command/status */
+	long constant;		/* pll time constant */
+	long precision;		/* clock precision (usec) (read only) */
+	long tolerance;		/* clock frequency tolerance (ppm)
+				 * (read only)
+				 */
+	struct timeval time;	/* (read only) */
+	long tick;		/* (modified) usecs between clock ticks */
+
+	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
+	long jitter;            /* pps jitter (us) (ro) */
+	int shift;              /* interval duration (s) (shift) (ro) */
+	long stabil;            /* pps stability (scaled ppm) (ro) */
+	long jitcnt;            /* jitter limit exceeded (ro) */
+	long calcnt;            /* calibration intervals (ro) */
+	long errcnt;            /* calibration errors (ro) */
+	long stbcnt;            /* stability limit exceeded (ro) */
+
+	int tai;		/* TAI offset (ro) */
+
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32;
+};
+
+/*
+ * Mode codes (timex.mode)
+ */
+#define ADJ_OFFSET		0x0001	/* time offset */
+#define ADJ_FREQUENCY		0x0002	/* frequency offset */
+#define ADJ_MAXERROR		0x0004	/* maximum time error */
+#define ADJ_ESTERROR		0x0008	/* estimated time error */
+#define ADJ_STATUS		0x0010	/* clock status */
+#define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_TAI			0x0080	/* set TAI offset */
+#define ADJ_MICRO		0x1000	/* select microsecond resolution */
+#define ADJ_NANO		0x2000	/* select nanosecond resolution */
+#define ADJ_TICK		0x4000	/* tick value */
+
+#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
+#define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
+
+/* xntp 3.4 compatibility names */
+#define MOD_OFFSET	ADJ_OFFSET
+#define MOD_FREQUENCY	ADJ_FREQUENCY
+#define MOD_MAXERROR	ADJ_MAXERROR
+#define MOD_ESTERROR	ADJ_ESTERROR
+#define MOD_STATUS	ADJ_STATUS
+#define MOD_TIMECONST	ADJ_TIMECONST
+
+
+/*
+ * Status codes (timex.status)
+ */
+#define STA_PLL		0x0001	/* enable PLL updates (rw) */
+#define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
+#define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
+#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
+
+#define STA_INS		0x0010	/* insert leap (rw) */
+#define STA_DEL		0x0020	/* delete leap (rw) */
+#define STA_UNSYNC	0x0040	/* clock unsynchronized (rw) */
+#define STA_FREQHOLD	0x0080	/* hold frequency (rw) */
+
+#define STA_PPSSIGNAL	0x0100	/* PPS signal present (ro) */
+#define STA_PPSJITTER	0x0200	/* PPS signal jitter exceeded (ro) */
+#define STA_PPSWANDER	0x0400	/* PPS signal wander exceeded (ro) */
+#define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
+
+#define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
+#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
+#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
+
+/* read-only bits */
+#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
+	STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
+
+/*
+ * Clock states (time_state)
+ */
+#define TIME_OK		0	/* clock synchronized, no leap second */
+#define TIME_INS	1	/* insert leap second */
+#define TIME_DEL	2	/* delete leap second */
+#define TIME_OOP	3	/* leap second in progress */
+#define TIME_WAIT	4	/* leap second has occurred */
+#define TIME_ERROR	5	/* clock not synchronized */
+#define TIME_BAD	TIME_ERROR /* bw compat */
+
+
+#endif /* LINUX_TIMEX_H */
diff -uNr linux-2.6.32/usr/include/linux/tiocl.h clean_modified/linux-2.6.32/usr/include/linux/tiocl.h
--- linux-2.6.32/usr/include/linux/tiocl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tiocl.h	2019-04-14 13:24:03.155197498 -0500
@@ -0,0 +1,39 @@
+#ifndef _LINUX_TIOCL_H
+#define _LINUX_TIOCL_H
+
+#define TIOCL_SETSEL	2	/* set a selection */
+#define 	TIOCL_SELCHAR	0	/* select characters */
+#define 	TIOCL_SELWORD	1	/* select whole words */
+#define 	TIOCL_SELLINE	2	/* select whole lines */
+#define 	TIOCL_SELPOINTER	3	/* show the pointer */
+#define 	TIOCL_SELCLEAR	4	/* clear visibility of selection */
+#define 	TIOCL_SELMOUSEREPORT	16	/* report beginning of selection */
+#define 	TIOCL_SELBUTTONMASK	15	/* button mask for report */
+/* selection extent */
+struct tiocl_selection {
+	unsigned short xs;	/* X start */
+	unsigned short ys;	/* Y start */
+	unsigned short xe;	/* X end */
+	unsigned short ye;	/* Y end */
+	unsigned short sel_mode;	/* selection mode */
+};
+
+#define TIOCL_PASTESEL	3	/* paste previous selection */
+#define TIOCL_UNBLANKSCREEN	4	/* unblank screen */
+
+#define TIOCL_SELLOADLUT	5
+	/* set characters to be considered alphabetic when selecting */
+	/* u32[8] bit array, 4 bytes-aligned with type */
+
+/* these two don't return a value: they write it back in the type */
+#define TIOCL_GETSHIFTSTATE	6	/* write shift state */
+#define TIOCL_GETMOUSEREPORTING	7	/* write whether mouse event are reported */
+#define TIOCL_SETVESABLANK	10	/* set vesa blanking mode */
+#define TIOCL_SETKMSGREDIRECT	11	/* restrict kernel messages to a vt */
+#define TIOCL_GETFGCONSOLE	12	/* get foreground vt */
+#define TIOCL_SCROLLCONSOLE	13	/* scroll console */
+#define TIOCL_BLANKSCREEN	14	/* keep screen blank even if a key is pressed */
+#define TIOCL_BLANKEDSCREEN	15	/* return which vt was blanked */
+#define TIOCL_GETKMSGREDIRECT	17	/* get the vt the kernel messages are restricted to */
+
+#endif /* _LINUX_TIOCL_H */
diff -uNr linux-2.6.32/usr/include/linux/tipc_config.h clean_modified/linux-2.6.32/usr/include/linux/tipc_config.h
--- linux-2.6.32/usr/include/linux/tipc_config.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tipc_config.h	2019-04-14 13:24:03.156173410 -0500
@@ -0,0 +1,418 @@
+/*
+ * include/linux/tipc_config.h: Include file for TIPC configuration interface
+ * 
+ * Copyright (c) 2003-2006, Ericsson AB
+ * Copyright (c) 2005-2007, Wind River Systems
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_TIPC_CONFIG_H_
+#define _LINUX_TIPC_CONFIG_H_
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <asm/byteorder.h>
+
+/*
+ * Configuration
+ *
+ * All configuration management messaging involves sending a request message
+ * to the TIPC configuration service on a node, which sends a reply message
+ * back.  (In the future multi-message replies may be supported.)
+ *
+ * Both request and reply messages consist of a transport header and payload.
+ * The transport header contains info about the desired operation;
+ * the payload consists of zero or more type/length/value (TLV) items
+ * which specify parameters or results for the operation.
+ *
+ * For many operations, the request and reply messages have a fixed number
+ * of TLVs (usually zero or one); however, some reply messages may return 
+ * a variable number of TLVs.  A failed request is denoted by the presence
+ * of an "error string" TLV in the reply message instead of the TLV(s) the
+ * reply should contain if the request succeeds.
+ */
+ 
+/* 
+ * Public commands:
+ * May be issued by any process.
+ * Accepted by own node, or by remote node only if remote management enabled.                       
+ */
+ 
+#define  TIPC_CMD_NOOP   	    0x0000    /* tx none, rx none */
+#define  TIPC_CMD_GET_NODES         0x0001    /* tx net_addr, rx node_info(s) */
+#define  TIPC_CMD_GET_MEDIA_NAMES   0x0002    /* tx none, rx media_name(s) */
+#define  TIPC_CMD_GET_BEARER_NAMES  0x0003    /* tx none, rx bearer_name(s) */
+#define  TIPC_CMD_GET_LINKS         0x0004    /* tx net_addr, rx link_info(s) */
+#define  TIPC_CMD_SHOW_NAME_TABLE   0x0005    /* tx name_tbl_query, rx ultra_string */
+#define  TIPC_CMD_SHOW_PORTS        0x0006    /* tx none, rx ultra_string */
+#define  TIPC_CMD_SHOW_LINK_STATS   0x000B    /* tx link_name, rx ultra_string */
+
+#if 0
+#define  TIPC_CMD_SHOW_PORT_STATS   0x0008    /* tx port_ref, rx ultra_string */
+#define  TIPC_CMD_RESET_PORT_STATS  0x0009    /* tx port_ref, rx none */
+#define  TIPC_CMD_GET_ROUTES        0x000A    /* tx ?, rx ? */
+#define  TIPC_CMD_GET_LINK_PEER     0x000D    /* tx link_name, rx ? */
+#endif
+
+/* 
+ * Protected commands:
+ * May only be issued by "network administration capable" process.
+ * Accepted by own node, or by remote node only if remote management enabled
+ * and this node is zone manager.                       
+ */
+
+#define  TIPC_CMD_GET_REMOTE_MNG    0x4003    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_PORTS     0x4004    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_PUBL      0x4005    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_SUBSCR    0x4006    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_ZONES     0x4007    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_CLUSTERS  0x4008    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_NODES     0x4009    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_MAX_SLAVES    0x400A    /* tx none, rx unsigned */
+#define  TIPC_CMD_GET_NETID         0x400B    /* tx none, rx unsigned */
+
+#define  TIPC_CMD_ENABLE_BEARER     0x4101    /* tx bearer_config, rx none */
+#define  TIPC_CMD_DISABLE_BEARER    0x4102    /* tx bearer_name, rx none */
+#define  TIPC_CMD_SET_LINK_TOL      0x4107    /* tx link_config, rx none */
+#define  TIPC_CMD_SET_LINK_PRI      0x4108    /* tx link_config, rx none */
+#define  TIPC_CMD_SET_LINK_WINDOW   0x4109    /* tx link_config, rx none */
+#define  TIPC_CMD_SET_LOG_SIZE      0x410A    /* tx unsigned, rx none */
+#define  TIPC_CMD_DUMP_LOG          0x410B    /* tx none, rx ultra_string */
+#define  TIPC_CMD_RESET_LINK_STATS  0x410C    /* tx link_name, rx none */
+
+#if 0
+#define  TIPC_CMD_CREATE_LINK       0x4103    /* tx link_create, rx none */
+#define  TIPC_CMD_REMOVE_LINK       0x4104    /* tx link_name, rx none */
+#define  TIPC_CMD_BLOCK_LINK        0x4105    /* tx link_name, rx none */
+#define  TIPC_CMD_UNBLOCK_LINK      0x4106    /* tx link_name, rx none */
+#endif
+
+/* 
+ * Private commands:
+ * May only be issued by "network administration capable" process.
+ * Accepted by own node only; cannot be used on a remote node.                       
+ */
+
+#define  TIPC_CMD_SET_NODE_ADDR     0x8001    /* tx net_addr, rx none */
+#if 0
+#define  TIPC_CMD_SET_ZONE_MASTER   0x8002    /* tx none, rx none */
+#endif
+#define  TIPC_CMD_SET_REMOTE_MNG    0x8003    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_PORTS     0x8004    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_PUBL      0x8005    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_SUBSCR    0x8006    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_ZONES     0x8007    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_CLUSTERS  0x8008    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_NODES     0x8009    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_MAX_SLAVES    0x800A    /* tx unsigned, rx none */
+#define  TIPC_CMD_SET_NETID         0x800B    /* tx unsigned, rx none */
+
+/*
+ * Reserved commands:
+ * May not be issued by any process.
+ * Used internally by TIPC.
+ */
+
+#define  TIPC_CMD_NOT_NET_ADMIN     0xC001    /* tx none, rx none */
+
+/*
+ * TLV types defined for TIPC
+ */
+
+#define TIPC_TLV_NONE		0	/* no TLV present */
+#define TIPC_TLV_VOID		1	/* empty TLV (0 data bytes)*/
+#define TIPC_TLV_UNSIGNED	2	/* 32-bit integer */
+#define TIPC_TLV_STRING		3	/* char[128] (max) */
+#define TIPC_TLV_LARGE_STRING	4	/* char[2048] (max) */
+#define TIPC_TLV_ULTRA_STRING	5	/* char[32768] (max) */
+
+#define TIPC_TLV_ERROR_STRING	16	/* char[128] containing "error code" */
+#define TIPC_TLV_NET_ADDR   	17	/* 32-bit integer denoting <Z.C.N> */
+#define TIPC_TLV_MEDIA_NAME	18	/* char[TIPC_MAX_MEDIA_NAME] */
+#define TIPC_TLV_BEARER_NAME	19	/* char[TIPC_MAX_BEARER_NAME] */
+#define TIPC_TLV_LINK_NAME	20	/* char[TIPC_MAX_LINK_NAME] */
+#define TIPC_TLV_NODE_INFO	21	/* struct tipc_node_info */
+#define TIPC_TLV_LINK_INFO	22	/* struct tipc_link_info */
+#define TIPC_TLV_BEARER_CONFIG  23	/* struct tipc_bearer_config */
+#define TIPC_TLV_LINK_CONFIG    24	/* struct tipc_link_config */
+#define TIPC_TLV_NAME_TBL_QUERY	25	/* struct tipc_name_table_query */
+#define TIPC_TLV_PORT_REF   	26	/* 32-bit port reference */
+
+/*
+ * Maximum sizes of TIPC bearer-related names (including terminating NUL)
+ */ 
+
+#define TIPC_MAX_MEDIA_NAME	16	/* format = media */
+#define TIPC_MAX_IF_NAME	16	/* format = interface */
+#define TIPC_MAX_BEARER_NAME	32	/* format = media:interface */
+#define TIPC_MAX_LINK_NAME	60	/* format = Z.C.N:interface-Z.C.N:interface */
+
+/*
+ * Link priority limits (min, default, max, media default)
+ */
+
+#define TIPC_MIN_LINK_PRI	0
+#define TIPC_DEF_LINK_PRI	10
+#define TIPC_MAX_LINK_PRI	31
+#define TIPC_MEDIA_LINK_PRI	(TIPC_MAX_LINK_PRI + 1)
+
+/*
+ * Link tolerance limits (min, default, max), in ms
+ */
+
+#define TIPC_MIN_LINK_TOL 50
+#define TIPC_DEF_LINK_TOL 1500
+#define TIPC_MAX_LINK_TOL 30000
+
+/*
+ * Link window limits (min, default, max), in packets
+ */
+
+#define TIPC_MIN_LINK_WIN 16
+#define TIPC_DEF_LINK_WIN 50
+#define TIPC_MAX_LINK_WIN 150
+
+
+struct tipc_node_info {
+	__be32 addr;			/* network address of node */
+	__be32 up;			/* 0=down, 1= up */
+};
+
+struct tipc_link_info {
+	__be32 dest;			/* network address of peer node */
+	__be32 up;			/* 0=down, 1=up */
+	char str[TIPC_MAX_LINK_NAME];	/* link name */
+};
+
+struct tipc_bearer_config {
+	__be32 priority;		/* Range [1,31]. Override per link  */
+	__be32 detect_scope;
+	char name[TIPC_MAX_BEARER_NAME];
+};
+
+struct tipc_link_config {
+	__be32 value;
+	char name[TIPC_MAX_LINK_NAME];
+};
+
+#define TIPC_NTQ_ALLTYPES 0x80000000
+
+struct tipc_name_table_query {
+	__be32 depth;	/* 1:type, 2:+name info, 3:+port info, 4+:+debug info */
+	__be32 type;	/* {t,l,u} info ignored if high bit of "depth" is set */
+	__be32 lowbound; /* (i.e. displays all entries of name table) */
+	__be32 upbound;
+};
+
+/*
+ * The error string TLV is a null-terminated string describing the cause 
+ * of the request failure.  To simplify error processing (and to save space)
+ * the first character of the string can be a special error code character
+ * (lying by the range 0x80 to 0xFF) which represents a pre-defined reason.
+ */
+
+#define TIPC_CFG_TLV_ERROR      "\x80"  /* request contains incorrect TLV(s) */
+#define TIPC_CFG_NOT_NET_ADMIN  "\x81"	/* must be network administrator */
+#define TIPC_CFG_NOT_ZONE_MSTR	"\x82"	/* must be zone master */
+#define TIPC_CFG_NO_REMOTE	"\x83"	/* remote management not enabled */
+#define TIPC_CFG_NOT_SUPPORTED  "\x84"	/* request is not supported by TIPC */
+#define TIPC_CFG_INVALID_VALUE  "\x85"  /* request has invalid argument value */
+
+#if 0
+/* prototypes TLV structures for proposed commands */
+struct tipc_link_create {
+	__u32   domain;
+	struct tipc_media_addr peer_addr;
+	char bearer_name[TIPC_MAX_BEARER_NAME];
+};
+
+struct tipc_route_info {
+	__u32 dest;
+	__u32 router;
+};
+#endif
+
+/*
+ * A TLV consists of a descriptor, followed by the TLV value.
+ * TLV descriptor fields are stored in network byte order; 
+ * TLV values must also be stored in network byte order (where applicable).
+ * TLV descriptors must be aligned to addresses which are multiple of 4,
+ * so up to 3 bytes of padding may exist at the end of the TLV value area.
+ * There must not be any padding between the TLV descriptor and its value.
+ */
+
+struct tlv_desc {
+	__be16 tlv_len;		/* TLV length (descriptor + value) */
+	__be16 tlv_type;		/* TLV identifier */
+};
+
+#define TLV_ALIGNTO 4
+
+#define TLV_ALIGN(datalen) (((datalen)+(TLV_ALIGNTO-1)) & ~(TLV_ALIGNTO-1))
+#define TLV_LENGTH(datalen) (sizeof(struct tlv_desc) + (datalen))
+#define TLV_SPACE(datalen) (TLV_ALIGN(TLV_LENGTH(datalen)))
+#define TLV_DATA(tlv) ((void *)((char *)(tlv) + TLV_LENGTH(0)))
+
+static __inline__ int TLV_OK(const void *tlv, __u16 space)
+{
+	/*
+	 * Would also like to check that "tlv" is a multiple of 4,
+	 * but don't know how to do this in a portable way.
+	 * - Tried doing (!(tlv & (TLV_ALIGNTO-1))), but GCC compiler
+	 *   won't allow binary "&" with a pointer.
+	 * - Tried casting "tlv" to integer type, but causes warning about size
+	 *   mismatch when pointer is bigger than chosen type (int, long, ...).
+	 */
+
+	return (space >= TLV_SPACE(0)) &&
+		(ntohs(((struct tlv_desc *)tlv)->tlv_len) <= space);
+}
+
+static __inline__ int TLV_CHECK(const void *tlv, __u16 space, __u16 exp_type)
+{
+	return TLV_OK(tlv, space) && 
+		(ntohs(((struct tlv_desc *)tlv)->tlv_type) == exp_type);
+}
+
+static __inline__ int TLV_SET(void *tlv, __u16 type, void *data, __u16 len)
+{
+	struct tlv_desc *tlv_ptr;
+	int tlv_len;
+
+	tlv_len = TLV_LENGTH(len);
+	tlv_ptr = (struct tlv_desc *)tlv;
+	tlv_ptr->tlv_type = htons(type);
+	tlv_ptr->tlv_len  = htons(tlv_len);
+	if (len && data)
+		memcpy(TLV_DATA(tlv_ptr), data, tlv_len);
+	return TLV_SPACE(len);
+}
+
+/*
+ * A TLV list descriptor simplifies processing of messages 
+ * containing multiple TLVs.
+ */
+
+struct tlv_list_desc {
+	struct tlv_desc *tlv_ptr;	/* ptr to current TLV */
+	__u32 tlv_space;		/* # bytes from curr TLV to list end */
+};
+
+static __inline__ void TLV_LIST_INIT(struct tlv_list_desc *list, 
+				 void *data, __u32 space)
+{
+	list->tlv_ptr = (struct tlv_desc *)data;
+	list->tlv_space = space;
+}
+	     
+static __inline__ int TLV_LIST_EMPTY(struct tlv_list_desc *list)
+{ 
+	return (list->tlv_space == 0);
+}
+
+static __inline__ int TLV_LIST_CHECK(struct tlv_list_desc *list, __u16 exp_type)
+{
+	return TLV_CHECK(list->tlv_ptr, list->tlv_space, exp_type);
+}
+
+static __inline__ void *TLV_LIST_DATA(struct tlv_list_desc *list)
+{
+	return TLV_DATA(list->tlv_ptr);
+}
+
+static __inline__ void TLV_LIST_STEP(struct tlv_list_desc *list)
+{
+	__u16 tlv_space = TLV_ALIGN(ntohs(list->tlv_ptr->tlv_len));
+
+        list->tlv_ptr = (struct tlv_desc *)((char *)list->tlv_ptr + tlv_space);
+	list->tlv_space -= tlv_space;
+}
+
+/*
+ * Configuration messages exchanged via NETLINK_GENERIC use the following
+ * family id, name, version and command.
+ */
+#define TIPC_GENL_NAME		"TIPC"
+#define TIPC_GENL_VERSION	0x1
+#define TIPC_GENL_CMD		0x1
+
+/*
+ * TIPC specific header used in NETLINK_GENERIC requests.
+ */
+struct tipc_genlmsghdr {
+	__u32 dest;		/* Destination address */
+	__u16 cmd;		/* Command */
+	__u16 reserved;		/* Unused */
+};
+
+#define TIPC_GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct tipc_genlmsghdr))
+
+/*
+ * Configuration messages exchanged via TIPC sockets use the TIPC configuration 
+ * message header, which is defined below.  This structure is analogous 
+ * to the Netlink message header, but fields are stored in network byte order 
+ * and no padding is permitted between the header and the message data 
+ * that follows.
+ */
+
+struct tipc_cfg_msg_hdr
+{
+	__be32 tcm_len;		/* Message length (including header) */
+	__be16 tcm_type;	/* Command type */
+	__be16 tcm_flags;	/* Additional flags */
+	char  tcm_reserved[8];	/* Unused */
+};
+
+#define TCM_F_REQUEST	0x1	/* Flag: Request message */
+#define TCM_F_MORE	0x2	/* Flag: Message to be continued */
+
+#define TCM_ALIGN(datalen)  (((datalen)+3) & ~3)
+#define TCM_LENGTH(datalen) (sizeof(struct tipc_cfg_msg_hdr) + datalen)
+#define TCM_SPACE(datalen)  (TCM_ALIGN(TCM_LENGTH(datalen)))
+#define TCM_DATA(tcm_hdr)   ((void *)((char *)(tcm_hdr) + TCM_LENGTH(0)))
+
+static __inline__ int TCM_SET(void *msg, __u16 cmd, __u16 flags,
+			  void *data, __u16 data_len)
+{
+	struct tipc_cfg_msg_hdr *tcm_hdr;
+	int msg_len;
+
+	msg_len = TCM_LENGTH(data_len);
+	tcm_hdr = (struct tipc_cfg_msg_hdr *)msg;
+	tcm_hdr->tcm_len   = htonl(msg_len);
+	tcm_hdr->tcm_type  = htons(cmd);
+	tcm_hdr->tcm_flags = htons(flags);
+	if (data_len && data)
+		memcpy(TCM_DATA(msg), data, data_len);
+	return TCM_SPACE(data_len);
+}
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tipc.h clean_modified/linux-2.6.32/usr/include/linux/tipc.h
--- linux-2.6.32/usr/include/linux/tipc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tipc.h	2019-04-14 13:24:03.156779200 -0500
@@ -0,0 +1,215 @@
+/*
+ * include/linux/tipc.h: Include file for TIPC socket interface
+ * 
+ * Copyright (c) 2003-2006, Ericsson AB
+ * Copyright (c) 2005, Wind River Systems
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_TIPC_H_
+#define _LINUX_TIPC_H_
+
+#include <linux/types.h>
+
+/*
+ * TIPC addressing primitives
+ */
+ 
+struct tipc_portid {
+	__u32 ref;
+	__u32 node;
+};
+
+struct tipc_name {
+	__u32 type;
+	__u32 instance;
+};
+
+struct tipc_name_seq {
+	__u32 type;
+	__u32 lower;
+	__u32 upper;
+};
+
+static __inline__ __u32 tipc_addr(unsigned int zone,
+			      unsigned int cluster,
+			      unsigned int node)
+{
+	return (zone << 24) | (cluster << 12) | node;
+}
+
+static __inline__ unsigned int tipc_zone(__u32 addr)
+{
+	return addr >> 24;
+}
+
+static __inline__ unsigned int tipc_cluster(__u32 addr)
+{
+	return (addr >> 12) & 0xfff;
+}
+
+static __inline__ unsigned int tipc_node(__u32 addr)
+{
+	return addr & 0xfff;
+}
+
+/*
+ * Application-accessible port name types
+ */
+
+#define TIPC_CFG_SRV		0	/* configuration service name type */
+#define TIPC_TOP_SRV		1	/* topology service name type */
+#define TIPC_RESERVED_TYPES	64	/* lowest user-publishable name type */
+
+/* 
+ * Publication scopes when binding port names and port name sequences
+ */
+
+#define TIPC_ZONE_SCOPE		1
+#define TIPC_CLUSTER_SCOPE	2
+#define TIPC_NODE_SCOPE		3
+
+/*
+ * Limiting values for messages
+ */
+
+#define TIPC_MAX_USER_MSG_SIZE	66000
+
+/*
+ * Message importance levels
+ */
+
+#define TIPC_LOW_IMPORTANCE		0  /* default */
+#define TIPC_MEDIUM_IMPORTANCE		1
+#define TIPC_HIGH_IMPORTANCE		2
+#define TIPC_CRITICAL_IMPORTANCE	3
+
+/* 
+ * Msg rejection/connection shutdown reasons
+ */
+
+#define TIPC_OK			0
+#define TIPC_ERR_NO_NAME	1
+#define TIPC_ERR_NO_PORT	2
+#define TIPC_ERR_NO_NODE	3
+#define TIPC_ERR_OVERLOAD	4
+#define TIPC_CONN_SHUTDOWN	5
+
+/*
+ * TIPC topology subscription service definitions
+ */
+
+#define TIPC_SUB_PORTS     	0x01  	/* filter for port availability */
+#define TIPC_SUB_SERVICE     	0x02  	/* filter for service availability */
+#define TIPC_SUB_CANCEL         0x04    /* cancel a subscription */
+#if 0
+/* The following filter options are not currently implemented */
+#define TIPC_SUB_NO_BIND_EVTS	0x04	/* filter out "publish" events */
+#define TIPC_SUB_NO_UNBIND_EVTS	0x08	/* filter out "withdraw" events */
+#define TIPC_SUB_SINGLE_EVT	0x10	/* expire after first event */
+#endif
+
+#define TIPC_WAIT_FOREVER	~0	/* timeout for permanent subscription */
+
+struct tipc_subscr {
+	struct tipc_name_seq seq;	/* name sequence of interest */
+	__u32 timeout;			/* subscription duration (in ms) */
+        __u32 filter;   		/* bitmask of filter options */
+	char usr_handle[8];		/* available for subscriber use */
+};
+
+#define TIPC_PUBLISHED		1	/* publication event */
+#define TIPC_WITHDRAWN		2	/* withdraw event */
+#define TIPC_SUBSCR_TIMEOUT	3	/* subscription timeout event */
+
+struct tipc_event {
+	__u32 event;			/* event type */
+	__u32 found_lower;		/* matching name seq instances */
+	__u32 found_upper;		/*    "      "    "     "      */
+	struct tipc_portid port;	/* associated port */
+	struct tipc_subscr s;		/* associated subscription */
+};
+
+/*
+ * Socket API
+ */
+
+#ifndef AF_TIPC
+#define AF_TIPC		30
+#endif
+
+#ifndef PF_TIPC
+#define PF_TIPC		AF_TIPC
+#endif
+
+#ifndef SOL_TIPC
+#define SOL_TIPC	271
+#endif
+
+#define TIPC_ADDR_NAMESEQ	1
+#define TIPC_ADDR_MCAST		1
+#define TIPC_ADDR_NAME		2
+#define TIPC_ADDR_ID		3
+
+struct sockaddr_tipc {
+	unsigned short family;
+	unsigned char  addrtype;
+	signed   char  scope;
+	union {
+		struct tipc_portid id;
+		struct tipc_name_seq nameseq;
+		struct {
+			struct tipc_name name;
+			__u32 domain; /* 0: own zone */
+		} name;
+	} addr;
+};
+
+/*
+ * Ancillary data objects supported by recvmsg()
+ */
+
+#define TIPC_ERRINFO	1	/* error info */
+#define TIPC_RETDATA	2	/* returned data */
+#define TIPC_DESTNAME	3	/* destination name */
+
+/*
+ * TIPC-specific socket option values
+ */
+
+#define TIPC_IMPORTANCE		127	/* Default: TIPC_LOW_IMPORTANCE */
+#define TIPC_SRC_DROPPABLE	128	/* Default: 0 (resend congested msg) */
+#define TIPC_DEST_DROPPABLE	129	/* Default: based on socket type */
+#define TIPC_CONN_TIMEOUT	130	/* Default: 8000 (ms)  */
+#define TIPC_NODE_RECVQ_DEPTH	131	/* Default: none (read only) */
+#define TIPC_SOCK_RECVQ_DEPTH	132	/* Default: none (read only) */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/toshiba.h clean_modified/linux-2.6.32/usr/include/linux/toshiba.h
--- linux-2.6.32/usr/include/linux/toshiba.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/toshiba.h	2019-04-14 13:24:03.156779200 -0500
@@ -0,0 +1,38 @@
+/* toshiba.h -- Linux driver for accessing the SMM on Toshiba laptops 
+ *
+ * Copyright (c) 1996-2000  Jonathan A. Buzzard (jonathan@buzzard.org.uk)
+ *
+ * Thanks to Juergen Heinzl <juergen@monocerus.demon.co.uk> for the pointers
+ * on making sure the structure is aligned and packed.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_TOSHIBA_H
+#define _LINUX_TOSHIBA_H
+
+#define TOSH_PROC "/proc/toshiba"
+#define TOSH_DEVICE "/dev/toshiba"
+#define TOSH_SMM _IOWR('t', 0x90, int)	/* broken: meant 24 bytes */
+
+typedef struct {
+	unsigned int eax;
+	unsigned int ebx __attribute__ ((packed));
+	unsigned int ecx __attribute__ ((packed));
+	unsigned int edx __attribute__ ((packed));
+	unsigned int esi __attribute__ ((packed));
+	unsigned int edi __attribute__ ((packed));
+} SMMRegisters;
+
+int tosh_smm(SMMRegisters *regs);
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/tty.h clean_modified/linux-2.6.32/usr/include/linux/tty.h
--- linux-2.6.32/usr/include/linux/tty.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/tty.h	2019-04-14 13:24:03.156779200 -0500
@@ -0,0 +1,8 @@
+#ifndef _LINUX_TTY_H
+#define _LINUX_TTY_H
+
+/*
+ * 'tty.h' defines some structures used by tty_io.c and some defines.
+ */
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/types.h clean_modified/linux-2.6.32/usr/include/linux/types.h
--- linux-2.6.32/usr/include/linux/types.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/types.h	2019-04-14 13:24:03.156779200 -0500
@@ -0,0 +1,38 @@
+#ifndef _LINUX_TYPES_H
+#define _LINUX_TYPES_H
+
+#include <asm/types.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/posix_types.h>
+
+
+/*
+ * Below are truly Linux-specific types that should never collide with
+ * any application/library that wants linux/types.h.
+ */
+
+#ifdef __CHECKER__
+#define __bitwise__ __attribute__((bitwise))
+#else
+#define __bitwise__
+#endif
+#ifdef __CHECK_ENDIAN__
+#define __bitwise __bitwise__
+#else
+#define __bitwise
+#endif
+
+typedef __u16 __bitwise __le16;
+typedef __u16 __bitwise __be16;
+typedef __u32 __bitwise __le32;
+typedef __u32 __bitwise __be32;
+typedef __u64 __bitwise __le64;
+typedef __u64 __bitwise __be64;
+
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+
+#endif /*  __ASSEMBLY__ */
+#endif /* _LINUX_TYPES_H */
diff -uNr linux-2.6.32/usr/include/linux/udf_fs_i.h clean_modified/linux-2.6.32/usr/include/linux/udf_fs_i.h
--- linux-2.6.32/usr/include/linux/udf_fs_i.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/udf_fs_i.h	2019-04-14 13:24:03.156779200 -0500
@@ -0,0 +1,21 @@
+/*
+ * udf_fs_i.h
+ *
+ * This file is intended for the Linux kernel/module. 
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+#ifndef _UDF_FS_I_H
+#define _UDF_FS_I_H 1
+
+/* exported IOCTLs, we have 'l', 0x40-0x7f */
+#define UDF_GETEASIZE   _IOR('l', 0x40, int)
+#define UDF_GETEABLOCK  _IOR('l', 0x41, void *)
+#define UDF_GETVOLIDENT _IOR('l', 0x42, void *)
+#define UDF_RELOCATE_BLOCKS _IOWR('l', 0x43, long)
+
+#endif /* _UDF_FS_I_H */
diff -uNr linux-2.6.32/usr/include/linux/udp.h clean_modified/linux-2.6.32/usr/include/linux/udp.h
--- linux-2.6.32/usr/include/linux/udp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/udp.h	2019-04-14 13:24:03.158143966 -0500
@@ -0,0 +1,39 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the UDP protocol.
+ *
+ * Version:	@(#)udp.h	1.0.2	04/28/93
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_UDP_H
+#define _LINUX_UDP_H
+
+#include <linux/types.h>
+
+struct udphdr {
+	__be16	source;
+	__be16	dest;
+	__be16	len;
+	__sum16	check;
+};
+
+/* UDP socket options */
+#define UDP_CORK	1	/* Never send partially complete segments */
+#define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
+
+/* UDP encapsulation types */
+#define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
+#define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
+#define UDP_ENCAP_L2TPINUDP	3 /* rfc2661 */
+
+
+#endif	/* _LINUX_UDP_H */
diff -uNr linux-2.6.32/usr/include/linux/uinput.h clean_modified/linux-2.6.32/usr/include/linux/uinput.h
--- linux-2.6.32/usr/include/linux/uinput.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/uinput.h	2019-04-14 13:24:03.158143966 -0500
@@ -0,0 +1,136 @@
+#ifndef __UINPUT_H_
+#define __UINPUT_H_
+/*
+ *  User level driver support for input subsystem
+ *
+ * Heavily based on evdev.c by Vojtech Pavlik
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
+ *
+ * Changes/Revisions:
+ *	0.3	24/05/2006 (Anssi Hannula <anssi.hannulagmail.com>)
+ *		- update ff support for the changes in kernel interface
+ *		- add UINPUT_VERSION
+ *	0.2	16/10/2004 (Micah Dowty <micah@navi.cx>)
+ *		- added force feedback support
+ *             - added UI_SET_PHYS
+ *	0.1	20/06/2002
+ *		- first public version
+ */
+
+#include <linux/input.h>
+
+#define UINPUT_VERSION		3
+
+
+struct uinput_ff_upload {
+	int			request_id;
+	int			retval;
+	struct ff_effect	effect;
+	struct ff_effect	old;
+};
+
+struct uinput_ff_erase {
+	int			request_id;
+	int			retval;
+	int			effect_id;
+};
+
+/* ioctl */
+#define UINPUT_IOCTL_BASE	'U'
+#define UI_DEV_CREATE		_IO(UINPUT_IOCTL_BASE, 1)
+#define UI_DEV_DESTROY		_IO(UINPUT_IOCTL_BASE, 2)
+
+#define UI_SET_EVBIT		_IOW(UINPUT_IOCTL_BASE, 100, int)
+#define UI_SET_KEYBIT		_IOW(UINPUT_IOCTL_BASE, 101, int)
+#define UI_SET_RELBIT		_IOW(UINPUT_IOCTL_BASE, 102, int)
+#define UI_SET_ABSBIT		_IOW(UINPUT_IOCTL_BASE, 103, int)
+#define UI_SET_MSCBIT		_IOW(UINPUT_IOCTL_BASE, 104, int)
+#define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)
+#define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)
+#define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)
+#define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)
+#define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)
+
+#define UI_BEGIN_FF_UPLOAD	_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload)
+#define UI_END_FF_UPLOAD	_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload)
+#define UI_BEGIN_FF_ERASE	_IOWR(UINPUT_IOCTL_BASE, 202, struct uinput_ff_erase)
+#define UI_END_FF_ERASE		_IOW(UINPUT_IOCTL_BASE, 203, struct uinput_ff_erase)
+
+/*
+ * To write a force-feedback-capable driver, the upload_effect
+ * and erase_effect callbacks in input_dev must be implemented.
+ * The uinput driver will generate a fake input event when one of
+ * these callbacks are invoked. The userspace code then uses
+ * ioctls to retrieve additional parameters and send the return code.
+ * The callback blocks until this return code is sent.
+ *
+ * The described callback mechanism is only used if ff_effects_max
+ * is set.
+ *
+ * To implement upload_effect():
+ *   1. Wait for an event with type == EV_UINPUT and code == UI_FF_UPLOAD.
+ *      A request ID will be given in 'value'.
+ *   2. Allocate a uinput_ff_upload struct, fill in request_id with
+ *      the 'value' from the EV_UINPUT event.
+ *   3. Issue a UI_BEGIN_FF_UPLOAD ioctl, giving it the
+ *      uinput_ff_upload struct. It will be filled in with the
+ *      ff_effects passed to upload_effect().
+ *   4. Perform the effect upload, and place a return code back into
+        the uinput_ff_upload struct.
+ *   5. Issue a UI_END_FF_UPLOAD ioctl, also giving it the
+ *      uinput_ff_upload_effect struct. This will complete execution
+ *      of our upload_effect() handler.
+ *
+ * To implement erase_effect():
+ *   1. Wait for an event with type == EV_UINPUT and code == UI_FF_ERASE.
+ *      A request ID will be given in 'value'.
+ *   2. Allocate a uinput_ff_erase struct, fill in request_id with
+ *      the 'value' from the EV_UINPUT event.
+ *   3. Issue a UI_BEGIN_FF_ERASE ioctl, giving it the
+ *      uinput_ff_erase struct. It will be filled in with the
+ *      effect ID passed to erase_effect().
+ *   4. Perform the effect erasure, and place a return code back
+ *      into the uinput_ff_erase struct.
+ *   5. Issue a UI_END_FF_ERASE ioctl, also giving it the
+ *      uinput_ff_erase_effect struct. This will complete execution
+ *      of our erase_effect() handler.
+ */
+
+/*
+ * This is the new event type, used only by uinput.
+ * 'code' is UI_FF_UPLOAD or UI_FF_ERASE, and 'value'
+ * is the unique request ID. This number was picked
+ * arbitrarily, above EV_MAX (since the input system
+ * never sees it) but in the range of a 16-bit int.
+ */
+#define EV_UINPUT		0x0101
+#define UI_FF_UPLOAD		1
+#define UI_FF_ERASE		2
+
+#define UINPUT_MAX_NAME_SIZE	80
+struct uinput_user_dev {
+	char name[UINPUT_MAX_NAME_SIZE];
+	struct input_id id;
+        int ff_effects_max;
+        int absmax[ABS_MAX + 1];
+        int absmin[ABS_MAX + 1];
+        int absfuzz[ABS_MAX + 1];
+        int absflat[ABS_MAX + 1];
+};
+#endif	/* __UINPUT_H_ */
+
diff -uNr linux-2.6.32/usr/include/linux/uio.h clean_modified/linux-2.6.32/usr/include/linux/uio.h
--- linux-2.6.32/usr/include/linux/uio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/uio.h	2019-04-14 13:24:03.158143966 -0500
@@ -0,0 +1,30 @@
+#ifndef __LINUX_UIO_H
+#define __LINUX_UIO_H
+
+
+#include <linux/types.h>
+
+/*
+ *	Berkeley style UIO structures	-	Alan Cox 1994.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+struct iovec
+{
+	void *iov_base;	/* BSD uses caddr_t (1003.1g requires void *) */
+	__kernel_size_t iov_len; /* Must be size_t (1003.1g) */
+};
+
+/*
+ *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
+ */
+ 
+#define UIO_FASTIOV	8
+#define UIO_MAXIOV	1024
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/ultrasound.h clean_modified/linux-2.6.32/usr/include/linux/ultrasound.h
--- linux-2.6.32/usr/include/linux/ultrasound.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/ultrasound.h	2019-04-14 13:24:03.158143966 -0500
@@ -0,0 +1,103 @@
+#ifndef _ULTRASOUND_H_
+#define _ULTRASOUND_H_
+/*
+ *	ultrasound.h - Macros for programming the Gravis Ultrasound
+ *			These macros are extremely device dependent
+ *			and not portable.
+ */
+/*
+ * Copyright (C) by Hannu Savolainen 1993-1997
+ *
+ * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
+ * Version 2 (June 1991). See the "COPYING" file distributed with this software
+ * for more info.
+ */
+
+
+/*
+ *	Private events for Gravis Ultrasound (GUS)
+ *
+ *	Format:
+ *		byte 0 		- SEQ_PRIVATE (0xfe)
+ *		byte 1 		- Synthesizer device number (0-N)
+ *		byte 2 		- Command (see below)
+ *		byte 3 		- Voice number (0-31)
+ *		bytes 4 and 5	- parameter P1 (unsigned short)
+ *		bytes 6 and 7	- parameter P2 (unsigned short)
+ *
+ *	Commands:
+ *		Each command affects one voice defined in byte 3.
+ *		Unused parameters (P1 and/or P2 *MUST* be initialized to zero).
+ *		_GUS_NUMVOICES	- Sets max. number of concurrent voices (P1=14-31, default 16)
+ *		_GUS_VOICESAMPLE- ************ OBSOLETE *************
+ *		_GUS_VOICEON	- Starts voice (P1=voice mode)
+ *		_GUS_VOICEOFF	- Stops voice (no parameters)
+ *		_GUS_VOICEFADE	- Stops the voice smoothly.
+ *		_GUS_VOICEMODE	- Alters the voice mode, don't start or stop voice (P1=voice mode)
+ *		_GUS_VOICEBALA	- Sets voice balance (P1, 0=left, 7=middle and 15=right, default 7)
+ *		_GUS_VOICEFREQ	- Sets voice (sample) playback frequency (P1=Hz)
+ *		_GUS_VOICEVOL	- Sets voice volume (P1=volume, 0xfff=max, 0xeff=half, 0x000=off)
+ *		_GUS_VOICEVOL2	- Sets voice volume (P1=volume, 0xfff=max, 0xeff=half, 0x000=off)
+ *				  (Like GUS_VOICEVOL but doesn't change the hw
+ *				  volume. It just updates volume in the voice table).
+ *
+ *		_GUS_RAMPRANGE	- Sets limits for volume ramping (P1=low volume, P2=high volume)
+ *		_GUS_RAMPRATE	- Sets the speed for volume ramping (P1=scale, P2=rate)
+ *		_GUS_RAMPMODE	- Sets the volume ramping mode (P1=ramping mode)
+ *		_GUS_RAMPON	- Starts volume ramping (no parameters)
+ *		_GUS_RAMPOFF	- Stops volume ramping (no parameters)
+ *		_GUS_VOLUME_SCALE - Changes the volume calculation constants
+ *				  for all voices.
+ */
+
+#define _GUS_NUMVOICES		0x00
+#define _GUS_VOICESAMPLE	0x01	/* OBSOLETE */
+#define _GUS_VOICEON		0x02
+#define _GUS_VOICEOFF		0x03
+#define _GUS_VOICEMODE		0x04
+#define _GUS_VOICEBALA		0x05
+#define _GUS_VOICEFREQ		0x06
+#define _GUS_VOICEVOL		0x07
+#define _GUS_RAMPRANGE		0x08
+#define _GUS_RAMPRATE		0x09
+#define _GUS_RAMPMODE		0x0a
+#define _GUS_RAMPON		0x0b
+#define _GUS_RAMPOFF		0x0c
+#define _GUS_VOICEFADE		0x0d
+#define _GUS_VOLUME_SCALE	0x0e
+#define _GUS_VOICEVOL2		0x0f
+#define _GUS_VOICE_POS		0x10
+
+/*
+ *	GUS API macros
+ */
+
+#define _GUS_CMD(chn, voice, cmd, p1, p2) \
+					{_SEQ_NEEDBUF(8); _seqbuf[_seqbufptr] = SEQ_PRIVATE;\
+					_seqbuf[_seqbufptr+1] = (chn); _seqbuf[_seqbufptr+2] = cmd;\
+					_seqbuf[_seqbufptr+3] = voice;\
+					*(unsigned short*)&_seqbuf[_seqbufptr+4] = p1;\
+					*(unsigned short*)&_seqbuf[_seqbufptr+6] = p2;\
+					_SEQ_ADVBUF(8);}
+
+#define GUS_NUMVOICES(chn, p1)			_GUS_CMD(chn, 0, _GUS_NUMVOICES, (p1), 0)
+#define GUS_VOICESAMPLE(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICESAMPLE, (p1), 0)	/* OBSOLETE */
+#define GUS_VOICEON(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICEON, (p1), 0)
+#define GUS_VOICEOFF(chn, voice)		_GUS_CMD(chn, voice, _GUS_VOICEOFF, 0, 0)
+#define GUS_VOICEFADE(chn, voice)		_GUS_CMD(chn, voice, _GUS_VOICEFADE, 0, 0)
+#define GUS_VOICEMODE(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICEMODE, (p1), 0)
+#define GUS_VOICEBALA(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICEBALA, (p1), 0)
+#define GUS_VOICEFREQ(chn, voice, p)		_GUS_CMD(chn, voice, _GUS_VOICEFREQ, \
+							(p) & 0xffff, ((p) >> 16) & 0xffff)
+#define GUS_VOICEVOL(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICEVOL, (p1), 0)
+#define GUS_VOICEVOL2(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_VOICEVOL2, (p1), 0)
+#define GUS_RAMPRANGE(chn, voice, low, high)	_GUS_CMD(chn, voice, _GUS_RAMPRANGE, (low), (high))
+#define GUS_RAMPRATE(chn, voice, p1, p2)	_GUS_CMD(chn, voice, _GUS_RAMPRATE, (p1), (p2))
+#define GUS_RAMPMODE(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_RAMPMODE, (p1), 0)
+#define GUS_RAMPON(chn, voice, p1)		_GUS_CMD(chn, voice, _GUS_RAMPON, (p1), 0)
+#define GUS_RAMPOFF(chn, voice)			_GUS_CMD(chn, voice, _GUS_RAMPOFF, 0, 0)
+#define GUS_VOLUME_SCALE(chn, voice, p1, p2)	_GUS_CMD(chn, voice, _GUS_VOLUME_SCALE, (p1), (p2))
+#define GUS_VOICE_POS(chn, voice, p)		_GUS_CMD(chn, voice, _GUS_VOICE_POS, \
+							(p) & 0xffff, ((p) >> 16) & 0xffff)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/un.h clean_modified/linux-2.6.32/usr/include/linux/un.h
--- linux-2.6.32/usr/include/linux/un.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/un.h	2019-04-14 13:24:03.158143966 -0500
@@ -0,0 +1,11 @@
+#ifndef _LINUX_UN_H
+#define _LINUX_UN_H
+
+#define UNIX_PATH_MAX	108
+
+struct sockaddr_un {
+	sa_family_t sun_family;	/* AF_UNIX */
+	char sun_path[UNIX_PATH_MAX];	/* pathname */
+};
+
+#endif /* _LINUX_UN_H */
diff -uNr linux-2.6.32/usr/include/linux/unistd.h clean_modified/linux-2.6.32/usr/include/linux/unistd.h
--- linux-2.6.32/usr/include/linux/unistd.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/unistd.h	2019-04-14 13:24:03.159709296 -0500
@@ -0,0 +1,9 @@
+#ifndef _LINUX_UNISTD_H_
+#define _LINUX_UNISTD_H_
+
+/*
+ * Include machine specific syscall numbers
+ */
+#include <asm/unistd.h>
+
+#endif /* _LINUX_UNISTD_H_ */
diff -uNr linux-2.6.32/usr/include/linux/usb/audio.h clean_modified/linux-2.6.32/usr/include/linux/usb/audio.h
--- linux-2.6.32/usr/include/linux/usb/audio.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/audio.h	2019-04-14 13:24:03.159709296 -0500
@@ -0,0 +1,280 @@
+/*
+ * <linux/usb/audio.h> -- USB Audio definitions.
+ *
+ * Copyright (C) 2006 Thumtronics Pty Ltd.
+ * Developed for Thumtronics by Grey Innovation
+ * Ben Williamson <ben.williamson@greyinnovation.com>
+ *
+ * This software is distributed under the terms of the GNU General Public
+ * License ("GPL") version 2, as published by the Free Software Foundation.
+ *
+ * This file holds USB constants and structures defined
+ * by the USB Device Class Definition for Audio Devices.
+ * Comments below reference relevant sections of that document:
+ *
+ * http://www.usb.org/developers/devclass_docs/audio10.pdf
+ */
+
+#ifndef __LINUX_USB_AUDIO_H
+#define __LINUX_USB_AUDIO_H
+
+#include <linux/types.h>
+
+/* A.2 Audio Interface Subclass Codes */
+#define USB_SUBCLASS_AUDIOCONTROL	0x01
+#define USB_SUBCLASS_AUDIOSTREAMING	0x02
+#define USB_SUBCLASS_MIDISTREAMING	0x03
+
+/* A.5 Audio Class-Specific AC Interface Descriptor Subtypes */
+#define UAC_HEADER			0x01
+#define UAC_INPUT_TERMINAL		0x02
+#define UAC_OUTPUT_TERMINAL		0x03
+#define UAC_MIXER_UNIT			0x04
+#define UAC_SELECTOR_UNIT		0x05
+#define UAC_FEATURE_UNIT		0x06
+#define UAC_PROCESSING_UNIT		0x07
+#define UAC_EXTENSION_UNIT		0x08
+
+/* A.6 Audio Class-Specific AS Interface Descriptor Subtypes */
+#define UAC_AS_GENERAL			0x01
+#define UAC_FORMAT_TYPE			0x02
+#define UAC_FORMAT_SPECIFIC		0x03
+
+/* A.8 Audio Class-Specific Endpoint Descriptor Subtypes */
+#define UAC_EP_GENERAL			0x01
+
+/* A.9 Audio Class-Specific Request Codes */
+#define UAC_SET_			0x00
+#define UAC_GET_			0x80
+
+#define UAC__CUR			0x1
+#define UAC__MIN			0x2
+#define UAC__MAX			0x3
+#define UAC__RES			0x4
+#define UAC__MEM			0x5
+
+#define UAC_SET_CUR			(UAC_SET_ | UAC__CUR)
+#define UAC_GET_CUR			(UAC_GET_ | UAC__CUR)
+#define UAC_SET_MIN			(UAC_SET_ | UAC__MIN)
+#define UAC_GET_MIN			(UAC_GET_ | UAC__MIN)
+#define UAC_SET_MAX			(UAC_SET_ | UAC__MAX)
+#define UAC_GET_MAX			(UAC_GET_ | UAC__MAX)
+#define UAC_SET_RES			(UAC_SET_ | UAC__RES)
+#define UAC_GET_RES			(UAC_GET_ | UAC__RES)
+#define UAC_SET_MEM			(UAC_SET_ | UAC__MEM)
+#define UAC_GET_MEM			(UAC_GET_ | UAC__MEM)
+
+#define UAC_GET_STAT			0xff
+
+/* MIDI - A.1 MS Class-Specific Interface Descriptor Subtypes */
+#define UAC_MS_HEADER			0x01
+#define UAC_MIDI_IN_JACK		0x02
+#define UAC_MIDI_OUT_JACK		0x03
+
+/* MIDI - A.1 MS Class-Specific Endpoint Descriptor Subtypes */
+#define UAC_MS_GENERAL			0x01
+
+/* Terminals - 2.1 USB Terminal Types */
+#define UAC_TERMINAL_UNDEFINED		0x100
+#define UAC_TERMINAL_STREAMING		0x101
+#define UAC_TERMINAL_VENDOR_SPEC	0x1FF
+
+/* Terminal Control Selectors */
+/* 4.3.2  Class-Specific AC Interface Descriptor */
+struct uac_ac_header_descriptor {
+	__u8  bLength;			/* 8 + n */
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* UAC_MS_HEADER */
+	__le16 bcdADC;			/* 0x0100 */
+	__le16 wTotalLength;		/* includes Unit and Terminal desc. */
+	__u8  bInCollection;		/* n */
+	__u8  baInterfaceNr[];		/* [n] */
+} __attribute__ ((packed));
+
+#define UAC_DT_AC_HEADER_SIZE(n)	(8 + (n))
+
+/* As above, but more useful for defining your own descriptors: */
+#define DECLARE_UAC_AC_HEADER_DESCRIPTOR(n) 			\
+struct uac_ac_header_descriptor_##n {				\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__le16 bcdADC;						\
+	__le16 wTotalLength;					\
+	__u8  bInCollection;					\
+	__u8  baInterfaceNr[n];					\
+} __attribute__ ((packed))
+
+/* 4.3.2.1 Input Terminal Descriptor */
+struct uac_input_terminal_descriptor {
+	__u8  bLength;			/* in bytes: 12 */
+	__u8  bDescriptorType;		/* CS_INTERFACE descriptor type */
+	__u8  bDescriptorSubtype;	/* INPUT_TERMINAL descriptor subtype */
+	__u8  bTerminalID;		/* Constant uniquely terminal ID */
+	__le16 wTerminalType;		/* USB Audio Terminal Types */
+	__u8  bAssocTerminal;		/* ID of the Output Terminal associated */
+	__u8  bNrChannels;		/* Number of logical output channels */
+	__le16 wChannelConfig;
+	__u8  iChannelNames;
+	__u8  iTerminal;
+} __attribute__ ((packed));
+
+#define UAC_DT_INPUT_TERMINAL_SIZE			12
+
+/* Terminals - 2.2 Input Terminal Types */
+#define UAC_INPUT_TERMINAL_UNDEFINED			0x200
+#define UAC_INPUT_TERMINAL_MICROPHONE			0x201
+#define UAC_INPUT_TERMINAL_DESKTOP_MICROPHONE		0x202
+#define UAC_INPUT_TERMINAL_PERSONAL_MICROPHONE		0x203
+#define UAC_INPUT_TERMINAL_OMNI_DIR_MICROPHONE		0x204
+#define UAC_INPUT_TERMINAL_MICROPHONE_ARRAY		0x205
+#define UAC_INPUT_TERMINAL_PROC_MICROPHONE_ARRAY	0x206
+
+/* 4.3.2.2 Output Terminal Descriptor */
+struct uac_output_terminal_descriptor {
+	__u8  bLength;			/* in bytes: 9 */
+	__u8  bDescriptorType;		/* CS_INTERFACE descriptor type */
+	__u8  bDescriptorSubtype;	/* OUTPUT_TERMINAL descriptor subtype */
+	__u8  bTerminalID;		/* Constant uniquely terminal ID */
+	__le16 wTerminalType;		/* USB Audio Terminal Types */
+	__u8  bAssocTerminal;		/* ID of the Input Terminal associated */
+	__u8  bSourceID;		/* ID of the connected Unit or Terminal*/
+	__u8  iTerminal;
+} __attribute__ ((packed));
+
+#define UAC_DT_OUTPUT_TERMINAL_SIZE			9
+
+/* Terminals - 2.3 Output Terminal Types */
+#define UAC_OUTPUT_TERMINAL_UNDEFINED			0x300
+#define UAC_OUTPUT_TERMINAL_SPEAKER			0x301
+#define UAC_OUTPUT_TERMINAL_HEADPHONES			0x302
+#define UAC_OUTPUT_TERMINAL_HEAD_MOUNTED_DISPLAY_AUDIO	0x303
+#define UAC_OUTPUT_TERMINAL_DESKTOP_SPEAKER		0x304
+#define UAC_OUTPUT_TERMINAL_ROOM_SPEAKER		0x305
+#define UAC_OUTPUT_TERMINAL_COMMUNICATION_SPEAKER	0x306
+#define UAC_OUTPUT_TERMINAL_LOW_FREQ_EFFECTS_SPEAKER	0x307
+
+/* Set bControlSize = 2 as default setting */
+#define UAC_DT_FEATURE_UNIT_SIZE(ch)		(7 + ((ch) + 1) * 2)
+
+/* As above, but more useful for defining your own descriptors: */
+#define DECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(ch) 		\
+struct uac_feature_unit_descriptor_##ch {			\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__u8  bUnitID;						\
+	__u8  bSourceID;					\
+	__u8  bControlSize;					\
+	__le16 bmaControls[ch + 1];				\
+	__u8  iFeature;						\
+} __attribute__ ((packed))
+
+/* 4.5.2 Class-Specific AS Interface Descriptor */
+struct uac_as_header_descriptor {
+	__u8  bLength;			/* in bytes: 7 */
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* AS_GENERAL */
+	__u8  bTerminalLink;		/* Terminal ID of connected Terminal */
+	__u8  bDelay;			/* Delay introduced by the data path */
+	__le16 wFormatTag;		/* The Audio Data Format */
+} __attribute__ ((packed));
+
+#define UAC_DT_AS_HEADER_SIZE		7
+
+/* Formats - A.1.1 Audio Data Format Type I Codes */
+#define UAC_FORMAT_TYPE_I_UNDEFINED	0x0
+#define UAC_FORMAT_TYPE_I_PCM		0x1
+#define UAC_FORMAT_TYPE_I_PCM8		0x2
+#define UAC_FORMAT_TYPE_I_IEEE_FLOAT	0x3
+#define UAC_FORMAT_TYPE_I_ALAW		0x4
+#define UAC_FORMAT_TYPE_I_MULAW		0x5
+
+struct uac_format_type_i_continuous_descriptor {
+	__u8  bLength;			/* in bytes: 8 + (ns * 3) */
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* FORMAT_TYPE */
+	__u8  bFormatType;		/* FORMAT_TYPE_1 */
+	__u8  bNrChannels;		/* physical channels in the stream */
+	__u8  bSubframeSize;		/* */
+	__u8  bBitResolution;
+	__u8  bSamFreqType;
+	__u8  tLowerSamFreq[3];
+	__u8  tUpperSamFreq[3];
+} __attribute__ ((packed));
+
+#define UAC_FORMAT_TYPE_I_CONTINUOUS_DESC_SIZE	14
+
+struct uac_format_type_i_discrete_descriptor {
+	__u8  bLength;			/* in bytes: 8 + (ns * 3) */
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* FORMAT_TYPE */
+	__u8  bFormatType;		/* FORMAT_TYPE_1 */
+	__u8  bNrChannels;		/* physical channels in the stream */
+	__u8  bSubframeSize;		/* */
+	__u8  bBitResolution;
+	__u8  bSamFreqType;
+	__u8  tSamFreq[][3];
+} __attribute__ ((packed));
+
+#define DECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(n) 		\
+struct uac_format_type_i_discrete_descriptor_##n {		\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__u8  bFormatType;					\
+	__u8  bNrChannels;					\
+	__u8  bSubframeSize;					\
+	__u8  bBitResolution;					\
+	__u8  bSamFreqType;					\
+	__u8  tSamFreq[n][3];					\
+} __attribute__ ((packed))
+
+#define UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(n)	(8 + (n * 3))
+
+/* Formats - A.2 Format Type Codes */
+#define UAC_FORMAT_TYPE_UNDEFINED	0x0
+#define UAC_FORMAT_TYPE_I		0x1
+#define UAC_FORMAT_TYPE_II		0x2
+#define UAC_FORMAT_TYPE_III		0x3
+
+struct uac_iso_endpoint_descriptor {
+	__u8  bLength;			/* in bytes: 7 */
+	__u8  bDescriptorType;		/* USB_DT_CS_ENDPOINT */
+	__u8  bDescriptorSubtype;	/* EP_GENERAL */
+	__u8  bmAttributes;
+	__u8  bLockDelayUnits;
+	__le16 wLockDelay;
+};
+#define UAC_ISO_ENDPOINT_DESC_SIZE	7
+
+#define UAC_EP_CS_ATTR_SAMPLE_RATE	0x01
+#define UAC_EP_CS_ATTR_PITCH_CONTROL	0x02
+#define UAC_EP_CS_ATTR_FILL_MAX		0x80
+
+/* A.10.2 Feature Unit Control Selectors */
+#define UAC_FU_CONTROL_UNDEFINED	0x00
+#define UAC_MUTE_CONTROL		0x01
+#define UAC_VOLUME_CONTROL		0x02
+#define UAC_BASS_CONTROL		0x03
+#define UAC_MID_CONTROL			0x04
+#define UAC_TREBLE_CONTROL		0x05
+#define UAC_GRAPHIC_EQUALIZER_CONTROL	0x06
+#define UAC_AUTOMATIC_GAIN_CONTROL	0x07
+#define UAC_DELAY_CONTROL		0x08
+#define UAC_BASS_BOOST_CONTROL		0x09
+#define UAC_LOUDNESS_CONTROL		0x0a
+
+#define UAC_FU_MUTE		(1 << (UAC_MUTE_CONTROL - 1))
+#define UAC_FU_VOLUME		(1 << (UAC_VOLUME_CONTROL - 1))
+#define UAC_FU_BASS		(1 << (UAC_BASS_CONTROL - 1))
+#define UAC_FU_MID		(1 << (UAC_MID_CONTROL - 1))
+#define UAC_FU_TREBLE		(1 << (UAC_TREBLE_CONTROL - 1))
+#define UAC_FU_GRAPHIC_EQ	(1 << (UAC_GRAPHIC_EQUALIZER_CONTROL - 1))
+#define UAC_FU_AUTO_GAIN	(1 << (UAC_AUTOMATIC_GAIN_CONTROL - 1))
+#define UAC_FU_DELAY		(1 << (UAC_DELAY_CONTROL - 1))
+#define UAC_FU_BASS_BOOST	(1 << (UAC_BASS_BOOST_CONTROL - 1))
+#define UAC_FU_LOUDNESS		(1 << (UAC_LOUDNESS_CONTROL - 1))
+
+
+#endif /* __LINUX_USB_AUDIO_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/cdc.h clean_modified/linux-2.6.32/usr/include/linux/usb/cdc.h
--- linux-2.6.32/usr/include/linux/usb/cdc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/cdc.h	2019-04-14 13:24:03.160701435 -0500
@@ -0,0 +1,250 @@
+/*
+ * USB Communications Device Class (CDC) definitions
+ *
+ * CDC says how to talk to lots of different types of network adapters,
+ * notably ethernet adapters and various modems.  It's used mostly with
+ * firmware based USB peripherals.
+ */
+
+#ifndef __LINUX_USB_CDC_H
+#define __LINUX_USB_CDC_H
+
+#include <linux/types.h>
+
+#define USB_CDC_SUBCLASS_ACM			0x02
+#define USB_CDC_SUBCLASS_ETHERNET		0x06
+#define USB_CDC_SUBCLASS_WHCM			0x08
+#define USB_CDC_SUBCLASS_DMM			0x09
+#define USB_CDC_SUBCLASS_MDLM			0x0a
+#define USB_CDC_SUBCLASS_OBEX			0x0b
+#define USB_CDC_SUBCLASS_EEM			0x0c
+
+#define USB_CDC_PROTO_NONE			0
+
+#define USB_CDC_ACM_PROTO_AT_V25TER		1
+#define USB_CDC_ACM_PROTO_AT_PCCA101		2
+#define USB_CDC_ACM_PROTO_AT_PCCA101_WAKE	3
+#define USB_CDC_ACM_PROTO_AT_GSM		4
+#define USB_CDC_ACM_PROTO_AT_3G			5
+#define USB_CDC_ACM_PROTO_AT_CDMA		6
+#define USB_CDC_ACM_PROTO_VENDOR		0xff
+
+#define USB_CDC_PROTO_EEM			7
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific descriptors ... there are a couple dozen of them
+ */
+
+#define USB_CDC_HEADER_TYPE		0x00	/* header_desc */
+#define USB_CDC_CALL_MANAGEMENT_TYPE	0x01	/* call_mgmt_descriptor */
+#define USB_CDC_ACM_TYPE		0x02	/* acm_descriptor */
+#define USB_CDC_UNION_TYPE		0x06	/* union_desc */
+#define USB_CDC_COUNTRY_TYPE		0x07
+#define USB_CDC_NETWORK_TERMINAL_TYPE	0x0a	/* network_terminal_desc */
+#define USB_CDC_ETHERNET_TYPE		0x0f	/* ether_desc */
+#define USB_CDC_WHCM_TYPE		0x11
+#define USB_CDC_MDLM_TYPE		0x12	/* mdlm_desc */
+#define USB_CDC_MDLM_DETAIL_TYPE	0x13	/* mdlm_detail_desc */
+#define USB_CDC_DMM_TYPE		0x14
+#define USB_CDC_OBEX_TYPE		0x15
+
+/* "Header Functional Descriptor" from CDC spec  5.2.3.1 */
+struct usb_cdc_header_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__le16	bcdCDC;
+} __attribute__ ((packed));
+
+/* "Call Management Descriptor" from CDC spec  5.2.3.2 */
+struct usb_cdc_call_mgmt_descriptor {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	bmCapabilities;
+#define USB_CDC_CALL_MGMT_CAP_CALL_MGMT		0x01
+#define USB_CDC_CALL_MGMT_CAP_DATA_INTF		0x02
+
+	__u8	bDataInterface;
+} __attribute__ ((packed));
+
+/* "Abstract Control Management Descriptor" from CDC spec  5.2.3.3 */
+struct usb_cdc_acm_descriptor {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	bmCapabilities;
+} __attribute__ ((packed));
+
+/* capabilities from 5.2.3.3 */
+
+#define USB_CDC_COMM_FEATURE	0x01
+#define USB_CDC_CAP_LINE	0x02
+#define USB_CDC_CAP_BRK	0x04
+#define USB_CDC_CAP_NOTIFY	0x08
+
+/* "Union Functional Descriptor" from CDC spec 5.2.3.8 */
+struct usb_cdc_union_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	bMasterInterface0;
+	__u8	bSlaveInterface0;
+	/* ... and there could be other slave interfaces */
+} __attribute__ ((packed));
+
+/* "Country Selection Functional Descriptor" from CDC spec 5.2.3.9 */
+struct usb_cdc_country_functional_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	iCountryCodeRelDate;
+	__le16	wCountyCode0;
+	/* ... and there can be a lot of country codes */
+} __attribute__ ((packed));
+
+/* "Network Channel Terminal Functional Descriptor" from CDC spec 5.2.3.11 */
+struct usb_cdc_network_terminal_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	bEntityId;
+	__u8	iName;
+	__u8	bChannelIndex;
+	__u8	bPhysicalInterface;
+} __attribute__ ((packed));
+
+/* "Ethernet Networking Functional Descriptor" from CDC spec 5.2.3.16 */
+struct usb_cdc_ether_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__u8	iMACAddress;
+	__le32	bmEthernetStatistics;
+	__le16	wMaxSegmentSize;
+	__le16	wNumberMCFilters;
+	__u8	bNumberPowerFilters;
+} __attribute__ ((packed));
+
+/* "Telephone Control Model Functional Descriptor" from CDC WMC spec 6.3..3 */
+struct usb_cdc_dmm_desc {
+	__u8	bFunctionLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubtype;
+	__u16	bcdVersion;
+	__le16	wMaxCommand;
+} __attribute__ ((packed));
+
+/* "MDLM Functional Descriptor" from CDC WMC spec 6.7.2.3 */
+struct usb_cdc_mdlm_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__le16	bcdVersion;
+	__u8	bGUID[16];
+} __attribute__ ((packed));
+
+/* "MDLM Detail Functional Descriptor" from CDC WMC spec 6.7.2.4 */
+struct usb_cdc_mdlm_detail_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	/* type is associated with mdlm_desc.bGUID */
+	__u8	bGuidDescriptorType;
+	__u8	bDetailData[0];
+} __attribute__ ((packed));
+
+/* "OBEX Control Model Functional Descriptor" */
+struct usb_cdc_obex_desc {
+	__u8	bLength;
+	__u8	bDescriptorType;
+	__u8	bDescriptorSubType;
+
+	__le16	bcdVersion;
+} __attribute__ ((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific Control Requests (6.2)
+ *
+ * section 3.6.2.1 table 4 has the ACM profile, for modems.
+ * section 3.8.2 table 10 has the ethernet profile.
+ *
+ * Microsoft's RNDIS stack for Ethernet is a vendor-specific CDC ACM variant,
+ * heavily dependent on the encapsulated (proprietary) command mechanism.
+ */
+
+#define USB_CDC_SEND_ENCAPSULATED_COMMAND	0x00
+#define USB_CDC_GET_ENCAPSULATED_RESPONSE	0x01
+#define USB_CDC_REQ_SET_LINE_CODING		0x20
+#define USB_CDC_REQ_GET_LINE_CODING		0x21
+#define USB_CDC_REQ_SET_CONTROL_LINE_STATE	0x22
+#define USB_CDC_REQ_SEND_BREAK			0x23
+#define USB_CDC_SET_ETHERNET_MULTICAST_FILTERS	0x40
+#define USB_CDC_SET_ETHERNET_PM_PATTERN_FILTER	0x41
+#define USB_CDC_GET_ETHERNET_PM_PATTERN_FILTER	0x42
+#define USB_CDC_SET_ETHERNET_PACKET_FILTER	0x43
+#define USB_CDC_GET_ETHERNET_STATISTIC		0x44
+
+/* Line Coding Structure from CDC spec 6.2.13 */
+struct usb_cdc_line_coding {
+	__le32	dwDTERate;
+	__u8	bCharFormat;
+#define USB_CDC_1_STOP_BITS			0
+#define USB_CDC_1_5_STOP_BITS			1
+#define USB_CDC_2_STOP_BITS			2
+
+	__u8	bParityType;
+#define USB_CDC_NO_PARITY			0
+#define USB_CDC_ODD_PARITY			1
+#define USB_CDC_EVEN_PARITY			2
+#define USB_CDC_MARK_PARITY			3
+#define USB_CDC_SPACE_PARITY			4
+
+	__u8	bDataBits;
+} __attribute__ ((packed));
+
+/* table 62; bits in multicast filter */
+#define	USB_CDC_PACKET_TYPE_PROMISCUOUS		(1 << 0)
+#define	USB_CDC_PACKET_TYPE_ALL_MULTICAST	(1 << 1) /* no filter */
+#define	USB_CDC_PACKET_TYPE_DIRECTED		(1 << 2)
+#define	USB_CDC_PACKET_TYPE_BROADCAST		(1 << 3)
+#define	USB_CDC_PACKET_TYPE_MULTICAST		(1 << 4) /* filtered */
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific Notifications (6.3) sent by interrupt transfers
+ *
+ * section 3.8.2 table 11 of the CDC spec lists Ethernet notifications
+ * section 3.6.2.1 table 5 specifies ACM notifications, accepted by RNDIS
+ * RNDIS also defines its own bit-incompatible notifications
+ */
+
+#define USB_CDC_NOTIFY_NETWORK_CONNECTION	0x00
+#define USB_CDC_NOTIFY_RESPONSE_AVAILABLE	0x01
+#define USB_CDC_NOTIFY_SERIAL_STATE		0x20
+#define USB_CDC_NOTIFY_SPEED_CHANGE		0x2a
+
+struct usb_cdc_notification {
+	__u8	bmRequestType;
+	__u8	bNotificationType;
+	__le16	wValue;
+	__le16	wIndex;
+	__le16	wLength;
+} __attribute__ ((packed));
+
+#endif /* __LINUX_USB_CDC_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/ch9.h clean_modified/linux-2.6.32/usr/include/linux/usb/ch9.h
--- linux-2.6.32/usr/include/linux/usb/ch9.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/ch9.h	2019-04-14 13:24:03.161675304 -0500
@@ -0,0 +1,807 @@
+/*
+ * This file holds USB constants and structures that are needed for
+ * USB device APIs.  These are used by the USB device model, which is
+ * defined in chapter 9 of the USB 2.0 specification and in the
+ * Wireless USB 1.0 (spread around).  Linux has several APIs in C that
+ * need these:
+ *
+ * - the master/host side Linux-USB kernel driver API;
+ * - the "usbfs" user space API; and
+ * - the Linux "gadget" slave/device/peripheral side driver API.
+ *
+ * USB 2.0 adds an additional "On The Go" (OTG) mode, which lets systems
+ * act either as a USB master/host or as a USB slave/device.  That means
+ * the master and slave side APIs benefit from working well together.
+ *
+ * There's also "Wireless USB", using low power short range radios for
+ * peripheral interconnection but otherwise building on the USB framework.
+ *
+ * Note all descriptors are declared '__attribute__((packed))' so that:
+ *
+ * [a] they never get padded, either internally (USB spec writers
+ *     probably handled that) or externally;
+ *
+ * [b] so that accessing bigger-than-a-bytes fields will never
+ *     generate bus errors on any platform, even when the location of
+ *     its descriptor inside a bundle isn't "naturally aligned", and
+ *
+ * [c] for consistency, removing all doubt even when it appears to
+ *     someone that the two other points are non-issues for that
+ *     particular descriptor type.
+ */
+
+#ifndef __LINUX_USB_CH9_H
+#define __LINUX_USB_CH9_H
+
+#include <linux/types.h>	/* __u8 etc */
+
+/*-------------------------------------------------------------------------*/
+
+/* CONTROL REQUEST SUPPORT */
+
+/*
+ * USB directions
+ *
+ * This bit flag is used in endpoint descriptors' bEndpointAddress field.
+ * It's also one of three fields in control requests bRequestType.
+ */
+#define USB_DIR_OUT			0		/* to device */
+#define USB_DIR_IN			0x80		/* to host */
+
+/*
+ * USB types, the second of three bRequestType fields
+ */
+#define USB_TYPE_MASK			(0x03 << 5)
+#define USB_TYPE_STANDARD		(0x00 << 5)
+#define USB_TYPE_CLASS			(0x01 << 5)
+#define USB_TYPE_VENDOR			(0x02 << 5)
+#define USB_TYPE_RESERVED		(0x03 << 5)
+
+/*
+ * USB recipients, the third of three bRequestType fields
+ */
+#define USB_RECIP_MASK			0x1f
+#define USB_RECIP_DEVICE		0x00
+#define USB_RECIP_INTERFACE		0x01
+#define USB_RECIP_ENDPOINT		0x02
+#define USB_RECIP_OTHER			0x03
+/* From Wireless USB 1.0 */
+#define USB_RECIP_PORT			0x04
+#define USB_RECIP_RPIPE		0x05
+
+/*
+ * Standard requests, for the bRequest field of a SETUP packet.
+ *
+ * These are qualified by the bRequestType field, so that for example
+ * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved
+ * by a GET_STATUS request.
+ */
+#define USB_REQ_GET_STATUS		0x00
+#define USB_REQ_CLEAR_FEATURE		0x01
+#define USB_REQ_SET_FEATURE		0x03
+#define USB_REQ_SET_ADDRESS		0x05
+#define USB_REQ_GET_DESCRIPTOR		0x06
+#define USB_REQ_SET_DESCRIPTOR		0x07
+#define USB_REQ_GET_CONFIGURATION	0x08
+#define USB_REQ_SET_CONFIGURATION	0x09
+#define USB_REQ_GET_INTERFACE		0x0A
+#define USB_REQ_SET_INTERFACE		0x0B
+#define USB_REQ_SYNCH_FRAME		0x0C
+
+#define USB_REQ_SET_ENCRYPTION		0x0D	/* Wireless USB */
+#define USB_REQ_GET_ENCRYPTION		0x0E
+#define USB_REQ_RPIPE_ABORT		0x0E
+#define USB_REQ_SET_HANDSHAKE		0x0F
+#define USB_REQ_RPIPE_RESET		0x0F
+#define USB_REQ_GET_HANDSHAKE		0x10
+#define USB_REQ_SET_CONNECTION		0x11
+#define USB_REQ_SET_SECURITY_DATA	0x12
+#define USB_REQ_GET_SECURITY_DATA	0x13
+#define USB_REQ_SET_WUSB_DATA		0x14
+#define USB_REQ_LOOPBACK_DATA_WRITE	0x15
+#define USB_REQ_LOOPBACK_DATA_READ	0x16
+#define USB_REQ_SET_INTERFACE_DS	0x17
+
+/* The Link Power Management (LPM) ECN defines USB_REQ_TEST_AND_SET command,
+ * used by hubs to put ports into a new L1 suspend state, except that it
+ * forgot to define its number ...
+ */
+
+/*
+ * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
+ * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
+ * are at most sixteen features of each type.)  Hubs may also support a
+ * new USB_REQ_TEST_AND_SET_FEATURE to put ports into L1 suspend.
+ */
+#define USB_DEVICE_SELF_POWERED		0	/* (read only) */
+#define USB_DEVICE_REMOTE_WAKEUP	1	/* dev may initiate wakeup */
+#define USB_DEVICE_TEST_MODE		2	/* (wired high speed only) */
+#define USB_DEVICE_BATTERY		2	/* (wireless) */
+#define USB_DEVICE_B_HNP_ENABLE		3	/* (otg) dev may initiate HNP */
+#define USB_DEVICE_WUSB_DEVICE		3	/* (wireless)*/
+#define USB_DEVICE_A_HNP_SUPPORT	4	/* (otg) RH port supports HNP */
+#define USB_DEVICE_A_ALT_HNP_SUPPORT	5	/* (otg) other RH port does */
+#define USB_DEVICE_DEBUG_MODE		6	/* (special devices only) */
+
+#define USB_ENDPOINT_HALT		0	/* IN/OUT will STALL */
+
+
+/**
+ * struct usb_ctrlrequest - SETUP data for a USB device control request
+ * @bRequestType: matches the USB bmRequestType field
+ * @bRequest: matches the USB bRequest field
+ * @wValue: matches the USB wValue field (le16 byte order)
+ * @wIndex: matches the USB wIndex field (le16 byte order)
+ * @wLength: matches the USB wLength field (le16 byte order)
+ *
+ * This structure is used to send control requests to a USB device.  It matches
+ * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
+ * USB spec for a fuller description of the different fields, and what they are
+ * used for.
+ *
+ * Note that the driver for any interface can issue control requests.
+ * For most devices, interfaces don't coordinate with each other, so
+ * such requests may be made at any time.
+ */
+struct usb_ctrlrequest {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__le16 wValue;
+	__le16 wIndex;
+	__le16 wLength;
+} __attribute__ ((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or
+ * (rarely) accepted by SET_DESCRIPTOR.
+ *
+ * Note that all multi-byte values here are encoded in little endian
+ * byte order "on the wire".  Within the kernel and when exposed
+ * through the Linux-USB APIs, they are not converted to cpu byte
+ * order; it is the responsibility of the client code to do this.
+ * The single exception is when device and configuration descriptors (but
+ * not other descriptors) are read from usbfs (i.e. /proc/bus/usb/BBB/DDD);
+ * in this case the fields are converted to host endianness by the kernel.
+ */
+
+/*
+ * Descriptor types ... USB 2.0 spec table 9.5
+ */
+#define USB_DT_DEVICE			0x01
+#define USB_DT_CONFIG			0x02
+#define USB_DT_STRING			0x03
+#define USB_DT_INTERFACE		0x04
+#define USB_DT_ENDPOINT			0x05
+#define USB_DT_DEVICE_QUALIFIER		0x06
+#define USB_DT_OTHER_SPEED_CONFIG	0x07
+#define USB_DT_INTERFACE_POWER		0x08
+/* these are from a minor usb 2.0 revision (ECN) */
+#define USB_DT_OTG			0x09
+#define USB_DT_DEBUG			0x0a
+#define USB_DT_INTERFACE_ASSOCIATION	0x0b
+/* these are from the Wireless USB spec */
+#define USB_DT_SECURITY			0x0c
+#define USB_DT_KEY			0x0d
+#define USB_DT_ENCRYPTION_TYPE		0x0e
+#define USB_DT_BOS			0x0f
+#define USB_DT_DEVICE_CAPABILITY	0x10
+#define USB_DT_WIRELESS_ENDPOINT_COMP	0x11
+#define USB_DT_WIRE_ADAPTER		0x21
+#define USB_DT_RPIPE			0x22
+#define USB_DT_CS_RADIO_CONTROL		0x23
+/* From the USB 3.0 spec */
+#define	USB_DT_SS_ENDPOINT_COMP		0x30
+
+/* Conventional codes for class-specific descriptors.  The convention is
+ * defined in the USB "Common Class" Spec (3.11).  Individual class specs
+ * are authoritative for their usage, not the "common class" writeup.
+ */
+#define USB_DT_CS_DEVICE		(USB_TYPE_CLASS | USB_DT_DEVICE)
+#define USB_DT_CS_CONFIG		(USB_TYPE_CLASS | USB_DT_CONFIG)
+#define USB_DT_CS_STRING		(USB_TYPE_CLASS | USB_DT_STRING)
+#define USB_DT_CS_INTERFACE		(USB_TYPE_CLASS | USB_DT_INTERFACE)
+#define USB_DT_CS_ENDPOINT		(USB_TYPE_CLASS | USB_DT_ENDPOINT)
+
+/* All standard descriptors have these 2 fields at the beginning */
+struct usb_descriptor_header {
+	__u8  bLength;
+	__u8  bDescriptorType;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEVICE: Device descriptor */
+struct usb_device_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__le16 idVendor;
+	__le16 idProduct;
+	__le16 bcdDevice;
+	__u8  iManufacturer;
+	__u8  iProduct;
+	__u8  iSerialNumber;
+	__u8  bNumConfigurations;
+} __attribute__ ((packed));
+
+#define USB_DT_DEVICE_SIZE		18
+
+
+/*
+ * Device and/or Interface Class codes
+ * as found in bDeviceClass or bInterfaceClass
+ * and defined by www.usb.org documents
+ */
+#define USB_CLASS_PER_INTERFACE		0	/* for DeviceClass */
+#define USB_CLASS_AUDIO			1
+#define USB_CLASS_COMM			2
+#define USB_CLASS_HID			3
+#define USB_CLASS_PHYSICAL		5
+#define USB_CLASS_STILL_IMAGE		6
+#define USB_CLASS_PRINTER		7
+#define USB_CLASS_MASS_STORAGE		8
+#define USB_CLASS_HUB			9
+#define USB_CLASS_CDC_DATA		0x0a
+#define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
+#define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
+#define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_WIRELESS_CONTROLLER	0xe0
+#define USB_CLASS_MISC			0xef
+#define USB_CLASS_APP_SPEC		0xfe
+#define USB_CLASS_VENDOR_SPEC		0xff
+
+#define USB_SUBCLASS_VENDOR_SPEC	0xff
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_CONFIG: Configuration descriptor information.
+ *
+ * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
+ * descriptor type is different.  Highspeed-capable devices can look
+ * different depending on what speed they're currently running.  Only
+ * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
+ * descriptors.
+ */
+struct usb_config_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wTotalLength;
+	__u8  bNumInterfaces;
+	__u8  bConfigurationValue;
+	__u8  iConfiguration;
+	__u8  bmAttributes;
+	__u8  bMaxPower;
+} __attribute__ ((packed));
+
+#define USB_DT_CONFIG_SIZE		9
+
+/* from config descriptor bmAttributes */
+#define USB_CONFIG_ATT_ONE		(1 << 7)	/* must be set */
+#define USB_CONFIG_ATT_SELFPOWER	(1 << 6)	/* self powered */
+#define USB_CONFIG_ATT_WAKEUP		(1 << 5)	/* can wakeup */
+#define USB_CONFIG_ATT_BATTERY		(1 << 4)	/* battery powered */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_STRING: String descriptor */
+struct usb_string_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wData[1];		/* UTF-16LE encoded */
+} __attribute__ ((packed));
+
+/* note that "string" zero is special, it holds language codes that
+ * the device supports, not Unicode characters.
+ */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_INTERFACE: Interface descriptor */
+struct usb_interface_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bInterfaceNumber;
+	__u8  bAlternateSetting;
+	__u8  bNumEndpoints;
+	__u8  bInterfaceClass;
+	__u8  bInterfaceSubClass;
+	__u8  bInterfaceProtocol;
+	__u8  iInterface;
+} __attribute__ ((packed));
+
+#define USB_DT_INTERFACE_SIZE		9
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_ENDPOINT: Endpoint descriptor */
+struct usb_endpoint_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bEndpointAddress;
+	__u8  bmAttributes;
+	__le16 wMaxPacketSize;
+	__u8  bInterval;
+
+	/* NOTE:  these two are _only_ in audio endpoints. */
+	/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */
+	__u8  bRefresh;
+	__u8  bSynchAddress;
+} __attribute__ ((packed));
+
+#define USB_DT_ENDPOINT_SIZE		7
+#define USB_DT_ENDPOINT_AUDIO_SIZE	9	/* Audio extension */
+
+
+/*
+ * Endpoints
+ */
+#define USB_ENDPOINT_NUMBER_MASK	0x0f	/* in bEndpointAddress */
+#define USB_ENDPOINT_DIR_MASK		0x80
+
+#define USB_ENDPOINT_SYNCTYPE		0x0c
+#define USB_ENDPOINT_SYNC_NONE		(0 << 2)
+#define USB_ENDPOINT_SYNC_ASYNC		(1 << 2)
+#define USB_ENDPOINT_SYNC_ADAPTIVE	(2 << 2)
+#define USB_ENDPOINT_SYNC_SYNC		(3 << 2)
+
+#define USB_ENDPOINT_XFERTYPE_MASK	0x03	/* in bmAttributes */
+#define USB_ENDPOINT_XFER_CONTROL	0
+#define USB_ENDPOINT_XFER_ISOC		1
+#define USB_ENDPOINT_XFER_BULK		2
+#define USB_ENDPOINT_XFER_INT		3
+#define USB_ENDPOINT_MAX_ADJUSTABLE	0x80
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * usb_endpoint_num - get the endpoint's number
+ * @epd: endpoint to be checked
+ *
+ * Returns @epd's number: 0 to 15.
+ */
+static __inline__ int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+}
+
+/**
+ * usb_endpoint_type - get the endpoint's transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
+ * to @epd's transfer type.
+ */
+static __inline__ int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+}
+
+/**
+ * usb_endpoint_dir_in - check if the endpoint has IN direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type IN, otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
+}
+
+/**
+ * usb_endpoint_dir_out - check if the endpoint has OUT direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type OUT, otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_dir_out(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
+}
+
+/**
+ * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type bulk, otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_xfer_bulk(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_BULK);
+}
+
+/**
+ * usb_endpoint_xfer_control - check if the endpoint has control transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type control, otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_xfer_control(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_CONTROL);
+}
+
+/**
+ * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type interrupt, otherwise it returns
+ * false.
+ */
+static __inline__ int usb_endpoint_xfer_int(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_INT);
+}
+
+/**
+ * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type isochronous, otherwise it returns
+ * false.
+ */
+static __inline__ int usb_endpoint_xfer_isoc(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_ISOC);
+}
+
+/**
+ * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has bulk transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_bulk_in(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has bulk transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_bulk_out(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd));
+}
+
+/**
+ * usb_endpoint_is_int_in - check if the endpoint is interrupt IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has interrupt transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_int_in(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has interrupt transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_int_out(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd));
+}
+
+/**
+ * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has isochronous transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_isoc_in(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has isochronous transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static __inline__ int usb_endpoint_is_isoc_out(
+				const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd));
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */
+struct usb_ss_ep_comp_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bMaxBurst;
+	__u8  bmAttributes;
+	__u16 wBytesPerInterval;
+} __attribute__ ((packed));
+
+#define USB_DT_SS_EP_COMP_SIZE		6
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */
+struct usb_qualifier_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__u8  bNumConfigurations;
+	__u8  bRESERVED;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_OTG (from OTG 1.0a supplement) */
+struct usb_otg_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bmAttributes;	/* support for HNP, SRP, etc */
+} __attribute__ ((packed));
+
+/* from usb_otg_descriptor.bmAttributes */
+#define USB_OTG_SRP		(1 << 0)
+#define USB_OTG_HNP		(1 << 1)	/* swap host/device roles */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEBUG:  for special highspeed devices, replacing serial console */
+struct usb_debug_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	/* bulk endpoints with 8 byte maxpacket */
+	__u8  bDebugInEndpoint;
+	__u8  bDebugOutEndpoint;
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */
+struct usb_interface_assoc_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bFirstInterface;
+	__u8  bInterfaceCount;
+	__u8  bFunctionClass;
+	__u8  bFunctionSubClass;
+	__u8  bFunctionProtocol;
+	__u8  iFunction;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_SECURITY:  group of wireless security descriptors, including
+ * encryption types available for setting up a CC/association.
+ */
+struct usb_security_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wTotalLength;
+	__u8  bNumEncryptionTypes;
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys
+ * may be retrieved.
+ */
+struct usb_key_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  tTKID[3];
+	__u8  bReserved;
+	__u8  bKeyData[0];
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */
+struct usb_encryption_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bEncryptionType;
+#define	USB_ENC_TYPE_UNSECURE		0
+#define	USB_ENC_TYPE_WIRED		1	/* non-wireless mode */
+#define	USB_ENC_TYPE_CCM_1		2	/* aes128/cbc session */
+#define	USB_ENC_TYPE_RSA_1		3	/* rsa3072/sha1 auth */
+	__u8  bEncryptionValue;		/* use in SET_ENCRYPTION */
+	__u8  bAuthKeyIndex;
+} __attribute__((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_BOS:  group of device-level capabilities */
+struct usb_bos_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wTotalLength;
+	__u8  bNumDeviceCaps;
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEVICE_CAPABILITY:  grouped with BOS */
+struct usb_dev_cap_header {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDevCapabilityType;
+} __attribute__((packed));
+
+#define	USB_CAP_TYPE_WIRELESS_USB	1
+
+struct usb_wireless_cap_descriptor {	/* Ultra Wide Band */
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDevCapabilityType;
+
+	__u8  bmAttributes;
+#define	USB_WIRELESS_P2P_DRD		(1 << 1)
+#define	USB_WIRELESS_BEACON_MASK	(3 << 2)
+#define	USB_WIRELESS_BEACON_SELF	(1 << 2)
+#define	USB_WIRELESS_BEACON_DIRECTED	(2 << 2)
+#define	USB_WIRELESS_BEACON_NONE	(3 << 2)
+	__le16 wPHYRates;	/* bit rates, Mbps */
+#define	USB_WIRELESS_PHY_53		(1 << 0)	/* always set */
+#define	USB_WIRELESS_PHY_80		(1 << 1)
+#define	USB_WIRELESS_PHY_107		(1 << 2)	/* always set */
+#define	USB_WIRELESS_PHY_160		(1 << 3)
+#define	USB_WIRELESS_PHY_200		(1 << 4)	/* always set */
+#define	USB_WIRELESS_PHY_320		(1 << 5)
+#define	USB_WIRELESS_PHY_400		(1 << 6)
+#define	USB_WIRELESS_PHY_480		(1 << 7)
+	__u8  bmTFITXPowerInfo;	/* TFI power levels */
+	__u8  bmFFITXPowerInfo;	/* FFI power levels */
+	__le16 bmBandGroup;
+	__u8  bReserved;
+} __attribute__((packed));
+
+#define	USB_CAP_TYPE_EXT		2
+
+struct usb_ext_cap_descriptor {		/* Link Power Management */
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDevCapabilityType;
+	__u8  bmAttributes;
+#define USB_LPM_SUPPORT			(1 << 1)	/* supports LPM */
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with
+ * each endpoint descriptor for a wireless device
+ */
+struct usb_wireless_ep_comp_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bMaxBurst;
+	__u8  bMaxSequence;
+	__le16 wMaxStreamDelay;
+	__le16 wOverTheAirPacketSize;
+	__u8  bOverTheAirInterval;
+	__u8  bmCompAttributes;
+#define USB_ENDPOINT_SWITCH_MASK	0x03	/* in bmCompAttributes */
+#define USB_ENDPOINT_SWITCH_NO		0
+#define USB_ENDPOINT_SWITCH_SWITCH	1
+#define USB_ENDPOINT_SWITCH_SCALE	2
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless
+ * host and a device for connection set up, mutual authentication, and
+ * exchanging short lived session keys.  The handshake depends on a CC.
+ */
+struct usb_handshake {
+	__u8 bMessageNumber;
+	__u8 bStatus;
+	__u8 tTKID[3];
+	__u8 bReserved;
+	__u8 CDID[16];
+	__u8 nonce[16];
+	__u8 MIC[8];
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).
+ * A CC may also be set up using non-wireless secure channels (including
+ * wired USB!), and some devices may support CCs with multiple hosts.
+ */
+struct usb_connection_context {
+	__u8 CHID[16];		/* persistent host id */
+	__u8 CDID[16];		/* device id (unique w/in host context) */
+	__u8 CK[16];		/* connection key */
+} __attribute__((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/* USB 2.0 defines three speeds, here's how Linux identifies them */
+
+enum usb_device_speed {
+	USB_SPEED_UNKNOWN = 0,			/* enumerating */
+	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
+	USB_SPEED_HIGH,				/* usb 2.0 */
+	USB_SPEED_VARIABLE,			/* wireless (usb 2.5) */
+	USB_SPEED_SUPER,			/* usb 3.0 */
+};
+
+enum usb_device_state {
+	/* NOTATTACHED isn't in the USB spec, and this state acts
+	 * the same as ATTACHED ... but it's clearer this way.
+	 */
+	USB_STATE_NOTATTACHED = 0,
+
+	/* chapter 9 and authentication (wireless) device states */
+	USB_STATE_ATTACHED,
+	USB_STATE_POWERED,			/* wired */
+	USB_STATE_RECONNECTING,			/* auth */
+	USB_STATE_UNAUTHENTICATED,		/* auth */
+	USB_STATE_DEFAULT,			/* limited function */
+	USB_STATE_ADDRESS,
+	USB_STATE_CONFIGURED,			/* most functions */
+
+	USB_STATE_SUSPENDED
+
+	/* NOTE:  there are actually four different SUSPENDED
+	 * states, returning to POWERED, DEFAULT, ADDRESS, or
+	 * CONFIGURED respectively when SOF tokens flow again.
+	 * At this level there's no difference between L1 and L2
+	 * suspend states.  (L2 being original USB 1.1 suspend.)
+	 */
+};
+
+#endif /* __LINUX_USB_CH9_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/gadgetfs.h clean_modified/linux-2.6.32/usr/include/linux/usb/gadgetfs.h
--- linux-2.6.32/usr/include/linux/usb/gadgetfs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/gadgetfs.h	2019-04-14 13:24:03.167526499 -0500
@@ -0,0 +1,88 @@
+/*
+ * Filesystem based user-mode API to USB Gadget controller hardware
+ *
+ * Other than ep0 operations, most things are done by read() and write()
+ * on endpoint files found in one directory.  They are configured by
+ * writing descriptors, and then may be used for normal stream style
+ * i/o requests.  When ep0 is configured, the device can enumerate;
+ * when it's closed, the device disconnects from usb.  Operations on
+ * ep0 require ioctl() operations.
+ *
+ * Configuration and device descriptors get written to /dev/gadget/$CHIP,
+ * which may then be used to read usb_gadgetfs_event structs.  The driver
+ * may activate endpoints as it handles SET_CONFIGURATION setup events,
+ * or earlier; writing endpoint descriptors to /dev/gadget/$ENDPOINT
+ * then performing data transfers by reading or writing.
+ */
+
+#ifndef __LINUX_USB_GADGETFS_H
+#define __LINUX_USB_GADGETFS_H
+
+#include <linux/types.h>
+#include <asm/ioctl.h>
+
+#include <linux/usb/ch9.h>
+
+/*
+ * Events are delivered on the ep0 file descriptor, when the user mode driver
+ * reads from this file descriptor after writing the descriptors.  Don't
+ * stop polling this descriptor.
+ */
+
+enum usb_gadgetfs_event_type {
+	GADGETFS_NOP = 0,
+
+	GADGETFS_CONNECT,
+	GADGETFS_DISCONNECT,
+	GADGETFS_SETUP,
+	GADGETFS_SUSPEND,
+	/* and likely more ! */
+};
+
+/* NOTE:  this structure must stay the same size and layout on
+ * both 32-bit and 64-bit kernels.
+ */
+struct usb_gadgetfs_event {
+	union {
+		/* NOP, DISCONNECT, SUSPEND: nothing
+		 * ... some hardware can't report disconnection
+		 */
+
+		/* CONNECT: just the speed */
+		enum usb_device_speed	speed;
+
+		/* SETUP: packet; DATA phase i/o precedes next event
+		 *(setup.bmRequestType & USB_DIR_IN) flags direction
+		 * ... includes SET_CONFIGURATION, SET_INTERFACE
+		 */
+		struct usb_ctrlrequest	setup;
+	} u;
+	enum usb_gadgetfs_event_type	type;
+};
+
+
+/* The 'g' code is also used by printer gadget ioctl requests.
+ * Don't add any colliding codes to either driver, and keep
+ * them in unique ranges (size 0x20 for now).
+ */
+
+/* endpoint ioctls */
+
+/* IN transfers may be reported to the gadget driver as complete
+ *	when the fifo is loaded, before the host reads the data;
+ * OUT transfers may be reported to the host's "client" driver as
+ *	complete when they're sitting in the FIFO unread.
+ * THIS returns how many bytes are "unclaimed" in the endpoint fifo
+ * (needed for precise fault handling, when the hardware allows it)
+ */
+#define	GADGETFS_FIFO_STATUS	_IO('g', 1)
+
+/* discards any unclaimed data in the fifo. */
+#define	GADGETFS_FIFO_FLUSH	_IO('g', 2)
+
+/* resets endpoint halt+toggle; used to implement set_interface.
+ * some hardware (like pxa2xx) can't support this.
+ */
+#define	GADGETFS_CLEAR_HALT	_IO('g', 3)
+
+#endif /* __LINUX_USB_GADGETFS_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/g_printer.h clean_modified/linux-2.6.32/usr/include/linux/usb/g_printer.h
--- linux-2.6.32/usr/include/linux/usb/g_printer.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/g_printer.h	2019-04-14 13:24:03.167526499 -0500
@@ -0,0 +1,35 @@
+/*
+ * g_printer.h -- Header file for USB Printer gadget driver
+ *
+ * Copyright (C) 2007 Craig W. Nadler
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_USB_G_PRINTER_H
+#define __LINUX_USB_G_PRINTER_H
+
+#define PRINTER_NOT_ERROR	0x08
+#define PRINTER_SELECTED	0x10
+#define PRINTER_PAPER_EMPTY	0x20
+
+/* The 'g' code is also used by gadgetfs ioctl requests.
+ * Don't add any colliding codes to either driver, and keep
+ * them in unique ranges (size 0x20 for now).
+ */
+#define GADGET_GET_PRINTER_STATUS	_IOR('g', 0x21, unsigned char)
+#define GADGET_SET_PRINTER_STATUS	_IOWR('g', 0x22, unsigned char)
+
+#endif /* __LINUX_USB_G_PRINTER_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/midi.h clean_modified/linux-2.6.32/usr/include/linux/usb/midi.h
--- linux-2.6.32/usr/include/linux/usb/midi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/midi.h	2019-04-14 13:24:03.168511434 -0500
@@ -0,0 +1,112 @@
+/*
+ * <linux/usb/midi.h> -- USB MIDI definitions.
+ *
+ * Copyright (C) 2006 Thumtronics Pty Ltd.
+ * Developed for Thumtronics by Grey Innovation
+ * Ben Williamson <ben.williamson@greyinnovation.com>
+ *
+ * This software is distributed under the terms of the GNU General Public
+ * License ("GPL") version 2, as published by the Free Software Foundation.
+ *
+ * This file holds USB constants and structures defined
+ * by the USB Device Class Definition for MIDI Devices.
+ * Comments below reference relevant sections of that document:
+ *
+ * http://www.usb.org/developers/devclass_docs/midi10.pdf
+ */
+
+#ifndef __LINUX_USB_MIDI_H
+#define __LINUX_USB_MIDI_H
+
+#include <linux/types.h>
+
+/* A.1  MS Class-Specific Interface Descriptor Subtypes */
+#define USB_MS_HEADER		0x01
+#define USB_MS_MIDI_IN_JACK	0x02
+#define USB_MS_MIDI_OUT_JACK	0x03
+#define USB_MS_ELEMENT		0x04
+
+/* A.2  MS Class-Specific Endpoint Descriptor Subtypes */
+#define USB_MS_GENERAL		0x01
+
+/* A.3  MS MIDI IN and OUT Jack Types */
+#define USB_MS_EMBEDDED		0x01
+#define USB_MS_EXTERNAL		0x02
+
+/* 6.1.2.1  Class-Specific MS Interface Header Descriptor */
+struct usb_ms_header_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__le16 bcdMSC;
+	__le16 wTotalLength;
+} __attribute__ ((packed));
+
+#define USB_DT_MS_HEADER_SIZE	7
+
+/* 6.1.2.2  MIDI IN Jack Descriptor */
+struct usb_midi_in_jack_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* USB_MS_MIDI_IN_JACK */
+	__u8  bJackType;		/* USB_MS_EMBEDDED/EXTERNAL */
+	__u8  bJackID;
+	__u8  iJack;
+} __attribute__ ((packed));
+
+#define USB_DT_MIDI_IN_SIZE	6
+
+struct usb_midi_source_pin {
+	__u8  baSourceID;
+	__u8  baSourcePin;
+} __attribute__ ((packed));
+
+/* 6.1.2.3  MIDI OUT Jack Descriptor */
+struct usb_midi_out_jack_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;		/* USB_DT_CS_INTERFACE */
+	__u8  bDescriptorSubtype;	/* USB_MS_MIDI_OUT_JACK */
+	__u8  bJackType;		/* USB_MS_EMBEDDED/EXTERNAL */
+	__u8  bJackID;
+	__u8  bNrInputPins;		/* p */
+	struct usb_midi_source_pin pins[]; /* [p] */
+	/*__u8  iJack;  -- ommitted due to variable-sized pins[] */
+} __attribute__ ((packed));
+
+#define USB_DT_MIDI_OUT_SIZE(p)	(7 + 2 * (p))
+
+/* As above, but more useful for defining your own descriptors: */
+#define DECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(p)			\
+struct usb_midi_out_jack_descriptor_##p {			\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__u8  bJackType;					\
+	__u8  bJackID;						\
+	__u8  bNrInputPins;					\
+	struct usb_midi_source_pin pins[p];			\
+	__u8  iJack;						\
+} __attribute__ ((packed))
+
+/* 6.2.2  Class-Specific MS Bulk Data Endpoint Descriptor */
+struct usb_ms_endpoint_descriptor {
+	__u8  bLength;			/* 4+n */
+	__u8  bDescriptorType;		/* USB_DT_CS_ENDPOINT */
+	__u8  bDescriptorSubtype;	/* USB_MS_GENERAL */
+	__u8  bNumEmbMIDIJack;		/* n */
+	__u8  baAssocJackID[];		/* [n] */
+} __attribute__ ((packed));
+
+#define USB_DT_MS_ENDPOINT_SIZE(n)	(4 + (n))
+
+/* As above, but more useful for defining your own descriptors: */
+#define DECLARE_USB_MS_ENDPOINT_DESCRIPTOR(n)			\
+struct usb_ms_endpoint_descriptor_##n {				\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__u8  bNumEmbMIDIJack;					\
+	__u8  baAssocJackID[n];					\
+} __attribute__ ((packed))
+
+#endif /* __LINUX_USB_MIDI_H */
diff -uNr linux-2.6.32/usr/include/linux/usb/tmc.h clean_modified/linux-2.6.32/usr/include/linux/usb/tmc.h
--- linux-2.6.32/usr/include/linux/usb/tmc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/tmc.h	2019-04-14 13:24:03.169166652 -0500
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2007 Stefan Kopp, Gechingen, Germany
+ * Copyright (C) 2008 Novell, Inc.
+ * Copyright (C) 2008 Greg Kroah-Hartman <gregkh@suse.de>
+ *
+ * This file holds USB constants defined by the USB Device Class
+ * Definition for Test and Measurement devices published by the USB-IF.
+ *
+ * It also has the ioctl definitions for the usbtmc kernel driver that
+ * userspace needs to know about.
+ */
+
+#ifndef __LINUX_USB_TMC_H
+#define __LINUX_USB_TMC_H
+
+/* USB TMC status values */
+#define USBTMC_STATUS_SUCCESS				0x01
+#define USBTMC_STATUS_PENDING				0x02
+#define USBTMC_STATUS_FAILED				0x80
+#define USBTMC_STATUS_TRANSFER_NOT_IN_PROGRESS		0x81
+#define USBTMC_STATUS_SPLIT_NOT_IN_PROGRESS		0x82
+#define USBTMC_STATUS_SPLIT_IN_PROGRESS			0x83
+
+/* USB TMC requests values */
+#define USBTMC_REQUEST_INITIATE_ABORT_BULK_OUT		1
+#define USBTMC_REQUEST_CHECK_ABORT_BULK_OUT_STATUS	2
+#define USBTMC_REQUEST_INITIATE_ABORT_BULK_IN		3
+#define USBTMC_REQUEST_CHECK_ABORT_BULK_IN_STATUS	4
+#define USBTMC_REQUEST_INITIATE_CLEAR			5
+#define USBTMC_REQUEST_CHECK_CLEAR_STATUS		6
+#define USBTMC_REQUEST_GET_CAPABILITIES			7
+#define USBTMC_REQUEST_INDICATOR_PULSE			64
+
+/* Request values for USBTMC driver's ioctl entry point */
+#define USBTMC_IOC_NR			91
+#define USBTMC_IOCTL_INDICATOR_PULSE	_IO(USBTMC_IOC_NR, 1)
+#define USBTMC_IOCTL_CLEAR		_IO(USBTMC_IOC_NR, 2)
+#define USBTMC_IOCTL_ABORT_BULK_OUT	_IO(USBTMC_IOC_NR, 3)
+#define USBTMC_IOCTL_ABORT_BULK_IN	_IO(USBTMC_IOC_NR, 4)
+#define USBTMC_IOCTL_CLEAR_OUT_HALT	_IO(USBTMC_IOC_NR, 6)
+#define USBTMC_IOCTL_CLEAR_IN_HALT	_IO(USBTMC_IOC_NR, 7)
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/usb/vstusb.h clean_modified/linux-2.6.32/usr/include/linux/usb/vstusb.h
--- linux-2.6.32/usr/include/linux/usb/vstusb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usb/vstusb.h	2019-04-14 13:24:03.169832668 -0500
@@ -0,0 +1,71 @@
+/*****************************************************************************
+ *  File: drivers/usb/misc/vstusb.h
+ *
+ *  Purpose: Support for the bulk USB Vernier Spectrophotometers
+ *
+ *  Author:     EQware Engineering, Inc.
+ *              Oregon City, OR, USA 97045
+ *
+ *  Copyright:  2007, 2008
+ *              Vernier Software & Technology
+ *              Beaverton, OR, USA 97005
+ *
+ *  Web:        www.vernier.com
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *****************************************************************************/
+/*****************************************************************************
+ *
+ *  The vstusb module is a standard usb 'client' driver running on top of the
+ *  standard usb host controller stack.
+ *
+ *  In general, vstusb supports standard bulk usb pipes.  It supports multiple
+ *  devices and multiple pipes per device.
+ *
+ *  The vstusb driver supports two interfaces:
+ *  1 - ioctl SEND_PIPE/RECV_PIPE - a general bulk write/read msg
+ *  	interface to any pipe with timeout support;
+ *  2 - standard read/write with ioctl config - offers standard read/write
+ *  	interface with ioctl configured pipes and timeouts.
+ *
+ *  Both interfaces can be signal from other process and will abort its i/o
+ *  operation.
+ *
+ *  A timeout of 0 means NO timeout.  The user can still terminate the read via
+ *  signal.
+ *
+ *  If using multiple threads with this driver, the user should ensure that
+ *  any reads, writes, or ioctls are complete before closing the device.
+ *  Changing read/write timeouts or pipes takes effect on next read/write.
+ *
+ *****************************************************************************/
+
+struct vstusb_args {
+	union {
+		/* this struct is used for IOCTL_VSTUSB_SEND_PIPE,	*
+		 * IOCTL_VSTUSB_RECV_PIPE, and read()/write() fops	*/
+		struct {
+			void *buffer;
+			size_t          count;
+			unsigned int    timeout_ms;
+			int             pipe;
+		};
+
+		/* this one is used for IOCTL_VSTUSB_CONFIG_RW  	*/
+		struct {
+			int rd_pipe;
+			int rd_timeout_ms;
+			int wr_pipe;
+			int wr_timeout_ms;
+		};
+	};
+};
+
+#define VST_IOC_MAGIC 'L'
+#define VST_IOC_FIRST 0x20
+#define IOCTL_VSTUSB_SEND_PIPE	_IO(VST_IOC_MAGIC, VST_IOC_FIRST)
+#define IOCTL_VSTUSB_RECV_PIPE	_IO(VST_IOC_MAGIC, VST_IOC_FIRST + 1)
+#define IOCTL_VSTUSB_CONFIG_RW	_IO(VST_IOC_MAGIC, VST_IOC_FIRST + 2)
diff -uNr linux-2.6.32/usr/include/linux/usbdevice_fs.h clean_modified/linux-2.6.32/usr/include/linux/usbdevice_fs.h
--- linux-2.6.32/usr/include/linux/usbdevice_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/usbdevice_fs.h	2019-04-14 13:24:03.169832668 -0500
@@ -0,0 +1,155 @@
+/*****************************************************************************/
+
+/*
+ *	usbdevice_fs.h  --  USB device file system.
+ *
+ *	Copyright (C) 2000
+ *          Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History:
+ *   0.1  04.01.2000  Created
+ */
+
+/*****************************************************************************/
+
+#ifndef _LINUX_USBDEVICE_FS_H
+#define _LINUX_USBDEVICE_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/* --------------------------------------------------------------------- */
+
+/* usbdevfs ioctl codes */
+
+struct usbdevfs_ctrltransfer {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+	__u32 timeout;  /* in milliseconds */
+ 	void *data;
+};
+
+struct usbdevfs_bulktransfer {
+	unsigned int ep;
+	unsigned int len;
+	unsigned int timeout; /* in milliseconds */
+	void *data;
+};
+
+struct usbdevfs_setinterface {
+	unsigned int interface;
+	unsigned int altsetting;
+};
+
+struct usbdevfs_disconnectsignal {
+	unsigned int signr;
+	void *context;
+};
+
+#define USBDEVFS_MAXDRIVERNAME 255
+
+struct usbdevfs_getdriver {
+	unsigned int interface;
+	char driver[USBDEVFS_MAXDRIVERNAME + 1];
+};
+
+struct usbdevfs_connectinfo {
+	unsigned int devnum;
+	unsigned char slow;
+};
+
+#define USBDEVFS_URB_SHORT_NOT_OK	0x01
+#define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_BULK_CONTINUATION	0x04
+#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_ZERO_PACKET	0x40
+#define USBDEVFS_URB_NO_INTERRUPT	0x80
+
+#define USBDEVFS_URB_TYPE_ISO		   0
+#define USBDEVFS_URB_TYPE_INTERRUPT	   1
+#define USBDEVFS_URB_TYPE_CONTROL	   2
+#define USBDEVFS_URB_TYPE_BULK		   3
+
+struct usbdevfs_iso_packet_desc {
+	unsigned int length;
+	unsigned int actual_length;
+	unsigned int status;
+};
+
+struct usbdevfs_urb {
+	unsigned char type;
+	unsigned char endpoint;
+	int status;
+	unsigned int flags;
+	void *buffer;
+	int buffer_length;
+	int actual_length;
+	int start_frame;
+	int number_of_packets;
+	int error_count;
+	unsigned int signr;	/* signal to be sent on completion,
+				  or 0 if none should be sent. */
+	void *usercontext;
+	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
+};
+
+/* ioctls for talking directly to drivers */
+struct usbdevfs_ioctl {
+	int	ifno;		/* interface 0..N ; negative numbers reserved */
+	int	ioctl_code;	/* MUST encode size + direction of data so the
+				 * macros in <asm/ioctl.h> give correct values */
+	void *data;	/* param buffer (in, or out) */
+};
+
+/* You can do most things with hubs just through control messages,
+ * except find out what device connects to what port. */
+struct usbdevfs_hub_portinfo {
+	char nports;		/* number of downstream ports in this hub */
+	char port [127];	/* e.g. port 3 connects to device 27 */
+};
+
+
+#define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
+#define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
+#define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
+#define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
+#define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
+#define USBDEVFS_GETDRIVER         _IOW('U', 8, struct usbdevfs_getdriver)
+#define USBDEVFS_SUBMITURB         _IOR('U', 10, struct usbdevfs_urb)
+#define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
+#define USBDEVFS_DISCARDURB        _IO('U', 11)
+#define USBDEVFS_REAPURB           _IOW('U', 12, void *)
+#define USBDEVFS_REAPURB32         _IOW('U', 12, __u32)
+#define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
+#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
+#define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
+#define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
+#define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
+#define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
+#define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
+#define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)
+#define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
+#define USBDEVFS_RESET             _IO('U', 20)
+#define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
+#define USBDEVFS_DISCONNECT        _IO('U', 22)
+#define USBDEVFS_CONNECT           _IO('U', 23)
+#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
+#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
+#endif /* _LINUX_USBDEVICE_FS_H */
diff -uNr linux-2.6.32/usr/include/linux/utime.h clean_modified/linux-2.6.32/usr/include/linux/utime.h
--- linux-2.6.32/usr/include/linux/utime.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/utime.h	2019-04-14 13:24:03.169832668 -0500
@@ -0,0 +1,11 @@
+#ifndef _LINUX_UTIME_H
+#define _LINUX_UTIME_H
+
+#include <linux/types.h>
+
+struct utimbuf {
+	__kernel_time_t actime;
+	__kernel_time_t modtime;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/utsname.h clean_modified/linux-2.6.32/usr/include/linux/utsname.h
--- linux-2.6.32/usr/include/linux/utsname.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/utsname.h	2019-04-14 13:24:03.169832668 -0500
@@ -0,0 +1,34 @@
+#ifndef _LINUX_UTSNAME_H
+#define _LINUX_UTSNAME_H
+
+#define __OLD_UTS_LEN 8
+
+struct oldold_utsname {
+	char sysname[9];
+	char nodename[9];
+	char release[9];
+	char version[9];
+	char machine[9];
+};
+
+#define __NEW_UTS_LEN 64
+
+struct old_utsname {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+};
+
+struct new_utsname {
+	char sysname[__NEW_UTS_LEN + 1];
+	char nodename[__NEW_UTS_LEN + 1];
+	char release[__NEW_UTS_LEN + 1];
+	char version[__NEW_UTS_LEN + 1];
+	char machine[__NEW_UTS_LEN + 1];
+	char domainname[__NEW_UTS_LEN + 1];
+};
+
+
+#endif /* _LINUX_UTSNAME_H */
diff -uNr linux-2.6.32/usr/include/linux/version.h clean_modified/linux-2.6.32/usr/include/linux/version.h
--- linux-2.6.32/usr/include/linux/version.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/version.h	2019-04-14 13:24:03.172107404 -0500
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132640
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -uNr linux-2.6.32/usr/include/linux/veth.h clean_modified/linux-2.6.32/usr/include/linux/veth.h
--- linux-2.6.32/usr/include/linux/veth.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/veth.h	2019-04-14 13:24:03.172107404 -0500
@@ -0,0 +1,12 @@
+#ifndef __NET_VETH_H_
+#define __NET_VETH_H_
+
+enum {
+	VETH_INFO_UNSPEC,
+	VETH_INFO_PEER,
+
+	__VETH_INFO_MAX
+#define VETH_INFO_MAX	(__VETH_INFO_MAX - 1)
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/videodev2.h clean_modified/linux-2.6.32/usr/include/linux/videodev2.h
--- linux-2.6.32/usr/include/linux/videodev2.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/videodev2.h	2019-04-14 13:24:03.174869144 -0500
@@ -0,0 +1,1631 @@
+/*
+ *  Video for Linux Two header file
+ *
+ *  Copyright (C) 1999-2007 the contributors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Alternatively you can redistribute this file under the terms of the
+ *  BSD license as stated below:
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *  3. The names of its contributors may not be used to endorse or promote
+ *     products derived from this software without specific prior written
+ *     permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *	Header file for v4l or V4L2 drivers and applications
+ * with public API.
+ * All kernel-specific stuff were moved to media/v4l2-dev.h, so
+ * no #if __KERNEL tests are allowed here
+ *
+ *	See http://linuxtv.org for more info
+ *
+ *	Author: Bill Dirks <bill@thedirks.org>
+ *		Justin Schoeman
+ *              Hans Verkuil <hverkuil@xs4all.nl>
+ *		et al.
+ */
+#ifndef __LINUX_VIDEODEV2_H
+#define __LINUX_VIDEODEV2_H
+
+#include <sys/time.h>
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/*
+ * Common stuff for both V4L1 and V4L2
+ * Moved from videodev.h
+ */
+#define VIDEO_MAX_FRAME               32
+
+
+/* These defines are V4L1 specific and should not be used with the V4L2 API!
+   They will be removed from this header in the future. */
+
+#define VID_TYPE_CAPTURE	1	/* Can capture */
+#define VID_TYPE_TUNER		2	/* Can tune */
+#define VID_TYPE_TELETEXT	4	/* Does teletext */
+#define VID_TYPE_OVERLAY	8	/* Overlay onto frame buffer */
+#define VID_TYPE_CHROMAKEY	16	/* Overlay by chromakey */
+#define VID_TYPE_CLIPPING	32	/* Can clip */
+#define VID_TYPE_FRAMERAM	64	/* Uses the frame buffer memory */
+#define VID_TYPE_SCALES		128	/* Scalable */
+#define VID_TYPE_MONOCHROME	256	/* Monochrome only */
+#define VID_TYPE_SUBCAPTURE	512	/* Can capture subareas of the image */
+#define VID_TYPE_MPEG_DECODER	1024	/* Can decode MPEG streams */
+#define VID_TYPE_MPEG_ENCODER	2048	/* Can encode MPEG streams */
+#define VID_TYPE_MJPEG_DECODER	4096	/* Can decode MJPEG streams */
+#define VID_TYPE_MJPEG_ENCODER	8192	/* Can encode MJPEG streams */
+
+/*
+ *	M I S C E L L A N E O U S
+ */
+
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a, b, c, d)\
+	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
+
+/*
+ *	E N U M S
+ */
+enum v4l2_field {
+	V4L2_FIELD_ANY           = 0, /* driver can choose from none,
+					 top, bottom, interlaced
+					 depending on whatever it thinks
+					 is approximate ... */
+	V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
+	V4L2_FIELD_TOP           = 2, /* top field only */
+	V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
+	V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
+	V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
+					 buffer, top-bottom order */
+	V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
+	V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
+					 separate buffers */
+	V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
+					 first and the top field is
+					 transmitted first */
+	V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
+					 first and the bottom field is
+					 transmitted first */
+};
+#define V4L2_FIELD_HAS_TOP(field)	\
+	((field) == V4L2_FIELD_TOP 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTTOM(field)	\
+	((field) == V4L2_FIELD_BOTTOM 	||\
+	 (field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB	||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+#define V4L2_FIELD_HAS_BOTH(field)	\
+	((field) == V4L2_FIELD_INTERLACED ||\
+	 (field) == V4L2_FIELD_INTERLACED_TB ||\
+	 (field) == V4L2_FIELD_INTERLACED_BT ||\
+	 (field) == V4L2_FIELD_SEQ_TB ||\
+	 (field) == V4L2_FIELD_SEQ_BT)
+
+enum v4l2_buf_type {
+	V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
+	V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
+	V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
+	V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
+	V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
+	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
+	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
+#if 1
+	/* Experimental */
+	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
+#endif
+	V4L2_BUF_TYPE_PRIVATE              = 0x80,
+};
+
+enum v4l2_ctrl_type {
+	V4L2_CTRL_TYPE_INTEGER	     = 1,
+	V4L2_CTRL_TYPE_BOOLEAN	     = 2,
+	V4L2_CTRL_TYPE_MENU	     = 3,
+	V4L2_CTRL_TYPE_BUTTON	     = 4,
+	V4L2_CTRL_TYPE_INTEGER64     = 5,
+	V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
+	V4L2_CTRL_TYPE_STRING        = 7,
+};
+
+enum v4l2_tuner_type {
+	V4L2_TUNER_RADIO	     = 1,
+	V4L2_TUNER_ANALOG_TV	     = 2,
+	V4L2_TUNER_DIGITAL_TV	     = 3,
+};
+
+enum v4l2_memory {
+	V4L2_MEMORY_MMAP             = 1,
+	V4L2_MEMORY_USERPTR          = 2,
+	V4L2_MEMORY_OVERLAY          = 3,
+};
+
+/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
+enum v4l2_colorspace {
+	/* ITU-R 601 -- broadcast NTSC/PAL */
+	V4L2_COLORSPACE_SMPTE170M     = 1,
+
+	/* 1125-Line (US) HDTV */
+	V4L2_COLORSPACE_SMPTE240M     = 2,
+
+	/* HD and modern captures. */
+	V4L2_COLORSPACE_REC709        = 3,
+
+	/* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
+	V4L2_COLORSPACE_BT878         = 4,
+
+	/* These should be useful.  Assume 601 extents. */
+	V4L2_COLORSPACE_470_SYSTEM_M  = 5,
+	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
+
+	/* I know there will be cameras that send this.  So, this is
+	 * unspecified chromaticities and full 0-255 on each of the
+	 * Y'CbCr components
+	 */
+	V4L2_COLORSPACE_JPEG          = 7,
+
+	/* For RGB colourspaces, this is probably a good start. */
+	V4L2_COLORSPACE_SRGB          = 8,
+};
+
+enum v4l2_priority {
+	V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
+	V4L2_PRIORITY_BACKGROUND  = 1,
+	V4L2_PRIORITY_INTERACTIVE = 2,
+	V4L2_PRIORITY_RECORD      = 3,
+	V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
+};
+
+struct v4l2_rect {
+	__s32   left;
+	__s32   top;
+	__s32   width;
+	__s32   height;
+};
+
+struct v4l2_fract {
+	__u32   numerator;
+	__u32   denominator;
+};
+
+/*
+ *	D R I V E R   C A P A B I L I T I E S
+ */
+struct v4l2_capability {
+	__u8	driver[16];	/* i.e. "bttv" */
+	__u8	card[32];	/* i.e. "Hauppauge WinTV" */
+	__u8	bus_info[32];	/* "PCI:" + pci_name(pci_dev) */
+	__u32   version;        /* should use KERNEL_VERSION() */
+	__u32	capabilities;	/* Device capabilities */
+	__u32	reserved[4];
+};
+
+/* Values for 'capabilities' field */
+#define V4L2_CAP_VIDEO_CAPTURE		0x00000001  /* Is a video capture device */
+#define V4L2_CAP_VIDEO_OUTPUT		0x00000002  /* Is a video output device */
+#define V4L2_CAP_VIDEO_OVERLAY		0x00000004  /* Can do video overlay */
+#define V4L2_CAP_VBI_CAPTURE		0x00000010  /* Is a raw VBI capture device */
+#define V4L2_CAP_VBI_OUTPUT		0x00000020  /* Is a raw VBI output device */
+#define V4L2_CAP_SLICED_VBI_CAPTURE	0x00000040  /* Is a sliced VBI capture device */
+#define V4L2_CAP_SLICED_VBI_OUTPUT	0x00000080  /* Is a sliced VBI output device */
+#define V4L2_CAP_RDS_CAPTURE		0x00000100  /* RDS data capture */
+#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY	0x00000200  /* Can do video output overlay */
+#define V4L2_CAP_HW_FREQ_SEEK		0x00000400  /* Can do hardware frequency seek  */
+#define V4L2_CAP_RDS_OUTPUT		0x00000800  /* Is an RDS encoder */
+
+#define V4L2_CAP_TUNER			0x00010000  /* has a tuner */
+#define V4L2_CAP_AUDIO			0x00020000  /* has audio support */
+#define V4L2_CAP_RADIO			0x00040000  /* is a radio device */
+#define V4L2_CAP_MODULATOR		0x00080000  /* has a modulator */
+
+#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
+#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
+#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */
+
+/*
+ *	V I D E O   I M A G E   F O R M A T
+ */
+struct v4l2_pix_format {
+	__u32         		width;
+	__u32			height;
+	__u32			pixelformat;
+	enum v4l2_field  	field;
+	__u32            	bytesperline;	/* for padding, zero if unused */
+	__u32          		sizeimage;
+	enum v4l2_colorspace	colorspace;
+	__u32			priv;		/* private data, depends on pixelformat */
+};
+
+/*      Pixel format         FOURCC                          depth  Description  */
+
+/* RGB formats */
+#define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
+#define V4L2_PIX_FMT_RGB444  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
+#define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
+#define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
+#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
+#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */
+#define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
+#define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
+#define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
+#define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
+
+/* Grey formats */
+#define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
+#define V4L2_PIX_FMT_Y16     v4l2_fourcc('Y', '1', '6', ' ') /* 16  Greyscale     */
+
+/* Palette formats */
+#define V4L2_PIX_FMT_PAL8    v4l2_fourcc('P', 'A', 'L', '8') /*  8  8-bit palette */
+
+/* Luminance+Chrominance formats */
+#define V4L2_PIX_FMT_YVU410  v4l2_fourcc('Y', 'V', 'U', '9') /*  9  YVU 4:1:0     */
+#define V4L2_PIX_FMT_YVU420  v4l2_fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
+#define V4L2_PIX_FMT_YUYV    v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YYUV    v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YVYU    v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
+#define V4L2_PIX_FMT_UYVY    v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_VYUY    v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16  YUV 4:2:2     */
+#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4', '2', '2', 'P') /* 16  YVU422 planar */
+#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4', '1', '1', 'P') /* 16  YVU411 planar */
+#define V4L2_PIX_FMT_Y41P    v4l2_fourcc('Y', '4', '1', 'P') /* 12  YUV 4:1:1     */
+#define V4L2_PIX_FMT_YUV444  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
+#define V4L2_PIX_FMT_YUV555  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
+#define V4L2_PIX_FMT_YUV565  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
+#define V4L2_PIX_FMT_YUV32   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
+#define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
+#define V4L2_PIX_FMT_YUV420  v4l2_fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
+#define V4L2_PIX_FMT_HI240   v4l2_fourcc('H', 'I', '2', '4') /*  8  8-bit color   */
+#define V4L2_PIX_FMT_HM12    v4l2_fourcc('H', 'M', '1', '2') /*  8  YUV 4:2:0 16x16 macroblocks */
+
+/* two planes -- one Y, one Cr + Cb interleaved  */
+#define V4L2_PIX_FMT_NV12    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define V4L2_PIX_FMT_NV21    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
+#define V4L2_PIX_FMT_NV16    v4l2_fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
+#define V4L2_PIX_FMT_NV61    v4l2_fourcc('N', 'V', '6', '1') /* 16  Y/CrCb 4:2:2  */
+
+/* Bayer formats - see http://www.siliconimaging.com/RGB%20Bayer.htm */
+#define V4L2_PIX_FMT_SBGGR8  v4l2_fourcc('B', 'A', '8', '1') /*  8  BGBG.. GRGR.. */
+#define V4L2_PIX_FMT_SGBRG8  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
+#define V4L2_PIX_FMT_SGRBG8  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
+#define V4L2_PIX_FMT_SGRBG10 v4l2_fourcc('B', 'A', '1', '0') /* 10bit raw bayer */
+	/* 10bit raw bayer DPCM compressed to 8 bits */
+#define V4L2_PIX_FMT_SGRBG10DPCM8 v4l2_fourcc('B', 'D', '1', '0')
+	/*
+	 * 10bit raw bayer, expanded to 16 bits
+	 * xxxxrrrrrrrrrrxxxxgggggggggg xxxxggggggggggxxxxbbbbbbbbbb...
+	 */
+#define V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */
+
+/* compressed formats */
+#define V4L2_PIX_FMT_MJPEG    v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG   */
+#define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
+#define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
+#define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4    */
+
+/*  Vendor-specific formats   */
+#define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
+#define V4L2_PIX_FMT_SN9C10X  v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
+#define V4L2_PIX_FMT_SN9C20X_I420 v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
+#define V4L2_PIX_FMT_PWC1     v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
+#define V4L2_PIX_FMT_PWC2     v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
+#define V4L2_PIX_FMT_ET61X251 v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
+#define V4L2_PIX_FMT_SPCA501  v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
+#define V4L2_PIX_FMT_SPCA505  v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
+#define V4L2_PIX_FMT_SPCA508  v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
+#define V4L2_PIX_FMT_SPCA561  v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
+#define V4L2_PIX_FMT_PAC207   v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
+#define V4L2_PIX_FMT_MR97310A v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
+#define V4L2_PIX_FMT_SQ905C   v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
+#define V4L2_PIX_FMT_PJPG     v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
+#define V4L2_PIX_FMT_OV511    v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
+#define V4L2_PIX_FMT_OV518    v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
+
+/*
+ *	F O R M A T   E N U M E R A T I O N
+ */
+struct v4l2_fmtdesc {
+	__u32		    index;             /* Format number      */
+	enum v4l2_buf_type  type;              /* buffer type        */
+	__u32               flags;
+	__u8		    description[32];   /* Description string */
+	__u32		    pixelformat;       /* Format fourcc      */
+	__u32		    reserved[4];
+};
+
+#define V4L2_FMT_FLAG_COMPRESSED 0x0001
+#define V4L2_FMT_FLAG_EMULATED   0x0002
+
+#if 1
+	/* Experimental Frame Size and frame rate enumeration */
+/*
+ *	F R A M E   S I Z E   E N U M E R A T I O N
+ */
+enum v4l2_frmsizetypes {
+	V4L2_FRMSIZE_TYPE_DISCRETE	= 1,
+	V4L2_FRMSIZE_TYPE_CONTINUOUS	= 2,
+	V4L2_FRMSIZE_TYPE_STEPWISE	= 3,
+};
+
+struct v4l2_frmsize_discrete {
+	__u32			width;		/* Frame width [pixel] */
+	__u32			height;		/* Frame height [pixel] */
+};
+
+struct v4l2_frmsize_stepwise {
+	__u32			min_width;	/* Minimum frame width [pixel] */
+	__u32			max_width;	/* Maximum frame width [pixel] */
+	__u32			step_width;	/* Frame width step size [pixel] */
+	__u32			min_height;	/* Minimum frame height [pixel] */
+	__u32			max_height;	/* Maximum frame height [pixel] */
+	__u32			step_height;	/* Frame height step size [pixel] */
+};
+
+struct v4l2_frmsizeenum {
+	__u32			index;		/* Frame size number */
+	__u32			pixel_format;	/* Pixel format */
+	__u32			type;		/* Frame size type the device supports. */
+
+	union {					/* Frame size */
+		struct v4l2_frmsize_discrete	discrete;
+		struct v4l2_frmsize_stepwise	stepwise;
+	};
+
+	__u32   reserved[2];			/* Reserved space for future use */
+};
+
+/*
+ *	F R A M E   R A T E   E N U M E R A T I O N
+ */
+enum v4l2_frmivaltypes {
+	V4L2_FRMIVAL_TYPE_DISCRETE	= 1,
+	V4L2_FRMIVAL_TYPE_CONTINUOUS	= 2,
+	V4L2_FRMIVAL_TYPE_STEPWISE	= 3,
+};
+
+struct v4l2_frmival_stepwise {
+	struct v4l2_fract	min;		/* Minimum frame interval [s] */
+	struct v4l2_fract	max;		/* Maximum frame interval [s] */
+	struct v4l2_fract	step;		/* Frame interval step size [s] */
+};
+
+struct v4l2_frmivalenum {
+	__u32			index;		/* Frame format index */
+	__u32			pixel_format;	/* Pixel format */
+	__u32			width;		/* Frame width */
+	__u32			height;		/* Frame height */
+	__u32			type;		/* Frame interval type the device supports. */
+
+	union {					/* Frame interval */
+		struct v4l2_fract		discrete;
+		struct v4l2_frmival_stepwise	stepwise;
+	};
+
+	__u32	reserved[2];			/* Reserved space for future use */
+};
+#endif
+
+/*
+ *	T I M E C O D E
+ */
+struct v4l2_timecode {
+	__u32	type;
+	__u32	flags;
+	__u8	frames;
+	__u8	seconds;
+	__u8	minutes;
+	__u8	hours;
+	__u8	userbits[4];
+};
+
+/*  Type  */
+#define V4L2_TC_TYPE_24FPS		1
+#define V4L2_TC_TYPE_25FPS		2
+#define V4L2_TC_TYPE_30FPS		3
+#define V4L2_TC_TYPE_50FPS		4
+#define V4L2_TC_TYPE_60FPS		5
+
+/*  Flags  */
+#define V4L2_TC_FLAG_DROPFRAME		0x0001 /* "drop-frame" mode */
+#define V4L2_TC_FLAG_COLORFRAME		0x0002
+#define V4L2_TC_USERBITS_field		0x000C
+#define V4L2_TC_USERBITS_USERDEFINED	0x0000
+#define V4L2_TC_USERBITS_8BITCHARS	0x0008
+/* The above is based on SMPTE timecodes */
+
+struct v4l2_jpegcompression {
+	int quality;
+
+	int  APPn;              /* Number of APP segment to be written,
+				 * must be 0..15 */
+	int  APP_len;           /* Length of data in JPEG APPn segment */
+	char APP_data[60];      /* Data in the JPEG APPn segment. */
+
+	int  COM_len;           /* Length of data in JPEG COM segment */
+	char COM_data[60];      /* Data in JPEG COM segment */
+
+	__u32 jpeg_markers;     /* Which markers should go into the JPEG
+				 * output. Unless you exactly know what
+				 * you do, leave them untouched.
+				 * Inluding less markers will make the
+				 * resulting code smaller, but there will
+				 * be fewer aplications which can read it.
+				 * The presence of the APP and COM marker
+				 * is influenced by APP_len and COM_len
+				 * ONLY, not by this property! */
+
+#define V4L2_JPEG_MARKER_DHT (1<<3)    /* Define Huffman Tables */
+#define V4L2_JPEG_MARKER_DQT (1<<4)    /* Define Quantization Tables */
+#define V4L2_JPEG_MARKER_DRI (1<<5)    /* Define Restart Interval */
+#define V4L2_JPEG_MARKER_COM (1<<6)    /* Comment segment */
+#define V4L2_JPEG_MARKER_APP (1<<7)    /* App segment, driver will
+					* allways use APP0 */
+};
+
+/*
+ *	M E M O R Y - M A P P I N G   B U F F E R S
+ */
+struct v4l2_requestbuffers {
+	__u32			count;
+	enum v4l2_buf_type      type;
+	enum v4l2_memory        memory;
+	__u32			reserved[2];
+};
+
+struct v4l2_buffer {
+	__u32			index;
+	enum v4l2_buf_type      type;
+	__u32			bytesused;
+	__u32			flags;
+	enum v4l2_field		field;
+	struct timeval		timestamp;
+	struct v4l2_timecode	timecode;
+	__u32			sequence;
+
+	/* memory location */
+	enum v4l2_memory        memory;
+	union {
+		__u32           offset;
+		unsigned long   userptr;
+	} m;
+	__u32			length;
+	__u32			input;
+	__u32			reserved;
+};
+
+/*  Flags for 'flags' field */
+#define V4L2_BUF_FLAG_MAPPED	0x0001  /* Buffer is mapped (flag) */
+#define V4L2_BUF_FLAG_QUEUED	0x0002	/* Buffer is queued for processing */
+#define V4L2_BUF_FLAG_DONE	0x0004	/* Buffer is ready */
+#define V4L2_BUF_FLAG_KEYFRAME	0x0008	/* Image is a keyframe (I-frame) */
+#define V4L2_BUF_FLAG_PFRAME	0x0010	/* Image is a P-frame */
+#define V4L2_BUF_FLAG_BFRAME	0x0020	/* Image is a B-frame */
+#define V4L2_BUF_FLAG_TIMECODE	0x0100	/* timecode field is valid */
+#define V4L2_BUF_FLAG_INPUT     0x0200  /* input field is valid */
+
+/*
+ *	O V E R L A Y   P R E V I E W
+ */
+struct v4l2_framebuffer {
+	__u32			capability;
+	__u32			flags;
+/* FIXME: in theory we should pass something like PCI device + memory
+ * region + offset instead of some physical address */
+	void                    *base;
+	struct v4l2_pix_format	fmt;
+};
+/*  Flags for the 'capability' field. Read only */
+#define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
+#define V4L2_FBUF_CAP_CHROMAKEY		0x0002
+#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
+#define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
+#define V4L2_FBUF_CAP_LOCAL_ALPHA	0x0010
+#define V4L2_FBUF_CAP_GLOBAL_ALPHA	0x0020
+#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA	0x0040
+/*  Flags for the 'flags' field. */
+#define V4L2_FBUF_FLAG_PRIMARY		0x0001
+#define V4L2_FBUF_FLAG_OVERLAY		0x0002
+#define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
+#define V4L2_FBUF_FLAG_LOCAL_ALPHA	0x0008
+#define V4L2_FBUF_FLAG_GLOBAL_ALPHA	0x0010
+#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA	0x0020
+
+struct v4l2_clip {
+	struct v4l2_rect        c;
+	struct v4l2_clip	*next;
+};
+
+struct v4l2_window {
+	struct v4l2_rect        w;
+	enum v4l2_field  	field;
+	__u32			chromakey;
+	struct v4l2_clip	*clips;
+	__u32			clipcount;
+	void			*bitmap;
+	__u8                    global_alpha;
+};
+
+/*
+ *	C A P T U R E   P A R A M E T E R S
+ */
+struct v4l2_captureparm {
+	__u32		   capability;	  /*  Supported modes */
+	__u32		   capturemode;	  /*  Current mode */
+	struct v4l2_fract  timeperframe;  /*  Time per frame in .1us units */
+	__u32		   extendedmode;  /*  Driver-specific extensions */
+	__u32              readbuffers;   /*  # of buffers for read */
+	__u32		   reserved[4];
+};
+
+/*  Flags for 'capability' and 'capturemode' fields */
+#define V4L2_MODE_HIGHQUALITY	0x0001	/*  High quality imaging mode */
+#define V4L2_CAP_TIMEPERFRAME	0x1000	/*  timeperframe field is supported */
+
+struct v4l2_outputparm {
+	__u32		   capability;	 /*  Supported modes */
+	__u32		   outputmode;	 /*  Current mode */
+	struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
+	__u32		   extendedmode; /*  Driver-specific extensions */
+	__u32              writebuffers; /*  # of buffers for write */
+	__u32		   reserved[4];
+};
+
+/*
+ *	I N P U T   I M A G E   C R O P P I N G
+ */
+struct v4l2_cropcap {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        bounds;
+	struct v4l2_rect        defrect;
+	struct v4l2_fract       pixelaspect;
+};
+
+struct v4l2_crop {
+	enum v4l2_buf_type      type;
+	struct v4l2_rect        c;
+};
+
+/*
+ *      A N A L O G   V I D E O   S T A N D A R D
+ */
+
+typedef __u64 v4l2_std_id;
+
+/* one bit for each */
+#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
+#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
+#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
+#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
+#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
+#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
+#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
+#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)
+
+#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
+#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
+#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
+#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
+
+#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
+#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
+#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
+#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)
+
+#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
+#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
+#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
+#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
+#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
+#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
+#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
+#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)
+
+/* ATSC/HDTV */
+#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
+#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
+
+/* FIXME:
+   Although std_id is 64 bits, there is an issue on PPC32 architecture that
+   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
+   this value to 32 bits.
+   As, currently, the max value is for V4L2_STD_ATSC_16_VSB (30 bits wide),
+   it should work fine. However, if needed to add more than two standards,
+   v4l2-common.c should be fixed.
+ */
+
+/* some merged standards */
+#define V4L2_STD_MN	(V4L2_STD_PAL_M|V4L2_STD_PAL_N|V4L2_STD_PAL_Nc|V4L2_STD_NTSC)
+#define V4L2_STD_B	(V4L2_STD_PAL_B|V4L2_STD_PAL_B1|V4L2_STD_SECAM_B)
+#define V4L2_STD_GH	(V4L2_STD_PAL_G|V4L2_STD_PAL_H|V4L2_STD_SECAM_G|V4L2_STD_SECAM_H)
+#define V4L2_STD_DK	(V4L2_STD_PAL_DK|V4L2_STD_SECAM_DK)
+
+/* some common needed stuff */
+#define V4L2_STD_PAL_BG		(V4L2_STD_PAL_B		|\
+				 V4L2_STD_PAL_B1	|\
+				 V4L2_STD_PAL_G)
+#define V4L2_STD_PAL_DK		(V4L2_STD_PAL_D		|\
+				 V4L2_STD_PAL_D1	|\
+				 V4L2_STD_PAL_K)
+#define V4L2_STD_PAL		(V4L2_STD_PAL_BG	|\
+				 V4L2_STD_PAL_DK	|\
+				 V4L2_STD_PAL_H		|\
+				 V4L2_STD_PAL_I)
+#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M	|\
+				 V4L2_STD_NTSC_M_JP     |\
+				 V4L2_STD_NTSC_M_KR)
+#define V4L2_STD_SECAM_DK      	(V4L2_STD_SECAM_D	|\
+				 V4L2_STD_SECAM_K	|\
+				 V4L2_STD_SECAM_K1)
+#define V4L2_STD_SECAM		(V4L2_STD_SECAM_B	|\
+				 V4L2_STD_SECAM_G	|\
+				 V4L2_STD_SECAM_H	|\
+				 V4L2_STD_SECAM_DK	|\
+				 V4L2_STD_SECAM_L       |\
+				 V4L2_STD_SECAM_LC)
+
+#define V4L2_STD_525_60		(V4L2_STD_PAL_M		|\
+				 V4L2_STD_PAL_60	|\
+				 V4L2_STD_NTSC		|\
+				 V4L2_STD_NTSC_443)
+#define V4L2_STD_625_50		(V4L2_STD_PAL		|\
+				 V4L2_STD_PAL_N		|\
+				 V4L2_STD_PAL_Nc	|\
+				 V4L2_STD_SECAM)
+#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
+				 V4L2_STD_ATSC_16_VSB)
+
+#define V4L2_STD_UNKNOWN        0
+#define V4L2_STD_ALL            (V4L2_STD_525_60	|\
+				 V4L2_STD_625_50)
+
+struct v4l2_standard {
+	__u32		     index;
+	v4l2_std_id          id;
+	__u8		     name[24];
+	struct v4l2_fract    frameperiod; /* Frames, not fields */
+	__u32		     framelines;
+	__u32		     reserved[4];
+};
+
+/*
+ *	V I D E O   I N P U T S
+ */
+struct v4l2_input {
+	__u32	     index;		/*  Which input */
+	__u8	     name[32];		/*  Label */
+	__u32	     type;		/*  Type of input */
+	__u32	     audioset;		/*  Associated audios (bitfield) */
+	__u32        tuner;             /*  Associated tuner */
+	v4l2_std_id  std;
+	__u32	     status;
+	__u32	     reserved[4];
+};
+
+/*  Values for the 'type' field */
+#define V4L2_INPUT_TYPE_TUNER		1
+#define V4L2_INPUT_TYPE_CAMERA		2
+
+/* field 'status' - general */
+#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
+#define V4L2_IN_ST_NO_SIGNAL   0x00000002
+#define V4L2_IN_ST_NO_COLOR    0x00000004
+
+/* field 'status' - sensor orientation */
+/* If sensor is mounted upside down set both bits */
+#define V4L2_IN_ST_HFLIP       0x00000010 /* Frames are flipped horizontally */
+#define V4L2_IN_ST_VFLIP       0x00000020 /* Frames are flipped vertically */
+
+/* field 'status' - analog */
+#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
+#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */
+
+/* field 'status' - digital */
+#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
+#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
+#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */
+
+/* field 'status' - VCR and set-top box */
+#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
+#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
+#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */
+
+/*
+ *	V I D E O   O U T P U T S
+ */
+struct v4l2_output {
+	__u32	     index;		/*  Which output */
+	__u8	     name[32];		/*  Label */
+	__u32	     type;		/*  Type of output */
+	__u32	     audioset;		/*  Associated audios (bitfield) */
+	__u32	     modulator;         /*  Associated modulator */
+	v4l2_std_id  std;
+	__u32	     reserved[4];
+};
+/*  Values for the 'type' field */
+#define V4L2_OUTPUT_TYPE_MODULATOR		1
+#define V4L2_OUTPUT_TYPE_ANALOG			2
+#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
+
+/*
+ *	C O N T R O L S
+ */
+struct v4l2_control {
+	__u32		     id;
+	__s32		     value;
+};
+
+struct v4l2_ext_control {
+	__u32 id;
+	__u32 size;
+	__u32 reserved2[1];
+	union {
+		__s32 value;
+		__s64 value64;
+		char *string;
+	};
+} __attribute__ ((packed));
+
+struct v4l2_ext_controls {
+	__u32 ctrl_class;
+	__u32 count;
+	__u32 error_idx;
+	__u32 reserved[2];
+	struct v4l2_ext_control *controls;
+};
+
+/*  Values for ctrl_class field */
+#define V4L2_CTRL_CLASS_USER 0x00980000	/* Old-style 'user' controls */
+#define V4L2_CTRL_CLASS_MPEG 0x00990000	/* MPEG-compression controls */
+#define V4L2_CTRL_CLASS_CAMERA 0x009a0000	/* Camera class controls */
+#define V4L2_CTRL_CLASS_FM_TX 0x009b0000	/* FM Modulator control class */
+
+#define V4L2_CTRL_ID_MASK      	  (0x0fffffff)
+#define V4L2_CTRL_ID2CLASS(id)    ((id) & 0x0fff0000UL)
+#define V4L2_CTRL_DRIVER_PRIV(id) (((id) & 0xffff) >= 0x1000)
+
+/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
+struct v4l2_queryctrl {
+	__u32		     id;
+	enum v4l2_ctrl_type  type;
+	__u8		     name[32];	/* Whatever */
+	__s32		     minimum;	/* Note signedness */
+	__s32		     maximum;
+	__s32		     step;
+	__s32		     default_value;
+	__u32                flags;
+	__u32		     reserved[2];
+};
+
+/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
+struct v4l2_querymenu {
+	__u32		id;
+	__u32		index;
+	__u8		name[32];	/* Whatever */
+	__u32		reserved;
+};
+
+/*  Control flags  */
+#define V4L2_CTRL_FLAG_DISABLED		0x0001
+#define V4L2_CTRL_FLAG_GRABBED		0x0002
+#define V4L2_CTRL_FLAG_READ_ONLY 	0x0004
+#define V4L2_CTRL_FLAG_UPDATE 		0x0008
+#define V4L2_CTRL_FLAG_INACTIVE 	0x0010
+#define V4L2_CTRL_FLAG_SLIDER 		0x0020
+#define V4L2_CTRL_FLAG_WRITE_ONLY 	0x0040
+
+/*  Query flag, to be ORed with the control ID */
+#define V4L2_CTRL_FLAG_NEXT_CTRL	0x80000000
+
+/*  User-class control IDs defined by V4L2 */
+#define V4L2_CID_BASE			(V4L2_CTRL_CLASS_USER | 0x900)
+#define V4L2_CID_USER_BASE 		V4L2_CID_BASE
+/*  IDs reserved for driver specific controls */
+#define V4L2_CID_PRIVATE_BASE		0x08000000
+
+#define V4L2_CID_USER_CLASS 		(V4L2_CTRL_CLASS_USER | 1)
+#define V4L2_CID_BRIGHTNESS		(V4L2_CID_BASE+0)
+#define V4L2_CID_CONTRAST		(V4L2_CID_BASE+1)
+#define V4L2_CID_SATURATION		(V4L2_CID_BASE+2)
+#define V4L2_CID_HUE			(V4L2_CID_BASE+3)
+#define V4L2_CID_AUDIO_VOLUME		(V4L2_CID_BASE+5)
+#define V4L2_CID_AUDIO_BALANCE		(V4L2_CID_BASE+6)
+#define V4L2_CID_AUDIO_BASS		(V4L2_CID_BASE+7)
+#define V4L2_CID_AUDIO_TREBLE		(V4L2_CID_BASE+8)
+#define V4L2_CID_AUDIO_MUTE		(V4L2_CID_BASE+9)
+#define V4L2_CID_AUDIO_LOUDNESS		(V4L2_CID_BASE+10)
+#define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11) /* Deprecated */
+#define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
+#define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+#define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
+#define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
+#define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
+#define V4L2_CID_WHITENESS		(V4L2_CID_GAMMA) /* Deprecated */
+#define V4L2_CID_EXPOSURE		(V4L2_CID_BASE+17)
+#define V4L2_CID_AUTOGAIN		(V4L2_CID_BASE+18)
+#define V4L2_CID_GAIN			(V4L2_CID_BASE+19)
+#define V4L2_CID_HFLIP			(V4L2_CID_BASE+20)
+#define V4L2_CID_VFLIP			(V4L2_CID_BASE+21)
+
+/* Deprecated; use V4L2_CID_PAN_RESET and V4L2_CID_TILT_RESET */
+#define V4L2_CID_HCENTER		(V4L2_CID_BASE+22)
+#define V4L2_CID_VCENTER		(V4L2_CID_BASE+23)
+
+#define V4L2_CID_POWER_LINE_FREQUENCY	(V4L2_CID_BASE+24)
+enum v4l2_power_line_frequency {
+	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED	= 0,
+	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 1,
+	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 2,
+};
+#define V4L2_CID_HUE_AUTO			(V4L2_CID_BASE+25)
+#define V4L2_CID_WHITE_BALANCE_TEMPERATURE	(V4L2_CID_BASE+26)
+#define V4L2_CID_SHARPNESS			(V4L2_CID_BASE+27)
+#define V4L2_CID_BACKLIGHT_COMPENSATION 	(V4L2_CID_BASE+28)
+#define V4L2_CID_CHROMA_AGC                     (V4L2_CID_BASE+29)
+#define V4L2_CID_COLOR_KILLER                   (V4L2_CID_BASE+30)
+#define V4L2_CID_COLORFX			(V4L2_CID_BASE+31)
+enum v4l2_colorfx {
+	V4L2_COLORFX_NONE	= 0,
+	V4L2_COLORFX_BW		= 1,
+	V4L2_COLORFX_SEPIA	= 2,
+};
+#define V4L2_CID_AUTOBRIGHTNESS			(V4L2_CID_BASE+32)
+#define V4L2_CID_BAND_STOP_FILTER		(V4L2_CID_BASE+33)
+
+/* last CID + 1 */
+#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+34)
+
+/*  MPEG-class control IDs defined by V4L2 */
+#define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
+#define V4L2_CID_MPEG_CLASS 			(V4L2_CTRL_CLASS_MPEG | 1)
+
+/*  MPEG streams */
+#define V4L2_CID_MPEG_STREAM_TYPE 		(V4L2_CID_MPEG_BASE+0)
+enum v4l2_mpeg_stream_type {
+	V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
+	V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
+};
+#define V4L2_CID_MPEG_STREAM_PID_PMT 		(V4L2_CID_MPEG_BASE+1)
+#define V4L2_CID_MPEG_STREAM_PID_AUDIO 		(V4L2_CID_MPEG_BASE+2)
+#define V4L2_CID_MPEG_STREAM_PID_VIDEO 		(V4L2_CID_MPEG_BASE+3)
+#define V4L2_CID_MPEG_STREAM_PID_PCR 		(V4L2_CID_MPEG_BASE+4)
+#define V4L2_CID_MPEG_STREAM_PES_ID_AUDIO 	(V4L2_CID_MPEG_BASE+5)
+#define V4L2_CID_MPEG_STREAM_PES_ID_VIDEO 	(V4L2_CID_MPEG_BASE+6)
+#define V4L2_CID_MPEG_STREAM_VBI_FMT 		(V4L2_CID_MPEG_BASE+7)
+enum v4l2_mpeg_stream_vbi_fmt {
+	V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
+	V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
+};
+
+/*  MPEG audio */
+#define V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ 	(V4L2_CID_MPEG_BASE+100)
+enum v4l2_mpeg_audio_sampling_freq {
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
+	V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
+};
+#define V4L2_CID_MPEG_AUDIO_ENCODING 		(V4L2_CID_MPEG_BASE+101)
+enum v4l2_mpeg_audio_encoding {
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
+	V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
+	V4L2_MPEG_AUDIO_ENCODING_AAC     = 3,
+	V4L2_MPEG_AUDIO_ENCODING_AC3     = 4,
+};
+#define V4L2_CID_MPEG_AUDIO_L1_BITRATE 		(V4L2_CID_MPEG_BASE+102)
+enum v4l2_mpeg_audio_l1_bitrate {
+	V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
+	V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
+	V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
+	V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
+	V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
+	V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
+	V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
+	V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
+	V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
+	V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
+	V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
+	V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
+	V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_L2_BITRATE 		(V4L2_CID_MPEG_BASE+103)
+enum v4l2_mpeg_audio_l2_bitrate {
+	V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
+	V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
+	V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
+	V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
+	V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
+	V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
+	V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
+	V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
+	V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
+	V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
+	V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
+	V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
+	V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_L3_BITRATE 		(V4L2_CID_MPEG_BASE+104)
+enum v4l2_mpeg_audio_l3_bitrate {
+	V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
+	V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
+	V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
+	V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
+	V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
+	V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
+	V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
+	V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
+	V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
+	V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
+	V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
+	V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
+	V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
+};
+#define V4L2_CID_MPEG_AUDIO_MODE 		(V4L2_CID_MPEG_BASE+105)
+enum v4l2_mpeg_audio_mode {
+	V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
+	V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
+	V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
+	V4L2_MPEG_AUDIO_MODE_MONO         = 3,
+};
+#define V4L2_CID_MPEG_AUDIO_MODE_EXTENSION 	(V4L2_CID_MPEG_BASE+106)
+enum v4l2_mpeg_audio_mode_extension {
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
+	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
+};
+#define V4L2_CID_MPEG_AUDIO_EMPHASIS 		(V4L2_CID_MPEG_BASE+107)
+enum v4l2_mpeg_audio_emphasis {
+	V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
+	V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
+	V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
+};
+#define V4L2_CID_MPEG_AUDIO_CRC 		(V4L2_CID_MPEG_BASE+108)
+enum v4l2_mpeg_audio_crc {
+	V4L2_MPEG_AUDIO_CRC_NONE  = 0,
+	V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
+};
+#define V4L2_CID_MPEG_AUDIO_MUTE 		(V4L2_CID_MPEG_BASE+109)
+#define V4L2_CID_MPEG_AUDIO_AAC_BITRATE		(V4L2_CID_MPEG_BASE+110)
+#define V4L2_CID_MPEG_AUDIO_AC3_BITRATE		(V4L2_CID_MPEG_BASE+111)
+enum v4l2_mpeg_audio_ac3_bitrate {
+	V4L2_MPEG_AUDIO_AC3_BITRATE_32K  = 0,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_40K  = 1,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_48K  = 2,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_56K  = 3,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_64K  = 4,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_80K  = 5,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_96K  = 6,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
+	V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
+};
+
+/*  MPEG video */
+#define V4L2_CID_MPEG_VIDEO_ENCODING 		(V4L2_CID_MPEG_BASE+200)
+enum v4l2_mpeg_video_encoding {
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_1     = 0,
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_2     = 1,
+	V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
+};
+#define V4L2_CID_MPEG_VIDEO_ASPECT 		(V4L2_CID_MPEG_BASE+201)
+enum v4l2_mpeg_video_aspect {
+	V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
+	V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
+	V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
+	V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
+};
+#define V4L2_CID_MPEG_VIDEO_B_FRAMES 		(V4L2_CID_MPEG_BASE+202)
+#define V4L2_CID_MPEG_VIDEO_GOP_SIZE 		(V4L2_CID_MPEG_BASE+203)
+#define V4L2_CID_MPEG_VIDEO_GOP_CLOSURE 	(V4L2_CID_MPEG_BASE+204)
+#define V4L2_CID_MPEG_VIDEO_PULLDOWN 		(V4L2_CID_MPEG_BASE+205)
+#define V4L2_CID_MPEG_VIDEO_BITRATE_MODE 	(V4L2_CID_MPEG_BASE+206)
+enum v4l2_mpeg_video_bitrate_mode {
+	V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
+	V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
+};
+#define V4L2_CID_MPEG_VIDEO_BITRATE 		(V4L2_CID_MPEG_BASE+207)
+#define V4L2_CID_MPEG_VIDEO_BITRATE_PEAK 	(V4L2_CID_MPEG_BASE+208)
+#define V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION (V4L2_CID_MPEG_BASE+209)
+#define V4L2_CID_MPEG_VIDEO_MUTE 		(V4L2_CID_MPEG_BASE+210)
+#define V4L2_CID_MPEG_VIDEO_MUTE_YUV 		(V4L2_CID_MPEG_BASE+211)
+
+/*  MPEG-class control IDs specific to the CX2341x driver as defined by V4L2 */
+#define V4L2_CID_MPEG_CX2341X_BASE 				(V4L2_CTRL_CLASS_MPEG | 0x1000)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+0)
+enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
+	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
+	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+1)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+2)
+enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
+	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+3)
+enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
+	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+4)
+enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
+	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
+	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+5)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE 		(V4L2_CID_MPEG_CX2341X_BASE+6)
+enum v4l2_mpeg_cx2341x_video_median_filter_type {
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
+	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
+};
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM 	(V4L2_CID_MPEG_CX2341X_BASE+7)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+8)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM	(V4L2_CID_MPEG_CX2341X_BASE+9)
+#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+10)
+#define V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS 	(V4L2_CID_MPEG_CX2341X_BASE+11)
+
+/*  Camera class control IDs */
+#define V4L2_CID_CAMERA_CLASS_BASE 	(V4L2_CTRL_CLASS_CAMERA | 0x900)
+#define V4L2_CID_CAMERA_CLASS 		(V4L2_CTRL_CLASS_CAMERA | 1)
+
+#define V4L2_CID_EXPOSURE_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+1)
+enum  v4l2_exposure_auto_type {
+	V4L2_EXPOSURE_AUTO = 0,
+	V4L2_EXPOSURE_MANUAL = 1,
+	V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
+	V4L2_EXPOSURE_APERTURE_PRIORITY = 3
+};
+#define V4L2_CID_EXPOSURE_ABSOLUTE		(V4L2_CID_CAMERA_CLASS_BASE+2)
+#define V4L2_CID_EXPOSURE_AUTO_PRIORITY		(V4L2_CID_CAMERA_CLASS_BASE+3)
+
+#define V4L2_CID_PAN_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+4)
+#define V4L2_CID_TILT_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+5)
+#define V4L2_CID_PAN_RESET			(V4L2_CID_CAMERA_CLASS_BASE+6)
+#define V4L2_CID_TILT_RESET			(V4L2_CID_CAMERA_CLASS_BASE+7)
+
+#define V4L2_CID_PAN_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+8)
+#define V4L2_CID_TILT_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+9)
+
+#define V4L2_CID_FOCUS_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+10)
+#define V4L2_CID_FOCUS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+11)
+#define V4L2_CID_FOCUS_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+12)
+
+#define V4L2_CID_ZOOM_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+13)
+#define V4L2_CID_ZOOM_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+14)
+#define V4L2_CID_ZOOM_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE+15)
+
+#define V4L2_CID_PRIVACY			(V4L2_CID_CAMERA_CLASS_BASE+16)
+
+/* FM Modulator class control IDs */
+#define V4L2_CID_FM_TX_CLASS_BASE		(V4L2_CTRL_CLASS_FM_TX | 0x900)
+#define V4L2_CID_FM_TX_CLASS			(V4L2_CTRL_CLASS_FM_TX | 1)
+
+#define V4L2_CID_RDS_TX_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 1)
+#define V4L2_CID_RDS_TX_PI			(V4L2_CID_FM_TX_CLASS_BASE + 2)
+#define V4L2_CID_RDS_TX_PTY			(V4L2_CID_FM_TX_CLASS_BASE + 3)
+#define V4L2_CID_RDS_TX_PS_NAME			(V4L2_CID_FM_TX_CLASS_BASE + 5)
+#define V4L2_CID_RDS_TX_RADIO_TEXT		(V4L2_CID_FM_TX_CLASS_BASE + 6)
+
+#define V4L2_CID_AUDIO_LIMITER_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 64)
+#define V4L2_CID_AUDIO_LIMITER_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 65)
+#define V4L2_CID_AUDIO_LIMITER_DEVIATION	(V4L2_CID_FM_TX_CLASS_BASE + 66)
+
+#define V4L2_CID_AUDIO_COMPRESSION_ENABLED	(V4L2_CID_FM_TX_CLASS_BASE + 80)
+#define V4L2_CID_AUDIO_COMPRESSION_GAIN		(V4L2_CID_FM_TX_CLASS_BASE + 81)
+#define V4L2_CID_AUDIO_COMPRESSION_THRESHOLD	(V4L2_CID_FM_TX_CLASS_BASE + 82)
+#define V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 83)
+#define V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 84)
+
+#define V4L2_CID_PILOT_TONE_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 96)
+#define V4L2_CID_PILOT_TONE_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 97)
+#define V4L2_CID_PILOT_TONE_FREQUENCY		(V4L2_CID_FM_TX_CLASS_BASE + 98)
+
+#define V4L2_CID_TUNE_PREEMPHASIS		(V4L2_CID_FM_TX_CLASS_BASE + 112)
+enum v4l2_preemphasis {
+	V4L2_PREEMPHASIS_DISABLED	= 0,
+	V4L2_PREEMPHASIS_50_uS		= 1,
+	V4L2_PREEMPHASIS_75_uS		= 2,
+};
+#define V4L2_CID_TUNE_POWER_LEVEL		(V4L2_CID_FM_TX_CLASS_BASE + 113)
+#define V4L2_CID_TUNE_ANTENNA_CAPACITOR		(V4L2_CID_FM_TX_CLASS_BASE + 114)
+
+/*
+ *	T U N I N G
+ */
+struct v4l2_tuner {
+	__u32                   index;
+	__u8			name[32];
+	enum v4l2_tuner_type    type;
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			rxsubchans;
+	__u32			audmode;
+	__s32			signal;
+	__s32			afc;
+	__u32			reserved[4];
+};
+
+struct v4l2_modulator {
+	__u32			index;
+	__u8			name[32];
+	__u32			capability;
+	__u32			rangelow;
+	__u32			rangehigh;
+	__u32			txsubchans;
+	__u32			reserved[4];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_TUNER_CAP_LOW		0x0001
+#define V4L2_TUNER_CAP_NORM		0x0002
+#define V4L2_TUNER_CAP_STEREO		0x0010
+#define V4L2_TUNER_CAP_LANG2		0x0020
+#define V4L2_TUNER_CAP_SAP		0x0020
+#define V4L2_TUNER_CAP_LANG1		0x0040
+#define V4L2_TUNER_CAP_RDS		0x0080
+
+/*  Flags for the 'rxsubchans' field */
+#define V4L2_TUNER_SUB_MONO		0x0001
+#define V4L2_TUNER_SUB_STEREO		0x0002
+#define V4L2_TUNER_SUB_LANG2		0x0004
+#define V4L2_TUNER_SUB_SAP		0x0004
+#define V4L2_TUNER_SUB_LANG1		0x0008
+#define V4L2_TUNER_SUB_RDS		0x0010
+
+/*  Values for the 'audmode' field */
+#define V4L2_TUNER_MODE_MONO		0x0000
+#define V4L2_TUNER_MODE_STEREO		0x0001
+#define V4L2_TUNER_MODE_LANG2		0x0002
+#define V4L2_TUNER_MODE_SAP		0x0002
+#define V4L2_TUNER_MODE_LANG1		0x0003
+#define V4L2_TUNER_MODE_LANG1_LANG2	0x0004
+
+struct v4l2_frequency {
+	__u32		      tuner;
+	enum v4l2_tuner_type  type;
+	__u32		      frequency;
+	__u32		      reserved[8];
+};
+
+struct v4l2_hw_freq_seek {
+	__u32		      tuner;
+	enum v4l2_tuner_type  type;
+	__u32		      seek_upward;
+	__u32		      wrap_around;
+	__u32		      reserved[8];
+};
+
+/*
+ *	R D S
+ */
+
+struct v4l2_rds_data {
+	__u8 	lsb;
+	__u8 	msb;
+	__u8 	block;
+} __attribute__ ((packed));
+
+#define V4L2_RDS_BLOCK_MSK 	 0x7
+#define V4L2_RDS_BLOCK_A 	 0
+#define V4L2_RDS_BLOCK_B 	 1
+#define V4L2_RDS_BLOCK_C 	 2
+#define V4L2_RDS_BLOCK_D 	 3
+#define V4L2_RDS_BLOCK_C_ALT 	 4
+#define V4L2_RDS_BLOCK_INVALID 	 7
+
+#define V4L2_RDS_BLOCK_CORRECTED 0x40
+#define V4L2_RDS_BLOCK_ERROR 	 0x80
+
+/*
+ *	A U D I O
+ */
+struct v4l2_audio {
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*  Flags for the 'capability' field */
+#define V4L2_AUDCAP_STEREO		0x00001
+#define V4L2_AUDCAP_AVL			0x00002
+
+/*  Flags for the 'mode' field */
+#define V4L2_AUDMODE_AVL		0x00001
+
+struct v4l2_audioout {
+	__u32	index;
+	__u8	name[32];
+	__u32	capability;
+	__u32	mode;
+	__u32	reserved[2];
+};
+
+/*
+ *	M P E G   S E R V I C E S
+ *
+ *	NOTE: EXPERIMENTAL API
+ */
+#if 1
+#define V4L2_ENC_IDX_FRAME_I    (0)
+#define V4L2_ENC_IDX_FRAME_P    (1)
+#define V4L2_ENC_IDX_FRAME_B    (2)
+#define V4L2_ENC_IDX_FRAME_MASK (0xf)
+
+struct v4l2_enc_idx_entry {
+	__u64 offset;
+	__u64 pts;
+	__u32 length;
+	__u32 flags;
+	__u32 reserved[2];
+};
+
+#define V4L2_ENC_IDX_ENTRIES (64)
+struct v4l2_enc_idx {
+	__u32 entries;
+	__u32 entries_cap;
+	__u32 reserved[4];
+	struct v4l2_enc_idx_entry entry[V4L2_ENC_IDX_ENTRIES];
+};
+
+
+#define V4L2_ENC_CMD_START      (0)
+#define V4L2_ENC_CMD_STOP       (1)
+#define V4L2_ENC_CMD_PAUSE      (2)
+#define V4L2_ENC_CMD_RESUME     (3)
+
+/* Flags for V4L2_ENC_CMD_STOP */
+#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 << 0)
+
+struct v4l2_encoder_cmd {
+	__u32 cmd;
+	__u32 flags;
+	union {
+		struct {
+			__u32 data[8];
+		} raw;
+	};
+};
+
+#endif
+
+
+/*
+ *	D A T A   S E R V I C E S   ( V B I )
+ *
+ *	Data services API by Michael Schimek
+ */
+
+/* Raw VBI */
+struct v4l2_vbi_format {
+	__u32	sampling_rate;		/* in 1 Hz */
+	__u32	offset;
+	__u32	samples_per_line;
+	__u32	sample_format;		/* V4L2_PIX_FMT_* */
+	__s32	start[2];
+	__u32	count[2];
+	__u32	flags;			/* V4L2_VBI_* */
+	__u32	reserved[2];		/* must be zero */
+};
+
+/*  VBI flags  */
+#define V4L2_VBI_UNSYNC		(1 << 0)
+#define V4L2_VBI_INTERLACED	(1 << 1)
+
+/* Sliced VBI
+ *
+ *    This implements is a proposal V4L2 API to allow SLICED VBI
+ * required for some hardware encoders. It should change without
+ * notice in the definitive implementation.
+ */
+
+struct v4l2_sliced_vbi_format {
+	__u16   service_set;
+	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
+	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
+				 (equals frame lines 313-336 for 625 line video
+				  standards, 263-286 for 525 line standards) */
+	__u16   service_lines[2][24];
+	__u32   io_size;
+	__u32   reserved[2];            /* must be zero */
+};
+
+/* Teletext World System Teletext
+   (WST), defined on ITU-R BT.653-2 */
+#define V4L2_SLICED_TELETEXT_B          (0x0001)
+/* Video Program System, defined on ETS 300 231*/
+#define V4L2_SLICED_VPS                 (0x0400)
+/* Closed Caption, defined on EIA-608 */
+#define V4L2_SLICED_CAPTION_525         (0x1000)
+/* Wide Screen System, defined on ITU-R BT1119.1 */
+#define V4L2_SLICED_WSS_625             (0x4000)
+
+#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
+#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)
+
+struct v4l2_sliced_vbi_cap {
+	__u16   service_set;
+	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
+	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
+				 (equals frame lines 313-336 for 625 line video
+				  standards, 263-286 for 525 line standards) */
+	__u16   service_lines[2][24];
+	enum v4l2_buf_type type;
+	__u32   reserved[3];    /* must be 0 */
+};
+
+struct v4l2_sliced_vbi_data {
+	__u32   id;
+	__u32   field;          /* 0: first field, 1: second field */
+	__u32   line;           /* 1-23 */
+	__u32   reserved;       /* must be 0 */
+	__u8    data[48];
+};
+
+/*
+ * Sliced VBI data inserted into MPEG Streams
+ */
+
+/*
+ * V4L2_MPEG_STREAM_VBI_FMT_IVTV:
+ *
+ * Structure of payload contained in an MPEG 2 Private Stream 1 PES Packet in an
+ * MPEG-2 Program Pack that contains V4L2_MPEG_STREAM_VBI_FMT_IVTV Sliced VBI
+ * data
+ *
+ * Note, the MPEG-2 Program Pack and Private Stream 1 PES packet header
+ * definitions are not included here.  See the MPEG-2 specifications for details
+ * on these headers.
+ */
+
+/* Line type IDs */
+#define V4L2_MPEG_VBI_IVTV_TELETEXT_B     (1)
+#define V4L2_MPEG_VBI_IVTV_CAPTION_525    (4)
+#define V4L2_MPEG_VBI_IVTV_WSS_625        (5)
+#define V4L2_MPEG_VBI_IVTV_VPS            (7)
+
+struct v4l2_mpeg_vbi_itv0_line {
+	__u8 id;	/* One of V4L2_MPEG_VBI_IVTV_* above */
+	__u8 data[42];	/* Sliced VBI data for the line */
+} __attribute__ ((packed));
+
+struct v4l2_mpeg_vbi_itv0 {
+	__le32 linemask[2]; /* Bitmasks of VBI service lines present */
+	struct v4l2_mpeg_vbi_itv0_line line[35];
+} __attribute__ ((packed));
+
+struct v4l2_mpeg_vbi_ITV0 {
+	struct v4l2_mpeg_vbi_itv0_line line[36];
+} __attribute__ ((packed));
+
+#define V4L2_MPEG_VBI_IVTV_MAGIC0	"itv0"
+#define V4L2_MPEG_VBI_IVTV_MAGIC1	"ITV0"
+
+struct v4l2_mpeg_vbi_fmt_ivtv {
+	__u8 magic[4];
+	union {
+		struct v4l2_mpeg_vbi_itv0 itv0;
+		struct v4l2_mpeg_vbi_ITV0 ITV0;
+	};
+} __attribute__ ((packed));
+
+/*
+ *	A G G R E G A T E   S T R U C T U R E S
+ */
+
+/*	Stream data format
+ */
+struct v4l2_format {
+	enum v4l2_buf_type type;
+	union {
+		struct v4l2_pix_format		pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
+		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
+		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
+		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
+		__u8	raw_data[200];                   /* user-defined */
+	} fmt;
+};
+
+
+/*	Stream type-dependent parameters
+ */
+struct v4l2_streamparm {
+	enum v4l2_buf_type type;
+	union {
+		struct v4l2_captureparm	capture;
+		struct v4l2_outputparm	output;
+		__u8	raw_data[200];  /* user-defined */
+	} parm;
+};
+
+/*
+ *	A D V A N C E D   D E B U G G I N G
+ *
+ *	NOTE: EXPERIMENTAL API, NEVER RELY ON THIS IN APPLICATIONS!
+ *	FOR DEBUGGING, TESTING AND INTERNAL USE ONLY!
+ */
+
+/* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */
+
+#define V4L2_CHIP_MATCH_HOST       0  /* Match against chip ID on host (0 for the host) */
+#define V4L2_CHIP_MATCH_I2C_DRIVER 1  /* Match against I2C driver name */
+#define V4L2_CHIP_MATCH_I2C_ADDR   2  /* Match against I2C 7-bit address */
+#define V4L2_CHIP_MATCH_AC97       3  /* Match against anciliary AC97 chip */
+
+struct v4l2_dbg_match {
+	__u32 type; /* Match type */
+	union {     /* Match this chip, meaning determined by type */
+		__u32 addr;
+		char name[32];
+	};
+} __attribute__ ((packed));
+
+struct v4l2_dbg_register {
+	struct v4l2_dbg_match match;
+	__u32 size;	/* register size in bytes */
+	__u64 reg;
+	__u64 val;
+} __attribute__ ((packed));
+
+/* VIDIOC_DBG_G_CHIP_IDENT */
+struct v4l2_dbg_chip_ident {
+	struct v4l2_dbg_match match;
+	__u32 ident;       /* chip identifier as specified in <media/v4l2-chip-ident.h> */
+	__u32 revision;    /* chip revision, chip specific */
+} __attribute__ ((packed));
+
+/*
+ *	I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
+ *
+ */
+#define VIDIOC_QUERYCAP		 _IOR('V',  0, struct v4l2_capability)
+#define VIDIOC_RESERVED		  _IO('V',  1)
+#define VIDIOC_ENUM_FMT         _IOWR('V',  2, struct v4l2_fmtdesc)
+#define VIDIOC_G_FMT		_IOWR('V',  4, struct v4l2_format)
+#define VIDIOC_S_FMT		_IOWR('V',  5, struct v4l2_format)
+#define VIDIOC_REQBUFS		_IOWR('V',  8, struct v4l2_requestbuffers)
+#define VIDIOC_QUERYBUF		_IOWR('V',  9, struct v4l2_buffer)
+#define VIDIOC_G_FBUF		 _IOR('V', 10, struct v4l2_framebuffer)
+#define VIDIOC_S_FBUF		 _IOW('V', 11, struct v4l2_framebuffer)
+#define VIDIOC_OVERLAY		 _IOW('V', 14, int)
+#define VIDIOC_QBUF		_IOWR('V', 15, struct v4l2_buffer)
+#define VIDIOC_DQBUF		_IOWR('V', 17, struct v4l2_buffer)
+#define VIDIOC_STREAMON		 _IOW('V', 18, int)
+#define VIDIOC_STREAMOFF	 _IOW('V', 19, int)
+#define VIDIOC_G_PARM		_IOWR('V', 21, struct v4l2_streamparm)
+#define VIDIOC_S_PARM		_IOWR('V', 22, struct v4l2_streamparm)
+#define VIDIOC_G_STD		 _IOR('V', 23, v4l2_std_id)
+#define VIDIOC_S_STD		 _IOW('V', 24, v4l2_std_id)
+#define VIDIOC_ENUMSTD		_IOWR('V', 25, struct v4l2_standard)
+#define VIDIOC_ENUMINPUT	_IOWR('V', 26, struct v4l2_input)
+#define VIDIOC_G_CTRL		_IOWR('V', 27, struct v4l2_control)
+#define VIDIOC_S_CTRL		_IOWR('V', 28, struct v4l2_control)
+#define VIDIOC_G_TUNER		_IOWR('V', 29, struct v4l2_tuner)
+#define VIDIOC_S_TUNER		 _IOW('V', 30, struct v4l2_tuner)
+#define VIDIOC_G_AUDIO		 _IOR('V', 33, struct v4l2_audio)
+#define VIDIOC_S_AUDIO		 _IOW('V', 34, struct v4l2_audio)
+#define VIDIOC_QUERYCTRL	_IOWR('V', 36, struct v4l2_queryctrl)
+#define VIDIOC_QUERYMENU	_IOWR('V', 37, struct v4l2_querymenu)
+#define VIDIOC_G_INPUT		 _IOR('V', 38, int)
+#define VIDIOC_S_INPUT		_IOWR('V', 39, int)
+#define VIDIOC_G_OUTPUT		 _IOR('V', 46, int)
+#define VIDIOC_S_OUTPUT		_IOWR('V', 47, int)
+#define VIDIOC_ENUMOUTPUT	_IOWR('V', 48, struct v4l2_output)
+#define VIDIOC_G_AUDOUT		 _IOR('V', 49, struct v4l2_audioout)
+#define VIDIOC_S_AUDOUT		 _IOW('V', 50, struct v4l2_audioout)
+#define VIDIOC_G_MODULATOR	_IOWR('V', 54, struct v4l2_modulator)
+#define VIDIOC_S_MODULATOR	 _IOW('V', 55, struct v4l2_modulator)
+#define VIDIOC_G_FREQUENCY	_IOWR('V', 56, struct v4l2_frequency)
+#define VIDIOC_S_FREQUENCY	 _IOW('V', 57, struct v4l2_frequency)
+#define VIDIOC_CROPCAP		_IOWR('V', 58, struct v4l2_cropcap)
+#define VIDIOC_G_CROP		_IOWR('V', 59, struct v4l2_crop)
+#define VIDIOC_S_CROP		 _IOW('V', 60, struct v4l2_crop)
+#define VIDIOC_G_JPEGCOMP	 _IOR('V', 61, struct v4l2_jpegcompression)
+#define VIDIOC_S_JPEGCOMP	 _IOW('V', 62, struct v4l2_jpegcompression)
+#define VIDIOC_QUERYSTD      	 _IOR('V', 63, v4l2_std_id)
+#define VIDIOC_TRY_FMT      	_IOWR('V', 64, struct v4l2_format)
+#define VIDIOC_ENUMAUDIO	_IOWR('V', 65, struct v4l2_audio)
+#define VIDIOC_ENUMAUDOUT	_IOWR('V', 66, struct v4l2_audioout)
+#define VIDIOC_G_PRIORITY        _IOR('V', 67, enum v4l2_priority)
+#define VIDIOC_S_PRIORITY        _IOW('V', 68, enum v4l2_priority)
+#define VIDIOC_G_SLICED_VBI_CAP _IOWR('V', 69, struct v4l2_sliced_vbi_cap)
+#define VIDIOC_LOG_STATUS         _IO('V', 70)
+#define VIDIOC_G_EXT_CTRLS	_IOWR('V', 71, struct v4l2_ext_controls)
+#define VIDIOC_S_EXT_CTRLS	_IOWR('V', 72, struct v4l2_ext_controls)
+#define VIDIOC_TRY_EXT_CTRLS	_IOWR('V', 73, struct v4l2_ext_controls)
+#if 1
+#define VIDIOC_ENUM_FRAMESIZES	_IOWR('V', 74, struct v4l2_frmsizeenum)
+#define VIDIOC_ENUM_FRAMEINTERVALS _IOWR('V', 75, struct v4l2_frmivalenum)
+#define VIDIOC_G_ENC_INDEX       _IOR('V', 76, struct v4l2_enc_idx)
+#define VIDIOC_ENCODER_CMD      _IOWR('V', 77, struct v4l2_encoder_cmd)
+#define VIDIOC_TRY_ENCODER_CMD  _IOWR('V', 78, struct v4l2_encoder_cmd)
+#endif
+
+#if 1
+/* Experimental, meant for debugging, testing and internal use.
+   Only implemented if CONFIG_VIDEO_ADV_DEBUG is defined.
+   You must be root to use these ioctls. Never use these in applications! */
+#define	VIDIOC_DBG_S_REGISTER 	 _IOW('V', 79, struct v4l2_dbg_register)
+#define	VIDIOC_DBG_G_REGISTER 	_IOWR('V', 80, struct v4l2_dbg_register)
+
+/* Experimental, meant for debugging, testing and internal use.
+   Never use this ioctl in applications! */
+#define VIDIOC_DBG_G_CHIP_IDENT _IOWR('V', 81, struct v4l2_dbg_chip_ident)
+#endif
+
+#define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
+/* Reminder: when adding new ioctls please add support for them to
+   drivers/media/video/v4l2-compat-ioctl32.c as well! */
+
+#ifdef __OLD_VIDIOC_
+/* for compatibility, will go away some day */
+#define VIDIOC_OVERLAY_OLD     	_IOWR('V', 14, int)
+#define VIDIOC_S_PARM_OLD      	 _IOW('V', 22, struct v4l2_streamparm)
+#define VIDIOC_S_CTRL_OLD      	 _IOW('V', 28, struct v4l2_control)
+#define VIDIOC_G_AUDIO_OLD     	_IOWR('V', 33, struct v4l2_audio)
+#define VIDIOC_G_AUDOUT_OLD    	_IOWR('V', 49, struct v4l2_audioout)
+#define VIDIOC_CROPCAP_OLD     	 _IOR('V', 58, struct v4l2_cropcap)
+#endif
+
+#define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
+
+#endif /* __LINUX_VIDEODEV2_H */
diff -uNr linux-2.6.32/usr/include/linux/videodev.h clean_modified/linux-2.6.32/usr/include/linux/videodev.h
--- linux-2.6.32/usr/include/linux/videodev.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/videodev.h	2019-04-14 13:24:03.174869144 -0500
@@ -0,0 +1,320 @@
+/*
+ *	Video for Linux version 1 - OBSOLETE
+ *
+ *	Header file for v4l1 drivers and applications, for
+ *	Linux kernels 2.2.x or 2.4.x.
+ *
+ *	Provides header for legacy drivers and applications
+ *
+ *	See http://linuxtv.org for more info
+ *
+ */
+#ifndef __LINUX_VIDEODEV_H
+#define __LINUX_VIDEODEV_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/videodev2.h>
+
+
+#define VID_TYPE_CAPTURE	1	/* Can capture */
+#define VID_TYPE_TUNER		2	/* Can tune */
+#define VID_TYPE_TELETEXT	4	/* Does teletext */
+#define VID_TYPE_OVERLAY	8	/* Overlay onto frame buffer */
+#define VID_TYPE_CHROMAKEY	16	/* Overlay by chromakey */
+#define VID_TYPE_CLIPPING	32	/* Can clip */
+#define VID_TYPE_FRAMERAM	64	/* Uses the frame buffer memory */
+#define VID_TYPE_SCALES		128	/* Scalable */
+#define VID_TYPE_MONOCHROME	256	/* Monochrome only */
+#define VID_TYPE_SUBCAPTURE	512	/* Can capture subareas of the image */
+#define VID_TYPE_MPEG_DECODER	1024	/* Can decode MPEG streams */
+#define VID_TYPE_MPEG_ENCODER	2048	/* Can encode MPEG streams */
+#define VID_TYPE_MJPEG_DECODER	4096	/* Can decode MJPEG streams */
+#define VID_TYPE_MJPEG_ENCODER	8192	/* Can encode MJPEG streams */
+
+struct video_capability
+{
+	char name[32];
+	int type;
+	int channels;	/* Num channels */
+	int audios;	/* Num audio devices */
+	int maxwidth;	/* Supported width */
+	int maxheight;	/* And height */
+	int minwidth;	/* Supported width */
+	int minheight;	/* And height */
+};
+
+
+struct video_channel
+{
+	int channel;
+	char name[32];
+	int tuners;
+	__u32  flags;
+#define VIDEO_VC_TUNER		1	/* Channel has a tuner */
+#define VIDEO_VC_AUDIO		2	/* Channel has audio */
+	__u16  type;
+#define VIDEO_TYPE_TV		1
+#define VIDEO_TYPE_CAMERA	2
+	__u16 norm;			/* Norm set by channel */
+};
+
+struct video_tuner
+{
+	int tuner;
+	char name[32];
+	unsigned long rangelow, rangehigh;	/* Tuner range */
+	__u32 flags;
+#define VIDEO_TUNER_PAL		1
+#define VIDEO_TUNER_NTSC	2
+#define VIDEO_TUNER_SECAM	4
+#define VIDEO_TUNER_LOW		8	/* Uses KHz not MHz */
+#define VIDEO_TUNER_NORM	16	/* Tuner can set norm */
+#define VIDEO_TUNER_STEREO_ON	128	/* Tuner is seeing stereo */
+#define VIDEO_TUNER_RDS_ON      256     /* Tuner is seeing an RDS datastream */
+#define VIDEO_TUNER_MBS_ON      512     /* Tuner is seeing an MBS datastream */
+	__u16 mode;			/* PAL/NTSC/SECAM/OTHER */
+#define VIDEO_MODE_PAL		0
+#define VIDEO_MODE_NTSC		1
+#define VIDEO_MODE_SECAM	2
+#define VIDEO_MODE_AUTO		3
+	__u16 signal;			/* Signal strength 16bit scale */
+};
+
+struct video_picture
+{
+	__u16	brightness;
+	__u16	hue;
+	__u16	colour;
+	__u16	contrast;
+	__u16	whiteness;	/* Black and white only */
+	__u16	depth;		/* Capture depth */
+	__u16   palette;	/* Palette in use */
+#define VIDEO_PALETTE_GREY	1	/* Linear greyscale */
+#define VIDEO_PALETTE_HI240	2	/* High 240 cube (BT848) */
+#define VIDEO_PALETTE_RGB565	3	/* 565 16 bit RGB */
+#define VIDEO_PALETTE_RGB24	4	/* 24bit RGB */
+#define VIDEO_PALETTE_RGB32	5	/* 32bit RGB */
+#define VIDEO_PALETTE_RGB555	6	/* 555 15bit RGB */
+#define VIDEO_PALETTE_YUV422	7	/* YUV422 capture */
+#define VIDEO_PALETTE_YUYV	8
+#define VIDEO_PALETTE_UYVY	9	/* The great thing about standards is ... */
+#define VIDEO_PALETTE_YUV420	10
+#define VIDEO_PALETTE_YUV411	11	/* YUV411 capture */
+#define VIDEO_PALETTE_RAW	12	/* RAW capture (BT848) */
+#define VIDEO_PALETTE_YUV422P	13	/* YUV 4:2:2 Planar */
+#define VIDEO_PALETTE_YUV411P	14	/* YUV 4:1:1 Planar */
+#define VIDEO_PALETTE_YUV420P	15	/* YUV 4:2:0 Planar */
+#define VIDEO_PALETTE_YUV410P	16	/* YUV 4:1:0 Planar */
+#define VIDEO_PALETTE_PLANAR	13	/* start of planar entries */
+#define VIDEO_PALETTE_COMPONENT 7	/* start of component entries */
+};
+
+struct video_audio
+{
+	int	audio;		/* Audio channel */
+	__u16	volume;		/* If settable */
+	__u16	bass, treble;
+	__u32	flags;
+#define VIDEO_AUDIO_MUTE	1
+#define VIDEO_AUDIO_MUTABLE	2
+#define VIDEO_AUDIO_VOLUME	4
+#define VIDEO_AUDIO_BASS	8
+#define VIDEO_AUDIO_TREBLE	16
+#define VIDEO_AUDIO_BALANCE	32
+	char    name[16];
+#define VIDEO_SOUND_MONO	1
+#define VIDEO_SOUND_STEREO	2
+#define VIDEO_SOUND_LANG1	4
+#define VIDEO_SOUND_LANG2	8
+	__u16   mode;
+	__u16	balance;	/* Stereo balance */
+	__u16	step;		/* Step actual volume uses */
+};
+
+struct video_clip
+{
+	__s32	x,y;
+	__s32	width, height;
+	struct	video_clip *next;	/* For user use/driver use only */
+};
+
+struct video_window
+{
+	__u32	x,y;			/* Position of window */
+	__u32	width,height;		/* Its size */
+	__u32	chromakey;
+	__u32	flags;
+	struct	video_clip *clips;	/* Set only */
+	int	clipcount;
+#define VIDEO_WINDOW_INTERLACE	1
+#define VIDEO_WINDOW_CHROMAKEY	16	/* Overlay by chromakey */
+#define VIDEO_CLIP_BITMAP	-1
+/* bitmap is 1024x625, a '1' bit represents a clipped pixel */
+#define VIDEO_CLIPMAP_SIZE	(128 * 625)
+};
+
+struct video_capture
+{
+	__u32 	x,y;			/* Offsets into image */
+	__u32	width, height;		/* Area to capture */
+	__u16	decimation;		/* Decimation divider */
+	__u16	flags;			/* Flags for capture */
+#define VIDEO_CAPTURE_ODD		0	/* Temporal */
+#define VIDEO_CAPTURE_EVEN		1
+};
+
+struct video_buffer
+{
+	void	*base;
+	int	height,width;
+	int	depth;
+	int	bytesperline;
+};
+
+struct video_mmap
+{
+	unsigned	int frame;		/* Frame (0 - n) for double buffer */
+	int		height,width;
+	unsigned	int format;		/* should be VIDEO_PALETTE_* */
+};
+
+struct video_key
+{
+	__u8	key[8];
+	__u32	flags;
+};
+
+struct video_mbuf
+{
+	int	size;		/* Total memory to map */
+	int	frames;		/* Frames */
+	int	offsets[VIDEO_MAX_FRAME];
+};
+
+#define 	VIDEO_NO_UNIT	(-1)
+
+struct video_unit
+{
+	int 	video;		/* Video minor */
+	int	vbi;		/* VBI minor */
+	int	radio;		/* Radio minor */
+	int	audio;		/* Audio minor */
+	int	teletext;	/* Teletext minor */
+};
+
+struct vbi_format {
+	__u32	sampling_rate;	/* in Hz */
+	__u32	samples_per_line;
+	__u32	sample_format;	/* VIDEO_PALETTE_RAW only (1 byte) */
+	__s32	start[2];	/* starting line for each frame */
+	__u32	count[2];	/* count of lines for each frame */
+	__u32	flags;
+#define	VBI_UNSYNC	1	/* can distingues between top/bottom field */
+#define	VBI_INTERLACED	2	/* lines are interlaced */
+};
+
+/* video_info is biased towards hardware mpeg encode/decode */
+/* but it could apply generically to any hardware compressor/decompressor */
+struct video_info
+{
+	__u32	frame_count;	/* frames output since decode/encode began */
+	__u32	h_size;		/* current unscaled horizontal size */
+	__u32	v_size;		/* current unscaled veritcal size */
+	__u32	smpte_timecode;	/* current SMPTE timecode (for current GOP) */
+	__u32	picture_type;	/* current picture type */
+	__u32	temporal_reference;	/* current temporal reference */
+	__u8	user_data[256];	/* user data last found in compressed stream */
+	/* user_data[0] contains user data flags, user_data[1] has count */
+};
+
+/* generic structure for setting playback modes */
+struct video_play_mode
+{
+	int	mode;
+	int	p1;
+	int	p2;
+};
+
+/* for loading microcode / fpga programming */
+struct video_code
+{
+	char	loadwhat[16];	/* name or tag of file being passed */
+	int	datasize;
+	__u8	*data;
+};
+
+#define VIDIOCGCAP		_IOR('v',1,struct video_capability)	/* Get capabilities */
+#define VIDIOCGCHAN		_IOWR('v',2,struct video_channel)	/* Get channel info (sources) */
+#define VIDIOCSCHAN		_IOW('v',3,struct video_channel)	/* Set channel 	*/
+#define VIDIOCGTUNER		_IOWR('v',4,struct video_tuner)		/* Get tuner abilities */
+#define VIDIOCSTUNER		_IOW('v',5,struct video_tuner)		/* Tune the tuner for the current channel */
+#define VIDIOCGPICT		_IOR('v',6,struct video_picture)	/* Get picture properties */
+#define VIDIOCSPICT		_IOW('v',7,struct video_picture)	/* Set picture properties */
+#define VIDIOCCAPTURE		_IOW('v',8,int)				/* Start, end capture */
+#define VIDIOCGWIN		_IOR('v',9, struct video_window)	/* Get the video overlay window */
+#define VIDIOCSWIN		_IOW('v',10, struct video_window)	/* Set the video overlay window - passes clip list for hardware smarts , chromakey etc */
+#define VIDIOCGFBUF		_IOR('v',11, struct video_buffer)	/* Get frame buffer */
+#define VIDIOCSFBUF		_IOW('v',12, struct video_buffer)	/* Set frame buffer - root only */
+#define VIDIOCKEY		_IOR('v',13, struct video_key)		/* Video key event - to dev 255 is to all - cuts capture on all DMA windows with this key (0xFFFFFFFF == all) */
+#define VIDIOCGFREQ		_IOR('v',14, unsigned long)		/* Set tuner */
+#define VIDIOCSFREQ		_IOW('v',15, unsigned long)		/* Set tuner */
+#define VIDIOCGAUDIO		_IOR('v',16, struct video_audio)	/* Get audio info */
+#define VIDIOCSAUDIO		_IOW('v',17, struct video_audio)	/* Audio source, mute etc */
+#define VIDIOCSYNC		_IOW('v',18, int)			/* Sync with mmap grabbing */
+#define VIDIOCMCAPTURE		_IOW('v',19, struct video_mmap)		/* Grab frames */
+#define VIDIOCGMBUF		_IOR('v',20, struct video_mbuf)		/* Memory map buffer info */
+#define VIDIOCGUNIT		_IOR('v',21, struct video_unit)		/* Get attached units */
+#define VIDIOCGCAPTURE		_IOR('v',22, struct video_capture)	/* Get subcapture */
+#define VIDIOCSCAPTURE		_IOW('v',23, struct video_capture)	/* Set subcapture */
+#define VIDIOCSPLAYMODE		_IOW('v',24, struct video_play_mode)	/* Set output video mode/feature */
+#define VIDIOCSWRITEMODE	_IOW('v',25, int)			/* Set write mode */
+#define VIDIOCGPLAYINFO		_IOR('v',26, struct video_info)		/* Get current playback info from hardware */
+#define VIDIOCSMICROCODE	_IOW('v',27, struct video_code)		/* Load microcode into hardware */
+#define	VIDIOCGVBIFMT		_IOR('v',28, struct vbi_format)		/* Get VBI information */
+#define	VIDIOCSVBIFMT		_IOW('v',29, struct vbi_format)		/* Set VBI information */
+
+
+#define BASE_VIDIOCPRIVATE	192		/* 192-255 are private */
+
+/* VIDIOCSWRITEMODE */
+#define VID_WRITE_MPEG_AUD		0
+#define VID_WRITE_MPEG_VID		1
+#define VID_WRITE_OSD			2
+#define VID_WRITE_TTX			3
+#define VID_WRITE_CC			4
+#define VID_WRITE_MJPEG			5
+
+/* VIDIOCSPLAYMODE */
+#define VID_PLAY_VID_OUT_MODE		0
+	/* p1: = VIDEO_MODE_PAL, VIDEO_MODE_NTSC, etc ... */
+#define VID_PLAY_GENLOCK		1
+	/* p1: 0 = OFF, 1 = ON */
+	/* p2: GENLOCK FINE DELAY value */
+#define VID_PLAY_NORMAL			2
+#define VID_PLAY_PAUSE			3
+#define VID_PLAY_SINGLE_FRAME		4
+#define VID_PLAY_FAST_FORWARD		5
+#define VID_PLAY_SLOW_MOTION		6
+#define VID_PLAY_IMMEDIATE_NORMAL	7
+#define VID_PLAY_SWITCH_CHANNELS	8
+#define VID_PLAY_FREEZE_FRAME		9
+#define VID_PLAY_STILL_MODE		10
+#define VID_PLAY_MASTER_MODE		11
+	/* p1: see below */
+#define		VID_PLAY_MASTER_NONE	1
+#define		VID_PLAY_MASTER_VIDEO	2
+#define		VID_PLAY_MASTER_AUDIO	3
+#define VID_PLAY_ACTIVE_SCANLINES	12
+	/* p1 = first active; p2 = last active */
+#define VID_PLAY_RESET			13
+#define VID_PLAY_END_MARK		14
+
+
+#endif /* __LINUX_VIDEODEV_H */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -uNr linux-2.6.32/usr/include/linux/videotext.h clean_modified/linux-2.6.32/usr/include/linux/videotext.h
--- linux-2.6.32/usr/include/linux/videotext.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/videotext.h	2019-04-14 13:24:03.175841915 -0500
@@ -0,0 +1,125 @@
+#ifndef _VTX_H
+#define _VTX_H
+
+/*
+ * Teletext (=Videotext) hardware decoders using interface /dev/vtx
+ * Do not confuse with drivers using /dev/vbi which decode videotext by software
+ *
+ * Videotext IOCTLs changed in order to use _IO() macros defined in <linux/ioctl.h>,
+ * unused tuner IOCTLs cleaned up by
+ * Michael Geng <linux@MichaelGeng.de>
+ *
+ * Copyright (c) 1994-97 Martin Buck  <martin-2.buck@student.uni-ulm.de>
+ * Read COPYING for more information
+ *
+ */
+
+
+/*
+ *	Videotext ioctls
+ */
+#define VTXIOCGETINFO	_IOR  (0x81,  1, vtx_info_t)
+#define VTXIOCCLRPAGE	_IOW  (0x81,  2, vtx_pagereq_t)
+#define VTXIOCCLRFOUND	_IOW  (0x81,  3, vtx_pagereq_t)
+#define VTXIOCPAGEREQ	_IOW  (0x81,  4, vtx_pagereq_t)
+#define VTXIOCGETSTAT	_IOW  (0x81,  5, vtx_pagereq_t)
+#define VTXIOCGETPAGE	_IOW  (0x81,  6, vtx_pagereq_t)
+#define VTXIOCSTOPDAU	_IOW  (0x81,  7, vtx_pagereq_t)
+#define VTXIOCPUTPAGE	_IO   (0x81,  8)
+#define VTXIOCSETDISP	_IO   (0x81,  9)
+#define VTXIOCPUTSTAT	_IO   (0x81, 10)
+#define VTXIOCCLRCACHE	_IO   (0x81, 11)
+#define VTXIOCSETVIRT	_IOW  (0x81, 12, long)
+
+/* for compatibility, will go away some day */
+#define VTXIOCGETINFO_OLD  0x7101  /* get version of driver & capabilities of vtx-chipset */
+#define VTXIOCCLRPAGE_OLD  0x7102  /* clear page-buffer */
+#define VTXIOCCLRFOUND_OLD 0x7103  /* clear bits indicating that page was found */
+#define VTXIOCPAGEREQ_OLD  0x7104  /* search for page */
+#define VTXIOCGETSTAT_OLD  0x7105  /* get status of page-buffer */
+#define VTXIOCGETPAGE_OLD  0x7106  /* get contents of page-buffer */
+#define VTXIOCSTOPDAU_OLD  0x7107  /* stop data acquisition unit */
+#define VTXIOCPUTPAGE_OLD  0x7108  /* display page on TV-screen */
+#define VTXIOCSETDISP_OLD  0x7109  /* set TV-mode */
+#define VTXIOCPUTSTAT_OLD  0x710a  /* set status of TV-output-buffer */
+#define VTXIOCCLRCACHE_OLD 0x710b  /* clear cache on VTX-interface (if avail.) */
+#define VTXIOCSETVIRT_OLD  0x710c  /* turn on virtual mode (this disables TV-display) */
+
+/*
+ *	Definitions for VTXIOCGETINFO
+ */
+
+#define SAA5243 0
+#define SAA5246 1
+#define SAA5249 2
+#define SAA5248 3
+#define XSTV5346 4
+
+typedef struct {
+	int version_major, version_minor;	/* version of driver; if version_major changes, driver */
+						/* is not backward compatible!!! CHECK THIS!!! */
+	int numpages;				/* number of page-buffers of vtx-chipset */
+	int cct_type;				/* type of vtx-chipset (SAA5243, SAA5246, SAA5248 or
+						 * SAA5249) */
+}
+vtx_info_t;
+
+
+/*
+ *	Definitions for VTXIOC{CLRPAGE,CLRFOUND,PAGEREQ,GETSTAT,GETPAGE,STOPDAU,PUTPAGE,SETDISP}
+ */
+
+#define MIN_UNIT   (1<<0)
+#define MIN_TEN    (1<<1)
+#define HR_UNIT    (1<<2)
+#define HR_TEN     (1<<3)
+#define PG_UNIT    (1<<4)
+#define PG_TEN     (1<<5)
+#define PG_HUND    (1<<6)
+#define PGMASK_MAX (1<<7)
+#define PGMASK_PAGE (PG_HUND | PG_TEN | PG_UNIT)
+#define PGMASK_HOUR (HR_TEN | HR_UNIT)
+#define PGMASK_MINUTE (MIN_TEN | MIN_UNIT)
+
+typedef struct
+{
+	int page;	/* number of requested page (hexadecimal) */
+	int hour;	/* requested hour (hexadecimal) */
+	int minute;	/* requested minute (hexadecimal) */
+	int pagemask;	/* mask defining which values of the above are set */
+	int pgbuf;	/* buffer where page will be stored */
+	int start;	/* start of requested part of page */
+	int end;	/* end of requested part of page */
+	void *buffer;	/* pointer to beginning of destination buffer */
+}
+vtx_pagereq_t;
+
+
+/*
+ *	Definitions for VTXIOC{GETSTAT,PUTSTAT}
+ */
+
+#define VTX_PAGESIZE (40 * 24)
+#define VTX_VIRTUALSIZE (40 * 49)
+
+typedef struct
+{
+	int pagenum;			/* number of page (hexadecimal) */
+	int hour;			/* hour (hexadecimal) */
+	int minute;			/* minute (hexadecimal) */
+	int charset;			/* national charset */
+	unsigned delete : 1;		/* delete page (C4) */
+	unsigned headline : 1;		/* insert headline (C5) */
+	unsigned subtitle : 1;		/* insert subtitle (C6) */
+	unsigned supp_header : 1;	/* suppress header (C7) */
+	unsigned update : 1;		/* update page (C8) */
+	unsigned inter_seq : 1;		/* interrupted sequence (C9) */
+	unsigned dis_disp : 1;		/* disable/suppress display (C10) */
+	unsigned serial : 1;		/* serial mode (C11) */
+	unsigned notfound : 1;		/* /FOUND */
+	unsigned pblf : 1;		/* PBLF */
+	unsigned hamming : 1;		/* hamming-error occurred */
+}
+vtx_pageinfo_t;
+
+#endif /* _VTX_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_9p.h clean_modified/linux-2.6.32/usr/include/linux/virtio_9p.h
--- linux-2.6.32/usr/include/linux/virtio_9p.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_9p.h	2019-04-14 13:24:03.175841915 -0500
@@ -0,0 +1,11 @@
+#ifndef _LINUX_VIRTIO_9P_H
+#define _LINUX_VIRTIO_9P_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+
+/* Maximum number of virtio channels per partition (1 for now) */
+#define MAX_9P_CHAN	1
+
+#endif /* _LINUX_VIRTIO_9P_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_balloon.h clean_modified/linux-2.6.32/usr/include/linux/virtio_balloon.h
--- linux-2.6.32/usr/include/linux/virtio_balloon.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_balloon.h	2019-04-14 13:24:03.175841915 -0500
@@ -0,0 +1,21 @@
+#ifndef _LINUX_VIRTIO_BALLOON_H
+#define _LINUX_VIRTIO_BALLOON_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+
+/* The feature bitmap for virtio balloon */
+#define VIRTIO_BALLOON_F_MUST_TELL_HOST	0 /* Tell before reclaiming pages */
+
+/* Size of a PFN in the balloon interface. */
+#define VIRTIO_BALLOON_PFN_SHIFT 12
+
+struct virtio_balloon_config
+{
+	/* Number of pages host wants Guest to give up. */
+	__le32 num_pages;
+	/* Number of pages we've actually got in balloon. */
+	__le32 actual;
+};
+#endif /* _LINUX_VIRTIO_BALLOON_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_blk.h clean_modified/linux-2.6.32/usr/include/linux/virtio_blk.h
--- linux-2.6.32/usr/include/linux/virtio_blk.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_blk.h	2019-04-14 13:24:03.175841915 -0500
@@ -0,0 +1,81 @@
+#ifndef _LINUX_VIRTIO_BLK_H
+#define _LINUX_VIRTIO_BLK_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include <linux/types.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+
+/* Feature bits */
+#define VIRTIO_BLK_F_BARRIER	0	/* Does host support barriers? */
+#define VIRTIO_BLK_F_SIZE_MAX	1	/* Indicates maximum segment size */
+#define VIRTIO_BLK_F_SEG_MAX	2	/* Indicates maximum # of segments */
+#define VIRTIO_BLK_F_GEOMETRY	4	/* Legacy geometry available  */
+#define VIRTIO_BLK_F_RO		5	/* Disk is read-only */
+#define VIRTIO_BLK_F_BLK_SIZE	6	/* Block size of disk is available*/
+#define VIRTIO_BLK_F_SCSI	7	/* Supports scsi command passthru */
+#define VIRTIO_BLK_F_FLUSH	9	/* Cache flush command support */
+
+struct virtio_blk_config {
+	/* The capacity (in 512-byte sectors). */
+	__u64 capacity;
+	/* The maximum segment size (if VIRTIO_BLK_F_SIZE_MAX) */
+	__u32 size_max;
+	/* The maximum number of segments (if VIRTIO_BLK_F_SEG_MAX) */
+	__u32 seg_max;
+	/* geometry the device (if VIRTIO_BLK_F_GEOMETRY) */
+	struct virtio_blk_geometry {
+		__u16 cylinders;
+		__u8 heads;
+		__u8 sectors;
+	} geometry;
+	/* block size of device (if VIRTIO_BLK_F_BLK_SIZE) */
+	__u32 blk_size;
+} __attribute__((packed));
+
+/*
+ * Command types
+ *
+ * Usage is a bit tricky as some bits are used as flags and some are not.
+ *
+ * Rules:
+ *   VIRTIO_BLK_T_OUT may be combined with VIRTIO_BLK_T_SCSI_CMD or
+ *   VIRTIO_BLK_T_BARRIER.  VIRTIO_BLK_T_FLUSH is a command of its own
+ *   and may not be combined with any of the other flags.
+ */
+
+/* These two define direction. */
+#define VIRTIO_BLK_T_IN		0
+#define VIRTIO_BLK_T_OUT	1
+
+/* This bit says it's a scsi command, not an actual read or write. */
+#define VIRTIO_BLK_T_SCSI_CMD	2
+
+/* Cache flush command */
+#define VIRTIO_BLK_T_FLUSH	4
+
+/* Barrier before this op. */
+#define VIRTIO_BLK_T_BARRIER	0x80000000
+
+/* This is the first element of the read scatter-gather list. */
+struct virtio_blk_outhdr {
+	/* VIRTIO_BLK_T* */
+	__u32 type;
+	/* io priority. */
+	__u32 ioprio;
+	/* Sector (ie. 512 byte offset) */
+	__u64 sector;
+};
+
+struct virtio_scsi_inhdr {
+	__u32 errors;
+	__u32 data_len;
+	__u32 sense_len;
+	__u32 residual;
+};
+
+/* And this is the final byte of the write scatter-gather list. */
+#define VIRTIO_BLK_S_OK		0
+#define VIRTIO_BLK_S_IOERR	1
+#define VIRTIO_BLK_S_UNSUPP	2
+#endif /* _LINUX_VIRTIO_BLK_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_config.h clean_modified/linux-2.6.32/usr/include/linux/virtio_config.h
--- linux-2.6.32/usr/include/linux/virtio_config.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_config.h	2019-04-14 13:24:03.176902517 -0500
@@ -0,0 +1,31 @@
+#ifndef _LINUX_VIRTIO_CONFIG_H
+#define _LINUX_VIRTIO_CONFIG_H
+/* This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
+ * anyone can use the definitions to implement compatible drivers/servers. */
+
+/* Virtio devices use a standardized configuration space to define their
+ * features and pass configuration information, but each implementation can
+ * store and access that space differently. */
+#include <linux/types.h>
+
+/* Status byte for guest to report progress, and synchronize features. */
+/* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) */
+#define VIRTIO_CONFIG_S_ACKNOWLEDGE	1
+/* We have found a driver for the device. */
+#define VIRTIO_CONFIG_S_DRIVER		2
+/* Driver has used its parts of the config, and is happy */
+#define VIRTIO_CONFIG_S_DRIVER_OK	4
+/* We've given up on this device. */
+#define VIRTIO_CONFIG_S_FAILED		0x80
+
+/* Some virtio feature bits (currently bits 28 through 31) are reserved for the
+ * transport being used (eg. virtio_ring), the rest are per-device feature
+ * bits. */
+#define VIRTIO_TRANSPORT_F_START	28
+#define VIRTIO_TRANSPORT_F_END		32
+
+/* Do we get callbacks when the ring is completely used, even if we've
+ * suppressed them? */
+#define VIRTIO_F_NOTIFY_ON_EMPTY	24
+
+#endif /* _LINUX_VIRTIO_CONFIG_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_console.h clean_modified/linux-2.6.32/usr/include/linux/virtio_console.h
--- linux-2.6.32/usr/include/linux/virtio_console.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_console.h	2019-04-14 13:24:03.177975337 -0500
@@ -0,0 +1,21 @@
+#ifndef _LINUX_VIRTIO_CONSOLE_H
+#define _LINUX_VIRTIO_CONSOLE_H
+#include <linux/types.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+/* This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
+ * anyone can use the definitions to implement compatible drivers/servers. */
+
+/* Feature bits */
+#define VIRTIO_CONSOLE_F_SIZE	0	/* Does host provide console size? */
+
+struct virtio_console_config {
+	/* colums of the screens */
+	__u16 cols;
+	/* rows of the screens */
+	__u16 rows;
+} __attribute__((packed));
+
+
+
+#endif /* _LINUX_VIRTIO_CONSOLE_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_ids.h clean_modified/linux-2.6.32/usr/include/linux/virtio_ids.h
--- linux-2.6.32/usr/include/linux/virtio_ids.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_ids.h	2019-04-14 13:24:03.179247038 -0500
@@ -0,0 +1,17 @@
+#ifndef _LINUX_VIRTIO_IDS_H
+#define _LINUX_VIRTIO_IDS_H
+/*
+ * Virtio IDs
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ */
+
+#define VIRTIO_ID_NET		1 /* virtio net */
+#define VIRTIO_ID_BLOCK		2 /* virtio block */
+#define VIRTIO_ID_CONSOLE	3 /* virtio console */
+#define VIRTIO_ID_RNG		4 /* virtio ring */
+#define VIRTIO_ID_BALLOON	5 /* virtio balloon */
+#define VIRTIO_ID_9P		9 /* 9p virtio console */
+
+#endif /* _LINUX_VIRTIO_IDS_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_net.h clean_modified/linux-2.6.32/usr/include/linux/virtio_net.h
--- linux-2.6.32/usr/include/linux/virtio_net.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_net.h	2019-04-14 13:24:03.179890148 -0500
@@ -0,0 +1,131 @@
+#ifndef _LINUX_VIRTIO_NET_H
+#define _LINUX_VIRTIO_NET_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include <linux/types.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+#include <linux/if_ether.h>
+
+/* The feature bitmap for virtio net */
+#define VIRTIO_NET_F_CSUM	0	/* Host handles pkts w/ partial csum */
+#define VIRTIO_NET_F_GUEST_CSUM	1	/* Guest handles pkts w/ partial csum */
+#define VIRTIO_NET_F_MAC	5	/* Host has given MAC address. */
+#define VIRTIO_NET_F_GSO	6	/* Host handles pkts w/ any GSO type */
+#define VIRTIO_NET_F_GUEST_TSO4	7	/* Guest can handle TSOv4 in. */
+#define VIRTIO_NET_F_GUEST_TSO6	8	/* Guest can handle TSOv6 in. */
+#define VIRTIO_NET_F_GUEST_ECN	9	/* Guest can handle TSO[6] w/ ECN in. */
+#define VIRTIO_NET_F_GUEST_UFO	10	/* Guest can handle UFO in. */
+#define VIRTIO_NET_F_HOST_TSO4	11	/* Host can handle TSOv4 in. */
+#define VIRTIO_NET_F_HOST_TSO6	12	/* Host can handle TSOv6 in. */
+#define VIRTIO_NET_F_HOST_ECN	13	/* Host can handle TSO[6] w/ ECN in. */
+#define VIRTIO_NET_F_HOST_UFO	14	/* Host can handle UFO in. */
+#define VIRTIO_NET_F_MRG_RXBUF	15	/* Host can merge receive buffers. */
+#define VIRTIO_NET_F_STATUS	16	/* virtio_net_config.status available */
+#define VIRTIO_NET_F_CTRL_VQ	17	/* Control channel available */
+#define VIRTIO_NET_F_CTRL_RX	18	/* Control channel RX mode support */
+#define VIRTIO_NET_F_CTRL_VLAN	19	/* Control channel VLAN filtering */
+#define VIRTIO_NET_F_CTRL_RX_EXTRA 20	/* Extra RX mode control support */
+
+#define VIRTIO_NET_S_LINK_UP	1	/* Link is up */
+
+struct virtio_net_config {
+	/* The config defining mac address (if VIRTIO_NET_F_MAC) */
+	__u8 mac[6];
+	/* See VIRTIO_NET_F_STATUS and VIRTIO_NET_S_* above */
+	__u16 status;
+} __attribute__((packed));
+
+/* This is the first element of the scatter-gather list.  If you don't
+ * specify GSO or CSUM features, you can simply ignore the header. */
+struct virtio_net_hdr {
+#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1	// Use csum_start, csum_offset
+	__u8 flags;
+#define VIRTIO_NET_HDR_GSO_NONE		0	// Not a GSO frame
+#define VIRTIO_NET_HDR_GSO_TCPV4	1	// GSO frame, IPv4 TCP (TSO)
+#define VIRTIO_NET_HDR_GSO_UDP		3	// GSO frame, IPv4 UDP (UFO)
+#define VIRTIO_NET_HDR_GSO_TCPV6	4	// GSO frame, IPv6 TCP
+#define VIRTIO_NET_HDR_GSO_ECN		0x80	// TCP has ECN set
+	__u8 gso_type;
+	__u16 hdr_len;		/* Ethernet + IP + tcp/udp hdrs */
+	__u16 gso_size;		/* Bytes to append to hdr_len per frame */
+	__u16 csum_start;	/* Position to start checksumming from */
+	__u16 csum_offset;	/* Offset after that to place checksum */
+};
+
+/* This is the version of the header to use when the MRG_RXBUF
+ * feature has been negotiated. */
+struct virtio_net_hdr_mrg_rxbuf {
+	struct virtio_net_hdr hdr;
+	__u16 num_buffers;	/* Number of merged rx buffers */
+};
+
+/*
+ * Control virtqueue data structures
+ *
+ * The control virtqueue expects a header in the first sg entry
+ * and an ack/status response in the last entry.  Data for the
+ * command goes in between.
+ */
+struct virtio_net_ctrl_hdr {
+	__u8 class;
+	__u8 cmd;
+} __attribute__((packed));
+
+typedef __u8 virtio_net_ctrl_ack;
+
+#define VIRTIO_NET_OK     0
+#define VIRTIO_NET_ERR    1
+
+/*
+ * Control the RX mode, ie. promisucous, allmulti, etc...
+ * All commands require an "out" sg entry containing a 1 byte
+ * state value, zero = disable, non-zero = enable.  Commands
+ * 0 and 1 are supported with the VIRTIO_NET_F_CTRL_RX feature.
+ * Commands 2-5 are added with VIRTIO_NET_F_CTRL_RX_EXTRA.
+ */
+#define VIRTIO_NET_CTRL_RX    0
+ #define VIRTIO_NET_CTRL_RX_PROMISC      0
+ #define VIRTIO_NET_CTRL_RX_ALLMULTI     1
+ #define VIRTIO_NET_CTRL_RX_ALLUNI       2
+ #define VIRTIO_NET_CTRL_RX_NOMULTI      3
+ #define VIRTIO_NET_CTRL_RX_NOUNI        4
+ #define VIRTIO_NET_CTRL_RX_NOBCAST      5
+
+/*
+ * Control the MAC filter table.
+ *
+ * The MAC filter table is managed by the hypervisor, the guest should
+ * assume the size is infinite.  Filtering should be considered
+ * non-perfect, ie. based on hypervisor resources, the guest may
+ * received packets from sources not specified in the filter list.
+ *
+ * In addition to the class/cmd header, the TABLE_SET command requires
+ * two out scatterlists.  Each contains a 4 byte count of entries followed
+ * by a concatenated byte stream of the ETH_ALEN MAC addresses.  The
+ * first sg list contains unicast addresses, the second is for multicast.
+ * This functionality is present if the VIRTIO_NET_F_CTRL_RX feature
+ * is available.
+ */
+struct virtio_net_ctrl_mac {
+	__u32 entries;
+	__u8 macs[][ETH_ALEN];
+} __attribute__((packed));
+
+#define VIRTIO_NET_CTRL_MAC    1
+ #define VIRTIO_NET_CTRL_MAC_TABLE_SET        0
+
+/*
+ * Control VLAN filtering
+ *
+ * The VLAN filter table is controlled via a simple ADD/DEL interface.
+ * VLAN IDs not added may be filterd by the hypervisor.  Del is the
+ * opposite of add.  Both commands expect an out entry containing a 2
+ * byte VLAN ID.  VLAN filterting is available with the
+ * VIRTIO_NET_F_CTRL_VLAN feature bit.
+ */
+#define VIRTIO_NET_CTRL_VLAN       2
+ #define VIRTIO_NET_CTRL_VLAN_ADD             0
+ #define VIRTIO_NET_CTRL_VLAN_DEL             1
+
+#endif /* _LINUX_VIRTIO_NET_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_pci.h clean_modified/linux-2.6.32/usr/include/linux/virtio_pci.h
--- linux-2.6.32/usr/include/linux/virtio_pci.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_pci.h	2019-04-14 13:24:03.179890148 -0500
@@ -0,0 +1,72 @@
+/*
+ * Virtio PCI driver
+ *
+ * This module allows virtio devices to be used over a virtual PCI device.
+ * This can be used with QEMU based VMMs like KVM or Xen.
+ *
+ * Copyright IBM Corp. 2007
+ *
+ * Authors:
+ *  Anthony Liguori  <aliguori@us.ibm.com>
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ */
+
+#ifndef _LINUX_VIRTIO_PCI_H
+#define _LINUX_VIRTIO_PCI_H
+
+#include <linux/virtio_config.h>
+
+/* A 32-bit r/o bitmask of the features supported by the host */
+#define VIRTIO_PCI_HOST_FEATURES	0
+
+/* A 32-bit r/w bitmask of features activated by the guest */
+#define VIRTIO_PCI_GUEST_FEATURES	4
+
+/* A 32-bit r/w PFN for the currently selected queue */
+#define VIRTIO_PCI_QUEUE_PFN		8
+
+/* A 16-bit r/o queue size for the currently selected queue */
+#define VIRTIO_PCI_QUEUE_NUM		12
+
+/* A 16-bit r/w queue selector */
+#define VIRTIO_PCI_QUEUE_SEL		14
+
+/* A 16-bit r/w queue notifier */
+#define VIRTIO_PCI_QUEUE_NOTIFY		16
+
+/* An 8-bit device status register.  */
+#define VIRTIO_PCI_STATUS		18
+
+/* An 8-bit r/o interrupt status register.  Reading the value will return the
+ * current contents of the ISR and will also clear it.  This is effectively
+ * a read-and-acknowledge. */
+#define VIRTIO_PCI_ISR			19
+
+/* The bit of the ISR which indicates a device configuration change. */
+#define VIRTIO_PCI_ISR_CONFIG		0x2
+
+/* MSI-X registers: only enabled if MSI-X is enabled. */
+/* A 16-bit vector for configuration changes. */
+#define VIRTIO_MSI_CONFIG_VECTOR        20
+/* A 16-bit vector for selected queue notifications. */
+#define VIRTIO_MSI_QUEUE_VECTOR         22
+/* Vector value used to disable MSI for queue */
+#define VIRTIO_MSI_NO_VECTOR            0xffff
+
+/* The remaining space is defined by each driver as the per-driver
+ * configuration space */
+#define VIRTIO_PCI_CONFIG(dev)		((dev)->msix_enabled ? 24 : 20)
+
+/* Virtio ABI version, this must match exactly */
+#define VIRTIO_PCI_ABI_VERSION		0
+
+/* How many bits to shift physical queue address written to QUEUE_PFN.
+ * 12 is historical, and due to x86 page size. */
+#define VIRTIO_PCI_QUEUE_ADDR_SHIFT	12
+
+/* The alignment to use between consumer and producer parts of vring.
+ * x86 pagesize again. */
+#define VIRTIO_PCI_VRING_ALIGN		4096
+#endif
diff -uNr linux-2.6.32/usr/include/linux/virtio_ring.h clean_modified/linux-2.6.32/usr/include/linux/virtio_ring.h
--- linux-2.6.32/usr/include/linux/virtio_ring.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_ring.h	2019-04-14 13:24:03.179890148 -0500
@@ -0,0 +1,113 @@
+#ifndef _LINUX_VIRTIO_RING_H
+#define _LINUX_VIRTIO_RING_H
+/* An interface for efficient virtio implementation, currently for use by KVM
+ * and lguest, but hopefully others soon.  Do NOT change this since it will
+ * break existing servers and clients.
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Copyright Rusty Russell IBM Corporation 2007. */
+#include <linux/types.h>
+
+/* This marks a buffer as continuing via the next field. */
+#define VRING_DESC_F_NEXT	1
+/* This marks a buffer as write-only (otherwise read-only). */
+#define VRING_DESC_F_WRITE	2
+/* This means the buffer contains a list of buffer descriptors. */
+#define VRING_DESC_F_INDIRECT	4
+
+/* The Host uses this in used->flags to advise the Guest: don't kick me when
+ * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
+ * will still kick if it's out of buffers. */
+#define VRING_USED_F_NO_NOTIFY	1
+/* The Guest uses this in avail->flags to advise the Host: don't interrupt me
+ * when you consume a buffer.  It's unreliable, so it's simply an
+ * optimization.  */
+#define VRING_AVAIL_F_NO_INTERRUPT	1
+
+/* We support indirect buffer descriptors */
+#define VIRTIO_RING_F_INDIRECT_DESC	28
+
+/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
+struct vring_desc {
+	/* Address (guest-physical). */
+	__u64 addr;
+	/* Length. */
+	__u32 len;
+	/* The flags as indicated above. */
+	__u16 flags;
+	/* We chain unused descriptors via this, too */
+	__u16 next;
+};
+
+struct vring_avail {
+	__u16 flags;
+	__u16 idx;
+	__u16 ring[];
+};
+
+/* u32 is used here for ids for padding reasons. */
+struct vring_used_elem {
+	/* Index of start of used descriptor chain. */
+	__u32 id;
+	/* Total length of the descriptor chain which was used (written to) */
+	__u32 len;
+};
+
+struct vring_used {
+	__u16 flags;
+	__u16 idx;
+	struct vring_used_elem ring[];
+};
+
+struct vring {
+	unsigned int num;
+
+	struct vring_desc *desc;
+
+	struct vring_avail *avail;
+
+	struct vring_used *used;
+};
+
+/* The standard layout for the ring is a continuous chunk of memory which looks
+ * like this.  We assume num is a power of 2.
+ *
+ * struct vring
+ * {
+ *	// The actual descriptors (16 bytes each)
+ *	struct vring_desc desc[num];
+ *
+ *	// A ring of available descriptor heads with free-running index.
+ *	__u16 avail_flags;
+ *	__u16 avail_idx;
+ *	__u16 available[num];
+ *
+ *	// Padding to the next align boundary.
+ *	char pad[];
+ *
+ *	// A ring of used descriptor heads with free-running index.
+ *	__u16 used_flags;
+ *	__u16 used_idx;
+ *	struct vring_used_elem used[num];
+ * };
+ */
+static __inline__ void vring_init(struct vring *vr, unsigned int num, void *p,
+			      unsigned long align)
+{
+	vr->num = num;
+	vr->desc = p;
+	vr->avail = p + num*sizeof(struct vring_desc);
+	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + align-1)
+			    & ~(align - 1));
+}
+
+static __inline__ unsigned vring_size(unsigned int num, unsigned long align)
+{
+	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (2 + num)
+		 + align - 1) & ~(align - 1))
+		+ sizeof(__u16) * 2 + sizeof(struct vring_used_elem) * num;
+}
+
+#endif /* _LINUX_VIRTIO_RING_H */
diff -uNr linux-2.6.32/usr/include/linux/virtio_rng.h clean_modified/linux-2.6.32/usr/include/linux/virtio_rng.h
--- linux-2.6.32/usr/include/linux/virtio_rng.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/virtio_rng.h	2019-04-14 13:24:03.179890148 -0500
@@ -0,0 +1,8 @@
+#ifndef _LINUX_VIRTIO_RNG_H
+#define _LINUX_VIRTIO_RNG_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+
+#endif /* _LINUX_VIRTIO_RNG_H */
diff -uNr linux-2.6.32/usr/include/linux/vt.h clean_modified/linux-2.6.32/usr/include/linux/vt.h
--- linux-2.6.32/usr/include/linux/vt.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/vt.h	2019-04-14 13:24:03.181197926 -0500
@@ -0,0 +1,87 @@
+#ifndef _LINUX_VT_H
+#define _LINUX_VT_H
+
+
+/*
+ * These constants are also useful for user-level apps (e.g., VC
+ * resizing).
+ */
+#define MIN_NR_CONSOLES 1       /* must be at least 1 */
+#define MAX_NR_CONSOLES	63	/* serial lines start at 64 */
+#define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */
+		/* Note: the ioctl VT_GETSTATE does not work for
+		   consoles 16 and higher (since it returns a short) */
+
+/* 0x56 is 'V', to avoid collision with termios and kd */
+
+#define VT_OPENQRY	0x5600	/* find available vt */
+
+struct vt_mode {
+	char mode;		/* vt mode */
+	char waitv;		/* if set, hang on writes if not active */
+	short relsig;		/* signal to raise on release req */
+	short acqsig;		/* signal to raise on acquisition */
+	short frsig;		/* unused (set to 0) */
+};
+#define VT_GETMODE	0x5601	/* get mode of active vt */
+#define VT_SETMODE	0x5602	/* set mode of active vt */
+#define		VT_AUTO		0x00	/* auto vt switching */
+#define		VT_PROCESS	0x01	/* process controls switching */
+#define		VT_ACKACQ	0x02	/* acknowledge switch */
+
+struct vt_stat {
+	unsigned short v_active;	/* active vt */
+	unsigned short v_signal;	/* signal to send */
+	unsigned short v_state;		/* vt bitmask */
+};
+#define VT_GETSTATE	0x5603	/* get global vt state info */
+#define VT_SENDSIG	0x5604	/* signal to send to bitmask of vts */
+
+#define VT_RELDISP	0x5605	/* release display */
+
+#define VT_ACTIVATE	0x5606	/* make vt active */
+#define VT_WAITACTIVE	0x5607	/* wait for vt active */
+#define VT_DISALLOCATE	0x5608  /* free memory associated to vt */
+
+struct vt_sizes {
+	unsigned short v_rows;		/* number of rows */
+	unsigned short v_cols;		/* number of columns */
+	unsigned short v_scrollsize;	/* number of lines of scrollback */
+};
+#define VT_RESIZE	0x5609	/* set kernel's idea of screensize */
+
+struct vt_consize {
+	unsigned short v_rows;	/* number of rows */
+	unsigned short v_cols;	/* number of columns */
+	unsigned short v_vlin;	/* number of pixel rows on screen */
+	unsigned short v_clin;	/* number of pixel rows per character */
+	unsigned short v_vcol;	/* number of pixel columns on screen */
+	unsigned short v_ccol;	/* number of pixel columns per character */
+};
+#define VT_RESIZEX      0x560A  /* set kernel's idea of screensize + more */
+#define VT_LOCKSWITCH   0x560B  /* disallow vt switching */
+#define VT_UNLOCKSWITCH 0x560C  /* allow vt switching */
+#define VT_GETHIFONTMASK 0x560D  /* return hi font mask */
+
+struct vt_event {
+	unsigned int event;
+#define VT_EVENT_SWITCH		0x0001	/* Console switch */
+#define VT_EVENT_BLANK		0x0002	/* Screen blank */
+#define VT_EVENT_UNBLANK	0x0004	/* Screen unblank */
+#define VT_EVENT_RESIZE		0x0008	/* Resize display */
+#define VT_MAX_EVENT		0x000F
+	unsigned int oldev;		/* Old console */
+	unsigned int newev;		/* New console (if changing) */
+	unsigned int pad[4];		/* Padding for expansion */
+};
+
+#define VT_WAITEVENT	0x560E	/* Wait for an event */
+
+struct vt_setactivate {
+	unsigned int console;
+	struct vt_mode mode;
+};
+
+#define VT_SETACTIVATE	0x560F	/* Activate and set the mode of a console */
+
+#endif /* _LINUX_VT_H */
diff -uNr linux-2.6.32/usr/include/linux/wait.h clean_modified/linux-2.6.32/usr/include/linux/wait.h
--- linux-2.6.32/usr/include/linux/wait.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/wait.h	2019-04-14 13:24:03.181197926 -0500
@@ -0,0 +1,21 @@
+#ifndef _LINUX_WAIT_H
+#define _LINUX_WAIT_H
+
+#define WNOHANG		0x00000001
+#define WUNTRACED	0x00000002
+#define WSTOPPED	WUNTRACED
+#define WEXITED		0x00000004
+#define WCONTINUED	0x00000008
+#define WNOWAIT		0x01000000	/* Don't reap, just poll status.  */
+
+#define __WNOTHREAD	0x20000000	/* Don't wait on children of other threads in this group */
+#define __WALL		0x40000000	/* Wait on all children, regardless of type */
+#define __WCLONE	0x80000000	/* Wait only on non-SIGCHLD children */
+
+/* First argument to waitid: */
+#define P_ALL		0
+#define P_PID		1
+#define P_PGID		2
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/wanrouter.h clean_modified/linux-2.6.32/usr/include/linux/wanrouter.h
--- linux-2.6.32/usr/include/linux/wanrouter.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/wanrouter.h	2019-04-14 13:24:03.182170961 -0500
@@ -0,0 +1,452 @@
+/*****************************************************************************
+* wanrouter.h	Definitions for the WAN Multiprotocol Router Module.
+*		This module provides API and common services for WAN Link
+*		Drivers and is completely hardware-independent.
+*
+* Author: 	Nenad Corbic <ncorbic@sangoma.com>
+*		Gideon Hack 	
+* Additions:	Arnaldo Melo
+*
+* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
+*
+*		This program is free software; you can redistribute it and/or
+*		modify it under the terms of the GNU General Public License
+*		as published by the Free Software Foundation; either version
+*		2 of the License, or (at your option) any later version.
+* ============================================================================
+* Jul 21, 2000  Nenad Corbic	Added WAN_FT1_READY State
+* Feb 24, 2000  Nenad Corbic    Added support for socket based x25api
+* Jan 28, 2000  Nenad Corbic    Added support for the ASYNC protocol.
+* Oct 04, 1999  Nenad Corbic 	Updated for 2.1.0 release
+* Jun 02, 1999  Gideon Hack	Added support for the S514 adapter.
+* May 23, 1999	Arnaldo Melo	Added local_addr to wanif_conf_t
+*				WAN_DISCONNECTING state added
+* Jul 20, 1998	David Fong	Added Inverse ARP options to 'wanif_conf_t'
+* Jun 12, 1998	David Fong	Added Cisco HDLC support.
+* Dec 16, 1997	Jaspreet Singh	Moved 'enable_IPX' and 'network_number' to
+*				'wanif_conf_t'
+* Dec 05, 1997	Jaspreet Singh	Added 'pap', 'chap' to 'wanif_conf_t'
+*				Added 'authenticator' to 'wan_ppp_conf_t'
+* Nov 06, 1997	Jaspreet Singh	Changed Router Driver version to 1.1 from 1.0
+* Oct 20, 1997	Jaspreet Singh	Added 'cir','bc','be' and 'mc' to 'wanif_conf_t'
+*				Added 'enable_IPX' and 'network_number' to 
+*				'wan_device_t'.  Also added defines for
+*				UDP PACKET TYPE, Interrupt test, critical values
+*				for RACE conditions.
+* Oct 05, 1997	Jaspreet Singh	Added 'dlci_num' and 'dlci[100]' to 
+*				'wan_fr_conf_t' to configure a list of dlci(s)
+*				for a NODE 
+* Jul 07, 1997	Jaspreet Singh	Added 'ttl' to 'wandev_conf_t' & 'wan_device_t'
+* May 29, 1997 	Jaspreet Singh	Added 'tx_int_enabled' to 'wan_device_t'
+* May 21, 1997	Jaspreet Singh	Added 'udp_port' to 'wan_device_t'
+* Apr 25, 1997  Farhan Thawar   Added 'udp_port' to 'wandev_conf_t'
+* Jan 16, 1997	Gene Kozin	router_devlist made public
+* Jan 02, 1997	Gene Kozin	Initial version (based on wanpipe.h).
+*****************************************************************************/
+
+#ifndef	_ROUTER_H
+#define	_ROUTER_H
+
+#define	ROUTER_NAME	"wanrouter"	/* in case we ever change it */
+#define	ROUTER_VERSION	1		/* version number */
+#define	ROUTER_RELEASE	1		/* release (minor version) number */
+#define	ROUTER_IOCTL	'W'		/* for IOCTL calls */
+#define	ROUTER_MAGIC	0x524D4157L	/* signature: 'WANR' reversed */
+
+/* IOCTL codes for /proc/router/<device> entries (up to 255) */
+enum router_ioctls
+{
+	ROUTER_SETUP	= ROUTER_IOCTL<<8,	/* configure device */
+	ROUTER_DOWN,				/* shut down device */
+	ROUTER_STAT,				/* get device status */
+	ROUTER_IFNEW,				/* add interface */
+	ROUTER_IFDEL,				/* delete interface */
+	ROUTER_IFSTAT,				/* get interface status */
+	ROUTER_USER	= (ROUTER_IOCTL<<8)+16,	/* driver-specific calls */
+	ROUTER_USER_MAX	= (ROUTER_IOCTL<<8)+31
+};
+
+/* identifiers for displaying proc file data for dual port adapters */
+#define PROC_DATA_PORT_0 0x8000	/* the data is for port 0 */
+#define PROC_DATA_PORT_1 0x8001	/* the data is for port 1 */
+
+/* NLPID for packet encapsulation (ISO/IEC TR 9577) */
+#define	NLPID_IP	0xCC	/* Internet Protocol Datagram */
+#define	NLPID_SNAP	0x80	/* IEEE Subnetwork Access Protocol */
+#define	NLPID_CLNP	0x81	/* ISO/IEC 8473 */
+#define	NLPID_ESIS	0x82	/* ISO/IEC 9542 */
+#define	NLPID_ISIS	0x83	/* ISO/IEC ISIS */
+#define	NLPID_Q933	0x08	/* CCITT Q.933 */
+
+/* Miscellaneous */
+#define	WAN_IFNAME_SZ	15	/* max length of the interface name */
+#define	WAN_DRVNAME_SZ	15	/* max length of the link driver name */
+#define	WAN_ADDRESS_SZ	31	/* max length of the WAN media address */
+#define USED_BY_FIELD	8	/* max length of the used by field */
+
+/* Defines for UDP PACKET TYPE */
+#define UDP_PTPIPE_TYPE 	0x01
+#define UDP_FPIPE_TYPE		0x02
+#define UDP_CPIPE_TYPE		0x03
+#define UDP_DRVSTATS_TYPE 	0x04
+#define UDP_INVALID_TYPE  	0x05
+
+/* Command return code */
+#define CMD_OK		0		/* normal firmware return code */
+#define CMD_TIMEOUT	0xFF		/* firmware command timed out */
+
+/* UDP Packet Management */
+#define UDP_PKT_FRM_STACK	0x00
+#define UDP_PKT_FRM_NETWORK	0x01
+
+/* Maximum interrupt test counter */
+#define MAX_INTR_TEST_COUNTER	100
+
+/* Critical Values for RACE conditions*/
+#define CRITICAL_IN_ISR		0xA1
+#define CRITICAL_INTR_HANDLED	0xB1
+
+/****** Data Types **********************************************************/
+
+/*----------------------------------------------------------------------------
+ * X.25-specific link-level configuration.
+ */
+typedef struct wan_x25_conf
+{
+	unsigned lo_pvc;	/* lowest permanent circuit number */
+	unsigned hi_pvc;	/* highest permanent circuit number */
+	unsigned lo_svc;	/* lowest switched circuit number */
+	unsigned hi_svc;	/* highest switched circuit number */
+	unsigned hdlc_window;	/* HDLC window size (1..7) */
+	unsigned pkt_window;	/* X.25 packet window size (1..7) */
+	unsigned t1;		/* HDLC timer T1, sec (1..30) */
+	unsigned t2;		/* HDLC timer T2, sec (0..29) */
+	unsigned t4;		/* HDLC supervisory frame timer = T4 * T1 */
+	unsigned n2;		/* HDLC retransmission limit (1..30) */
+	unsigned t10_t20;	/* X.25 RESTART timeout, sec (1..255) */
+	unsigned t11_t21;	/* X.25 CALL timeout, sec (1..255) */
+	unsigned t12_t22;	/* X.25 RESET timeout, sec (1..255) */
+	unsigned t13_t23;	/* X.25 CLEAR timeout, sec (1..255) */
+	unsigned t16_t26;	/* X.25 INTERRUPT timeout, sec (1..255) */
+	unsigned t28;		/* X.25 REGISTRATION timeout, sec (1..255) */
+	unsigned r10_r20;	/* RESTART retransmission limit (0..250) */
+	unsigned r12_r22;	/* RESET retransmission limit (0..250) */
+	unsigned r13_r23;	/* CLEAR retransmission limit (0..250) */
+	unsigned ccitt_compat;	/* compatibility mode: 1988/1984/1980 */
+	unsigned x25_conf_opt;   /* User defined x25 config optoins */
+	unsigned char LAPB_hdlc_only; /* Run in HDLC only mode */
+	unsigned char logging;   /* Control connection logging */  
+	unsigned char oob_on_modem; /* Whether to send modem status to the user app */
+} wan_x25_conf_t;
+
+/*----------------------------------------------------------------------------
+ * Frame relay specific link-level configuration.
+ */
+typedef struct wan_fr_conf
+{
+	unsigned signalling;	/* local in-channel signalling type */
+	unsigned t391;		/* link integrity verification timer */
+	unsigned t392;		/* polling verification timer */
+	unsigned n391;		/* full status polling cycle counter */
+	unsigned n392;		/* error threshold counter */
+	unsigned n393;		/* monitored events counter */
+	unsigned dlci_num;	/* number of DLCs (access node) */
+	unsigned  dlci[100];    /* List of all DLCIs */
+} wan_fr_conf_t;
+
+/*----------------------------------------------------------------------------
+ * PPP-specific link-level configuration.
+ */
+typedef struct wan_ppp_conf
+{
+	unsigned restart_tmr;	/* restart timer */
+	unsigned auth_rsrt_tmr;	/* authentication timer */
+	unsigned auth_wait_tmr;	/* authentication timer */
+	unsigned mdm_fail_tmr;	/* modem failure timer */
+	unsigned dtr_drop_tmr;	/* DTR drop timer */
+	unsigned connect_tmout;	/* connection timeout */
+	unsigned conf_retry;	/* max. retry */
+	unsigned term_retry;	/* max. retry */
+	unsigned fail_retry;	/* max. retry */
+	unsigned auth_retry;	/* max. retry */
+	unsigned auth_options;	/* authentication opt. */
+	unsigned ip_options;	/* IP options */
+	char	authenticator;	/* AUTHENTICATOR or not */
+	char	ip_mode;	/* Static/Host/Peer */
+} wan_ppp_conf_t;
+
+/*----------------------------------------------------------------------------
+ * CHDLC-specific link-level configuration.
+ */
+typedef struct wan_chdlc_conf
+{
+	unsigned char ignore_dcd;	/* Protocol options:		*/
+	unsigned char ignore_cts;	/*  Ignore these to determine	*/
+	unsigned char ignore_keepalive;	/*  link status (Yes or No)	*/
+	unsigned char hdlc_streaming;	/*  hdlc_streaming mode (Y/N) */
+	unsigned char receive_only;	/*  no transmit buffering (Y/N) */
+	unsigned keepalive_tx_tmr;	/* transmit keepalive timer */
+	unsigned keepalive_rx_tmr;	/* receive  keepalive timer */
+	unsigned keepalive_err_margin;	/* keepalive_error_tolerance */
+	unsigned slarp_timer;		/* SLARP request timer */
+} wan_chdlc_conf_t;
+
+
+/*----------------------------------------------------------------------------
+ * WAN device configuration. Passed to ROUTER_SETUP IOCTL.
+ */
+typedef struct wandev_conf
+{
+	unsigned magic;		/* magic number (for verification) */
+	unsigned config_id;	/* configuration structure identifier */
+				/****** hardware configuration ******/
+	unsigned ioport;	/* adapter I/O port base */
+	unsigned long maddr;	/* dual-port memory address */
+	unsigned msize;		/* dual-port memory size */
+	int irq;		/* interrupt request level */
+	int dma;		/* DMA request level */
+        char S514_CPU_no[1];	/* S514 PCI adapter CPU number ('A' or 'B') */
+        unsigned PCI_slot_no;	/* S514 PCI adapter slot number */
+	char auto_pci_cfg;	/* S515 PCI automatic slot detection */
+	char comm_port;		/* Communication Port (PRI=0, SEC=1) */ 
+	unsigned bps;		/* data transfer rate */
+	unsigned mtu;		/* maximum transmit unit size */
+        unsigned udp_port;      /* UDP port for management */
+	unsigned char ttl;	/* Time To Live for UDP security */
+	unsigned char ft1;	/* FT1 Configurator Option */
+        char interface;		/* RS-232/V.35, etc. */
+	char clocking;		/* external/internal */
+	char line_coding;	/* NRZ/NRZI/FM0/FM1, etc. */
+	char station;		/* DTE/DCE, primary/secondary, etc. */
+	char connection;	/* permanent/switched/on-demand */
+	char read_mode;		/* read mode: Polling or interrupt */
+	char receive_only;	/* disable tx buffers */
+	char tty;		/* Create a fake tty device */
+	unsigned tty_major;	/* Major number for wanpipe tty device */
+	unsigned tty_minor; 	/* Minor number for wanpipe tty device */
+	unsigned tty_mode;	/* TTY operation mode SYNC or ASYNC */
+	char backup;		/* Backup Mode */
+	unsigned hw_opt[4];	/* other hardware options */
+	unsigned reserved[4];
+				/****** arbitrary data ***************/
+	unsigned data_size;	/* data buffer size */
+	void* data;		/* data buffer, e.g. firmware */
+	union			/****** protocol-specific ************/
+	{
+		wan_x25_conf_t x25;	/* X.25 configuration */
+		wan_ppp_conf_t ppp;	/* PPP configuration */
+		wan_fr_conf_t fr;	/* frame relay configuration */
+		wan_chdlc_conf_t chdlc;	/* Cisco HDLC configuration */
+	} u;
+} wandev_conf_t;
+
+/* 'config_id' definitions */
+#define	WANCONFIG_X25	101	/* X.25 link */
+#define	WANCONFIG_FR	102	/* frame relay link */
+#define	WANCONFIG_PPP	103	/* synchronous PPP link */
+#define WANCONFIG_CHDLC	104	/* Cisco HDLC Link */
+#define WANCONFIG_BSC	105	/* BiSync Streaming */
+#define WANCONFIG_HDLC	106	/* HDLC Support */
+#define WANCONFIG_MPPP  107	/* Multi Port PPP over RAW CHDLC */
+
+/*
+ * Configuration options defines.
+ */
+/* general options */
+#define	WANOPT_OFF	0
+#define	WANOPT_ON	1
+#define	WANOPT_NO	0
+#define	WANOPT_YES	1
+
+/* intercace options */
+#define	WANOPT_RS232	0
+#define	WANOPT_V35	1
+
+/* data encoding options */
+#define	WANOPT_NRZ	0
+#define	WANOPT_NRZI	1
+#define	WANOPT_FM0	2
+#define	WANOPT_FM1	3
+
+/* link type options */
+#define	WANOPT_POINTTOPOINT	0	/* RTS always active */
+#define	WANOPT_MULTIDROP	1	/* RTS is active when transmitting */
+
+/* clocking options */
+#define	WANOPT_EXTERNAL	0
+#define	WANOPT_INTERNAL	1
+
+/* station options */
+#define	WANOPT_DTE		0
+#define	WANOPT_DCE		1
+#define	WANOPT_CPE		0
+#define	WANOPT_NODE		1
+#define	WANOPT_SECONDARY	0
+#define	WANOPT_PRIMARY		1
+
+/* connection options */
+#define	WANOPT_PERMANENT	0	/* DTR always active */
+#define	WANOPT_SWITCHED		1	/* use DTR to setup link (dial-up) */
+#define	WANOPT_ONDEMAND		2	/* activate DTR only before sending */
+
+/* frame relay in-channel signalling */
+#define	WANOPT_FR_ANSI		1	/* ANSI T1.617 Annex D */
+#define	WANOPT_FR_Q933		2	/* ITU Q.933A */
+#define	WANOPT_FR_LMI		3	/* LMI */
+
+/* PPP IP Mode Options */
+#define	WANOPT_PPP_STATIC	0
+#define	WANOPT_PPP_HOST		1
+#define	WANOPT_PPP_PEER		2
+
+/* ASY Mode Options */
+#define WANOPT_ONE 		1
+#define WANOPT_TWO		2
+#define WANOPT_ONE_AND_HALF	3
+
+#define WANOPT_NONE	0
+#define WANOPT_ODD      1
+#define WANOPT_EVEN	2
+
+/* CHDLC Protocol Options */
+/* DF Commmented out for now.
+
+#define WANOPT_CHDLC_NO_DCD		IGNORE_DCD_FOR_LINK_STAT
+#define WANOPT_CHDLC_NO_CTS		IGNORE_CTS_FOR_LINK_STAT
+#define WANOPT_CHDLC_NO_KEEPALIVE	IGNORE_KPALV_FOR_LINK_STAT
+*/
+
+/* Port options */
+#define WANOPT_PRI 0
+#define WANOPT_SEC 1
+/* read mode */
+#define	WANOPT_INTR	0
+#define WANOPT_POLL	1
+
+
+#define WANOPT_TTY_SYNC  0
+#define WANOPT_TTY_ASYNC 1
+/*----------------------------------------------------------------------------
+ * WAN Link Status Info (for ROUTER_STAT IOCTL).
+ */
+typedef struct wandev_stat
+{
+	unsigned state;		/* link state */
+	unsigned ndev;		/* number of configured interfaces */
+
+	/* link/interface configuration */
+	unsigned connection;	/* permanent/switched/on-demand */
+	unsigned media_type;	/* Frame relay/PPP/X.25/SDLC, etc. */
+	unsigned mtu;		/* max. transmit unit for this device */
+
+	/* physical level statistics */
+	unsigned modem_status;	/* modem status */
+	unsigned rx_frames;	/* received frames count */
+	unsigned rx_overruns;	/* receiver overrun error count */
+	unsigned rx_crc_err;	/* receive CRC error count */
+	unsigned rx_aborts;	/* received aborted frames count */
+	unsigned rx_bad_length;	/* unexpetedly long/short frames count */
+	unsigned rx_dropped;	/* frames discarded at device level */
+	unsigned tx_frames;	/* transmitted frames count */
+	unsigned tx_underruns;	/* aborted transmissions (underruns) count */
+	unsigned tx_timeouts;	/* transmission timeouts */
+	unsigned tx_rejects;	/* other transmit errors */
+
+	/* media level statistics */
+	unsigned rx_bad_format;	/* frames with invalid format */
+	unsigned rx_bad_addr;	/* frames with invalid media address */
+	unsigned tx_retries;	/* frames re-transmitted */
+	unsigned reserved[16];	/* reserved for future use */
+} wandev_stat_t;
+
+/* 'state' defines */
+enum wan_states
+{
+	WAN_UNCONFIGURED,	/* link/channel is not configured */
+	WAN_DISCONNECTED,	/* link/channel is disconnected */
+	WAN_CONNECTING,		/* connection is in progress */
+	WAN_CONNECTED,		/* link/channel is operational */
+	WAN_LIMIT,		/* for verification only */
+	WAN_DUALPORT,		/* for Dual Port cards */
+	WAN_DISCONNECTING,
+	WAN_FT1_READY		/* FT1 Configurator Ready */
+};
+
+enum {
+	WAN_LOCAL_IP,
+	WAN_POINTOPOINT_IP,
+	WAN_NETMASK_IP,
+	WAN_BROADCAST_IP
+};
+
+/* 'modem_status' masks */
+#define	WAN_MODEM_CTS	0x0001	/* CTS line active */
+#define	WAN_MODEM_DCD	0x0002	/* DCD line active */
+#define	WAN_MODEM_DTR	0x0010	/* DTR line active */
+#define	WAN_MODEM_RTS	0x0020	/* RTS line active */
+
+/*----------------------------------------------------------------------------
+ * WAN interface (logical channel) configuration (for ROUTER_IFNEW IOCTL).
+ */
+typedef struct wanif_conf
+{
+	unsigned magic;			/* magic number */
+	unsigned config_id;		/* configuration identifier */
+	char name[WAN_IFNAME_SZ+1];	/* interface name, ASCIIZ */
+	char addr[WAN_ADDRESS_SZ+1];	/* media address, ASCIIZ */
+	char usedby[USED_BY_FIELD];	/* used by API or WANPIPE */
+	unsigned idle_timeout;		/* sec, before disconnecting */
+	unsigned hold_timeout;		/* sec, before re-connecting */
+	unsigned cir;			/* Committed Information Rate fwd,bwd*/
+	unsigned bc;			/* Committed Burst Size fwd, bwd */
+	unsigned be;			/* Excess Burst Size fwd, bwd */ 
+	unsigned char enable_IPX;	/* Enable or Disable IPX */
+	unsigned char inarp;		/* Send Inverse ARP requests Y/N */
+	unsigned inarp_interval;	/* sec, between InARP requests */
+	unsigned long network_number;	/* Network Number for IPX */
+	char mc;			/* Multicast on or off */
+	char local_addr[WAN_ADDRESS_SZ+1];/* local media address, ASCIIZ */
+	unsigned char port;		/* board port */
+	unsigned char protocol;		/* prococol used in this channel (TCPOX25 or X25) */
+	char pap;			/* PAP enabled or disabled */
+	char chap;			/* CHAP enabled or disabled */
+	unsigned char userid[511];	/* List of User Id */
+	unsigned char passwd[511];	/* List of passwords */
+	unsigned char sysname[31];	/* Name of the system */
+	unsigned char ignore_dcd;	/* Protocol options: */
+	unsigned char ignore_cts;	/*  Ignore these to determine */
+	unsigned char ignore_keepalive;	/*  link status (Yes or No) */
+	unsigned char hdlc_streaming;	/*  Hdlc streaming mode (Y/N) */
+	unsigned keepalive_tx_tmr;	/* transmit keepalive timer */
+	unsigned keepalive_rx_tmr;	/* receive  keepalive timer */
+	unsigned keepalive_err_margin;	/* keepalive_error_tolerance */
+	unsigned slarp_timer;		/* SLARP request timer */
+	unsigned char ttl;		/* Time To Live for UDP security */
+	char interface;			/* RS-232/V.35, etc. */
+	char clocking;			/* external/internal */
+	unsigned bps;			/* data transfer rate */
+	unsigned mtu;			/* maximum transmit unit size */
+	unsigned char if_down;		/* brind down interface when disconnected */
+	unsigned char gateway;		/* Is this interface a gateway */
+	unsigned char true_if_encoding;	/* Set the dev->type to true board protocol */
+
+	unsigned char asy_data_trans;     /* async API options */
+        unsigned char rts_hs_for_receive; /* async Protocol options */
+        unsigned char xon_xoff_hs_for_receive;
+	unsigned char xon_xoff_hs_for_transmit;
+	unsigned char dcd_hs_for_transmit;
+	unsigned char cts_hs_for_transmit;
+	unsigned char async_mode;
+	unsigned tx_bits_per_char;
+	unsigned rx_bits_per_char;
+	unsigned stop_bits;  
+	unsigned char parity;
+ 	unsigned break_timer;
+        unsigned inter_char_timer;
+	unsigned rx_complete_length;
+	unsigned xon_char;
+	unsigned xoff_char;
+	unsigned char receive_only;	/*  no transmit buffering (Y/N) */
+} wanif_conf_t;
+
+#endif	/* _ROUTER_H */
diff -uNr linux-2.6.32/usr/include/linux/watchdog.h clean_modified/linux-2.6.32/usr/include/linux/watchdog.h
--- linux-2.6.32/usr/include/linux/watchdog.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/watchdog.h	2019-04-14 13:24:03.182170961 -0500
@@ -0,0 +1,55 @@
+/*
+ *	Generic watchdog defines. Derived from..
+ *
+ * Berkshire PC Watchdog Defines
+ * by Ken Hollis <khollis@bitgate.com>
+ *
+ */
+
+#ifndef _LINUX_WATCHDOG_H
+#define _LINUX_WATCHDOG_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define	WATCHDOG_IOCTL_BASE	'W'
+
+struct watchdog_info {
+	__u32 options;		/* Options the card/driver supports */
+	__u32 firmware_version;	/* Firmware version of the card */
+	__u8  identity[32];	/* Identity of the board */
+};
+
+#define	WDIOC_GETSUPPORT	_IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
+#define	WDIOC_GETSTATUS		_IOR(WATCHDOG_IOCTL_BASE, 1, int)
+#define	WDIOC_GETBOOTSTATUS	_IOR(WATCHDOG_IOCTL_BASE, 2, int)
+#define	WDIOC_GETTEMP		_IOR(WATCHDOG_IOCTL_BASE, 3, int)
+#define	WDIOC_SETOPTIONS	_IOR(WATCHDOG_IOCTL_BASE, 4, int)
+#define	WDIOC_KEEPALIVE		_IOR(WATCHDOG_IOCTL_BASE, 5, int)
+#define	WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
+#define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
+#define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)
+#define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)
+#define	WDIOC_GETTIMELEFT	_IOR(WATCHDOG_IOCTL_BASE, 10, int)
+
+#define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
+#define	WDIOS_UNKNOWN		-1	/* Unknown status error */
+
+#define	WDIOF_OVERHEAT		0x0001	/* Reset due to CPU overheat */
+#define	WDIOF_FANFAULT		0x0002	/* Fan failed */
+#define	WDIOF_EXTERN1		0x0004	/* External relay 1 */
+#define	WDIOF_EXTERN2		0x0008	/* External relay 2 */
+#define	WDIOF_POWERUNDER	0x0010	/* Power bad/power fault */
+#define	WDIOF_CARDRESET		0x0020	/* Card previously reset the CPU */
+#define	WDIOF_POWEROVER		0x0040	/* Power over voltage */
+#define	WDIOF_SETTIMEOUT	0x0080  /* Set timeout (in seconds) */
+#define	WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
+#define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
+#define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
+
+#define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */
+#define	WDIOS_ENABLECARD	0x0002	/* Turn on the watchdog timer */
+#define	WDIOS_TEMPPANIC		0x0004	/* Kernel panic on temperature trip */
+
+
+#endif  /* ifndef _LINUX_WATCHDOG_H */
diff -uNr linux-2.6.32/usr/include/linux/wimax/i2400m.h clean_modified/linux-2.6.32/usr/include/linux/wimax/i2400m.h
--- linux-2.6.32/usr/include/linux/wimax/i2400m.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/wimax/i2400m.h	2019-04-14 13:24:03.184122726 -0500
@@ -0,0 +1,581 @@
+/*
+ * Intel Wireless WiMax Connection 2400m
+ * Host-Device protocol interface definitions
+ *
+ *
+ * Copyright (C) 2007-2008 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * Intel Corporation <linux-wimax@intel.com>
+ * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
+ *  - Initial implementation
+ *
+ *
+ * This header defines the data structures and constants used to
+ * communicate with the device.
+ *
+ * BOOTMODE/BOOTROM/FIRMWARE UPLOAD PROTOCOL
+ *
+ * The firmware upload protocol is quite simple and only requires a
+ * handful of commands. See drivers/net/wimax/i2400m/fw.c for more
+ * details.
+ *
+ * The BCF data structure is for the firmware file header.
+ *
+ *
+ * THE DATA / CONTROL PROTOCOL
+ *
+ * This is the normal protocol spoken with the device once the
+ * firmware is uploaded. It transports data payloads and control
+ * messages back and forth.
+ *
+ * It consists 'messages' that pack one or more payloads each. The
+ * format is described in detail in drivers/net/wimax/i2400m/rx.c and
+ * tx.c.
+ *
+ *
+ * THE L3L4 PROTOCOL
+ *
+ * The term L3L4 refers to Layer 3 (the device), Layer 4 (the
+ * driver/host software).
+ *
+ * This is the control protocol used by the host to control the i2400m
+ * device (scan, connect, disconnect...). This is sent to / received
+ * as control frames. These frames consist of a header and zero or
+ * more TLVs with information. We call each control frame a "message".
+ *
+ * Each message is composed of:
+ *
+ * HEADER
+ * [TLV0 + PAYLOAD0]
+ * [TLV1 + PAYLOAD1]
+ * [...]
+ * [TLVN + PAYLOADN]
+ *
+ * The HEADER is defined by 'struct i2400m_l3l4_hdr'. The payloads are
+ * defined by a TLV structure (Type Length Value) which is a 'header'
+ * (struct i2400m_tlv_hdr) and then the payload.
+ *
+ * All integers are represented as Little Endian.
+ *
+ * - REQUESTS AND EVENTS
+ *
+ * The requests can be clasified as follows:
+ *
+ *   COMMAND:  implies a request from the host to the device requesting
+ *             an action being performed. The device will reply with a
+ *             message (with the same type as the command), status and
+ *             no (TLV) payload. Execution of a command might cause
+ *             events (of different type) to be sent later on as
+ *             device's state changes.
+ *
+ *   GET/SET:  similar to COMMAND, but will not cause other
+ *             EVENTs. The reply, in the case of GET, will contain
+ *             TLVs with the requested information.
+ *
+ *   EVENT:    asynchronous messages sent from the device, maybe as a
+ *             consequence of previous COMMANDs but disassociated from
+ *             them.
+ *
+ * Only one request might be pending at the same time (ie: don't
+ * parallelize nor post another GET request before the previous
+ * COMMAND has been acknowledged with it's corresponding reply by the
+ * device).
+ *
+ * The different requests and their formats are described below:
+ *
+ *  I2400M_MT_*   Message types
+ *  I2400M_MS_*   Message status (for replies, events)
+ *  i2400m_tlv_*  TLVs
+ *
+ * data types are named 'struct i2400m_msg_OPNAME', OPNAME matching the
+ * operation.
+ */
+
+#ifndef __LINUX__WIMAX__I2400M_H__
+#define __LINUX__WIMAX__I2400M_H__
+
+#include <linux/types.h>
+
+
+/*
+ * Host Device Interface (HDI) common to all busses
+ */
+
+/* Boot-mode (firmware upload mode) commands */
+
+/* Header for the firmware file */
+struct i2400m_bcf_hdr {
+	__le32 module_type;
+	__le32 header_len;
+	__le32 header_version;
+	__le32 module_id;
+	__le32 module_vendor;
+	__le32 date;		/* BCD YYYMMDD */
+	__le32 size;
+	__le32 key_size;	/* in dwords */
+	__le32 modulus_size;	/* in dwords */
+	__le32 exponent_size;	/* in dwords */
+	__u8 reserved[88];
+} __attribute__ ((packed));
+
+/* Boot mode opcodes */
+enum i2400m_brh_opcode {
+	I2400M_BRH_READ = 1,
+	I2400M_BRH_WRITE = 2,
+	I2400M_BRH_JUMP = 3,
+	I2400M_BRH_SIGNED_JUMP = 8,
+	I2400M_BRH_HASH_PAYLOAD_ONLY = 9,
+};
+
+/* Boot mode command masks and stuff */
+enum i2400m_brh {
+	I2400M_BRH_SIGNATURE = 0xcbbc0000,
+	I2400M_BRH_SIGNATURE_MASK = 0xffff0000,
+	I2400M_BRH_SIGNATURE_SHIFT = 16,
+	I2400M_BRH_OPCODE_MASK = 0x0000000f,
+	I2400M_BRH_RESPONSE_MASK = 0x000000f0,
+	I2400M_BRH_RESPONSE_SHIFT = 4,
+	I2400M_BRH_DIRECT_ACCESS = 0x00000400,
+	I2400M_BRH_RESPONSE_REQUIRED = 0x00000200,
+	I2400M_BRH_USE_CHECKSUM = 0x00000100,
+};
+
+
+/* Constants for bcf->module_id */
+enum i2400m_bcf_mod_id {
+	/* Firmware file carries its own pokes -- pokes are a set of
+	 * magical values that have to be written in certain memory
+	 * addresses to get the device up and ready for firmware
+	 * download when it is in non-signed boot mode. */
+	I2400M_BCF_MOD_ID_POKES = 0x000000001,
+};
+
+
+/**
+ * i2400m_bootrom_header - Header for a boot-mode command
+ *
+ * @cmd: the above command descriptor
+ * @target_addr: where on the device memory should the action be performed.
+ * @data_size: for read/write, amount of data to be read/written
+ * @block_checksum: checksum value (if applicable)
+ * @payload: the beginning of data attached to this header
+ */
+struct i2400m_bootrom_header {
+	__le32 command;		/* Compose with enum i2400_brh */
+	__le32 target_addr;
+	__le32 data_size;
+	__le32 block_checksum;
+	char payload[0];
+} __attribute__ ((packed));
+
+
+/*
+ * Data / control protocol
+ */
+
+/* Packet types for the host-device interface */
+enum i2400m_pt {
+	I2400M_PT_DATA = 0,
+	I2400M_PT_CTRL,
+	I2400M_PT_TRACE,	/* For device debug */
+	I2400M_PT_RESET_WARM,	/* device reset */
+	I2400M_PT_RESET_COLD,	/* USB[transport] reset, like reconnect */
+	I2400M_PT_EDATA,	/* Extended RX data */
+	I2400M_PT_ILLEGAL
+};
+
+
+/*
+ * Payload for a data packet
+ *
+ * This is prefixed to each and every outgoing DATA type.
+ */
+struct i2400m_pl_data_hdr {
+	__le32 reserved;
+} __attribute__((packed));
+
+
+/*
+ * Payload for an extended data packet
+ *
+ * New in fw v1.4
+ *
+ * @reorder: if this payload has to be reorder or not (and how)
+ * @cs: the type of data in the packet, as defined per (802.16e
+ *     T11.13.19.1). Currently only 2 (IPv4 packet) supported.
+ *
+ * This is prefixed to each and every INCOMING DATA packet.
+ */
+struct i2400m_pl_edata_hdr {
+	__le32 reorder;		/* bits defined in i2400m_ro */
+	__u8 cs;
+	__u8 reserved[11];
+} __attribute__((packed));
+
+enum i2400m_cs {
+	I2400M_CS_IPV4_0 = 0,
+	I2400M_CS_IPV4 = 2,
+};
+
+enum i2400m_ro {
+	I2400M_RO_NEEDED     = 0x01,
+	I2400M_RO_TYPE       = 0x03,
+	I2400M_RO_TYPE_SHIFT = 1,
+	I2400M_RO_CIN        = 0x0f,
+	I2400M_RO_CIN_SHIFT  = 4,
+	I2400M_RO_FBN        = 0x07ff,
+	I2400M_RO_FBN_SHIFT  = 8,
+	I2400M_RO_SN         = 0x07ff,
+	I2400M_RO_SN_SHIFT   = 21,
+};
+
+enum i2400m_ro_type {
+	I2400M_RO_TYPE_RESET = 0,
+	I2400M_RO_TYPE_PACKET,
+	I2400M_RO_TYPE_WS,
+	I2400M_RO_TYPE_PACKET_WS,
+};
+
+
+/* Misc constants */
+enum {
+	I2400M_PL_ALIGN = 16,	/* Payload data size alignment */
+	I2400M_PL_SIZE_MAX = 0x3EFF,
+	I2400M_MAX_PLS_IN_MSG = 60,
+	/* protocol barkers: sync sequences; for notifications they
+	 * are sent in groups of four. */
+	I2400M_H2D_PREVIEW_BARKER = 0xcafe900d,
+	I2400M_COLD_RESET_BARKER = 0xc01dc01d,
+	I2400M_WARM_RESET_BARKER = 0x50f750f7,
+	I2400M_NBOOT_BARKER = 0xdeadbeef,
+	I2400M_SBOOT_BARKER = 0x0ff1c1a1,
+	I2400M_ACK_BARKER = 0xfeedbabe,
+	I2400M_D2H_MSG_BARKER = 0xbeefbabe,
+};
+
+
+/*
+ * Hardware payload descriptor
+ *
+ * Bitfields encoded in a struct to enforce typing semantics.
+ *
+ * Look in rx.c and tx.c for a full description of the format.
+ */
+struct i2400m_pld {
+	__le32 val;
+} __attribute__ ((packed));
+
+#define I2400M_PLD_SIZE_MASK 0x00003fff
+#define I2400M_PLD_TYPE_SHIFT 16
+#define I2400M_PLD_TYPE_MASK 0x000f0000
+
+/*
+ * Header for a TX message or RX message
+ *
+ * @barker: preamble
+ * @size: used for management of the FIFO queue buffer; before
+ *     sending, this is converted to be a real preamble. This
+ *     indicates the real size of the TX message that starts at this
+ *     point. If the highest bit is set, then this message is to be
+ *     skipped.
+ * @sequence: sequence number of this message
+ * @offset: offset where the message itself starts -- see the comments
+ *     in the file header about message header and payload descriptor
+ *     alignment.
+ * @num_pls: number of payloads in this message
+ * @padding: amount of padding bytes at the end of the message to make
+ *           it be of block-size aligned
+ *
+ * Look in rx.c and tx.c for a full description of the format.
+ */
+struct i2400m_msg_hdr {
+	union {
+		__le32 barker;
+		__u32 size;	/* same size type as barker!! */
+	};
+	union {
+		__le32 sequence;
+		__u32 offset;	/* same size type as barker!! */
+	};
+	__le16 num_pls;
+	__le16 rsv1;
+	__le16 padding;
+	__le16 rsv2;
+	struct i2400m_pld pld[0];
+} __attribute__ ((packed));
+
+
+
+/*
+ * L3/L4 control protocol
+ */
+
+enum {
+	/* Interface version */
+	I2400M_L3L4_VERSION             = 0x0100,
+};
+
+/* Message types */
+enum i2400m_mt {
+	I2400M_MT_RESERVED              = 0x0000,
+	I2400M_MT_INVALID               = 0xffff,
+	I2400M_MT_REPORT_MASK		= 0x8000,
+
+	I2400M_MT_GET_SCAN_RESULT  	= 0x4202,
+	I2400M_MT_SET_SCAN_PARAM   	= 0x4402,
+	I2400M_MT_CMD_RF_CONTROL   	= 0x4602,
+	I2400M_MT_CMD_SCAN         	= 0x4603,
+	I2400M_MT_CMD_CONNECT      	= 0x4604,
+	I2400M_MT_CMD_DISCONNECT   	= 0x4605,
+	I2400M_MT_CMD_EXIT_IDLE   	= 0x4606,
+	I2400M_MT_GET_LM_VERSION   	= 0x5201,
+	I2400M_MT_GET_DEVICE_INFO  	= 0x5202,
+	I2400M_MT_GET_LINK_STATUS  	= 0x5203,
+	I2400M_MT_GET_STATISTICS   	= 0x5204,
+	I2400M_MT_GET_STATE        	= 0x5205,
+	I2400M_MT_GET_MEDIA_STATUS	= 0x5206,
+	I2400M_MT_SET_INIT_CONFIG	= 0x5404,
+	I2400M_MT_CMD_INIT	        = 0x5601,
+	I2400M_MT_CMD_TERMINATE		= 0x5602,
+	I2400M_MT_CMD_MODE_OF_OP	= 0x5603,
+	I2400M_MT_CMD_RESET_DEVICE	= 0x5604,
+	I2400M_MT_CMD_MONITOR_CONTROL   = 0x5605,
+	I2400M_MT_CMD_ENTER_POWERSAVE   = 0x5606,
+	I2400M_MT_GET_TLS_OPERATION_RESULT = 0x6201,
+	I2400M_MT_SET_EAP_SUCCESS       = 0x6402,
+	I2400M_MT_SET_EAP_FAIL          = 0x6403,
+	I2400M_MT_SET_EAP_KEY          	= 0x6404,
+	I2400M_MT_CMD_SEND_EAP_RESPONSE = 0x6602,
+	I2400M_MT_REPORT_SCAN_RESULT    = 0xc002,
+	I2400M_MT_REPORT_STATE		= 0xd002,
+	I2400M_MT_REPORT_POWERSAVE_READY = 0xd005,
+	I2400M_MT_REPORT_EAP_REQUEST    = 0xe002,
+	I2400M_MT_REPORT_EAP_RESTART    = 0xe003,
+	I2400M_MT_REPORT_ALT_ACCEPT    	= 0xe004,
+	I2400M_MT_REPORT_KEY_REQUEST 	= 0xe005,
+};
+
+
+/*
+ * Message Ack Status codes
+ *
+ * When a message is replied-to, this status is reported.
+ */
+enum i2400m_ms {
+	I2400M_MS_DONE_OK                  = 0,
+	I2400M_MS_DONE_IN_PROGRESS         = 1,
+	I2400M_MS_INVALID_OP               = 2,
+	I2400M_MS_BAD_STATE                = 3,
+	I2400M_MS_ILLEGAL_VALUE            = 4,
+	I2400M_MS_MISSING_PARAMS           = 5,
+	I2400M_MS_VERSION_ERROR            = 6,
+	I2400M_MS_ACCESSIBILITY_ERROR      = 7,
+	I2400M_MS_BUSY                     = 8,
+	I2400M_MS_CORRUPTED_TLV            = 9,
+	I2400M_MS_UNINITIALIZED            = 10,
+	I2400M_MS_UNKNOWN_ERROR            = 11,
+	I2400M_MS_PRODUCTION_ERROR         = 12,
+	I2400M_MS_NO_RF                    = 13,
+	I2400M_MS_NOT_READY_FOR_POWERSAVE  = 14,
+	I2400M_MS_THERMAL_CRITICAL         = 15,
+	I2400M_MS_MAX
+};
+
+
+/**
+ * i2400m_tlv - enumeration of the different types of TLVs
+ *
+ * TLVs stand for type-length-value and are the header for a payload
+ * composed of almost anything. Each payload has a type assigned
+ * and a length.
+ */
+enum i2400m_tlv {
+	I2400M_TLV_L4_MESSAGE_VERSIONS = 129,
+	I2400M_TLV_SYSTEM_STATE = 141,
+	I2400M_TLV_MEDIA_STATUS = 161,
+	I2400M_TLV_RF_OPERATION = 162,
+	I2400M_TLV_RF_STATUS = 163,
+	I2400M_TLV_DEVICE_RESET_TYPE = 132,
+	I2400M_TLV_CONFIG_IDLE_PARAMETERS = 601,
+	I2400M_TLV_CONFIG_IDLE_TIMEOUT = 611,
+	I2400M_TLV_CONFIG_D2H_DATA_FORMAT = 614,
+	I2400M_TLV_CONFIG_DL_HOST_REORDER = 615,
+};
+
+
+struct i2400m_tlv_hdr {
+	__le16 type;
+	__le16 length;		/* payload's */
+	__u8   pl[0];
+} __attribute__((packed));
+
+
+struct i2400m_l3l4_hdr {
+	__le16 type;
+	__le16 length;		/* payload's */
+	__le16 version;
+	__le16 resv1;
+	__le16 status;
+	__le16 resv2;
+	struct i2400m_tlv_hdr pl[0];
+} __attribute__((packed));
+
+
+/**
+ * i2400m_system_state - different states of the device
+ */
+enum i2400m_system_state {
+	I2400M_SS_UNINITIALIZED = 1,
+	I2400M_SS_INIT,
+	I2400M_SS_READY,
+	I2400M_SS_SCAN,
+	I2400M_SS_STANDBY,
+	I2400M_SS_CONNECTING,
+	I2400M_SS_WIMAX_CONNECTED,
+	I2400M_SS_DATA_PATH_CONNECTED,
+	I2400M_SS_IDLE,
+	I2400M_SS_DISCONNECTING,
+	I2400M_SS_OUT_OF_ZONE,
+	I2400M_SS_SLEEPACTIVE,
+	I2400M_SS_PRODUCTION,
+	I2400M_SS_CONFIG,
+	I2400M_SS_RF_OFF,
+	I2400M_SS_RF_SHUTDOWN,
+	I2400M_SS_DEVICE_DISCONNECT,
+	I2400M_SS_MAX,
+};
+
+
+/**
+ * i2400m_tlv_system_state - report on the state of the system
+ *
+ * @state: see enum i2400m_system_state
+ */
+struct i2400m_tlv_system_state {
+	struct i2400m_tlv_hdr hdr;
+	__le32 state;
+} __attribute__((packed));
+
+
+struct i2400m_tlv_l4_message_versions {
+	struct i2400m_tlv_hdr hdr;
+	__le16 major;
+	__le16 minor;
+	__le16 branch;
+	__le16 reserved;
+} __attribute__((packed));
+
+
+struct i2400m_tlv_detailed_device_info {
+	struct i2400m_tlv_hdr hdr;
+	__u8 reserved1[400];
+	__u8 mac_address[6];
+	__u8 reserved2[2];
+} __attribute__((packed));
+
+
+enum i2400m_rf_switch_status {
+	I2400M_RF_SWITCH_ON = 1,
+	I2400M_RF_SWITCH_OFF = 2,
+};
+
+struct i2400m_tlv_rf_switches_status {
+	struct i2400m_tlv_hdr hdr;
+	__u8 sw_rf_switch;	/* 1 ON, 2 OFF */
+	__u8 hw_rf_switch;	/* 1 ON, 2 OFF */
+	__u8 reserved[2];
+} __attribute__((packed));
+
+
+enum {
+	i2400m_rf_operation_on = 1,
+	i2400m_rf_operation_off = 2
+};
+
+struct i2400m_tlv_rf_operation {
+	struct i2400m_tlv_hdr hdr;
+	__le32 status;	/* 1 ON, 2 OFF */
+} __attribute__((packed));
+
+
+enum i2400m_tlv_reset_type {
+	I2400M_RESET_TYPE_COLD = 1,
+	I2400M_RESET_TYPE_WARM
+};
+
+struct i2400m_tlv_device_reset_type {
+	struct i2400m_tlv_hdr hdr;
+	__le32 reset_type;
+} __attribute__((packed));
+
+
+struct i2400m_tlv_config_idle_parameters {
+	struct i2400m_tlv_hdr hdr;
+	__le32 idle_timeout;	/* 100 to 300000 ms [5min], 100 increments
+				 * 0 disabled */
+	__le32 idle_paging_interval;	/* frames */
+} __attribute__((packed));
+
+
+enum i2400m_media_status {
+	I2400M_MEDIA_STATUS_LINK_UP = 1,
+	I2400M_MEDIA_STATUS_LINK_DOWN,
+	I2400M_MEDIA_STATUS_LINK_RENEW,
+};
+
+struct i2400m_tlv_media_status {
+	struct i2400m_tlv_hdr hdr;
+	__le32 media_status;
+} __attribute__((packed));
+
+
+/* New in v1.4 */
+struct i2400m_tlv_config_idle_timeout {
+	struct i2400m_tlv_hdr hdr;
+	__le32 timeout;	/* 100 to 300000 ms [5min], 100 increments
+			 * 0 disabled */
+} __attribute__((packed));
+
+/* New in v1.4 -- for backward compat, will be removed */
+struct i2400m_tlv_config_d2h_data_format {
+	struct i2400m_tlv_hdr hdr;
+	__u8 format; 		/* 0 old format, 1 enhanced */
+	__u8 reserved[3];
+} __attribute__((packed));
+
+/* New in v1.4 */
+struct i2400m_tlv_config_dl_host_reorder {
+	struct i2400m_tlv_hdr hdr;
+	__u8 reorder; 		/* 0 disabled, 1 enabled */
+	__u8 reserved[3];
+} __attribute__((packed));
+
+
+#endif /* #ifndef __LINUX__WIMAX__I2400M_H__ */
diff -uNr linux-2.6.32/usr/include/linux/wimax.h clean_modified/linux-2.6.32/usr/include/linux/wimax.h
--- linux-2.6.32/usr/include/linux/wimax.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/wimax.h	2019-04-14 13:24:03.184122726 -0500
@@ -0,0 +1,239 @@
+/*
+ * Linux WiMax
+ * API for user space
+ *
+ *
+ * Copyright (C) 2007-2008 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * Intel Corporation <linux-wimax@intel.com>
+ * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
+ *  - Initial implementation
+ *
+ *
+ * This file declares the user/kernel protocol that is spoken over
+ * Generic Netlink, as well as any type declaration that is to be used
+ * by kernel and user space.
+ *
+ * It is intended for user space to clone it verbatim to use it as a
+ * primary reference for definitions.
+ *
+ * Stuff intended for kernel usage as well as full protocol and stack
+ * documentation is rooted in include/net/wimax.h.
+ */
+
+#ifndef __LINUX__WIMAX_H__
+#define __LINUX__WIMAX_H__
+
+#include <linux/types.h>
+
+enum {
+	/**
+	 * Version of the interface (unsigned decimal, MMm, max 25.5)
+	 * M - Major: change if removing or modifying an existing call.
+	 * m - minor: change when adding a new call
+	 */
+	WIMAX_GNL_VERSION = 01,
+	/* Generic NetLink attributes */
+	WIMAX_GNL_ATTR_INVALID = 0x00,
+	WIMAX_GNL_ATTR_MAX = 10,
+};
+
+
+/*
+ * Generic NetLink operations
+ *
+ * Most of these map to an API call; _OP_ stands for operation, _RP_
+ * for reply and _RE_ for report (aka: signal).
+ */
+enum {
+	WIMAX_GNL_OP_MSG_FROM_USER,	/* User to kernel message */
+	WIMAX_GNL_OP_MSG_TO_USER,	/* Kernel to user message */
+	WIMAX_GNL_OP_RFKILL,	/* Run wimax_rfkill() */
+	WIMAX_GNL_OP_RESET,	/* Run wimax_rfkill() */
+	WIMAX_GNL_RE_STATE_CHANGE,	/* Report: status change */
+	WIMAX_GNL_OP_STATE_GET,		/* Request for current state */
+};
+
+
+/* Message from user / to user */
+enum {
+	WIMAX_GNL_MSG_IFIDX = 1,
+	WIMAX_GNL_MSG_PIPE_NAME,
+	WIMAX_GNL_MSG_DATA,
+};
+
+
+/*
+ * wimax_rfkill()
+ *
+ * The state of the radio (ON/OFF) is mapped to the rfkill subsystem's
+ * switch state (DISABLED/ENABLED).
+ */
+enum wimax_rf_state {
+	WIMAX_RF_OFF = 0,	/* Radio is off, rfkill on/enabled */
+	WIMAX_RF_ON = 1,	/* Radio is on, rfkill off/disabled */
+	WIMAX_RF_QUERY = 2,
+};
+
+/* Attributes */
+enum {
+	WIMAX_GNL_RFKILL_IFIDX = 1,
+	WIMAX_GNL_RFKILL_STATE,
+};
+
+
+/* Attributes for wimax_reset() */
+enum {
+	WIMAX_GNL_RESET_IFIDX = 1,
+};
+
+/* Atributes for wimax_state_get() */
+enum {
+	WIMAX_GNL_STGET_IFIDX = 1,
+};
+
+/*
+ * Attributes for the Report State Change
+ *
+ * For now we just have the old and new states; new attributes might
+ * be added later on.
+ */
+enum {
+	WIMAX_GNL_STCH_IFIDX = 1,
+	WIMAX_GNL_STCH_STATE_OLD,
+	WIMAX_GNL_STCH_STATE_NEW,
+};
+
+
+/**
+ * enum wimax_st - The different states of a WiMAX device
+ * @__WIMAX_ST_NULL: The device structure has been allocated and zeroed,
+ *     but still wimax_dev_add() hasn't been called. There is no state.
+ *
+ * @WIMAX_ST_DOWN: The device has been registered with the WiMAX and
+ *     networking stacks, but it is not initialized (normally that is
+ *     done with 'ifconfig DEV up' [or equivalent], which can upload
+ *     firmware and enable communications with the device).
+ *     In this state, the device is powered down and using as less
+ *     power as possible.
+ *     This state is the default after a call to wimax_dev_add(). It
+ *     is ok to have drivers move directly to %WIMAX_ST_UNINITIALIZED
+ *     or %WIMAX_ST_RADIO_OFF in _probe() after the call to
+ *     wimax_dev_add().
+ *     It is recommended that the driver leaves this state when
+ *     calling 'ifconfig DEV up' and enters it back on 'ifconfig DEV
+ *     down'.
+ *
+ * @__WIMAX_ST_QUIESCING: The device is being torn down, so no API
+ *     operations are allowed to proceed except the ones needed to
+ *     complete the device clean up process.
+ *
+ * @WIMAX_ST_UNINITIALIZED: [optional] Communication with the device
+ *     is setup, but the device still requires some configuration
+ *     before being operational.
+ *     Some WiMAX API calls might work.
+ *
+ * @WIMAX_ST_RADIO_OFF: The device is fully up; radio is off (wether
+ *     by hardware or software switches).
+ *     It is recommended to always leave the device in this state
+ *     after initialization.
+ *
+ * @WIMAX_ST_READY: The device is fully up and radio is on.
+ *
+ * @WIMAX_ST_SCANNING: [optional] The device has been instructed to
+ *     scan. In this state, the device cannot be actively connected to
+ *     a network.
+ *
+ * @WIMAX_ST_CONNECTING: The device is connecting to a network. This
+ *     state exists because in some devices, the connect process can
+ *     include a number of negotiations between user space, kernel
+ *     space and the device. User space needs to know what the device
+ *     is doing. If the connect sequence in a device is atomic and
+ *     fast, the device can transition directly to CONNECTED
+ *
+ * @WIMAX_ST_CONNECTED: The device is connected to a network.
+ *
+ * @__WIMAX_ST_INVALID: This is an invalid state used to mark the
+ *     maximum numeric value of states.
+ *
+ * Description:
+ *
+ * Transitions from one state to another one are atomic and can only
+ * be caused in kernel space with wimax_state_change(). To read the
+ * state, use wimax_state_get().
+ *
+ * States starting with __ are internal and shall not be used or
+ * referred to by drivers or userspace. They look ugly, but that's the
+ * point -- if any use is made non-internal to the stack, it is easier
+ * to catch on review.
+ *
+ * All API operations [with well defined exceptions] will take the
+ * device mutex before starting and then check the state. If the state
+ * is %__WIMAX_ST_NULL, %WIMAX_ST_DOWN, %WIMAX_ST_UNINITIALIZED or
+ * %__WIMAX_ST_QUIESCING, it will drop the lock and quit with
+ * -%EINVAL, -%ENOMEDIUM, -%ENOTCONN or -%ESHUTDOWN.
+ *
+ * The order of the definitions is important, so we can do numerical
+ * comparisons (eg: < %WIMAX_ST_RADIO_OFF means the device is not ready
+ * to operate).
+ */
+/*
+ * The allowed state transitions are described in the table below
+ * (states in rows can go to states in columns where there is an X):
+ *
+ *                                  UNINI   RADIO READY SCAN CONNEC CONNEC
+ *             NULL DOWN QUIESCING TIALIZED  OFF        NING  TING   TED
+ * NULL         -    x
+ * DOWN              -      x        x       x
+ * QUIESCING         x      -
+ * UNINITIALIZED            x        -       x
+ * RADIO_OFF                x                -     x
+ * READY                    x                x     -     x     x      x
+ * SCANNING                 x                x     x     -     x      x
+ * CONNECTING               x                x     x     x     -      x
+ * CONNECTED                x                x     x                  -
+ *
+ * This table not available in kernel-doc because the formatting messes it up.
+ */
+ enum wimax_st {
+	__WIMAX_ST_NULL = 0,
+	WIMAX_ST_DOWN,
+	__WIMAX_ST_QUIESCING,
+	WIMAX_ST_UNINITIALIZED,
+	WIMAX_ST_RADIO_OFF,
+	WIMAX_ST_READY,
+	WIMAX_ST_SCANNING,
+	WIMAX_ST_CONNECTING,
+	WIMAX_ST_CONNECTED,
+	__WIMAX_ST_INVALID			/* Always keep last */
+};
+
+
+#endif /* #ifndef __LINUX__WIMAX_H__ */
diff -uNr linux-2.6.32/usr/include/linux/wireless.h clean_modified/linux-2.6.32/usr/include/linux/wireless.h
--- linux-2.6.32/usr/include/linux/wireless.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/wireless.h	2019-04-14 13:24:03.187104684 -0500
@@ -0,0 +1,1126 @@
+/*
+ * This file define a set of standard wireless extensions
+ *
+ * Version :	22	16.3.07
+ *
+ * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
+ * Copyright (c) 1997-2007 Jean Tourrilhes, All Rights Reserved.
+ */
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/************************** DOCUMENTATION **************************/
+/*
+ * Initial APIs (1996 -> onward) :
+ * -----------------------------
+ * Basically, the wireless extensions are for now a set of standard ioctl
+ * call + /proc/net/wireless
+ *
+ * The entry /proc/net/wireless give statistics and information on the
+ * driver.
+ * This is better than having each driver having its entry because
+ * its centralised and we may remove the driver module safely.
+ *
+ * Ioctl are used to configure the driver and issue commands.  This is
+ * better than command line options of insmod because we may want to
+ * change dynamically (while the driver is running) some parameters.
+ *
+ * The ioctl mechanimsm are copied from standard devices ioctl.
+ * We have the list of command plus a structure descibing the
+ * data exchanged...
+ * Note that to add these ioctl, I was obliged to modify :
+ *	# net/core/dev.c (two place + add include)
+ *	# net/ipv4/af_inet.c (one place + add include)
+ *
+ * /proc/net/wireless is a copy of /proc/net/dev.
+ * We have a structure for data passed from the driver to /proc/net/wireless
+ * Too add this, I've modified :
+ *	# net/core/dev.c (two other places)
+ *	# include/linux/netdevice.h (one place)
+ *	# include/linux/proc_fs.h (one place)
+ *
+ * New driver API (2002 -> onward) :
+ * -------------------------------
+ * This file is only concerned with the user space API and common definitions.
+ * The new driver API is defined and documented in :
+ *	# include/net/iw_handler.h
+ *
+ * Note as well that /proc/net/wireless implementation has now moved in :
+ *	# net/core/wireless.c
+ *
+ * Wireless Events (2002 -> onward) :
+ * --------------------------------
+ * Events are defined at the end of this file, and implemented in :
+ *	# net/core/wireless.c
+ *
+ * Other comments :
+ * --------------
+ * Do not add here things that are redundant with other mechanisms
+ * (drivers init, ifconfig, /proc/net/dev, ...) and with are not
+ * wireless specific.
+ *
+ * These wireless extensions are not magic : each driver has to provide
+ * support for them...
+ *
+ * IMPORTANT NOTE : As everything in the kernel, this is very much a
+ * work in progress. Contact me if you have ideas of improvements...
+ */
+
+/***************************** INCLUDES *****************************/
+
+#include <linux/types.h>		/* for __u* and __s* typedefs */
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+
+/***************************** VERSION *****************************/
+/*
+ * This constant is used to know the availability of the wireless
+ * extensions and to know which version of wireless extensions it is
+ * (there is some stuff that will be added in the future...)
+ * I just plan to increment with each new version.
+ */
+#define WIRELESS_EXT	22
+
+/*
+ * Changes :
+ *
+ * V2 to V3
+ * --------
+ *	Alan Cox start some incompatibles changes. I've integrated a bit more.
+ *	- Encryption renamed to Encode to avoid US regulation problems
+ *	- Frequency changed from float to struct to avoid problems on old 386
+ *
+ * V3 to V4
+ * --------
+ *	- Add sensitivity
+ *
+ * V4 to V5
+ * --------
+ *	- Missing encoding definitions in range
+ *	- Access points stuff
+ *
+ * V5 to V6
+ * --------
+ *	- 802.11 support (ESSID ioctls)
+ *
+ * V6 to V7
+ * --------
+ *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
+ *
+ * V7 to V8
+ * --------
+ *	- Changed my e-mail address
+ *	- More 802.11 support (nickname, rate, rts, frag)
+ *	- List index in frequencies
+ *
+ * V8 to V9
+ * --------
+ *	- Support for 'mode of operation' (ad-hoc, managed...)
+ *	- Support for unicast and multicast power saving
+ *	- Change encoding to support larger tokens (>64 bits)
+ *	- Updated iw_params (disable, flags) and use it for NWID
+ *	- Extracted iw_point from iwreq for clarity
+ *
+ * V9 to V10
+ * ---------
+ *	- Add PM capability to range structure
+ *	- Add PM modifier : MAX/MIN/RELATIVE
+ *	- Add encoding option : IW_ENCODE_NOKEY
+ *	- Add TxPower ioctls (work like TxRate)
+ *
+ * V10 to V11
+ * ----------
+ *	- Add WE version in range (help backward/forward compatibility)
+ *	- Add retry ioctls (work like PM)
+ *
+ * V11 to V12
+ * ----------
+ *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
+ *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
+ *	- Add new statistics (frag, retry, beacon)
+ *	- Add average quality (for user space calibration)
+ *
+ * V12 to V13
+ * ----------
+ *	- Document creation of new driver API.
+ *	- Extract union iwreq_data from struct iwreq (for new driver API).
+ *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
+ *
+ * V13 to V14
+ * ----------
+ *	- Wireless Events support : define struct iw_event
+ *	- Define additional specific event numbers
+ *	- Add "addr" and "param" fields in union iwreq_data
+ *	- AP scanning stuff (SIOCSIWSCAN and friends)
+ *
+ * V14 to V15
+ * ----------
+ *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
+ *	- Make struct iw_freq signed (both m & e), add explicit padding
+ *	- Add IWEVCUSTOM for driver specific event/scanning token
+ *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
+ *	- Add IW_TXPOW_RANGE for range of Tx Powers
+ *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
+ *	- Add IW_MODE_MONITOR for passive monitor
+ *
+ * V15 to V16
+ * ----------
+ *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
+ *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
+ *	- Reshuffle struct iw_range for increases, add filler
+ *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
+ *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
+ *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
+ *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
+ *
+ * V16 to V17
+ * ----------
+ *	- Add flags to frequency -> auto/fixed
+ *	- Document (struct iw_quality *)->updated, add new flags (INVALID)
+ *	- Wireless Event capability in struct iw_range
+ *	- Add support for relative TxPower (yick !)
+ *
+ * V17 to V18 (From Jouni Malinen <j@w1.fi>)
+ * ----------
+ *	- Add support for WPA/WPA2
+ *	- Add extended encoding configuration (SIOCSIWENCODEEXT and
+ *	  SIOCGIWENCODEEXT)
+ *	- Add SIOCSIWGENIE/SIOCGIWGENIE
+ *	- Add SIOCSIWMLME
+ *	- Add SIOCSIWPMKSA
+ *	- Add struct iw_range bit field for supported encoding capabilities
+ *	- Add optional scan request parameters for SIOCSIWSCAN
+ *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA
+ *	  related parameters (extensible up to 4096 parameter values)
+ *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,
+ *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND
+ *
+ * V18 to V19
+ * ----------
+ *	- Remove (struct iw_point *)->pointer from events and streams
+ *	- Remove header includes to help user space
+ *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64
+ *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros
+ *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM
+ *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros
+ *
+ * V19 to V20
+ * ----------
+ *	- RtNetlink requests support (SET/GET)
+ *
+ * V20 to V21
+ * ----------
+ *	- Remove (struct net_device *)->get_wireless_stats()
+ *	- Change length in ESSID and NICK to strlen() instead of strlen()+1
+ *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers
+ *	- Power/Retry relative values no longer * 100000
+ *	- Add explicit flag to tell stats are in 802.11k RCPI : IW_QUAL_RCPI
+ *
+ * V21 to V22
+ * ----------
+ *	- Prevent leaking of kernel space in stream on 64 bits.
+ */
+
+/**************************** CONSTANTS ****************************/
+
+/* -------------------------- IOCTL LIST -------------------------- */
+
+/* Wireless Identification */
+#define SIOCSIWCOMMIT	0x8B00		/* Commit pending changes to driver */
+#define SIOCGIWNAME	0x8B01		/* get name == wireless protocol */
+/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+ * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+ * Don't put the name of your driver there, it's useless. */
+
+/* Basic operations */
+#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
+#define SIOCGIWNWID	0x8B03		/* get network id (the cell) */
+#define SIOCSIWFREQ	0x8B04		/* set channel/frequency (Hz) */
+#define SIOCGIWFREQ	0x8B05		/* get channel/frequency (Hz) */
+#define SIOCSIWMODE	0x8B06		/* set operation mode */
+#define SIOCGIWMODE	0x8B07		/* get operation mode */
+#define SIOCSIWSENS	0x8B08		/* set sensitivity (dBm) */
+#define SIOCGIWSENS	0x8B09		/* get sensitivity (dBm) */
+
+/* Informative stuff */
+#define SIOCSIWRANGE	0x8B0A		/* Unused */
+#define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */
+#define SIOCSIWPRIV	0x8B0C		/* Unused */
+#define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */
+#define SIOCSIWSTATS	0x8B0E		/* Unused */
+#define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */
+/* SIOCGIWSTATS is strictly used between user space and the kernel, and
+ * is never passed to the driver (i.e. the driver will never see it). */
+
+/* Spy support (statistics per MAC address - used for Mobile IP support) */
+#define SIOCSIWSPY	0x8B10		/* set spy addresses */
+#define SIOCGIWSPY	0x8B11		/* get spy info (quality of link) */
+#define SIOCSIWTHRSPY	0x8B12		/* set spy threshold (spy event) */
+#define SIOCGIWTHRSPY	0x8B13		/* get spy threshold */
+
+/* Access Point manipulation */
+#define SIOCSIWAP	0x8B14		/* set access point MAC addresses */
+#define SIOCGIWAP	0x8B15		/* get access point MAC addresses */
+#define SIOCGIWAPLIST	0x8B17		/* Deprecated in favor of scanning */
+#define SIOCSIWSCAN	0x8B18		/* trigger scanning (list cells) */
+#define SIOCGIWSCAN	0x8B19		/* get scanning results */
+
+/* 802.11 specific support */
+#define SIOCSIWESSID	0x8B1A		/* set ESSID (network name) */
+#define SIOCGIWESSID	0x8B1B		/* get ESSID */
+#define SIOCSIWNICKN	0x8B1C		/* set node name/nickname */
+#define SIOCGIWNICKN	0x8B1D		/* get node name/nickname */
+/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+ * within the 'iwreq' structure, so we need to use the 'data' member to
+ * point to a string in user space, like it is done for RANGE... */
+
+/* Other parameters useful in 802.11 and some other devices */
+#define SIOCSIWRATE	0x8B20		/* set default bit rate (bps) */
+#define SIOCGIWRATE	0x8B21		/* get default bit rate (bps) */
+#define SIOCSIWRTS	0x8B22		/* set RTS/CTS threshold (bytes) */
+#define SIOCGIWRTS	0x8B23		/* get RTS/CTS threshold (bytes) */
+#define SIOCSIWFRAG	0x8B24		/* set fragmentation thr (bytes) */
+#define SIOCGIWFRAG	0x8B25		/* get fragmentation thr (bytes) */
+#define SIOCSIWTXPOW	0x8B26		/* set transmit power (dBm) */
+#define SIOCGIWTXPOW	0x8B27		/* get transmit power (dBm) */
+#define SIOCSIWRETRY	0x8B28		/* set retry limits and lifetime */
+#define SIOCGIWRETRY	0x8B29		/* get retry limits and lifetime */
+
+/* Encoding stuff (scrambling, hardware security, WEP...) */
+#define SIOCSIWENCODE	0x8B2A		/* set encoding token & mode */
+#define SIOCGIWENCODE	0x8B2B		/* get encoding token & mode */
+/* Power saving stuff (power management, unicast and multicast) */
+#define SIOCSIWPOWER	0x8B2C		/* set Power Management settings */
+#define SIOCGIWPOWER	0x8B2D		/* get Power Management settings */
+
+/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+ * This ioctl uses struct iw_point and data buffer that includes IE id and len
+ * fields. More than one IE may be included in the request. Setting the generic
+ * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+ * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+ * are required to report the used IE as a wireless event, e.g., when
+ * associating with an AP. */
+#define SIOCSIWGENIE	0x8B30		/* set generic IE */
+#define SIOCGIWGENIE	0x8B31		/* get generic IE */
+
+/* WPA : IEEE 802.11 MLME requests */
+#define SIOCSIWMLME	0x8B16		/* request MLME operation; uses
+					 * struct iw_mlme */
+/* WPA : Authentication mode parameters */
+#define SIOCSIWAUTH	0x8B32		/* set authentication mode params */
+#define SIOCGIWAUTH	0x8B33		/* get authentication mode params */
+
+/* WPA : Extended version of encoding configuration */
+#define SIOCSIWENCODEEXT 0x8B34		/* set encoding token & mode */
+#define SIOCGIWENCODEEXT 0x8B35		/* get encoding token & mode */
+
+/* WPA2 : PMKSA cache management */
+#define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */
+
+/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+/* These 32 ioctl are wireless device private, for 16 commands.
+ * Each driver is free to use them for whatever purpose it chooses,
+ * however the driver *must* export the description of those ioctls
+ * with SIOCGIWPRIV and *must* use arguments as defined below.
+ * If you don't follow those rules, DaveM is going to hate you (reason :
+ * it make mixed 32/64bit operation impossible).
+ */
+#define SIOCIWFIRSTPRIV	0x8BE0
+#define SIOCIWLASTPRIV	0x8BFF
+/* Previously, we were using SIOCDEVPRIVATE, but we now have our
+ * separate range because of collisions with other tools such as
+ * 'mii-tool'.
+ * We now have 32 commands, so a bit more space ;-).
+ * Also, all 'even' commands are only usable by root and don't return the
+ * content of ifr/iwr to user (but you are not obliged to use the set/get
+ * convention, just use every other two command). More details in iwpriv.c.
+ * And I repeat : you are not forced to use them with iwpriv, but you
+ * must be compliant with it.
+ */
+
+/* ------------------------- IOCTL STUFF ------------------------- */
+
+/* The first and the last (range) */
+#define SIOCIWFIRST	0x8B00
+#define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */
+#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)
+
+/* Odd : get (world access), even : set (root access) */
+#define IW_IS_SET(cmd)	(!((cmd) & 0x1))
+#define IW_IS_GET(cmd)	((cmd) & 0x1)
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/* Those are *NOT* ioctls, do not issue request on them !!! */
+/* Most events use the same identifier as ioctl requests */
+
+#define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */
+#define IWEVQUAL	0x8C01		/* Quality part of statistics (scan) */
+#define IWEVCUSTOM	0x8C02		/* Driver specific ascii string */
+#define IWEVREGISTERED	0x8C03		/* Discovered a new node (AP mode) */
+#define IWEVEXPIRED	0x8C04		/* Expired a node (AP mode) */
+#define IWEVGENIE	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)
+					 * (scan results); This includes id and
+					 * length fields. One IWEVGENIE may
+					 * contain more than one IE. Scan
+					 * results may contain one or more
+					 * IWEVGENIE events. */
+#define IWEVMICHAELMICFAILURE 0x8C06	/* Michael MIC failure
+					 * (struct iw_michaelmicfailure)
+					 */
+#define IWEVASSOCREQIE	0x8C07		/* IEs used in (Re)Association Request.
+					 * The data includes id and length
+					 * fields and may contain more than one
+					 * IE. This event is required in
+					 * Managed mode if the driver
+					 * generates its own WPA/RSN IE. This
+					 * should be sent just before
+					 * IWEVREGISTERED event for the
+					 * association. */
+#define IWEVASSOCRESPIE	0x8C08		/* IEs used in (Re)Association
+					 * Response. The data includes id and
+					 * length fields and may contain more
+					 * than one IE. This may be sent
+					 * between IWEVASSOCREQIE and
+					 * IWEVREGISTERED events for the
+					 * association. */
+#define IWEVPMKIDCAND	0x8C09		/* PMKID candidate for RSN
+					 * pre-authentication
+					 * (struct iw_pmkid_cand) */
+
+#define IWEVFIRST	0x8C00
+#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)
+
+/* ------------------------- PRIVATE INFO ------------------------- */
+/*
+ * The following is used with SIOCGIWPRIV. It allow a driver to define
+ * the interface (name, type of data) for its private ioctl.
+ * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
+ */
+
+#define IW_PRIV_TYPE_MASK	0x7000	/* Type of arguments */
+#define IW_PRIV_TYPE_NONE	0x0000
+#define IW_PRIV_TYPE_BYTE	0x1000	/* Char as number */
+#define IW_PRIV_TYPE_CHAR	0x2000	/* Char as character */
+#define IW_PRIV_TYPE_INT	0x4000	/* 32 bits int */
+#define IW_PRIV_TYPE_FLOAT	0x5000	/* struct iw_freq */
+#define IW_PRIV_TYPE_ADDR	0x6000	/* struct sockaddr */
+
+#define IW_PRIV_SIZE_FIXED	0x0800	/* Variable or fixed number of args */
+
+#define IW_PRIV_SIZE_MASK	0x07FF	/* Max number of those args */
+
+/*
+ * Note : if the number of args is fixed and the size < 16 octets,
+ * instead of passing a pointer we will put args in the iwreq struct...
+ */
+
+/* ----------------------- OTHER CONSTANTS ----------------------- */
+
+/* Maximum frequencies in the range struct */
+#define IW_MAX_FREQUENCIES	32
+/* Note : if you have something like 80 frequencies,
+ * don't increase this constant and don't fill the frequency list.
+ * The user will be able to set by channel anyway... */
+
+/* Maximum bit rates in the range struct */
+#define IW_MAX_BITRATES		32
+
+/* Maximum tx powers in the range struct */
+#define IW_MAX_TXPOWER		8
+/* Note : if you more than 8 TXPowers, just set the max and min or
+ * a few of them in the struct iw_range. */
+
+/* Maximum of address that you may set with SPY */
+#define IW_MAX_SPY		8
+
+/* Maximum of address that you may get in the
+   list of access points in range */
+#define IW_MAX_AP		64
+
+/* Maximum size of the ESSID and NICKN strings */
+#define IW_ESSID_MAX_SIZE	32
+
+/* Modes of operation */
+#define IW_MODE_AUTO	0	/* Let the driver decides */
+#define IW_MODE_ADHOC	1	/* Single cell network */
+#define IW_MODE_INFRA	2	/* Multi cell network, roaming, ... */
+#define IW_MODE_MASTER	3	/* Synchronisation master or Access Point */
+#define IW_MODE_REPEAT	4	/* Wireless Repeater (forwarder) */
+#define IW_MODE_SECOND	5	/* Secondary master/repeater (backup) */
+#define IW_MODE_MONITOR	6	/* Passive monitor (listen only) */
+#define IW_MODE_MESH	7	/* Mesh (IEEE 802.11s) network */
+
+/* Statistics flags (bitmask in updated) */
+#define IW_QUAL_QUAL_UPDATED	0x01	/* Value was updated since last read */
+#define IW_QUAL_LEVEL_UPDATED	0x02
+#define IW_QUAL_NOISE_UPDATED	0x04
+#define IW_QUAL_ALL_UPDATED	0x07
+#define IW_QUAL_DBM		0x08	/* Level + Noise are dBm */
+#define IW_QUAL_QUAL_INVALID	0x10	/* Driver doesn't provide value */
+#define IW_QUAL_LEVEL_INVALID	0x20
+#define IW_QUAL_NOISE_INVALID	0x40
+#define IW_QUAL_RCPI		0x80	/* Level + Noise are 802.11k RCPI */
+#define IW_QUAL_ALL_INVALID	0x70
+
+/* Frequency flags */
+#define IW_FREQ_AUTO		0x00	/* Let the driver decides */
+#define IW_FREQ_FIXED		0x01	/* Force a specific value */
+
+/* Maximum number of size of encoding token available
+ * they are listed in the range structure */
+#define IW_MAX_ENCODING_SIZES	8
+
+/* Maximum size of the encoding token in bytes */
+#define IW_ENCODING_TOKEN_MAX	64	/* 512 bits (for now) */
+
+/* Flags for encoding (along with the token) */
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+
+/* Power management flags available (along with the value, if any) */
+#define IW_POWER_ON		0x0000	/* No details... */
+#define IW_POWER_TYPE		0xF000	/* Type of parameter */
+#define IW_POWER_PERIOD		0x1000	/* Value is a period/duration of  */
+#define IW_POWER_TIMEOUT	0x2000	/* Value is a timeout (to go asleep) */
+#define IW_POWER_MODE		0x0F00	/* Power Management mode */
+#define IW_POWER_UNICAST_R	0x0100	/* Receive only unicast messages */
+#define IW_POWER_MULTICAST_R	0x0200	/* Receive only multicast messages */
+#define IW_POWER_ALL_R		0x0300	/* Receive all messages though PM */
+#define IW_POWER_FORCE_S	0x0400	/* Force PM procedure for sending unicast */
+#define IW_POWER_REPEATER	0x0800	/* Repeat broadcast messages in PM period */
+#define IW_POWER_MODIFIER	0x000F	/* Modify a parameter */
+#define IW_POWER_MIN		0x0001	/* Value is a minimum  */
+#define IW_POWER_MAX		0x0002	/* Value is a maximum */
+#define IW_POWER_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+
+/* Transmit Power flags available */
+#define IW_TXPOW_TYPE		0x00FF	/* Type of value */
+#define IW_TXPOW_DBM		0x0000	/* Value is in dBm */
+#define IW_TXPOW_MWATT		0x0001	/* Value is in mW */
+#define IW_TXPOW_RELATIVE	0x0002	/* Value is in arbitrary units */
+#define IW_TXPOW_RANGE		0x1000	/* Range of value between min/max */
+
+/* Retry limits and lifetime flags available */
+#define IW_RETRY_ON		0x0000	/* No details... */
+#define IW_RETRY_TYPE		0xF000	/* Type of parameter */
+#define IW_RETRY_LIMIT		0x1000	/* Maximum number of retries*/
+#define IW_RETRY_LIFETIME	0x2000	/* Maximum duration of retries in us */
+#define IW_RETRY_MODIFIER	0x00FF	/* Modify a parameter */
+#define IW_RETRY_MIN		0x0001	/* Value is a minimum  */
+#define IW_RETRY_MAX		0x0002	/* Value is a maximum */
+#define IW_RETRY_RELATIVE	0x0004	/* Value is not in seconds/ms/us */
+#define IW_RETRY_SHORT		0x0010	/* Value is for short packets  */
+#define IW_RETRY_LONG		0x0020	/* Value is for long packets */
+
+/* Scanning request flags */
+#define IW_SCAN_DEFAULT		0x0000	/* Default scan of the driver */
+#define IW_SCAN_ALL_ESSID	0x0001	/* Scan all ESSIDs */
+#define IW_SCAN_THIS_ESSID	0x0002	/* Scan only this ESSID */
+#define IW_SCAN_ALL_FREQ	0x0004	/* Scan all Frequencies */
+#define IW_SCAN_THIS_FREQ	0x0008	/* Scan only this Frequency */
+#define IW_SCAN_ALL_MODE	0x0010	/* Scan all Modes */
+#define IW_SCAN_THIS_MODE	0x0020	/* Scan only this Mode */
+#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
+#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
+/* struct iw_scan_req scan_type */
+#define IW_SCAN_TYPE_ACTIVE 0
+#define IW_SCAN_TYPE_PASSIVE 1
+/* Maximum size of returned data */
+#define IW_SCAN_MAX_DATA	4096	/* In bytes */
+
+/* Scan capability flags - in (struct iw_range *)->scan_capa */
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+
+/* Max number of char in custom event - use multiple of them if needed */
+#define IW_CUSTOM_MAX		256	/* In bytes */
+
+/* Generic information element */
+#define IW_GENERIC_IE_MAX	1024
+
+/* MLME requests (SIOCSIWMLME / struct iw_mlme) */
+#define IW_MLME_DEAUTH		0
+#define IW_MLME_DISASSOC	1
+#define IW_MLME_AUTH		2
+#define IW_MLME_ASSOC		3
+
+/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */
+#define IW_AUTH_INDEX		0x0FFF
+#define IW_AUTH_FLAGS		0xF000
+/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)
+ * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the
+ * parameter that is being set/get to; value will be read/written to
+ * struct iw_param value field) */
+#define IW_AUTH_WPA_VERSION		0
+#define IW_AUTH_CIPHER_PAIRWISE		1
+#define IW_AUTH_CIPHER_GROUP		2
+#define IW_AUTH_KEY_MGMT		3
+#define IW_AUTH_TKIP_COUNTERMEASURES	4
+#define IW_AUTH_DROP_UNENCRYPTED	5
+#define IW_AUTH_80211_AUTH_ALG		6
+#define IW_AUTH_WPA_ENABLED		7
+#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8
+#define IW_AUTH_ROAMING_CONTROL		9
+#define IW_AUTH_PRIVACY_INVOKED		10
+#define IW_AUTH_CIPHER_GROUP_MGMT	11
+#define IW_AUTH_MFP			12
+
+/* IW_AUTH_WPA_VERSION values (bit field) */
+#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001
+#define IW_AUTH_WPA_VERSION_WPA		0x00000002
+#define IW_AUTH_WPA_VERSION_WPA2	0x00000004
+
+/* IW_AUTH_PAIRWISE_CIPHER, IW_AUTH_GROUP_CIPHER, and IW_AUTH_CIPHER_GROUP_MGMT
+ * values (bit field) */
+#define IW_AUTH_CIPHER_NONE	0x00000001
+#define IW_AUTH_CIPHER_WEP40	0x00000002
+#define IW_AUTH_CIPHER_TKIP	0x00000004
+#define IW_AUTH_CIPHER_CCMP	0x00000008
+#define IW_AUTH_CIPHER_WEP104	0x00000010
+#define IW_AUTH_CIPHER_AES_CMAC	0x00000020
+
+/* IW_AUTH_KEY_MGMT values (bit field) */
+#define IW_AUTH_KEY_MGMT_802_1X	1
+#define IW_AUTH_KEY_MGMT_PSK	2
+
+/* IW_AUTH_80211_AUTH_ALG values (bit field) */
+#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001
+#define IW_AUTH_ALG_SHARED_KEY	0x00000002
+#define IW_AUTH_ALG_LEAP	0x00000004
+
+/* IW_AUTH_ROAMING_CONTROL values */
+#define IW_AUTH_ROAMING_ENABLE	0	/* driver/firmware based roaming */
+#define IW_AUTH_ROAMING_DISABLE	1	/* user space program used for roaming
+					 * control */
+
+/* IW_AUTH_MFP (management frame protection) values */
+#define IW_AUTH_MFP_DISABLED	0	/* MFP disabled */
+#define IW_AUTH_MFP_OPTIONAL	1	/* MFP optional */
+#define IW_AUTH_MFP_REQUIRED	2	/* MFP required */
+
+/* SIOCSIWENCODEEXT definitions */
+#define IW_ENCODE_SEQ_MAX_SIZE	8
+/* struct iw_encode_ext ->alg */
+#define IW_ENCODE_ALG_NONE	0
+#define IW_ENCODE_ALG_WEP	1
+#define IW_ENCODE_ALG_TKIP	2
+#define IW_ENCODE_ALG_CCMP	3
+#define IW_ENCODE_ALG_PMK	4
+#define IW_ENCODE_ALG_AES_CMAC	5
+/* struct iw_encode_ext ->ext_flags */
+#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001
+#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
+#define IW_ENCODE_EXT_GROUP_KEY		0x00000004
+#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008
+
+/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags */
+#define IW_MICFAILURE_KEY_ID	0x00000003 /* Key ID 0..3 */
+#define IW_MICFAILURE_GROUP	0x00000004
+#define IW_MICFAILURE_PAIRWISE	0x00000008
+#define IW_MICFAILURE_STAKEY	0x00000010
+#define IW_MICFAILURE_COUNT	0x00000060 /* 1 or 2 (0 = count not supported)
+					    */
+
+/* Bit field values for enc_capa in struct iw_range */
+#define IW_ENC_CAPA_WPA		0x00000001
+#define IW_ENC_CAPA_WPA2	0x00000002
+#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004
+#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008
+#define IW_ENC_CAPA_4WAY_HANDSHAKE	0x00000010
+
+/* Event capability macros - in (struct iw_range *)->event_capa
+ * Because we have more than 32 possible events, we use an array of
+ * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */
+#define IW_EVENT_CAPA_BASE(cmd)		((cmd >= SIOCIWFIRSTPRIV) ? \
+					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \
+					 (cmd - SIOCSIWCOMMIT))
+#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) >> 5)
+#define IW_EVENT_CAPA_MASK(cmd)		(1 << (IW_EVENT_CAPA_BASE(cmd) & 0x1F))
+/* Event capability constants - event autogenerated by the kernel
+ * This list is valid for most 802.11 devices, customise as needed... */
+#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \
+				 IW_EVENT_CAPA_MASK(0x8B06) | \
+				 IW_EVENT_CAPA_MASK(0x8B1A))
+#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))
+/* "Easy" macro to set events in iw_range (less efficient) */
+#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))
+#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }
+
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	iw_param
+{
+  __s32		value;		/* The value of the parameter itself */
+  __u8		fixed;		/* Hardware should not use auto select */
+  __u8		disabled;	/* Disable the feature */
+  __u16		flags;		/* Various specifc flags (if any) */
+};
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void *pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+
+/*
+ *	A frequency
+ *	For numbers lower than 10^9, we encode the number in 'm' and
+ *	set 'e' to 0
+ *	For number greater than 10^9, we divide it by the lowest power
+ *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
+ *	The power of 10 is in 'e', the result of the division is in 'm'.
+ */
+struct	iw_freq
+{
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+/*
+ *	Quality of the link
+ */
+struct	iw_quality
+{
+	__u8		qual;		/* link quality (%retries, SNR,
+					   %missed beacons or better...) */
+	__u8		level;		/* signal level (dBm) */
+	__u8		noise;		/* noise level (dBm) */
+	__u8		updated;	/* Flags to know if updated */
+};
+
+/*
+ *	Packet discarded in the wireless adapter due to
+ *	"wireless" specific problems...
+ *	Note : the list of counter and statistics in net_device_stats
+ *	is already pretty exhaustive, and you should use that first.
+ *	This is only additional stats...
+ */
+struct	iw_discarded
+{
+	__u32		nwid;		/* Rx : Wrong nwid/essid */
+	__u32		code;		/* Rx : Unable to code/decode (WEP) */
+	__u32		fragment;	/* Rx : Can't perform MAC reassembly */
+	__u32		retries;	/* Tx : Max MAC retries num reached */
+	__u32		misc;		/* Others cases */
+};
+
+/*
+ *	Packet/Time period missed in the wireless adapter due to
+ *	"wireless" specific problems...
+ */
+struct	iw_missed
+{
+	__u32		beacon;		/* Missed beacons/superframe */
+};
+
+/*
+ *	Quality range (for spy threshold)
+ */
+struct	iw_thrspy
+{
+	struct sockaddr		addr;		/* Source address (hw/mac) */
+	struct iw_quality	qual;		/* Quality of the link */
+	struct iw_quality	low;		/* Low threshold */
+	struct iw_quality	high;		/* High threshold */
+};
+
+/*
+ *	Optional data for scan request
+ *
+ *	Note: these optional parameters are controlling parameters for the
+ *	scanning behavior, these do not apply to getting scan results
+ *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and
+ *	provide a merged results with all BSSes even if the previous scan
+ *	request limited scanning to a subset, e.g., by specifying an SSID.
+ *	Especially, scan results are required to include an entry for the
+ *	current BSS if the driver is in Managed mode and associated with an AP.
+ */
+struct	iw_scan_req
+{
+	__u8		scan_type; /* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */
+	__u8		essid_len;
+	__u8		num_channels; /* num entries in channel_list;
+				       * 0 = scan all allowed channels */
+	__u8		flags; /* reserved as padding; use zero, this may
+				* be used in the future for adding flags
+				* to request different scan behavior */
+	struct sockaddr	bssid; /* ff:ff:ff:ff:ff:ff for broadcast BSSID or
+				* individual address of a specific BSS */
+
+	/*
+	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using
+	 * the current ESSID. This allows scan requests for specific ESSID
+	 * without having to change the current ESSID and potentially breaking
+	 * the current association.
+	 */
+	__u8		essid[IW_ESSID_MAX_SIZE];
+
+	/*
+	 * Optional parameters for changing the default scanning behavior.
+	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.
+	 * TU is 1.024 ms. If these are set to 0, driver is expected to use
+	 * reasonable default values. min_channel_time defines the time that
+	 * will be used to wait for the first reply on each channel. If no
+	 * replies are received, next channel will be scanned after this. If
+	 * replies are received, total time waited on the channel is defined by
+	 * max_channel_time.
+	 */
+	__u32		min_channel_time; /* in TU */
+	__u32		max_channel_time; /* in TU */
+
+	struct iw_freq	channel_list[IW_MAX_FREQUENCIES];
+};
+
+/* ------------------------- WPA SUPPORT ------------------------- */
+
+/*
+ *	Extended data structure for get/set encoding (this is used with
+ *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*
+ *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and
+ *	only the data contents changes (key data -> this structure, including
+ *	key data).
+ *
+ *	If the new key is the first group key, it will be set as the default
+ *	TX key. Otherwise, default TX key index is only changed if
+ *	IW_ENCODE_EXT_SET_TX_KEY flag is set.
+ *
+ *	Key will be changed with SIOCSIWENCODEEXT in all cases except for
+ *	special "change TX key index" operation which is indicated by setting
+ *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.
+ *
+ *	tx_seq/rx_seq are only used when respective
+ *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal
+ *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start
+ *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally
+ *	used only by an Authenticator (AP or an IBSS station) to get the
+ *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and
+ *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for
+ *	debugging/testing.
+ */
+struct	iw_encode_ext
+{
+	__u32		ext_flags; /* IW_ENCODE_EXT_* */
+	__u8		tx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	__u8		rx_seq[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+	struct sockaddr	addr; /* ff:ff:ff:ff:ff:ff for broadcast/multicast
+			       * (group) keys or unicast address for
+			       * individual keys */
+	__u16		alg; /* IW_ENCODE_ALG_* */
+	__u16		key_len;
+	__u8		key[0];
+};
+
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+
+/* SIOCSIWPMKSA data */
+#define IW_PMKSA_ADD		1
+#define IW_PMKSA_REMOVE		2
+#define IW_PMKSA_FLUSH		3
+
+#define IW_PMKID_LEN	16
+
+struct	iw_pmksa
+{
+	__u32		cmd; /* IW_PMKSA_* */
+	struct sockaddr	bssid;
+	__u8		pmkid[IW_PMKID_LEN];
+};
+
+/* IWEVMICHAELMICFAILURE data */
+struct	iw_michaelmicfailure
+{
+	__u32		flags;
+	struct sockaddr	src_addr;
+	__u8		tsc[IW_ENCODE_SEQ_MAX_SIZE]; /* LSB first */
+};
+
+/* IWEVPMKIDCAND data */
+#define IW_PMKID_CAND_PREAUTH	0x00000001 /* RNS pre-authentication enabled */
+struct	iw_pmkid_cand
+{
+	__u32		flags; /* IW_PMKID_CAND_* */
+	__u32		index; /* the smaller the index, the higher the
+				* priority */
+	struct sockaddr	bssid;
+};
+
+/* ------------------------ WIRELESS STATS ------------------------ */
+/*
+ * Wireless statistics (used for /proc/net/wireless)
+ */
+struct	iw_statistics
+{
+	__u16		status;		/* Status
+					 * - device dependent for now */
+
+	struct iw_quality	qual;		/* Quality of the link
+						 * (instant/mean/max) */
+	struct iw_discarded	discard;	/* Packet discarded counts */
+	struct iw_missed	miss;		/* Packet missed counts */
+};
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used 
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	essid;		/* Extended network name */
+	struct iw_param	nwid;		/* network id (or domain - the cell) */
+	struct iw_freq	freq;		/* frequency or channel :
+					 * 0-1000 = channel
+					 * > 1000 = frequency in Hz */
+
+	struct iw_param	sens;		/* signal level threshold */
+	struct iw_param	bitrate;	/* default bit rate */
+	struct iw_param	txpower;	/* default transmit power */
+	struct iw_param	rts;		/* RTS threshold threshold */
+	struct iw_param	frag;		/* Fragmentation threshold */
+	__u32		mode;		/* Operation mode */
+	struct iw_param	retry;		/* Retry limits & lifetime */
+
+	struct iw_point	encoding;	/* Encoding stuff : tokens */
+	struct iw_param	power;		/* PM duration/timeout */
+	struct iw_quality qual;		/* Quality part of statistics */
+
+	struct sockaddr	ap_addr;	/* Access point address */
+	struct sockaddr	addr;		/* Destination address (hw/mac) */
+
+	struct iw_param	param;		/* Other small parameters */
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq 
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+/* -------------------------- IOCTL DATA -------------------------- */
+/*
+ *	For those ioctl which want to exchange mode data that what could
+ *	fit in the above structure...
+ */
+
+/*
+ *	Range of parameters
+ */
+
+struct	iw_range
+{
+	/* Informative stuff (to choose between different interface) */
+	__u32		throughput;	/* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32		min_nwid;	/* Minimal NWID we are able to set */
+	__u32		max_nwid;	/* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16		old_num_channels;
+	__u8		old_num_frequency;
+
+	/* Scan capabilities */
+	__u8		scan_capa; 	/* IW_SCAN_CAPA_* bit field */
+
+	/* Wireless event capability bitmasks */
+	__u32		event_capa[6];
+
+	/* signal level threshold range */
+	__s32		sensitivity;
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics... */
+	struct iw_quality	max_qual;	/* Quality of the link */
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	struct iw_quality	avg_qual;	/* Quality of the link */
+
+	/* Rates */
+	__u8		num_bitrates;	/* Number of entries in the list */
+	__s32		bitrate[IW_MAX_BITRATES];	/* list, in bps */
+
+	/* RTS threshold */
+	__s32		min_rts;	/* Minimal RTS threshold */
+	__s32		max_rts;	/* Maximal RTS threshold */
+
+	/* Frag threshold */
+	__s32		min_frag;	/* Minimal frag threshold */
+	__s32		max_frag;	/* Maximal frag threshold */
+
+	/* Power Management duration & timeout */
+	__s32		min_pmp;	/* Minimal PM period */
+	__s32		max_pmp;	/* Maximal PM period */
+	__s32		min_pmt;	/* Minimal PM timeout */
+	__s32		max_pmt;	/* Maximal PM timeout */
+	__u16		pmp_flags;	/* How to decode max/min PM period */
+	__u16		pmt_flags;	/* How to decode max/min PM timeout */
+	__u16		pm_capa;	/* What PM options are supported */
+
+	/* Encoder stuff */
+	__u16	encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+	__u8	num_encoding_sizes;	/* Number of entry in the list */
+	__u8	max_encoding_tokens;	/* Max number of tokens */
+	/* For drivers that need a "login/passwd" form */
+	__u8	encoding_login_index;	/* token index for login token */
+
+	/* Transmit power */
+	__u16		txpower_capa;	/* What options are supported */
+	__u8		num_txpower;	/* Number of entries in the list */
+	__s32		txpower[IW_MAX_TXPOWER];	/* list, in bps */
+
+	/* Wireless Extension version info */
+	__u8		we_version_compiled;	/* Must be WIRELESS_EXT */
+	__u8		we_version_source;	/* Last update of source */
+
+	/* Retry limits and lifetime */
+	__u16		retry_capa;	/* What retry options are supported */
+	__u16		retry_flags;	/* How to decode max/min retry limit */
+	__u16		r_time_flags;	/* How to decode max/min retry life */
+	__s32		min_retry;	/* Minimal number of retries */
+	__s32		max_retry;	/* Maximal number of retries */
+	__s32		min_r_time;	/* Minimal retry lifetime */
+	__s32		max_r_time;	/* Maximal retry lifetime */
+
+	/* Frequency */
+	__u16		num_channels;	/* Number of channels [0; num - 1] */
+	__u8		num_frequency;	/* Number of entry in the list */
+	struct iw_freq	freq[IW_MAX_FREQUENCIES];	/* list */
+	/* Note : this frequency list doesn't need to fit channel numbers,
+	 * because each entry contain its channel index */
+
+	__u32		enc_capa;	/* IW_ENC_CAPA_* bit field */
+};
+
+/*
+ * Private ioctl interface information
+ */
+ 
+struct	iw_priv_args
+{
+	__u32		cmd;		/* Number of the ioctl to issue */
+	__u16		set_args;	/* Type and number of args */
+	__u16		get_args;	/* Type and number of args */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+/* ----------------------- WIRELESS EVENTS ----------------------- */
+/*
+ * Wireless events are carried through the rtnetlink socket to user
+ * space. They are encapsulated in the IFLA_WIRELESS field of
+ * a RTM_NEWLINK message.
+ */
+
+/*
+ * A Wireless Event. Contains basically the same data as the ioctl...
+ */
+struct iw_event
+{
+	__u16		len;			/* Real length of this stuff */
+	__u16		cmd;			/* Wireless IOCTL */
+	union iwreq_data	u;		/* IOCTL fixed payload */
+};
+
+/* Size of the Event prefix (including padding and alignement junk) */
+#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
+/* Size of the various events */
+#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)
+#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))
+#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))
+
+/* iw_point events are special. First, the payload (extra data) come at
+ * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,
+ * we omit the pointer, so start at an offset. */
+#define IW_EV_POINT_OFF (((char *) &(((struct iw_point *) NULL)->length)) - \
+			  (char *) NULL)
+#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \
+			 IW_EV_POINT_OFF)
+
+
+/* Size of the Event prefix when packed in stream */
+#define IW_EV_LCP_PK_LEN	(4)
+/* Size of the various events when packed in stream */
+#define IW_EV_CHAR_PK_LEN	(IW_EV_LCP_PK_LEN + IFNAMSIZ)
+#define IW_EV_UINT_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(__u32))
+#define IW_EV_FREQ_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))
+#define IW_EV_PARAM_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))
+#define IW_EV_ADDR_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))
+#define IW_EV_QUAL_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))
+#define IW_EV_POINT_PK_LEN	(IW_EV_LCP_LEN + 4)
+
+#endif	/* _LINUX_WIRELESS_H */
diff -uNr linux-2.6.32/usr/include/linux/x25.h clean_modified/linux-2.6.32/usr/include/linux/x25.h
--- linux-2.6.32/usr/include/linux/x25.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/x25.h	2019-04-14 13:24:03.188133387 -0500
@@ -0,0 +1,150 @@
+/*
+ * These are the public elements of the Linux kernel X.25 implementation.
+ *
+ * 	History
+ *	mar/20/00	Daniela Squassoni Disabling/enabling of facilities 
+ *					  negotiation.
+ *	apr/02/05	Shaun Pereira Selective sub address matching with
+ *					call user data
+ */
+
+#ifndef	X25_KERNEL_H
+#define	X25_KERNEL_H
+
+#include <linux/types.h>
+
+#define	SIOCX25GSUBSCRIP	(SIOCPROTOPRIVATE + 0)
+#define	SIOCX25SSUBSCRIP	(SIOCPROTOPRIVATE + 1)
+#define	SIOCX25GFACILITIES	(SIOCPROTOPRIVATE + 2)
+#define	SIOCX25SFACILITIES	(SIOCPROTOPRIVATE + 3)
+#define	SIOCX25GCALLUSERDATA	(SIOCPROTOPRIVATE + 4)
+#define	SIOCX25SCALLUSERDATA	(SIOCPROTOPRIVATE + 5)
+#define	SIOCX25GCAUSEDIAG	(SIOCPROTOPRIVATE + 6)
+#define SIOCX25SCUDMATCHLEN	(SIOCPROTOPRIVATE + 7)
+#define SIOCX25CALLACCPTAPPRV   (SIOCPROTOPRIVATE + 8)
+#define SIOCX25SENDCALLACCPT    (SIOCPROTOPRIVATE + 9)
+#define SIOCX25GDTEFACILITIES (SIOCPROTOPRIVATE + 10)
+#define SIOCX25SDTEFACILITIES (SIOCPROTOPRIVATE + 11)
+
+/*
+ *	Values for {get,set}sockopt.
+ */
+#define	X25_QBITINCL		1
+
+/*
+ *	X.25 Packet Size values.
+ */
+#define	X25_PS16		4
+#define	X25_PS32		5
+#define	X25_PS64		6
+#define	X25_PS128		7
+#define	X25_PS256		8
+#define	X25_PS512		9
+#define	X25_PS1024		10
+#define	X25_PS2048		11
+#define	X25_PS4096		12
+
+/*
+ * An X.121 address, it is held as ASCII text, null terminated, up to 15
+ * digits and a null terminator.
+ */
+struct x25_address {
+	char x25_addr[16];
+};
+
+/*
+ *	Linux X.25 Address structure, used for bind, and connect mostly.
+ */
+struct sockaddr_x25 {
+	sa_family_t	   sx25_family;		/* Must be AF_X25 */
+	struct x25_address sx25_addr;		/* X.121 Address */
+};
+
+/*
+ *	DTE/DCE subscription options.
+ *
+ *      As this is missing lots of options, user should expect major
+ *	changes of this structure in 2.5.x which might break compatibilty.
+ *      The somewhat ugly dimension 200-sizeof() is needed to maintain
+ *	backward compatibility.
+ */
+struct x25_subscrip_struct {
+	char device[200-sizeof(unsigned long)];
+	unsigned long	global_facil_mask;	/* 0 to disable negotiation */
+	unsigned int	extended;
+};
+
+/* values for above global_facil_mask */
+
+#define	X25_MASK_REVERSE	0x01	
+#define	X25_MASK_THROUGHPUT	0x02
+#define	X25_MASK_PACKET_SIZE	0x04
+#define	X25_MASK_WINDOW_SIZE	0x08
+
+#define X25_MASK_CALLING_AE 0x10
+#define X25_MASK_CALLED_AE 0x20
+
+
+/*
+ *	Routing table control structure.
+ */
+struct x25_route_struct {
+	struct x25_address address;
+	unsigned int	   sigdigits;
+	char		   device[200];
+};
+
+/*
+ *	Facilities structure.
+ */
+struct x25_facilities {
+	unsigned int	winsize_in, winsize_out;
+	unsigned int	pacsize_in, pacsize_out;
+	unsigned int	throughput;
+	unsigned int	reverse;
+};
+
+/*
+* ITU DTE facilities
+* Only the called and calling address
+* extension are currently implemented.
+* The rest are in place to avoid the struct
+* changing size if someone needs them later
+*/
+
+struct x25_dte_facilities {
+	__u16 delay_cumul;
+	__u16 delay_target;
+	__u16 delay_max;
+	__u8 min_throughput;
+	__u8 expedited;
+	__u8 calling_len;
+	__u8 called_len;
+	__u8 calling_ae[20];
+	__u8 called_ae[20];
+};
+
+/*
+ *	Call User Data structure.
+ */
+struct x25_calluserdata {
+	unsigned int	cudlength;
+	unsigned char	cuddata[128];
+};
+
+/*
+ *	Call clearing Cause and Diagnostic structure.
+ */
+struct x25_causediag {
+	unsigned char	cause;
+	unsigned char	diagnostic;
+};
+
+/*
+ *	Further optional call user data match length selection
+ */
+struct x25_subaddr {
+	unsigned int cudmatchlength;
+};
+
+#endif
diff -uNr linux-2.6.32/usr/include/linux/xattr.h clean_modified/linux-2.6.32/usr/include/linux/xattr.h
--- linux-2.6.32/usr/include/linux/xattr.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/xattr.h	2019-04-14 13:24:03.188802065 -0500
@@ -0,0 +1,17 @@
+/*
+  File: linux/xattr.h
+
+  Extended attributes handling.
+
+  Copyright (C) 2001 by Andreas Gruenbacher <a.gruenbacher@computer.org>
+  Copyright (c) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.
+  Copyright (c) 2004 Red Hat, Inc., James Morris <jmorris@redhat.com>
+*/
+#ifndef _LINUX_XATTR_H
+#define _LINUX_XATTR_H
+
+#define XATTR_CREATE	0x1	/* set value, fail if attr already exists */
+#define XATTR_REPLACE	0x2	/* set value, fail if attr does not exist */
+
+
+#endif	/* _LINUX_XATTR_H */
diff -uNr linux-2.6.32/usr/include/linux/xfrm.h clean_modified/linux-2.6.32/usr/include/linux/xfrm.h
--- linux-2.6.32/usr/include/linux/xfrm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/linux/xfrm.h	2019-04-14 13:24:03.188802065 -0500
@@ -0,0 +1,483 @@
+#ifndef _LINUX_XFRM_H
+#define _LINUX_XFRM_H
+
+#include <linux/types.h>
+
+/* All of the structures in this file may not change size as they are
+ * passed into the kernel from userspace via netlink sockets.
+ */
+
+/* Structure to encapsulate addresses. I do not want to use
+ * "standard" structure. My apologies.
+ */
+typedef union
+{
+	__be32		a4;
+	__be32		a6[4];
+} xfrm_address_t;
+
+/* Ident of a specific xfrm_state. It is used on input to lookup
+ * the state by (spi,daddr,ah/esp) or to store information about
+ * spi, protocol and tunnel address on output.
+ */
+struct xfrm_id
+{
+	xfrm_address_t	daddr;
+	__be32		spi;
+	__u8		proto;
+};
+
+struct xfrm_sec_ctx {
+	__u8	ctx_doi;
+	__u8	ctx_alg;
+	__u16	ctx_len;
+	__u32	ctx_sid;
+	char	ctx_str[0];
+};
+
+/* Security Context Domains of Interpretation */
+#define XFRM_SC_DOI_RESERVED 0
+#define XFRM_SC_DOI_LSM 1
+
+/* Security Context Algorithms */
+#define XFRM_SC_ALG_RESERVED 0
+#define XFRM_SC_ALG_SELINUX 1
+
+/* Selector, used as selector both on policy rules (SPD) and SAs. */
+
+struct xfrm_selector
+{
+	xfrm_address_t	daddr;
+	xfrm_address_t	saddr;
+	__be16	dport;
+	__be16	dport_mask;
+	__be16	sport;
+	__be16	sport_mask;
+	__u16	family;
+	__u8	prefixlen_d;
+	__u8	prefixlen_s;
+	__u8	proto;
+	int	ifindex;
+	__kernel_uid32_t	user;
+};
+
+#define XFRM_INF (~(__u64)0)
+
+struct xfrm_lifetime_cfg
+{
+	__u64	soft_byte_limit;
+	__u64	hard_byte_limit;
+	__u64	soft_packet_limit;
+	__u64	hard_packet_limit;
+	__u64	soft_add_expires_seconds;
+	__u64	hard_add_expires_seconds;
+	__u64	soft_use_expires_seconds;
+	__u64	hard_use_expires_seconds;
+};
+
+struct xfrm_lifetime_cur
+{
+	__u64	bytes;
+	__u64	packets;
+	__u64	add_time;
+	__u64	use_time;
+};
+
+struct xfrm_replay_state
+{
+	__u32	oseq;
+	__u32	seq;
+	__u32	bitmap;
+};
+
+struct xfrm_algo {
+	char		alg_name[64];
+	unsigned int	alg_key_len;    /* in bits */
+	char		alg_key[0];
+};
+
+struct xfrm_algo_aead {
+	char		alg_name[64];
+	unsigned int	alg_key_len;	/* in bits */
+	unsigned int	alg_icv_len;	/* in bits */
+	char		alg_key[0];
+};
+
+struct xfrm_stats {
+	__u32	replay_window;
+	__u32	replay;
+	__u32	integrity_failed;
+};
+
+enum
+{
+	XFRM_POLICY_TYPE_MAIN	= 0,
+	XFRM_POLICY_TYPE_SUB	= 1,
+	XFRM_POLICY_TYPE_MAX	= 2,
+	XFRM_POLICY_TYPE_ANY	= 255
+};
+
+enum
+{
+	XFRM_POLICY_IN	= 0,
+	XFRM_POLICY_OUT	= 1,
+	XFRM_POLICY_FWD	= 2,
+	XFRM_POLICY_MASK = 3,
+	XFRM_POLICY_MAX	= 3
+};
+
+enum
+{
+	XFRM_SHARE_ANY,		/* No limitations */
+	XFRM_SHARE_SESSION,	/* For this session only */
+	XFRM_SHARE_USER,	/* For this user only */
+	XFRM_SHARE_UNIQUE	/* Use once */
+};
+
+#define XFRM_MODE_TRANSPORT 0
+#define XFRM_MODE_TUNNEL 1
+#define XFRM_MODE_ROUTEOPTIMIZATION 2
+#define XFRM_MODE_IN_TRIGGER 3
+#define XFRM_MODE_BEET 4
+#define XFRM_MODE_MAX 5
+
+/* Netlink configuration messages.  */
+enum {
+	XFRM_MSG_BASE = 0x10,
+
+	XFRM_MSG_NEWSA = 0x10,
+#define XFRM_MSG_NEWSA XFRM_MSG_NEWSA
+	XFRM_MSG_DELSA,
+#define XFRM_MSG_DELSA XFRM_MSG_DELSA
+	XFRM_MSG_GETSA,
+#define XFRM_MSG_GETSA XFRM_MSG_GETSA
+
+	XFRM_MSG_NEWPOLICY,
+#define XFRM_MSG_NEWPOLICY XFRM_MSG_NEWPOLICY
+	XFRM_MSG_DELPOLICY,
+#define XFRM_MSG_DELPOLICY XFRM_MSG_DELPOLICY
+	XFRM_MSG_GETPOLICY,
+#define XFRM_MSG_GETPOLICY XFRM_MSG_GETPOLICY
+
+	XFRM_MSG_ALLOCSPI,
+#define XFRM_MSG_ALLOCSPI XFRM_MSG_ALLOCSPI
+	XFRM_MSG_ACQUIRE,
+#define XFRM_MSG_ACQUIRE XFRM_MSG_ACQUIRE
+	XFRM_MSG_EXPIRE,
+#define XFRM_MSG_EXPIRE XFRM_MSG_EXPIRE
+
+	XFRM_MSG_UPDPOLICY,
+#define XFRM_MSG_UPDPOLICY XFRM_MSG_UPDPOLICY
+	XFRM_MSG_UPDSA,
+#define XFRM_MSG_UPDSA XFRM_MSG_UPDSA
+
+	XFRM_MSG_POLEXPIRE,
+#define XFRM_MSG_POLEXPIRE XFRM_MSG_POLEXPIRE
+
+	XFRM_MSG_FLUSHSA,
+#define XFRM_MSG_FLUSHSA XFRM_MSG_FLUSHSA
+	XFRM_MSG_FLUSHPOLICY,
+#define XFRM_MSG_FLUSHPOLICY XFRM_MSG_FLUSHPOLICY
+
+	XFRM_MSG_NEWAE,
+#define XFRM_MSG_NEWAE XFRM_MSG_NEWAE
+	XFRM_MSG_GETAE,
+#define XFRM_MSG_GETAE XFRM_MSG_GETAE
+
+	XFRM_MSG_REPORT,
+#define XFRM_MSG_REPORT XFRM_MSG_REPORT
+
+	XFRM_MSG_MIGRATE,
+#define XFRM_MSG_MIGRATE XFRM_MSG_MIGRATE
+
+	XFRM_MSG_NEWSADINFO,
+#define XFRM_MSG_NEWSADINFO XFRM_MSG_NEWSADINFO
+	XFRM_MSG_GETSADINFO,
+#define XFRM_MSG_GETSADINFO XFRM_MSG_GETSADINFO
+
+	XFRM_MSG_NEWSPDINFO,
+#define XFRM_MSG_NEWSPDINFO XFRM_MSG_NEWSPDINFO
+	XFRM_MSG_GETSPDINFO,
+#define XFRM_MSG_GETSPDINFO XFRM_MSG_GETSPDINFO
+
+	XFRM_MSG_MAPPING,
+#define XFRM_MSG_MAPPING XFRM_MSG_MAPPING
+	__XFRM_MSG_MAX
+};
+#define XFRM_MSG_MAX (__XFRM_MSG_MAX - 1)
+
+#define XFRM_NR_MSGTYPES (XFRM_MSG_MAX + 1 - XFRM_MSG_BASE)
+
+/*
+ * Generic LSM security context for comunicating to user space
+ * NOTE: Same format as sadb_x_sec_ctx
+ */
+struct xfrm_user_sec_ctx {
+	__u16			len;
+	__u16			exttype;
+	__u8			ctx_alg;  /* LSMs: e.g., selinux == 1 */
+	__u8			ctx_doi;
+	__u16			ctx_len;
+};
+
+struct xfrm_user_tmpl {
+	struct xfrm_id		id;
+	__u16			family;
+	xfrm_address_t		saddr;
+	__u32			reqid;
+	__u8			mode;
+	__u8			share;
+	__u8			optional;
+	__u32			aalgos;
+	__u32			ealgos;
+	__u32			calgos;
+};
+
+struct xfrm_encap_tmpl {
+	__u16		encap_type;
+	__be16		encap_sport;
+	__be16		encap_dport;
+	xfrm_address_t	encap_oa;
+};
+
+/* AEVENT flags  */
+enum xfrm_ae_ftype_t {
+	XFRM_AE_UNSPEC,
+	XFRM_AE_RTHR=1,	/* replay threshold*/
+	XFRM_AE_RVAL=2, /* replay value */
+	XFRM_AE_LVAL=4, /* lifetime value */
+	XFRM_AE_ETHR=8, /* expiry timer threshold */
+	XFRM_AE_CR=16, /* Event cause is replay update */
+	XFRM_AE_CE=32, /* Event cause is timer expiry */
+	XFRM_AE_CU=64, /* Event cause is policy update */
+	__XFRM_AE_MAX
+
+#define XFRM_AE_MAX (__XFRM_AE_MAX - 1)
+};
+
+struct xfrm_userpolicy_type {
+	__u8		type;
+	__u16		reserved1;
+	__u8		reserved2;
+};
+
+/* Netlink message attributes.  */
+enum xfrm_attr_type_t {
+	XFRMA_UNSPEC,
+	XFRMA_ALG_AUTH,		/* struct xfrm_algo */
+	XFRMA_ALG_CRYPT,	/* struct xfrm_algo */
+	XFRMA_ALG_COMP,		/* struct xfrm_algo */
+	XFRMA_ENCAP,		/* struct xfrm_algo + struct xfrm_encap_tmpl */
+	XFRMA_TMPL,		/* 1 or more struct xfrm_user_tmpl */
+	XFRMA_SA,
+	XFRMA_POLICY,
+	XFRMA_SEC_CTX,		/* struct xfrm_sec_ctx */
+	XFRMA_LTIME_VAL,
+	XFRMA_REPLAY_VAL,
+	XFRMA_REPLAY_THRESH,
+	XFRMA_ETIMER_THRESH,
+	XFRMA_SRCADDR,		/* xfrm_address_t */
+	XFRMA_COADDR,		/* xfrm_address_t */
+	XFRMA_LASTUSED,
+	XFRMA_POLICY_TYPE,	/* struct xfrm_userpolicy_type */
+	XFRMA_MIGRATE,
+	XFRMA_ALG_AEAD,		/* struct xfrm_algo_aead */
+	XFRMA_KMADDRESS,        /* struct xfrm_user_kmaddress */
+	__XFRMA_MAX
+
+#define XFRMA_MAX (__XFRMA_MAX - 1)
+};
+
+enum xfrm_sadattr_type_t {
+	XFRMA_SAD_UNSPEC,
+	XFRMA_SAD_CNT,
+	XFRMA_SAD_HINFO,
+	__XFRMA_SAD_MAX
+
+#define XFRMA_SAD_MAX (__XFRMA_SAD_MAX - 1)
+};
+
+struct xfrmu_sadhinfo {
+	__u32 sadhcnt; /* current hash bkts */
+	__u32 sadhmcnt; /* max allowed hash bkts */
+};
+
+enum xfrm_spdattr_type_t {
+	XFRMA_SPD_UNSPEC,
+	XFRMA_SPD_INFO,
+	XFRMA_SPD_HINFO,
+	__XFRMA_SPD_MAX
+
+#define XFRMA_SPD_MAX (__XFRMA_SPD_MAX - 1)
+};
+
+struct xfrmu_spdinfo {
+	__u32 incnt;
+	__u32 outcnt;
+	__u32 fwdcnt;
+	__u32 inscnt;
+	__u32 outscnt;
+	__u32 fwdscnt;
+};
+
+struct xfrmu_spdhinfo {
+	__u32 spdhcnt;
+	__u32 spdhmcnt;
+};
+
+struct xfrm_usersa_info {
+	struct xfrm_selector		sel;
+	struct xfrm_id			id;
+	xfrm_address_t			saddr;
+	struct xfrm_lifetime_cfg	lft;
+	struct xfrm_lifetime_cur	curlft;
+	struct xfrm_stats		stats;
+	__u32				seq;
+	__u32				reqid;
+	__u16				family;
+	__u8				mode;		/* XFRM_MODE_xxx */
+	__u8				replay_window;
+	__u8				flags;
+#define XFRM_STATE_NOECN	1
+#define XFRM_STATE_DECAP_DSCP	2
+#define XFRM_STATE_NOPMTUDISC	4
+#define XFRM_STATE_WILDRECV	8
+#define XFRM_STATE_ICMP		16
+#define XFRM_STATE_AF_UNSPEC	32
+};
+
+struct xfrm_usersa_id {
+	xfrm_address_t			daddr;
+	__be32				spi;
+	__u16				family;
+	__u8				proto;
+};
+
+struct xfrm_aevent_id {
+	struct xfrm_usersa_id		sa_id;
+	xfrm_address_t			saddr;
+	__u32				flags;
+	__u32				reqid;
+};
+
+struct xfrm_userspi_info {
+	struct xfrm_usersa_info		info;
+	__u32				min;
+	__u32				max;
+};
+
+struct xfrm_userpolicy_info {
+	struct xfrm_selector		sel;
+	struct xfrm_lifetime_cfg	lft;
+	struct xfrm_lifetime_cur	curlft;
+	__u32				priority;
+	__u32				index;
+	__u8				dir;
+	__u8				action;
+#define XFRM_POLICY_ALLOW	0
+#define XFRM_POLICY_BLOCK	1
+	__u8				flags;
+#define XFRM_POLICY_LOCALOK	1	/* Allow user to override global policy */
+	/* Automatically expand selector to include matching ICMP payloads. */
+#define XFRM_POLICY_ICMP	2
+	__u8				share;
+};
+
+struct xfrm_userpolicy_id {
+	struct xfrm_selector		sel;
+	__u32				index;
+	__u8				dir;
+};
+
+struct xfrm_user_acquire {
+	struct xfrm_id			id;
+	xfrm_address_t			saddr;
+	struct xfrm_selector		sel;
+	struct xfrm_userpolicy_info	policy;
+	__u32				aalgos;
+	__u32				ealgos;
+	__u32				calgos;
+	__u32				seq;
+};
+
+struct xfrm_user_expire {
+	struct xfrm_usersa_info		state;
+	__u8				hard;
+};
+
+struct xfrm_user_polexpire {
+	struct xfrm_userpolicy_info	pol;
+	__u8				hard;
+};
+
+struct xfrm_usersa_flush {
+	__u8				proto;
+};
+
+struct xfrm_user_report {
+	__u8				proto;
+	struct xfrm_selector		sel;
+};
+
+/* Used by MIGRATE to pass addresses IKE should use to perform
+ * SA negotiation with the peer */
+struct xfrm_user_kmaddress {
+	xfrm_address_t                  local;
+	xfrm_address_t                  remote;
+	__u32				reserved;
+	__u16				family;
+};
+
+struct xfrm_user_migrate {
+	xfrm_address_t			old_daddr;
+	xfrm_address_t			old_saddr;
+	xfrm_address_t			new_daddr;
+	xfrm_address_t			new_saddr;
+	__u8				proto;
+	__u8				mode;
+	__u16				reserved;
+	__u32				reqid;
+	__u16				old_family;
+	__u16				new_family;
+};
+
+struct xfrm_user_mapping {
+	struct xfrm_usersa_id		id;
+	__u32				reqid;
+	xfrm_address_t			old_saddr;
+	xfrm_address_t			new_saddr;
+	__be16				old_sport;
+	__be16				new_sport;
+};
+
+/* backwards compatibility for userspace */
+#define XFRMGRP_ACQUIRE		1
+#define XFRMGRP_EXPIRE		2
+#define XFRMGRP_SA		4
+#define XFRMGRP_POLICY		8
+#define XFRMGRP_REPORT		0x20
+
+enum xfrm_nlgroups {
+	XFRMNLGRP_NONE,
+#define XFRMNLGRP_NONE		XFRMNLGRP_NONE
+	XFRMNLGRP_ACQUIRE,
+#define XFRMNLGRP_ACQUIRE	XFRMNLGRP_ACQUIRE
+	XFRMNLGRP_EXPIRE,
+#define XFRMNLGRP_EXPIRE	XFRMNLGRP_EXPIRE
+	XFRMNLGRP_SA,
+#define XFRMNLGRP_SA		XFRMNLGRP_SA
+	XFRMNLGRP_POLICY,
+#define XFRMNLGRP_POLICY	XFRMNLGRP_POLICY
+	XFRMNLGRP_AEVENTS,
+#define XFRMNLGRP_AEVENTS	XFRMNLGRP_AEVENTS
+	XFRMNLGRP_REPORT,
+#define XFRMNLGRP_REPORT	XFRMNLGRP_REPORT
+	XFRMNLGRP_MIGRATE,
+#define XFRMNLGRP_MIGRATE	XFRMNLGRP_MIGRATE
+	XFRMNLGRP_MAPPING,
+#define XFRMNLGRP_MAPPING	XFRMNLGRP_MAPPING
+	__XFRMNLGRP_MAX
+};
+#define XFRMNLGRP_MAX	(__XFRMNLGRP_MAX - 1)
+
+#endif /* _LINUX_XFRM_H */
diff -uNr linux-2.6.32/usr/include/mtd/inftl-user.h clean_modified/linux-2.6.32/usr/include/mtd/inftl-user.h
--- linux-2.6.32/usr/include/mtd/inftl-user.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/mtd/inftl-user.h	2019-04-14 13:24:03.189980908 -0500
@@ -0,0 +1,91 @@
+/*
+ * Parts of INFTL headers shared with userspace
+ *
+ */
+
+#ifndef __MTD_INFTL_USER_H__
+#define __MTD_INFTL_USER_H__
+
+#include <linux/types.h>
+
+#define	OSAK_VERSION	0x5120
+#define	PERCENTUSED	98
+
+#define	SECTORSIZE	512
+
+/* Block Control Information */
+
+struct inftl_bci {
+	__u8 ECCsig[6];
+	__u8 Status;
+	__u8 Status1;
+} __attribute__((packed));
+
+struct inftl_unithead1 {
+	__u16 virtualUnitNo;
+	__u16 prevUnitNo;
+	__u8 ANAC;
+	__u8 NACs;
+	__u8 parityPerField;
+	__u8 discarded;
+} __attribute__((packed));
+
+struct inftl_unithead2 {
+	__u8 parityPerField;
+	__u8 ANAC;
+	__u16 prevUnitNo;
+	__u16 virtualUnitNo;
+	__u8 NACs;
+	__u8 discarded;
+} __attribute__((packed));
+
+struct inftl_unittail {
+	__u8 Reserved[4];
+	__u16 EraseMark;
+	__u16 EraseMark1;
+} __attribute__((packed));
+
+union inftl_uci {
+	struct inftl_unithead1 a;
+	struct inftl_unithead2 b;
+	struct inftl_unittail c;
+};
+
+struct inftl_oob {
+	struct inftl_bci b;
+	union inftl_uci u;
+};
+
+
+/* INFTL Media Header */
+
+struct INFTLPartition {
+	__u32 virtualUnits;
+	__u32 firstUnit;
+	__u32 lastUnit;
+	__u32 flags;
+	__u32 spareUnits;
+	__u32 Reserved0;
+	__u32 Reserved1;
+} __attribute__((packed));
+
+struct INFTLMediaHeader {
+	char bootRecordID[8];
+	__u32 NoOfBootImageBlocks;
+	__u32 NoOfBinaryPartitions;
+	__u32 NoOfBDTLPartitions;
+	__u32 BlockMultiplierBits;
+	__u32 FormatFlags;
+	__u32 OsakVersion;
+	__u32 PercentUsed;
+	struct INFTLPartition Partitions[4];
+} __attribute__((packed));
+
+/* Partition flag types */
+#define	INFTL_BINARY	0x20000000
+#define	INFTL_BDTL	0x40000000
+#define	INFTL_LAST	0x80000000
+
+#endif /* __MTD_INFTL_USER_H__ */
+
+
diff -uNr linux-2.6.32/usr/include/mtd/mtd-abi.h clean_modified/linux-2.6.32/usr/include/mtd/mtd-abi.h
--- linux-2.6.32/usr/include/mtd/mtd-abi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/mtd/mtd-abi.h	2019-04-14 13:24:03.189980908 -0500
@@ -0,0 +1,167 @@
+/*
+ * Portions of MTD ABI definition which are shared by kernel and user space
+ */
+
+#ifndef __MTD_ABI_H__
+#define __MTD_ABI_H__
+
+#include <linux/types.h>
+
+struct erase_info_user {
+	__u32 start;
+	__u32 length;
+};
+
+struct erase_info_user64 {
+	__u64 start;
+	__u64 length;
+};
+
+struct mtd_oob_buf {
+	__u32 start;
+	__u32 length;
+	unsigned char *ptr;
+};
+
+struct mtd_oob_buf64 {
+	__u64 start;
+	__u32 pad;
+	__u32 length;
+	__u64 usr_ptr;
+};
+
+#define MTD_ABSENT		0
+#define MTD_RAM			1
+#define MTD_ROM			2
+#define MTD_NORFLASH		3
+#define MTD_NANDFLASH		4
+#define MTD_DATAFLASH		6
+#define MTD_UBIVOLUME		7
+
+#define MTD_WRITEABLE		0x400	/* Device is writeable */
+#define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
+#define MTD_NO_ERASE		0x1000	/* No erase necessary */
+#define MTD_POWERUP_LOCK	0x2000	/* Always locked after reset */
+
+// Some common devices / combinations of capabilities
+#define MTD_CAP_ROM		0
+#define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
+#define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
+#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
+
+/* ECC byte placement */
+#define MTD_NANDECC_OFF		0	// Switch off ECC (Not recommended)
+#define MTD_NANDECC_PLACE	1	// Use the given placement in the structure (YAFFS1 legacy mode)
+#define MTD_NANDECC_AUTOPLACE	2	// Use the default placement scheme
+#define MTD_NANDECC_PLACEONLY	3	// Use the given placement in the structure (Do not store ecc result on read)
+#define MTD_NANDECC_AUTOPL_USR 	4	// Use the given autoplacement scheme rather than using the default
+
+/* OTP mode selection */
+#define MTD_OTP_OFF		0
+#define MTD_OTP_FACTORY		1
+#define MTD_OTP_USER		2
+
+struct mtd_info_user {
+	__u8 type;
+	__u32 flags;
+	__u32 size;	 // Total size of the MTD
+	__u32 erasesize;
+	__u32 writesize;
+	__u32 oobsize;   // Amount of OOB data per block (e.g. 16)
+	/* The below two fields are obsolete and broken, do not use them
+	 * (TODO: remove at some point) */
+	__u32 ecctype;
+	__u32 eccsize;
+};
+
+struct region_info_user {
+	__u32 offset;		/* At which this region starts,
+					 * from the beginning of the MTD */
+	__u32 erasesize;		/* For this region */
+	__u32 numblocks;		/* Number of blocks in this region */
+	__u32 regionindex;
+};
+
+struct otp_info {
+	__u32 start;
+	__u32 length;
+	__u32 locked;
+};
+
+#define MEMGETINFO		_IOR('M', 1, struct mtd_info_user)
+#define MEMERASE		_IOW('M', 2, struct erase_info_user)
+#define MEMWRITEOOB		_IOWR('M', 3, struct mtd_oob_buf)
+#define MEMREADOOB		_IOWR('M', 4, struct mtd_oob_buf)
+#define MEMLOCK			_IOW('M', 5, struct erase_info_user)
+#define MEMUNLOCK		_IOW('M', 6, struct erase_info_user)
+#define MEMGETREGIONCOUNT	_IOR('M', 7, int)
+#define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
+#define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
+#define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
+#define MEMGETBADBLOCK		_IOW('M', 11, __kernel_loff_t)
+#define MEMSETBADBLOCK		_IOW('M', 12, __kernel_loff_t)
+#define OTPSELECT		_IOR('M', 13, int)
+#define OTPGETREGIONCOUNT	_IOW('M', 14, int)
+#define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
+#define OTPLOCK			_IOR('M', 16, struct otp_info)
+#define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
+#define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
+#define MTDFILEMODE		_IO('M', 19)
+#define MEMERASE64		_IOW('M', 20, struct erase_info_user64)
+#define MEMWRITEOOB64		_IOWR('M', 21, struct mtd_oob_buf64)
+#define MEMREADOOB64		_IOWR('M', 22, struct mtd_oob_buf64)
+
+/*
+ * Obsolete legacy interface. Keep it in order not to break userspace
+ * interfaces
+ */
+struct nand_oobinfo {
+	__u32 useecc;
+	__u32 eccbytes;
+	__u32 oobfree[8][2];
+	__u32 eccpos[32];
+};
+
+struct nand_oobfree {
+	__u32 offset;
+	__u32 length;
+};
+
+#define MTD_MAX_OOBFREE_ENTRIES	8
+/*
+ * ECC layout control structure. Exported to userspace for
+ * diagnosis and to allow creation of raw images
+ */
+struct nand_ecclayout {
+	__u32 eccbytes;
+	__u32 eccpos[64];
+	__u32 oobavail;
+	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
+};
+
+/**
+ * struct mtd_ecc_stats - error correction stats
+ *
+ * @corrected:	number of corrected bits
+ * @failed:	number of uncorrectable errors
+ * @badblocks:	number of bad blocks in this partition
+ * @bbtblocks:	number of blocks reserved for bad block tables
+ */
+struct mtd_ecc_stats {
+	__u32 corrected;
+	__u32 failed;
+	__u32 badblocks;
+	__u32 bbtblocks;
+};
+
+/*
+ * Read/write file modes for access to MTD
+ */
+enum mtd_file_modes {
+	MTD_MODE_NORMAL = MTD_OTP_OFF,
+	MTD_MODE_OTP_FACTORY = MTD_OTP_FACTORY,
+	MTD_MODE_OTP_USER = MTD_OTP_USER,
+	MTD_MODE_RAW,
+};
+
+#endif /* __MTD_ABI_H__ */
diff -uNr linux-2.6.32/usr/include/mtd/mtd-user.h clean_modified/linux-2.6.32/usr/include/mtd/mtd-user.h
--- linux-2.6.32/usr/include/mtd/mtd-user.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/mtd/mtd-user.h	2019-04-14 13:24:03.189980908 -0500
@@ -0,0 +1,19 @@
+/*
+ * MTD ABI header for use by user space only.
+ */
+
+#ifndef __MTD_USER_H__
+#define __MTD_USER_H__
+
+#include <stdint.h>
+
+/* This file is blessed for inclusion by userspace */
+#include <mtd/mtd-abi.h>
+
+typedef struct mtd_info_user mtd_info_t;
+typedef struct erase_info_user erase_info_t;
+typedef struct region_info_user region_info_t;
+typedef struct nand_oobinfo nand_oobinfo_t;
+typedef struct nand_ecclayout nand_ecclayout_t;
+
+#endif /* __MTD_USER_H__ */
diff -uNr linux-2.6.32/usr/include/mtd/nftl-user.h clean_modified/linux-2.6.32/usr/include/mtd/nftl-user.h
--- linux-2.6.32/usr/include/mtd/nftl-user.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/mtd/nftl-user.h	2019-04-14 13:24:03.190957388 -0500
@@ -0,0 +1,76 @@
+/*
+ * Parts of NFTL headers shared with userspace
+ *
+ */
+
+#ifndef __MTD_NFTL_USER_H__
+#define __MTD_NFTL_USER_H__
+
+#include <linux/types.h>
+
+/* Block Control Information */
+
+struct nftl_bci {
+	unsigned char ECCSig[6];
+	__u8 Status;
+	__u8 Status1;
+}__attribute__((packed));
+
+/* Unit Control Information */
+
+struct nftl_uci0 {
+	__u16 VirtUnitNum;
+	__u16 ReplUnitNum;
+	__u16 SpareVirtUnitNum;
+	__u16 SpareReplUnitNum;
+} __attribute__((packed));
+
+struct nftl_uci1 {
+	__u32 WearInfo;
+	__u16 EraseMark;
+	__u16 EraseMark1;
+} __attribute__((packed));
+
+struct nftl_uci2 {
+        __u16 FoldMark;
+        __u16 FoldMark1;
+	__u32 unused;
+} __attribute__((packed));
+
+union nftl_uci {
+	struct nftl_uci0 a;
+	struct nftl_uci1 b;
+	struct nftl_uci2 c;
+};
+
+struct nftl_oob {
+	struct nftl_bci b;
+	union nftl_uci u;
+};
+
+/* NFTL Media Header */
+
+struct NFTLMediaHeader {
+	char DataOrgID[6];
+	__u16 NumEraseUnits;
+	__u16 FirstPhysicalEUN;
+	__u32 FormattedSize;
+	unsigned char UnitSizeFactor;
+} __attribute__((packed));
+
+#define MAX_ERASE_ZONES (8192 - 512)
+
+#define ERASE_MARK 0x3c69
+#define SECTOR_FREE 0xff
+#define SECTOR_USED 0x55
+#define SECTOR_IGNORE 0x11
+#define SECTOR_DELETED 0x00
+
+#define FOLD_MARK_IN_PROGRESS 0x5555
+
+#define ZONE_GOOD 0xff
+#define ZONE_BAD_ORIGINAL 0
+#define ZONE_BAD_MARKED 7
+
+
+#endif /* __MTD_NFTL_USER_H__ */
diff -uNr linux-2.6.32/usr/include/mtd/ubi-user.h clean_modified/linux-2.6.32/usr/include/mtd/ubi-user.h
--- linux-2.6.32/usr/include/mtd/ubi-user.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/mtd/ubi-user.h	2019-04-14 13:24:03.190957388 -0500
@@ -0,0 +1,412 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Artem Bityutskiy (Битюцкий Артём)
+ */
+
+#ifndef __UBI_USER_H__
+#define __UBI_USER_H__
+
+#include <linux/types.h>
+
+/*
+ * UBI device creation (the same as MTD device attachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI
+ * control device. The caller has to properly fill and pass
+ * &struct ubi_attach_req object - UBI will attach the MTD device specified in
+ * the request and return the newly created UBI device number as the ioctl
+ * return value.
+ *
+ * UBI device deletion (the same as MTD device detachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI
+ * control device.
+ *
+ * UBI volume creation
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character
+ * device. A &struct ubi_mkvol_req object has to be properly filled and a
+ * pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume deletion
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character
+ * device should be used. A pointer to the 32-bit volume ID hast to be passed
+ * to the ioctl.
+ *
+ * UBI volume re-size
+ * ~~~~~~~~~~~~~~~~~~
+ *
+ * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character
+ * device should be used. A &struct ubi_rsvol_req object has to be properly
+ * filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volumes re-name
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command
+ * of the UBI character device should be used. A &struct ubi_rnvol_req object
+ * has to be properly filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume update
+ * ~~~~~~~~~~~~~~~~~
+ *
+ * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the
+ * corresponding UBI volume character device. A pointer to a 64-bit update
+ * size should be passed to the ioctl. After this, UBI expects user to write
+ * this number of bytes to the volume character device. The update is finished
+ * when the claimed number of bytes is passed. So, the volume update sequence
+ * is something like:
+ *
+ * fd = open("/dev/my_volume");
+ * ioctl(fd, UBI_IOCVOLUP, &image_size);
+ * write(fd, buf, image_size);
+ * close(fd);
+ *
+ * Logical eraseblock erase
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the
+ * corresponding UBI volume character device should be used. This command
+ * unmaps the requested logical eraseblock, makes sure the corresponding
+ * physical eraseblock is successfully erased, and returns.
+ *
+ * Atomic logical eraseblock change
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH
+ * ioctl command of the corresponding UBI volume character device. A pointer to
+ * a &struct ubi_leb_change_req object has to be passed to the ioctl. Then the
+ * user is expected to write the requested amount of bytes (similarly to what
+ * should be done in case of the "volume update" ioctl).
+ *
+ * Logical eraseblock map
+ * ~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP
+ * ioctl command should be used. A pointer to a &struct ubi_map_req object is
+ * expected to be passed. The ioctl maps the requested logical eraseblock to
+ * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can
+ * be mapped. If the logical eraseblock specified in the request is already
+ * mapped to a physical eraseblock, the ioctl fails and returns error.
+ *
+ * Logical eraseblock unmap
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP
+ * ioctl command should be used. The ioctl unmaps the logical eraseblocks,
+ * schedules corresponding physical eraseblock for erasure, and returns. Unlike
+ * the "LEB erase" command, it does not wait for the physical eraseblock being
+ * erased. Note, the side effect of this is that if an unclean reboot happens
+ * after the unmap ioctl returns, you may find the LEB mapped again to the same
+ * physical eraseblock after the UBI is run again.
+ *
+ * Check if logical eraseblock is mapped
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To check if a logical eraseblock is mapped to a physical eraseblock, the
+ * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is
+ * not mapped, and %1 if it is mapped.
+ *
+ * Set an UBI volume property
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be
+ * used. A pointer to a &struct ubi_set_prop_req object is expected to be
+ * passed. The object describes which property should be set, and to which value
+ * it should be set.
+ */
+
+/*
+ * When a new UBI volume or UBI device is created, users may either specify the
+ * volume/device number they want to create or to let UBI automatically assign
+ * the number using these constants.
+ */
+#define UBI_VOL_NUM_AUTO (-1)
+#define UBI_DEV_NUM_AUTO (-1)
+
+/* Maximum volume name length */
+#define UBI_MAX_VOLUME_NAME 127
+
+/* ioctl commands of UBI character devices */
+
+#define UBI_IOC_MAGIC 'o'
+
+/* Create an UBI volume */
+#define UBI_IOCMKVOL _IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)
+/* Remove an UBI volume */
+#define UBI_IOCRMVOL _IOW(UBI_IOC_MAGIC, 1, __s32)
+/* Re-size an UBI volume */
+#define UBI_IOCRSVOL _IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)
+/* Re-name volumes */
+#define UBI_IOCRNVOL _IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)
+
+/* ioctl commands of the UBI control character device */
+
+#define UBI_CTRL_IOC_MAGIC 'o'
+
+/* Attach an MTD device */
+#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)
+/* Detach an MTD device */
+#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)
+
+/* ioctl commands of UBI volume character devices */
+
+#define UBI_VOL_IOC_MAGIC 'O'
+
+/* Start UBI volume update */
+#define UBI_IOCVOLUP _IOW(UBI_VOL_IOC_MAGIC, 0, __s64)
+/* LEB erasure command, used for debugging, disabled by default */
+#define UBI_IOCEBER _IOW(UBI_VOL_IOC_MAGIC, 1, __s32)
+/* Atomic LEB change command */
+#define UBI_IOCEBCH _IOW(UBI_VOL_IOC_MAGIC, 2, __s32)
+/* Map LEB command */
+#define UBI_IOCEBMAP _IOW(UBI_VOL_IOC_MAGIC, 3, struct ubi_map_req)
+/* Unmap LEB command */
+#define UBI_IOCEBUNMAP _IOW(UBI_VOL_IOC_MAGIC, 4, __s32)
+/* Check if LEB is mapped command */
+#define UBI_IOCEBISMAP _IOR(UBI_VOL_IOC_MAGIC, 5, __s32)
+/* Set an UBI volume property */
+#define UBI_IOCSETPROP _IOW(UBI_VOL_IOC_MAGIC, 6, struct ubi_set_prop_req)
+
+/* Maximum MTD device name length supported by UBI */
+#define MAX_UBI_MTD_NAME_LEN 127
+
+/* Maximum amount of UBI volumes that can be re-named at one go */
+#define UBI_MAX_RNVOL 32
+
+/*
+ * UBI data type hint constants.
+ *
+ * UBI_LONGTERM: long-term data
+ * UBI_SHORTTERM: short-term data
+ * UBI_UNKNOWN: data persistence is unknown
+ *
+ * These constants are used when data is written to UBI volumes in order to
+ * help the UBI wear-leveling unit to find more appropriate physical
+ * eraseblocks.
+ */
+enum {
+	UBI_LONGTERM  = 1,
+	UBI_SHORTTERM = 2,
+	UBI_UNKNOWN   = 3,
+};
+
+/*
+ * UBI volume type constants.
+ *
+ * @UBI_DYNAMIC_VOLUME: dynamic volume
+ * @UBI_STATIC_VOLUME:  static volume
+ */
+enum {
+	UBI_DYNAMIC_VOLUME = 3,
+	UBI_STATIC_VOLUME  = 4,
+};
+
+/*
+ * UBI set property ioctl constants
+ *
+ * @UBI_PROP_DIRECT_WRITE: allow / disallow user to directly write and
+ *                         erase individual eraseblocks on dynamic volumes
+ */
+enum {
+       UBI_PROP_DIRECT_WRITE = 1,
+};
+
+/**
+ * struct ubi_attach_req - attach MTD device request.
+ * @ubi_num: UBI device number to create
+ * @mtd_num: MTD device number to attach
+ * @vid_hdr_offset: VID header offset (use defaults if %0)
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * This data structure is used to specify MTD device UBI has to attach and the
+ * parameters it has to use. The number which should be assigned to the new UBI
+ * device is passed in @ubi_num. UBI may automatically assign the number if
+ * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in
+ * @ubi_num.
+ *
+ * Most applications should pass %0 in @vid_hdr_offset to make UBI use default
+ * offset of the VID header within physical eraseblocks. The default offset is
+ * the next min. I/O unit after the EC header. For example, it will be offset
+ * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or
+ * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.
+ *
+ * But in rare cases, if this optimizes things, the VID header may be placed to
+ * a different offset. For example, the boot-loader might do things faster if
+ * the VID header sits at the end of the first 2KiB NAND page with 4 sub-pages.
+ * As the boot-loader would not normally need to read EC headers (unless it
+ * needs UBI in RW mode), it might be faster to calculate ECC. This is weird
+ * example, but it real-life example. So, in this example, @vid_hdr_offer would
+ * be 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes
+ * aligned, which is OK, as UBI is clever enough to realize this is 4th
+ * sub-page of the first page and add needed padding.
+ */
+struct ubi_attach_req {
+	__s32 ubi_num;
+	__s32 mtd_num;
+	__s32 vid_hdr_offset;
+	__s8 padding[12];
+};
+
+/**
+ * struct ubi_mkvol_req - volume description data structure used in
+ *                        volume creation requests.
+ * @vol_id: volume number
+ * @alignment: volume alignment
+ * @bytes: volume size in bytes
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @padding1: reserved for future, not used, has to be zeroed
+ * @name_len: volume name length
+ * @padding2: reserved for future, not used, has to be zeroed
+ * @name: volume name
+ *
+ * This structure is used by user-space programs when creating new volumes. The
+ * @used_bytes field is only necessary when creating static volumes.
+ *
+ * The @alignment field specifies the required alignment of the volume logical
+ * eraseblock. This means, that the size of logical eraseblocks will be aligned
+ * to this number, i.e.,
+ *	(UBI device logical eraseblock size) mod (@alignment) = 0.
+ *
+ * To put it differently, the logical eraseblock of this volume may be slightly
+ * shortened in order to make it properly aligned. The alignment has to be
+ * multiple of the flash minimal input/output unit, or %1 to utilize the entire
+ * available space of logical eraseblocks.
+ *
+ * The @alignment field may be useful, for example, when one wants to maintain
+ * a block device on top of an UBI volume. In this case, it is desirable to fit
+ * an integer number of blocks in logical eraseblocks of this UBI volume. With
+ * alignment it is possible to update this volume using plane UBI volume image
+ * BLOBs, without caring about how to properly align them.
+ */
+struct ubi_mkvol_req {
+	__s32 vol_id;
+	__s32 alignment;
+	__s64 bytes;
+	__s8 vol_type;
+	__s8 padding1;
+	__s16 name_len;
+	__s8 padding2[4];
+	char name[UBI_MAX_VOLUME_NAME + 1];
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_rsvol_req - a data structure used in volume re-size requests.
+ * @vol_id: ID of the volume to re-size
+ * @bytes: new size of the volume in bytes
+ *
+ * Re-sizing is possible for both dynamic and static volumes. But while dynamic
+ * volumes may be re-sized arbitrarily, static volumes cannot be made to be
+ * smaller than the number of bytes they bear. To arbitrarily shrink a static
+ * volume, it must be wiped out first (by means of volume update operation with
+ * zero number of bytes).
+ */
+struct ubi_rsvol_req {
+	__s64 bytes;
+	__s32 vol_id;
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_rnvol_req - volumes re-name request.
+ * @count: count of volumes to re-name
+ * @padding1:  reserved for future, not used, has to be zeroed
+ * @vol_id: ID of the volume to re-name
+ * @name_len: name length
+ * @padding2:  reserved for future, not used, has to be zeroed
+ * @name: new volume name
+ *
+ * UBI allows to re-name up to %32 volumes at one go. The count of volumes to
+ * re-name is specified in the @count field. The ID of the volumes to re-name
+ * and the new names are specified in the @vol_id and @name fields.
+ *
+ * The UBI volume re-name operation is atomic, which means that should power cut
+ * happen, the volumes will have either old name or new name. So the possible
+ * use-cases of this command is atomic upgrade. Indeed, to upgrade, say, volumes
+ * A and B one may create temporary volumes %A1 and %B1 with the new contents,
+ * then atomically re-name A1->A and B1->B, in which case old %A and %B will
+ * be removed.
+ *
+ * If it is not desirable to remove old A and B, the re-name request has to
+ * contain 4 entries: A1->A, A->A1, B1->B, B->B1, in which case old A1 and B1
+ * become A and B, and old A and B will become A1 and B1.
+ *
+ * It is also OK to request: A1->A, A1->X, B1->B, B->Y, in which case old A1
+ * and B1 become A and B, and old A and B become X and Y.
+ *
+ * In other words, in case of re-naming into an existing volume name, the
+ * existing volume is removed, unless it is re-named as well at the same
+ * re-name request.
+ */
+struct ubi_rnvol_req {
+	__s32 count;
+	__s8 padding1[12];
+	struct {
+		__s32 vol_id;
+		__s16 name_len;
+		__s8  padding2[2];
+		char    name[UBI_MAX_VOLUME_NAME + 1];
+	} ents[UBI_MAX_RNVOL];
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_leb_change_req - a data structure used in atomic LEB change
+ *                             requests.
+ * @lnum: logical eraseblock number to change
+ * @bytes: how many bytes will be written to the logical eraseblock
+ * @dtype: data type (%UBI_LONGTERM, %UBI_SHORTTERM, %UBI_UNKNOWN)
+ * @padding: reserved for future, not used, has to be zeroed
+ */
+struct ubi_leb_change_req {
+	__s32 lnum;
+	__s32 bytes;
+	__s8  dtype;
+	__s8  padding[7];
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_map_req - a data structure used in map LEB requests.
+ * @lnum: logical eraseblock number to unmap
+ * @dtype: data type (%UBI_LONGTERM, %UBI_SHORTTERM, %UBI_UNKNOWN)
+ * @padding: reserved for future, not used, has to be zeroed
+ */
+struct ubi_map_req {
+	__s32 lnum;
+	__s8  dtype;
+	__s8  padding[3];
+} __attribute__ ((packed));
+
+
+/**
+ * struct ubi_set_prop_req - a data structure used to set an ubi volume
+ *                           property.
+ * @property: property to set (%UBI_PROP_DIRECT_WRITE)
+ * @padding: reserved for future, not used, has to be zeroed
+ * @value: value to set
+ */
+struct ubi_set_prop_req {
+       __u8  property;
+       __u8  padding[7];
+       __u64 value;
+}  __attribute__ ((packed));
+
+#endif /* __UBI_USER_H__ */
diff -uNr linux-2.6.32/usr/include/rdma/ib_user_mad.h clean_modified/linux-2.6.32/usr/include/rdma/ib_user_mad.h
--- linux-2.6.32/usr/include/rdma/ib_user_mad.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/rdma/ib_user_mad.h	2019-04-14 13:24:03.191948089 -0500
@@ -0,0 +1,203 @@
+/*
+ * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2005 Voltaire, Inc. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef IB_USER_MAD_H
+#define IB_USER_MAD_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/*
+ * Increment this value if any changes that break userspace ABI
+ * compatibility are made.
+ */
+#define IB_USER_MAD_ABI_VERSION	5
+
+/*
+ * Make sure that all structs defined in this file remain laid out so
+ * that they pack the same way on 32-bit and 64-bit architectures (to
+ * avoid incompatibility between 32-bit userspace and 64-bit kernels).
+ */
+
+/**
+ * ib_user_mad_hdr_old - Old version of MAD packet header without pkey_index
+ * @id - ID of agent MAD received with/to be sent with
+ * @status - 0 on successful receive, ETIMEDOUT if no response
+ *   received (transaction ID in data[] will be set to TID of original
+ *   request) (ignored on send)
+ * @timeout_ms - Milliseconds to wait for response (unset on receive)
+ * @retries - Number of automatic retries to attempt
+ * @qpn - Remote QP number received from/to be sent to
+ * @qkey - Remote Q_Key to be sent with (unset on receive)
+ * @lid - Remote lid received from/to be sent to
+ * @sl - Service level received with/to be sent with
+ * @path_bits - Local path bits received with/to be sent with
+ * @grh_present - If set, GRH was received/should be sent
+ * @gid_index - Local GID index to send with (unset on receive)
+ * @hop_limit - Hop limit in GRH
+ * @traffic_class - Traffic class in GRH
+ * @gid - Remote GID in GRH
+ * @flow_label - Flow label in GRH
+ */
+struct ib_user_mad_hdr_old {
+	__u32	id;
+	__u32	status;
+	__u32	timeout_ms;
+	__u32	retries;
+	__u32	length;
+	__be32	qpn;
+	__be32  qkey;
+	__be16	lid;
+	__u8	sl;
+	__u8	path_bits;
+	__u8	grh_present;
+	__u8	gid_index;
+	__u8	hop_limit;
+	__u8	traffic_class;
+	__u8	gid[16];
+	__be32	flow_label;
+};
+
+/**
+ * ib_user_mad_hdr - MAD packet header
+ *   This layout allows specifying/receiving the P_Key index.  To use
+ *   this capability, an application must call the
+ *   IB_USER_MAD_ENABLE_PKEY ioctl on the user MAD file handle before
+ *   any other actions with the file handle.
+ * @id - ID of agent MAD received with/to be sent with
+ * @status - 0 on successful receive, ETIMEDOUT if no response
+ *   received (transaction ID in data[] will be set to TID of original
+ *   request) (ignored on send)
+ * @timeout_ms - Milliseconds to wait for response (unset on receive)
+ * @retries - Number of automatic retries to attempt
+ * @qpn - Remote QP number received from/to be sent to
+ * @qkey - Remote Q_Key to be sent with (unset on receive)
+ * @lid - Remote lid received from/to be sent to
+ * @sl - Service level received with/to be sent with
+ * @path_bits - Local path bits received with/to be sent with
+ * @grh_present - If set, GRH was received/should be sent
+ * @gid_index - Local GID index to send with (unset on receive)
+ * @hop_limit - Hop limit in GRH
+ * @traffic_class - Traffic class in GRH
+ * @gid - Remote GID in GRH
+ * @flow_label - Flow label in GRH
+ * @pkey_index - P_Key index
+ */
+struct ib_user_mad_hdr {
+	__u32	id;
+	__u32	status;
+	__u32	timeout_ms;
+	__u32	retries;
+	__u32	length;
+	__be32	qpn;
+	__be32  qkey;
+	__be16	lid;
+	__u8	sl;
+	__u8	path_bits;
+	__u8	grh_present;
+	__u8	gid_index;
+	__u8	hop_limit;
+	__u8	traffic_class;
+	__u8	gid[16];
+	__be32	flow_label;
+	__u16	pkey_index;
+	__u8	reserved[6];
+};
+
+/**
+ * ib_user_mad - MAD packet
+ * @hdr - MAD packet header
+ * @data - Contents of MAD
+ *
+ */
+struct ib_user_mad {
+	struct ib_user_mad_hdr hdr;
+	__u64	data[0];
+};
+
+/*
+ * Earlier versions of this interface definition declared the
+ * method_mask[] member as an array of __u32 but treated it as a
+ * bitmap made up of longs in the kernel.  This ambiguity meant that
+ * 32-bit big-endian applications that can run on both 32-bit and
+ * 64-bit kernels had no consistent ABI to rely on, and 64-bit
+ * big-endian applications that treated method_mask as being made up
+ * of 32-bit words would have their bitmap misinterpreted.
+ *
+ * To clear up this confusion, we change the declaration of
+ * method_mask[] to use unsigned long and handle the conversion from
+ * 32-bit userspace to 64-bit kernel for big-endian systems in the
+ * compat_ioctl method.  Unfortunately, to keep the structure layout
+ * the same, we need the method_mask[] array to be aligned only to 4
+ * bytes even when long is 64 bits, which forces us into this ugly
+ * typedef.
+ */
+typedef unsigned long __attribute__((aligned(4))) packed_ulong;
+#define IB_USER_MAD_LONGS_PER_METHOD_MASK (128 / (8 * sizeof (long)))
+
+/**
+ * ib_user_mad_reg_req - MAD registration request
+ * @id - Set by the kernel; used to identify agent in future requests.
+ * @qpn - Queue pair number; must be 0 or 1.
+ * @method_mask - The caller will receive unsolicited MADs for any method
+ *   where @method_mask = 1.
+ * @mgmt_class - Indicates which management class of MADs should be receive
+ *   by the caller.  This field is only required if the user wishes to
+ *   receive unsolicited MADs, otherwise it should be 0.
+ * @mgmt_class_version - Indicates which version of MADs for the given
+ *   management class to receive.
+ * @oui: Indicates IEEE OUI when mgmt_class is a vendor class
+ *   in the range from 0x30 to 0x4f. Otherwise not used.
+ * @rmpp_version: If set, indicates the RMPP version used.
+ *
+ */
+struct ib_user_mad_reg_req {
+	__u32	id;
+	packed_ulong method_mask[IB_USER_MAD_LONGS_PER_METHOD_MASK];
+	__u8	qpn;
+	__u8	mgmt_class;
+	__u8	mgmt_class_version;
+	__u8    oui[3];
+	__u8	rmpp_version;
+};
+
+#define IB_IOCTL_MAGIC		0x1b
+
+#define IB_USER_MAD_REGISTER_AGENT	_IOWR(IB_IOCTL_MAGIC, 1, \
+					      struct ib_user_mad_reg_req)
+
+#define IB_USER_MAD_UNREGISTER_AGENT	_IOW(IB_IOCTL_MAGIC, 2, __u32)
+
+#define IB_USER_MAD_ENABLE_PKEY		_IO(IB_IOCTL_MAGIC, 3)
+
+#endif /* IB_USER_MAD_H */
diff -uNr linux-2.6.32/usr/include/scsi/scsi_bsg_fc.h clean_modified/linux-2.6.32/usr/include/scsi/scsi_bsg_fc.h
--- linux-2.6.32/usr/include/scsi/scsi_bsg_fc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/scsi/scsi_bsg_fc.h	2019-04-14 13:24:03.208484908 -0500
@@ -0,0 +1,322 @@
+/*
+ *  FC Transport BSG Interface
+ *
+ *  Copyright (C) 2008   James Smart, Emulex Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef SCSI_BSG_FC_H
+#define SCSI_BSG_FC_H
+
+/*
+ * This file intended to be included by both kernel and user space
+ */
+
+#include <scsi/scsi.h>
+
+/*
+ * FC Transport SGIO v4 BSG Message Support
+ */
+
+/* Default BSG request timeout (in seconds) */
+#define FC_DEFAULT_BSG_TIMEOUT		(10 * HZ)
+
+
+/*
+ * Request Message Codes supported by the FC Transport
+ */
+
+/* define the class masks for the message codes */
+#define FC_BSG_CLS_MASK		0xF0000000	/* find object class */
+#define FC_BSG_HST_MASK		0x80000000	/* fc host class */
+#define FC_BSG_RPT_MASK		0x40000000	/* fc rport class */
+
+	/* fc_host Message Codes */
+#define FC_BSG_HST_ADD_RPORT		(FC_BSG_HST_MASK | 0x00000001)
+#define FC_BSG_HST_DEL_RPORT		(FC_BSG_HST_MASK | 0x00000002)
+#define FC_BSG_HST_ELS_NOLOGIN		(FC_BSG_HST_MASK | 0x00000003)
+#define FC_BSG_HST_CT			(FC_BSG_HST_MASK | 0x00000004)
+#define FC_BSG_HST_VENDOR		(FC_BSG_HST_MASK | 0x000000FF)
+
+	/* fc_rport Message Codes */
+#define FC_BSG_RPT_ELS			(FC_BSG_RPT_MASK | 0x00000001)
+#define FC_BSG_RPT_CT			(FC_BSG_RPT_MASK | 0x00000002)
+
+
+
+/*
+ * FC Address Identifiers in Message Structures :
+ *
+ *   Whenever a command payload contains a FC Address Identifier
+ *   (aka port_id), the value is effectively in big-endian
+ *   order, thus the array elements are decoded as follows:
+ *     element [0] is bits 23:16 of the FC Address Identifier
+ *     element [1] is bits 15:8 of the FC Address Identifier
+ *     element [2] is bits 7:0 of the FC Address Identifier
+ */
+
+
+/*
+ * FC Host Messages
+ */
+
+/* FC_BSG_HST_ADDR_PORT : */
+
+/* Request:
+ * This message requests the FC host to login to the remote port
+ * at the specified N_Port_Id.  The remote port is to be enumerated
+ * with the transport upon completion of the login.
+ */
+struct fc_bsg_host_add_rport {
+	uint8_t		reserved;
+
+	/* FC Address Identier of the remote port to login to */
+	uint8_t		port_id[3];
+};
+
+/* Response:
+ * There is no additional response data - fc_bsg_reply->result is sufficient
+ */
+
+
+/* FC_BSG_HST_DEL_RPORT : */
+
+/* Request:
+ * This message requests the FC host to remove an enumerated
+ * remote port and to terminate the login to it.
+ *
+ * Note: The driver is free to reject this request if it desires to
+ * remain logged in with the remote port.
+ */
+struct fc_bsg_host_del_rport {
+	uint8_t		reserved;
+
+	/* FC Address Identier of the remote port to logout of */
+	uint8_t		port_id[3];
+};
+
+/* Response:
+ * There is no additional response data - fc_bsg_reply->result is sufficient
+ */
+
+
+/* FC_BSG_HST_ELS_NOLOGIN : */
+
+/* Request:
+ * This message requests the FC_Host to send an ELS to a specific
+ * N_Port_ID. The host does not need to log into the remote port,
+ * nor does it need to enumerate the rport for further traffic
+ * (although, the FC host is free to do so if it desires).
+ */
+struct fc_bsg_host_els {
+	/*
+	 * ELS Command Code being sent (must be the same as byte 0
+	 * of the payload)
+	 */
+	uint8_t 	command_code;
+
+	/* FC Address Identier of the remote port to send the ELS to */
+	uint8_t		port_id[3];
+};
+
+/* Response:
+ */
+/* fc_bsg_ctels_reply->status values */
+#define FC_CTELS_STATUS_OK	0x00000000
+#define FC_CTELS_STATUS_REJECT	0x00000001
+#define FC_CTELS_STATUS_P_RJT	0x00000002
+#define FC_CTELS_STATUS_F_RJT	0x00000003
+#define FC_CTELS_STATUS_P_BSY	0x00000004
+#define FC_CTELS_STATUS_F_BSY	0x00000006
+struct fc_bsg_ctels_reply {
+	/*
+	 * Note: An ELS LS_RJT may be reported in 2 ways:
+	 *  a) A status of FC_CTELS_STATUS_OK is returned. The caller
+	 *     is to look into the ELS receive payload to determine
+	 *     LS_ACC or LS_RJT (by contents of word 0). The reject
+	 *     data will be in word 1.
+	 *  b) A status of FC_CTELS_STATUS_REJECT is returned, The
+	 *     rjt_data field will contain valid data.
+	 *
+	 * Note: ELS LS_ACC is determined by an FC_CTELS_STATUS_OK, and
+	 *   the receive payload word 0 indicates LS_ACC
+	 *   (e.g. value is 0x02xxxxxx).
+	 *
+	 * Note: Similarly, a CT Reject may be reported in 2 ways:
+	 *  a) A status of FC_CTELS_STATUS_OK is returned. The caller
+	 *     is to look into the CT receive payload to determine
+	 *     Accept or Reject (by contents of word 2). The reject
+	 *     data will be in word 3.
+	 *  b) A status of FC_CTELS_STATUS_REJECT is returned, The
+	 *     rjt_data field will contain valid data.
+	 *
+	 * Note: x_RJT/BSY status will indicae that the rjt_data field
+	 *   is valid and contains the reason/explanation values.
+	 */
+	uint32_t	status;		/* See FC_CTELS_STATUS_xxx */
+
+	/* valid if status is not FC_CTELS_STATUS_OK */
+	struct	{
+		uint8_t	action;		/* fragment_id for CT REJECT */
+		uint8_t	reason_code;
+		uint8_t	reason_explanation;
+		uint8_t	vendor_unique;
+	} rjt_data;
+};
+
+
+/* FC_BSG_HST_CT : */
+
+/* Request:
+ * This message requests that a CT Request be performed with the
+ * indicated N_Port_ID. The driver is responsible for logging in with
+ * the fabric and/or N_Port_ID, etc as per FC rules. This request does
+ * not mandate that the driver must enumerate the destination in the
+ * transport. The driver is allowed to decide whether to enumerate it,
+ * and whether to tear it down after the request.
+ */
+struct fc_bsg_host_ct {
+	uint8_t		reserved;
+
+	/* FC Address Identier of the remote port to send the ELS to */
+	uint8_t		port_id[3];
+
+	/*
+	 * We need words 0-2 of the generic preamble for the LLD's
+	 */
+	uint32_t	preamble_word0;	/* revision & IN_ID */
+	uint32_t	preamble_word1;	/* GS_Type, GS_SubType, Options, Rsvd */
+	uint32_t	preamble_word2;	/* Cmd Code, Max Size */
+
+};
+/* Response:
+ *
+ * The reply structure is an fc_bsg_ctels_reply structure
+ */
+
+
+/* FC_BSG_HST_VENDOR : */
+
+/* Request:
+ * Note: When specifying vendor_id, be sure to read the Vendor Type and ID
+ *   formatting requirements specified in scsi_netlink.h
+ */
+struct fc_bsg_host_vendor {
+	/*
+	 * Identifies the vendor that the message is formatted for. This
+	 * should be the recipient of the message.
+	 */
+	uint64_t vendor_id;
+
+	/* start of vendor command area */
+	uint32_t vendor_cmd[0];
+};
+
+/* Response:
+ */
+struct fc_bsg_host_vendor_reply {
+	/* start of vendor response area */
+	uint32_t vendor_rsp[0];
+};
+
+
+
+/*
+ * FC Remote Port Messages
+ */
+
+/* FC_BSG_RPT_ELS : */
+
+/* Request:
+ * This message requests that an ELS be performed with the rport.
+ */
+struct fc_bsg_rport_els {
+	/*
+	 * ELS Command Code being sent (must be the same as
+	 * byte 0 of the payload)
+	 */
+	uint8_t els_code;
+};
+
+/* Response:
+ *
+ * The reply structure is an fc_bsg_ctels_reply structure
+ */
+
+
+/* FC_BSG_RPT_CT : */
+
+/* Request:
+ * This message requests that a CT Request be performed with the rport.
+ */
+struct fc_bsg_rport_ct {
+	/*
+	 * We need words 0-2 of the generic preamble for the LLD's
+	 */
+	uint32_t	preamble_word0;	/* revision & IN_ID */
+	uint32_t	preamble_word1;	/* GS_Type, GS_SubType, Options, Rsvd */
+	uint32_t	preamble_word2;	/* Cmd Code, Max Size */
+};
+/* Response:
+ *
+ * The reply structure is an fc_bsg_ctels_reply structure
+ */
+
+
+
+
+/* request (CDB) structure of the sg_io_v4 */
+struct fc_bsg_request {
+	uint32_t msgcode;
+	union {
+		struct fc_bsg_host_add_rport	h_addrport;
+		struct fc_bsg_host_del_rport	h_delrport;
+		struct fc_bsg_host_els		h_els;
+		struct fc_bsg_host_ct		h_ct;
+		struct fc_bsg_host_vendor	h_vendor;
+
+		struct fc_bsg_rport_els		r_els;
+		struct fc_bsg_rport_ct		r_ct;
+	} rqst_data;
+};
+
+
+/* response (request sense data) structure of the sg_io_v4 */
+struct fc_bsg_reply {
+	/*
+	 * The completion result. Result exists in two forms:
+	 *  if negative, it is an -Exxx system errno value. There will
+	 *    be no further reply information supplied.
+	 *  else, it's the 4-byte scsi error result, with driver, host,
+	 *    msg and status fields. The per-msgcode reply structure
+	 *    will contain valid data.
+	 */
+	uint32_t result;
+
+	/* If there was reply_payload, how much was recevied ? */
+	uint32_t reply_payload_rcv_len;
+
+	union {
+		struct fc_bsg_host_vendor_reply		vendor_reply;
+
+		struct fc_bsg_ctels_reply		ctels_reply;
+	} reply_data;
+};
+
+
+#endif /* SCSI_BSG_FC_H */
+
diff -uNr linux-2.6.32/usr/include/scsi/scsi.h clean_modified/linux-2.6.32/usr/include/scsi/scsi.h
--- linux-2.6.32/usr/include/scsi/scsi.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/scsi/scsi.h	2019-04-14 13:24:03.209464120 -0500
@@ -0,0 +1,514 @@
+/*
+ * This header file contains public constants and structures used by
+ * the scsi code for linux.
+ *
+ * For documentation on the OPCODES, MESSAGES, and SENSE values,
+ * please consult the SCSI standard.
+ */
+#ifndef _SCSI_SCSI_H
+#define _SCSI_SCSI_H
+
+#include <linux/types.h>
+
+struct scsi_cmnd;
+
+/*
+ * The maximum number of SG segments that we will put inside a
+ * scatterlist (unless chaining is used). Should ideally fit inside a
+ * single page, to avoid a higher order allocation.  We could define this
+ * to SG_MAX_SINGLE_ALLOC to pack correctly at the highest order.  The
+ * minimum value is 32
+ */
+#define SCSI_MAX_SG_SEGMENTS	128
+
+/*
+ * Like SCSI_MAX_SG_SEGMENTS, but for archs that have sg chaining. This limit
+ * is totally arbitrary, a setting of 2048 will get you at least 8mb ios.
+ */
+#ifdef ARCH_HAS_SG_CHAIN
+#define SCSI_MAX_SG_CHAIN_SEGMENTS	2048
+#else
+#define SCSI_MAX_SG_CHAIN_SEGMENTS	SCSI_MAX_SG_SEGMENTS
+#endif
+
+/*
+ * Special value for scanning to specify scanning or rescanning of all
+ * possible channels, (target) ids, or luns on a given shost.
+ */
+#define SCAN_WILD_CARD	~0
+
+/*
+ *      SCSI opcodes
+ */
+
+#define TEST_UNIT_READY       0x00
+#define REZERO_UNIT           0x01
+#define REQUEST_SENSE         0x03
+#define FORMAT_UNIT           0x04
+#define READ_BLOCK_LIMITS     0x05
+#define REASSIGN_BLOCKS       0x07
+#define INITIALIZE_ELEMENT_STATUS 0x07
+#define READ_6                0x08
+#define WRITE_6               0x0a
+#define SEEK_6                0x0b
+#define READ_REVERSE          0x0f
+#define WRITE_FILEMARKS       0x10
+#define SPACE                 0x11
+#define INQUIRY               0x12
+#define RECOVER_BUFFERED_DATA 0x14
+#define MODE_SELECT           0x15
+#define RESERVE               0x16
+#define RELEASE               0x17
+#define COPY                  0x18
+#define ERASE                 0x19
+#define MODE_SENSE            0x1a
+#define START_STOP            0x1b
+#define RECEIVE_DIAGNOSTIC    0x1c
+#define SEND_DIAGNOSTIC       0x1d
+#define ALLOW_MEDIUM_REMOVAL  0x1e
+
+#define SET_WINDOW            0x24
+#define READ_CAPACITY         0x25
+#define READ_10               0x28
+#define WRITE_10              0x2a
+#define SEEK_10               0x2b
+#define POSITION_TO_ELEMENT   0x2b
+#define WRITE_VERIFY          0x2e
+#define VERIFY                0x2f
+#define SEARCH_HIGH           0x30
+#define SEARCH_EQUAL          0x31
+#define SEARCH_LOW            0x32
+#define SET_LIMITS            0x33
+#define PRE_FETCH             0x34
+#define READ_POSITION         0x34
+#define SYNCHRONIZE_CACHE     0x35
+#define LOCK_UNLOCK_CACHE     0x36
+#define READ_DEFECT_DATA      0x37
+#define MEDIUM_SCAN           0x38
+#define COMPARE               0x39
+#define COPY_VERIFY           0x3a
+#define WRITE_BUFFER          0x3b
+#define READ_BUFFER           0x3c
+#define UPDATE_BLOCK          0x3d
+#define READ_LONG             0x3e
+#define WRITE_LONG            0x3f
+#define CHANGE_DEFINITION     0x40
+#define WRITE_SAME            0x41
+#define READ_TOC              0x43
+#define LOG_SELECT            0x4c
+#define LOG_SENSE             0x4d
+#define XDWRITEREAD_10        0x53
+#define MODE_SELECT_10        0x55
+#define RESERVE_10            0x56
+#define RELEASE_10            0x57
+#define MODE_SENSE_10         0x5a
+#define PERSISTENT_RESERVE_IN 0x5e
+#define PERSISTENT_RESERVE_OUT 0x5f
+#define VARIABLE_LENGTH_CMD   0x7f
+#define REPORT_LUNS           0xa0
+#define MAINTENANCE_IN        0xa3
+#define MAINTENANCE_OUT       0xa4
+#define MOVE_MEDIUM           0xa5
+#define EXCHANGE_MEDIUM       0xa6
+#define READ_12               0xa8
+#define WRITE_12              0xaa
+#define WRITE_VERIFY_12       0xae
+#define SEARCH_HIGH_12        0xb0
+#define SEARCH_EQUAL_12       0xb1
+#define SEARCH_LOW_12         0xb2
+#define READ_ELEMENT_STATUS   0xb8
+#define SEND_VOLUME_TAG       0xb6
+#define WRITE_LONG_2          0xea
+#define READ_16               0x88
+#define WRITE_16              0x8a
+#define VERIFY_16	      0x8f
+#define SERVICE_ACTION_IN     0x9e
+/* values for service action in */
+#define	SAI_READ_CAPACITY_16  0x10
+/* values for maintenance in */
+#define MI_REPORT_TARGET_PGS  0x0a
+/* values for maintenance out */
+#define MO_SET_TARGET_PGS     0x0a
+/* values for variable length command */
+#define READ_32		      0x09
+#define WRITE_32	      0x0b
+
+/* Values for T10/04-262r7 */
+#define	ATA_16		      0x85	/* 16-byte pass-thru */
+#define	ATA_12		      0xa1	/* 12-byte pass-thru */
+
+/*
+ *	SCSI command lengths
+ */
+
+#define SCSI_MAX_VARLEN_CDB_SIZE 260
+
+/* defined in T10 SCSI Primary Commands-2 (SPC2) */
+struct scsi_varlen_cdb_hdr {
+	u8 opcode;        /* opcode always == VARIABLE_LENGTH_CMD */
+	u8 control;
+	u8 misc[5];
+	u8 additional_cdb_length;         /* total cdb length - 8 */
+	__be16 service_action;
+	/* service specific data follows */
+};
+
+static __inline__ unsigned
+scsi_varlen_cdb_length(const void *hdr)
+{
+	return ((struct scsi_varlen_cdb_hdr *)hdr)->additional_cdb_length + 8;
+}
+
+extern const unsigned char scsi_command_size_tbl[8];
+#define COMMAND_SIZE(opcode) scsi_command_size_tbl[((opcode) >> 5) & 7]
+
+static __inline__ unsigned
+scsi_command_size(const unsigned char *cmnd)
+{
+	return (cmnd[0] == VARIABLE_LENGTH_CMD) ?
+		scsi_varlen_cdb_length(cmnd) : COMMAND_SIZE(cmnd[0]);
+}
+
+/*
+ *  SCSI Architecture Model (SAM) Status codes. Taken from SAM-3 draft
+ *  T10/1561-D Revision 4 Draft dated 7th November 2002.
+ */
+#define SAM_STAT_GOOD            0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+#define SAM_STAT_CONDITION_MET   0x04
+#define SAM_STAT_BUSY            0x08
+#define SAM_STAT_INTERMEDIATE    0x10
+#define SAM_STAT_INTERMEDIATE_CONDITION_MET 0x14
+#define SAM_STAT_RESERVATION_CONFLICT 0x18
+#define SAM_STAT_COMMAND_TERMINATED 0x22	/* obsolete in SAM-3 */
+#define SAM_STAT_TASK_SET_FULL   0x28
+#define SAM_STAT_ACA_ACTIVE      0x30
+#define SAM_STAT_TASK_ABORTED    0x40
+
+/** scsi_status_is_good - check the status return.
+ *
+ * @status: the status passed up from the driver (including host and
+ *          driver components)
+ *
+ * This returns true for known good conditions that may be treated as
+ * command completed normally
+ */
+static __inline__ int scsi_status_is_good(int status)
+{
+	/*
+	 * FIXME: bit0 is listed as reserved in SCSI-2, but is
+	 * significant in SCSI-3.  For now, we follow the SCSI-2
+	 * behaviour and ignore reserved bits.
+	 */
+	status &= 0xfe;
+	return ((status == SAM_STAT_GOOD) ||
+		(status == SAM_STAT_INTERMEDIATE) ||
+		(status == SAM_STAT_INTERMEDIATE_CONDITION_MET) ||
+		/* FIXME: this is obsolete in SAM-3 */
+		(status == SAM_STAT_COMMAND_TERMINATED));
+}
+
+/*
+ *  Status codes. These are deprecated as they are shifted 1 bit right
+ *  from those found in the SCSI standards. This causes confusion for
+ *  applications that are ported to several OSes. Prefer SAM Status codes
+ *  above.
+ */
+
+#define GOOD                 0x00
+#define CHECK_CONDITION      0x01
+#define CONDITION_GOOD       0x02
+#define BUSY                 0x04
+#define INTERMEDIATE_GOOD    0x08
+#define INTERMEDIATE_C_GOOD  0x0a
+#define RESERVATION_CONFLICT 0x0c
+#define COMMAND_TERMINATED   0x11
+#define QUEUE_FULL           0x14
+#define ACA_ACTIVE           0x18
+#define TASK_ABORTED         0x20
+
+#define STATUS_MASK          0xfe
+
+/*
+ *  SENSE KEYS
+ */
+
+#define NO_SENSE            0x00
+#define RECOVERED_ERROR     0x01
+#define NOT_READY           0x02
+#define MEDIUM_ERROR        0x03
+#define HARDWARE_ERROR      0x04
+#define ILLEGAL_REQUEST     0x05
+#define UNIT_ATTENTION      0x06
+#define DATA_PROTECT        0x07
+#define BLANK_CHECK         0x08
+#define COPY_ABORTED        0x0a
+#define ABORTED_COMMAND     0x0b
+#define VOLUME_OVERFLOW     0x0d
+#define MISCOMPARE          0x0e
+
+
+/*
+ *  DEVICE TYPES
+ *  Please keep them in 0x%02x format for $MODALIAS to work
+ */
+
+#define TYPE_DISK           0x00
+#define TYPE_TAPE           0x01
+#define TYPE_PRINTER        0x02
+#define TYPE_PROCESSOR      0x03    /* HP scanners use this */
+#define TYPE_WORM           0x04    /* Treated as ROM by our system */
+#define TYPE_ROM            0x05
+#define TYPE_SCANNER        0x06
+#define TYPE_MOD            0x07    /* Magneto-optical disk - 
+				     * - treated as TYPE_DISK */
+#define TYPE_MEDIUM_CHANGER 0x08
+#define TYPE_COMM           0x09    /* Communications device */
+#define TYPE_RAID           0x0c
+#define TYPE_ENCLOSURE      0x0d    /* Enclosure Services Device */
+#define TYPE_RBC	    0x0e
+#define TYPE_OSD            0x11
+#define TYPE_NO_LUN         0x7f
+
+/* SCSI protocols; these are taken from SPC-3 section 7.5 */
+enum scsi_protocol {
+	SCSI_PROTOCOL_FCP = 0,	/* Fibre Channel */
+	SCSI_PROTOCOL_SPI = 1,	/* parallel SCSI */
+	SCSI_PROTOCOL_SSA = 2,	/* Serial Storage Architecture - Obsolete */
+	SCSI_PROTOCOL_SBP = 3,	/* firewire */
+	SCSI_PROTOCOL_SRP = 4,	/* Infiniband RDMA */
+	SCSI_PROTOCOL_ISCSI = 5,
+	SCSI_PROTOCOL_SAS = 6,
+	SCSI_PROTOCOL_ADT = 7,	/* Media Changers */
+	SCSI_PROTOCOL_ATA = 8,
+	SCSI_PROTOCOL_UNSPEC = 0xf, /* No specific protocol */
+};
+
+/* Returns a human-readable name for the device */
+extern const char * scsi_device_type(unsigned type);
+
+/*
+ * standard mode-select header prepended to all mode-select commands
+ */
+
+struct ccs_modesel_head {
+	__u8 _r1;			/* reserved */
+	__u8 medium;		/* device-specific medium type */
+	__u8 _r2;			/* reserved */
+	__u8 block_desc_length;	/* block descriptor length */
+	__u8 density;		/* device-specific density code */
+	__u8 number_blocks_hi;	/* number of blocks in this block desc */
+	__u8 number_blocks_med;
+	__u8 number_blocks_lo;
+	__u8 _r3;
+	__u8 block_length_hi;	/* block length for blocks in this desc */
+	__u8 block_length_med;
+	__u8 block_length_lo;
+};
+
+/*
+ * ScsiLun: 8 byte LUN.
+ */
+struct scsi_lun {
+	__u8 scsi_lun[8];
+};
+
+/*
+ * The Well Known LUNS (SAM-3) in our int representation of a LUN
+ */
+#define SCSI_W_LUN_BASE 0xc100
+#define SCSI_W_LUN_REPORT_LUNS (SCSI_W_LUN_BASE + 1)
+#define SCSI_W_LUN_ACCESS_CONTROL (SCSI_W_LUN_BASE + 2)
+#define SCSI_W_LUN_TARGET_LOG_PAGE (SCSI_W_LUN_BASE + 3)
+
+static __inline__ int scsi_is_wlun(unsigned int lun)
+{
+	return (lun & 0xff00) == SCSI_W_LUN_BASE;
+}
+
+
+/*
+ *  MESSAGE CODES
+ */
+
+#define COMMAND_COMPLETE    0x00
+#define EXTENDED_MESSAGE    0x01
+#define     EXTENDED_MODIFY_DATA_POINTER    0x00
+#define     EXTENDED_SDTR                   0x01
+#define     EXTENDED_EXTENDED_IDENTIFY      0x02    /* SCSI-I only */
+#define     EXTENDED_WDTR                   0x03
+#define     EXTENDED_PPR                    0x04
+#define     EXTENDED_MODIFY_BIDI_DATA_PTR   0x05
+#define SAVE_POINTERS       0x02
+#define RESTORE_POINTERS    0x03
+#define DISCONNECT          0x04
+#define INITIATOR_ERROR     0x05
+#define ABORT_TASK_SET      0x06
+#define MESSAGE_REJECT      0x07
+#define NOP                 0x08
+#define MSG_PARITY_ERROR    0x09
+#define LINKED_CMD_COMPLETE 0x0a
+#define LINKED_FLG_CMD_COMPLETE 0x0b
+#define TARGET_RESET        0x0c
+#define ABORT_TASK          0x0d
+#define CLEAR_TASK_SET      0x0e
+#define INITIATE_RECOVERY   0x0f            /* SCSI-II only */
+#define RELEASE_RECOVERY    0x10            /* SCSI-II only */
+#define CLEAR_ACA           0x16
+#define LOGICAL_UNIT_RESET  0x17
+#define SIMPLE_QUEUE_TAG    0x20
+#define HEAD_OF_QUEUE_TAG   0x21
+#define ORDERED_QUEUE_TAG   0x22
+#define IGNORE_WIDE_RESIDUE 0x23
+#define ACA                 0x24
+#define QAS_REQUEST         0x55
+
+/* Old SCSI2 names, don't use in new code */
+#define BUS_DEVICE_RESET    TARGET_RESET
+#define ABORT               ABORT_TASK_SET
+
+/*
+ * Host byte codes
+ */
+
+#define DID_OK          0x00	/* NO error                                */
+#define DID_NO_CONNECT  0x01	/* Couldn't connect before timeout period  */
+#define DID_BUS_BUSY    0x02	/* BUS stayed busy through time out period */
+#define DID_TIME_OUT    0x03	/* TIMED OUT for other reason              */
+#define DID_BAD_TARGET  0x04	/* BAD target.                             */
+#define DID_ABORT       0x05	/* Told to abort for some other reason     */
+#define DID_PARITY      0x06	/* Parity error                            */
+#define DID_ERROR       0x07	/* Internal error                          */
+#define DID_RESET       0x08	/* Reset by somebody.                      */
+#define DID_BAD_INTR    0x09	/* Got an interrupt we weren't expecting.  */
+#define DID_PASSTHROUGH 0x0a	/* Force command past mid-layer            */
+#define DID_SOFT_ERROR  0x0b	/* The low level driver just wish a retry  */
+#define DID_IMM_RETRY   0x0c	/* Retry without decrementing retry count  */
+#define DID_REQUEUE	0x0d	/* Requeue command (no immediate retry) also
+				 * without decrementing the retry count	   */
+#define DID_TRANSPORT_DISRUPTED 0x0e /* Transport error disrupted execution
+				      * and the driver blocked the port to
+				      * recover the link. Transport class will
+				      * retry or fail IO */
+#define DID_TRANSPORT_FAILFAST	0x0f /* Transport class fastfailed the io */
+#define DRIVER_OK       0x00	/* Driver status                           */
+
+/*
+ *  These indicate the error that occurred, and what is available.
+ */
+
+#define DRIVER_BUSY         0x01
+#define DRIVER_SOFT         0x02
+#define DRIVER_MEDIA        0x03
+#define DRIVER_ERROR        0x04
+
+#define DRIVER_INVALID      0x05
+#define DRIVER_TIMEOUT      0x06
+#define DRIVER_HARD         0x07
+#define DRIVER_SENSE	    0x08
+
+/*
+ * Internal return values.
+ */
+
+#define NEEDS_RETRY     0x2001
+#define SUCCESS         0x2002
+#define FAILED          0x2003
+#define QUEUED          0x2004
+#define SOFT_ERROR      0x2005
+#define ADD_TO_MLQUEUE  0x2006
+#define TIMEOUT_ERROR   0x2007
+#define SCSI_RETURN_NOT_HANDLED   0x2008
+
+/*
+ * Midlevel queue return values.
+ */
+#define SCSI_MLQUEUE_HOST_BUSY   0x1055
+#define SCSI_MLQUEUE_DEVICE_BUSY 0x1056
+#define SCSI_MLQUEUE_EH_RETRY    0x1057
+#define SCSI_MLQUEUE_TARGET_BUSY 0x1058
+
+/*
+ *  Use these to separate status msg and our bytes
+ *
+ *  These are set by:
+ *
+ *      status byte = set from target device
+ *      msg_byte    = return status from host adapter itself.
+ *      host_byte   = set by low-level driver to indicate status.
+ *      driver_byte = set by mid-level.
+ */
+#define status_byte(result) (((result) >> 1) & 0x7f)
+#define msg_byte(result)    (((result) >> 8) & 0xff)
+#define host_byte(result)   (((result) >> 16) & 0xff)
+#define driver_byte(result) (((result) >> 24) & 0xff)
+
+#define sense_class(sense)  (((sense) >> 4) & 0x7)
+#define sense_error(sense)  ((sense) & 0xf)
+#define sense_valid(sense)  ((sense) & 0x80);
+
+/*
+ * default timeouts
+*/
+#define FORMAT_UNIT_TIMEOUT		(2 * 60 * 60 * HZ)
+#define START_STOP_TIMEOUT		(60 * HZ)
+#define MOVE_MEDIUM_TIMEOUT		(5 * 60 * HZ)
+#define READ_ELEMENT_STATUS_TIMEOUT	(5 * 60 * HZ)
+#define READ_DEFECT_DATA_TIMEOUT	(60 * HZ )
+
+
+#define IDENTIFY_BASE       0x80
+#define IDENTIFY(can_disconnect, lun)   (IDENTIFY_BASE |\
+		     ((can_disconnect) ?  0x40 : 0) |\
+		     ((lun) & 0x07))
+
+/*
+ *  struct scsi_device::scsi_level values. For SCSI devices other than those
+ *  prior to SCSI-2 (i.e. over 12 years old) this value is (resp[2] + 1)
+ *  where "resp" is a byte array of the response to an INQUIRY. The scsi_level
+ *  variable is visible to the user via sysfs.
+ */
+
+#define SCSI_UNKNOWN    0
+#define SCSI_1          1
+#define SCSI_1_CCS      2
+#define SCSI_2          3
+#define SCSI_3          4        /* SPC */
+#define SCSI_SPC_2      5
+#define SCSI_SPC_3      6
+
+/*
+ * INQ PERIPHERAL QUALIFIERS
+ */
+#define SCSI_INQ_PQ_CON         0x00
+#define SCSI_INQ_PQ_NOT_CON     0x01
+#define SCSI_INQ_PQ_NOT_CAP     0x03
+
+
+/*
+ * Here are some scsi specific ioctl commands which are sometimes useful.
+ *
+ * Note that include/linux/cdrom.h also defines IOCTL 0x5300 - 0x5395
+ */
+
+/* Used to obtain PUN and LUN info.  Conflicts with CDROMAUDIOBUFSIZ */
+#define SCSI_IOCTL_GET_IDLUN		0x5382
+
+/* 0x5383 and 0x5384 were used for SCSI_IOCTL_TAGGED_{ENABLE,DISABLE} */
+
+/* Used to obtain the host number of a device. */
+#define SCSI_IOCTL_PROBE_HOST		0x5385
+
+/* Used to obtain the bus number for a device */
+#define SCSI_IOCTL_GET_BUS_NUMBER	0x5386
+
+/* Used to obtain the PCI location of a device */
+#define SCSI_IOCTL_GET_PCI		0x5387
+
+/* Pull a u32 out of a SCSI message (using BE SCSI conventions) */
+static __inline__ __u32 scsi_to_u32(__u8 *ptr)
+{
+	return (ptr[0]<<24) + (ptr[1]<<16) + (ptr[2]<<8) + ptr[3];
+}
+
+#endif /* _SCSI_SCSI_H */
diff -uNr linux-2.6.32/usr/include/scsi/scsi_netlink_fc.h clean_modified/linux-2.6.32/usr/include/scsi/scsi_netlink_fc.h
--- linux-2.6.32/usr/include/scsi/scsi_netlink_fc.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/scsi/scsi_netlink_fc.h	2019-04-14 13:24:03.209464120 -0500
@@ -0,0 +1,71 @@
+/*
+ *  FC Transport Netlink Interface
+ *
+ *  Copyright (C) 2006   James Smart, Emulex Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef SCSI_NETLINK_FC_H
+#define SCSI_NETLINK_FC_H
+
+#include <scsi/scsi_netlink.h>
+
+/*
+ * This file intended to be included by both kernel and user space
+ */
+
+/*
+ * FC Transport Message Types
+ */
+	/* kernel -> user */
+#define FC_NL_ASYNC_EVENT			0x0100
+	/* user -> kernel */
+/* none */
+
+
+/*
+ * Message Structures :
+ */
+
+/* macro to round up message lengths to 8byte boundary */
+#define FC_NL_MSGALIGN(len)		(((len) + 7) & ~7)
+
+
+/*
+ * FC Transport Broadcast Event Message :
+ *   FC_NL_ASYNC_EVENT
+ *
+ * Note: if Vendor Unique message, &event_data will be  start of
+ * 	 vendor unique payload, and the length of the payload is
+ *       per event_datalen
+ *
+ * Note: When specifying vendor_id, be sure to read the Vendor Type and ID
+ *   formatting requirements specified in scsi_netlink.h
+ */
+struct fc_nl_event {
+	struct scsi_nl_hdr snlh;		/* must be 1st element ! */
+	uint64_t seconds;
+	uint64_t vendor_id;
+	uint16_t host_no;
+	uint16_t event_datalen;
+	uint32_t event_num;
+	uint32_t event_code;
+	uint32_t event_data;
+} __attribute__((aligned(sizeof(uint64_t))));
+
+
+#endif /* SCSI_NETLINK_FC_H */
+
diff -uNr linux-2.6.32/usr/include/scsi/scsi_netlink.h clean_modified/linux-2.6.32/usr/include/scsi/scsi_netlink.h
--- linux-2.6.32/usr/include/scsi/scsi_netlink.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/scsi/scsi_netlink.h	2019-04-14 13:24:03.209464120 -0500
@@ -0,0 +1,125 @@
+/*
+ *  SCSI Transport Netlink Interface
+ *    Used for the posting of outbound SCSI transport events
+ *
+ *  Copyright (C) 2006   James Smart, Emulex Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef SCSI_NETLINK_H
+#define SCSI_NETLINK_H
+
+#include <linux/netlink.h>
+
+
+/*
+ * This file intended to be included by both kernel and user space
+ */
+
+/* Single Netlink Message type to send all SCSI Transport messages */
+#define SCSI_TRANSPORT_MSG		NLMSG_MIN_TYPE + 1
+
+/* SCSI Transport Broadcast Groups */
+	/* leaving groups 0 and 1 unassigned */
+#define SCSI_NL_GRP_FC_EVENTS		(1<<2)		/* Group 2 */
+#define SCSI_NL_GRP_CNT			3
+
+
+/* SCSI_TRANSPORT_MSG event message header */
+struct scsi_nl_hdr {
+	uint8_t version;
+	uint8_t transport;
+	uint16_t magic;
+	uint16_t msgtype;
+	uint16_t msglen;
+} __attribute__((aligned(sizeof(uint64_t))));
+
+/* scsi_nl_hdr->version value */
+#define SCSI_NL_VERSION				1
+
+/* scsi_nl_hdr->magic value */
+#define SCSI_NL_MAGIC				0xA1B2
+
+/* scsi_nl_hdr->transport value */
+#define SCSI_NL_TRANSPORT			0
+#define SCSI_NL_TRANSPORT_FC			1
+#define SCSI_NL_MAX_TRANSPORTS			2
+
+/* Transport-based scsi_nl_hdr->msgtype values are defined in each transport */
+
+/*
+ * GENERIC SCSI scsi_nl_hdr->msgtype Values
+ */
+	/* kernel -> user */
+#define SCSI_NL_SHOST_VENDOR			0x0001
+	/* user -> kernel */
+/* SCSI_NL_SHOST_VENDOR msgtype is kernel->user and user->kernel */
+
+
+/*
+ * Message Structures :
+ */
+
+/* macro to round up message lengths to 8byte boundary */
+#define SCSI_NL_MSGALIGN(len)		(((len) + 7) & ~7)
+
+
+/*
+ * SCSI HOST Vendor Unique messages :
+ *   SCSI_NL_SHOST_VENDOR
+ *
+ * Note: The Vendor Unique message payload will begin directly after
+ * 	 this structure, with the length of the payload per vmsg_datalen.
+ *
+ * Note: When specifying vendor_id, be sure to read the Vendor Type and ID
+ *   formatting requirements specified below
+ */
+struct scsi_nl_host_vendor_msg {
+	struct scsi_nl_hdr snlh;		/* must be 1st element ! */
+	uint64_t vendor_id;
+	uint16_t host_no;
+	uint16_t vmsg_datalen;
+} __attribute__((aligned(sizeof(uint64_t))));
+
+
+/*
+ * Vendor ID:
+ *   If transports post vendor-unique events, they must pass a well-known
+ *   32-bit vendor identifier. This identifier consists of 8 bits indicating
+ *   the "type" of identifier contained, and 24 bits of id data.
+ *
+ *   Identifiers for each type:
+ *    PCI :  ID data is the 16 bit PCI Registered Vendor ID
+ */
+#define SCSI_NL_VID_TYPE_SHIFT		56
+#define SCSI_NL_VID_TYPE_MASK		((u64)0xFF << SCSI_NL_VID_TYPE_SHIFT)
+#define SCSI_NL_VID_TYPE_PCI		((u64)0x01 << SCSI_NL_VID_TYPE_SHIFT)
+#define SCSI_NL_VID_ID_MASK		(~ SCSI_NL_VID_TYPE_MASK)
+
+
+#define INIT_SCSI_NL_HDR(hdr, t, mtype, mlen)			\
+	{							\
+	(hdr)->version = SCSI_NL_VERSION;			\
+	(hdr)->transport = t;					\
+	(hdr)->magic = SCSI_NL_MAGIC;				\
+	(hdr)->msgtype = mtype;					\
+	(hdr)->msglen = mlen;					\
+	}
+
+
+
+#endif /* SCSI_NETLINK_H */
+
diff -uNr linux-2.6.32/usr/include/sound/asequencer.h clean_modified/linux-2.6.32/usr/include/sound/asequencer.h
--- linux-2.6.32/usr/include/sound/asequencer.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/asequencer.h	2019-04-14 13:24:03.211407884 -0500
@@ -0,0 +1,614 @@
+/*
+ *  Main header file for the ALSA sequencer
+ *  Copyright (c) 1998-1999 by Frank van de Pol <fvdpol@coil.demon.nl>
+ *            (c) 1998-1999 by Jaroslav Kysela <perex@perex.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __SOUND_ASEQUENCER_H
+#define __SOUND_ASEQUENCER_H
+
+
+/** version of the sequencer */
+#define SNDRV_SEQ_VERSION SNDRV_PROTOCOL_VERSION (1, 0, 1)
+
+/**
+ * definition of sequencer event types
+ */
+
+/** system messages
+ * event data type = #snd_seq_result
+ */
+#define SNDRV_SEQ_EVENT_SYSTEM		0
+#define SNDRV_SEQ_EVENT_RESULT		1
+
+/** note messages (channel specific)
+ * event data type = #snd_seq_ev_note
+ */
+#define SNDRV_SEQ_EVENT_NOTE		5
+#define SNDRV_SEQ_EVENT_NOTEON		6
+#define SNDRV_SEQ_EVENT_NOTEOFF		7
+#define SNDRV_SEQ_EVENT_KEYPRESS	8
+	
+/** control messages (channel specific)
+ * event data type = #snd_seq_ev_ctrl
+ */
+#define SNDRV_SEQ_EVENT_CONTROLLER	10
+#define SNDRV_SEQ_EVENT_PGMCHANGE	11
+#define SNDRV_SEQ_EVENT_CHANPRESS	12
+#define SNDRV_SEQ_EVENT_PITCHBEND	13	/**< from -8192 to 8191 */
+#define SNDRV_SEQ_EVENT_CONTROL14	14	/**< 14 bit controller value */
+#define SNDRV_SEQ_EVENT_NONREGPARAM	15	/**< 14 bit NRPN address + 14 bit unsigned value */
+#define SNDRV_SEQ_EVENT_REGPARAM	16	/**< 14 bit RPN address + 14 bit unsigned value */
+
+/** synchronisation messages
+ * event data type = #snd_seq_ev_ctrl
+ */
+#define SNDRV_SEQ_EVENT_SONGPOS		20	/* Song Position Pointer with LSB and MSB values */
+#define SNDRV_SEQ_EVENT_SONGSEL		21	/* Song Select with song ID number */
+#define SNDRV_SEQ_EVENT_QFRAME		22	/* midi time code quarter frame */
+#define SNDRV_SEQ_EVENT_TIMESIGN	23	/* SMF Time Signature event */
+#define SNDRV_SEQ_EVENT_KEYSIGN		24	/* SMF Key Signature event */
+	        
+/** timer messages
+ * event data type = snd_seq_ev_queue_control
+ */
+#define SNDRV_SEQ_EVENT_START		30	/* midi Real Time Start message */
+#define SNDRV_SEQ_EVENT_CONTINUE	31	/* midi Real Time Continue message */
+#define SNDRV_SEQ_EVENT_STOP		32	/* midi Real Time Stop message */	
+#define	SNDRV_SEQ_EVENT_SETPOS_TICK	33	/* set tick queue position */
+#define SNDRV_SEQ_EVENT_SETPOS_TIME	34	/* set realtime queue position */
+#define SNDRV_SEQ_EVENT_TEMPO		35	/* (SMF) Tempo event */
+#define SNDRV_SEQ_EVENT_CLOCK		36	/* midi Real Time Clock message */
+#define SNDRV_SEQ_EVENT_TICK		37	/* midi Real Time Tick message */
+#define SNDRV_SEQ_EVENT_QUEUE_SKEW	38	/* skew queue tempo */
+
+/** others
+ * event data type = none
+ */
+#define SNDRV_SEQ_EVENT_TUNE_REQUEST	40	/* tune request */
+#define SNDRV_SEQ_EVENT_RESET		41	/* reset to power-on state */
+#define SNDRV_SEQ_EVENT_SENSING		42	/* "active sensing" event */
+
+/** echo back, kernel private messages
+ * event data type = any type
+ */
+#define SNDRV_SEQ_EVENT_ECHO		50	/* echo event */
+#define SNDRV_SEQ_EVENT_OSS		51	/* OSS raw event */
+
+/** system status messages (broadcast for subscribers)
+ * event data type = snd_seq_addr
+ */
+#define SNDRV_SEQ_EVENT_CLIENT_START	60	/* new client has connected */
+#define SNDRV_SEQ_EVENT_CLIENT_EXIT	61	/* client has left the system */
+#define SNDRV_SEQ_EVENT_CLIENT_CHANGE	62	/* client status/info has changed */
+#define SNDRV_SEQ_EVENT_PORT_START	63	/* new port was created */
+#define SNDRV_SEQ_EVENT_PORT_EXIT	64	/* port was deleted from system */
+#define SNDRV_SEQ_EVENT_PORT_CHANGE	65	/* port status/info has changed */
+
+/** port connection changes
+ * event data type = snd_seq_connect
+ */
+#define SNDRV_SEQ_EVENT_PORT_SUBSCRIBED	66	/* ports connected */
+#define SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED 67	/* ports disconnected */
+
+/* 70-89:  synthesizer events - obsoleted */
+
+/** user-defined events with fixed length
+ * event data type = any
+ */
+#define SNDRV_SEQ_EVENT_USR0		90
+#define SNDRV_SEQ_EVENT_USR1		91
+#define SNDRV_SEQ_EVENT_USR2		92
+#define SNDRV_SEQ_EVENT_USR3		93
+#define SNDRV_SEQ_EVENT_USR4		94
+#define SNDRV_SEQ_EVENT_USR5		95
+#define SNDRV_SEQ_EVENT_USR6		96
+#define SNDRV_SEQ_EVENT_USR7		97
+#define SNDRV_SEQ_EVENT_USR8		98
+#define SNDRV_SEQ_EVENT_USR9		99
+
+/* 100-118: instrument layer - obsoleted */
+/* 119-129: reserved */
+
+/* 130-139: variable length events
+ * event data type = snd_seq_ev_ext
+ * (SNDRV_SEQ_EVENT_LENGTH_VARIABLE must be set)
+ */
+#define SNDRV_SEQ_EVENT_SYSEX		130	/* system exclusive data (variable length) */
+#define SNDRV_SEQ_EVENT_BOUNCE		131	/* error event */
+/* 132-134: reserved */
+#define SNDRV_SEQ_EVENT_USR_VAR0	135
+#define SNDRV_SEQ_EVENT_USR_VAR1	136
+#define SNDRV_SEQ_EVENT_USR_VAR2	137
+#define SNDRV_SEQ_EVENT_USR_VAR3	138
+#define SNDRV_SEQ_EVENT_USR_VAR4	139
+
+/* 150-151: kernel events with quote - DO NOT use in user clients */
+#define SNDRV_SEQ_EVENT_KERNEL_ERROR	150
+#define SNDRV_SEQ_EVENT_KERNEL_QUOTE	151	/* obsolete */
+
+/* 152-191: reserved */
+
+/* 192-254: hardware specific events */
+
+/* 255: special event */
+#define SNDRV_SEQ_EVENT_NONE		255
+
+
+typedef unsigned char snd_seq_event_type_t;
+
+/** event address */
+struct snd_seq_addr {
+	unsigned char client;	/**< Client number:         0..255, 255 = broadcast to all clients */
+	unsigned char port;	/**< Port within client:    0..255, 255 = broadcast to all ports */
+};
+
+/** port connection */
+struct snd_seq_connect {
+	struct snd_seq_addr sender;
+	struct snd_seq_addr dest;
+};
+
+
+#define SNDRV_SEQ_ADDRESS_UNKNOWN	253	/* unknown source */
+#define SNDRV_SEQ_ADDRESS_SUBSCRIBERS	254	/* send event to all subscribed ports */
+#define SNDRV_SEQ_ADDRESS_BROADCAST	255	/* send event to all queues/clients/ports/channels */
+#define SNDRV_SEQ_QUEUE_DIRECT		253	/* direct dispatch */
+
+	/* event mode flag - NOTE: only 8 bits available! */
+#define SNDRV_SEQ_TIME_STAMP_TICK	(0<<0) /* timestamp in clock ticks */
+#define SNDRV_SEQ_TIME_STAMP_REAL	(1<<0) /* timestamp in real time */
+#define SNDRV_SEQ_TIME_STAMP_MASK	(1<<0)
+
+#define SNDRV_SEQ_TIME_MODE_ABS		(0<<1)	/* absolute timestamp */
+#define SNDRV_SEQ_TIME_MODE_REL		(1<<1)	/* relative to current time */
+#define SNDRV_SEQ_TIME_MODE_MASK	(1<<1)
+
+#define SNDRV_SEQ_EVENT_LENGTH_FIXED	(0<<2)	/* fixed event size */
+#define SNDRV_SEQ_EVENT_LENGTH_VARIABLE	(1<<2)	/* variable event size */
+#define SNDRV_SEQ_EVENT_LENGTH_VARUSR	(2<<2)	/* variable event size - user memory space */
+#define SNDRV_SEQ_EVENT_LENGTH_MASK	(3<<2)
+
+#define SNDRV_SEQ_PRIORITY_NORMAL	(0<<4)	/* normal priority */
+#define SNDRV_SEQ_PRIORITY_HIGH		(1<<4)	/* event should be processed before others */
+#define SNDRV_SEQ_PRIORITY_MASK		(1<<4)
+
+
+	/* note event */
+struct snd_seq_ev_note {
+	unsigned char channel;
+	unsigned char note;
+	unsigned char velocity;
+	unsigned char off_velocity;	/* only for SNDRV_SEQ_EVENT_NOTE */
+	unsigned int duration;		/* only for SNDRV_SEQ_EVENT_NOTE */
+};
+
+	/* controller event */
+struct snd_seq_ev_ctrl {
+	unsigned char channel;
+	unsigned char unused1, unused2, unused3;	/* pad */
+	unsigned int param;
+	signed int value;
+};
+
+	/* generic set of bytes (12x8 bit) */
+struct snd_seq_ev_raw8 {
+	unsigned char d[12];	/* 8 bit value */
+};
+
+	/* generic set of integers (3x32 bit) */
+struct snd_seq_ev_raw32 {
+	unsigned int d[3];	/* 32 bit value */
+};
+
+	/* external stored data */
+struct snd_seq_ev_ext {
+	unsigned int len;	/* length of data */
+	void *ptr;		/* pointer to data (note: maybe 64-bit) */
+} __attribute__((packed));
+
+struct snd_seq_result {
+	int event;		/* processed event type */
+	int result;
+};
+
+
+struct snd_seq_real_time {
+	unsigned int tv_sec;	/* seconds */
+	unsigned int tv_nsec;	/* nanoseconds */
+};
+
+typedef unsigned int snd_seq_tick_time_t;	/* midi ticks */
+
+union snd_seq_timestamp {
+	snd_seq_tick_time_t tick;
+	struct snd_seq_real_time time;
+};
+
+struct snd_seq_queue_skew {
+	unsigned int value;
+	unsigned int base;
+};
+
+	/* queue timer control */
+struct snd_seq_ev_queue_control {
+	unsigned char queue;			/* affected queue */
+	unsigned char pad[3];			/* reserved */
+	union {
+		signed int value;		/* affected value (e.g. tempo) */
+		union snd_seq_timestamp time;	/* time */
+		unsigned int position;		/* sync position */
+		struct snd_seq_queue_skew skew;
+		unsigned int d32[2];
+		unsigned char d8[8];
+	} param;
+};
+
+	/* quoted event - inside the kernel only */
+struct snd_seq_ev_quote {
+	struct snd_seq_addr origin;		/* original sender */
+	unsigned short value;		/* optional data */
+	struct snd_seq_event *event;		/* quoted event */
+} __attribute__((packed));
+
+
+	/* sequencer event */
+struct snd_seq_event {
+	snd_seq_event_type_t type;	/* event type */
+	unsigned char flags;		/* event flags */
+	char tag;
+	
+	unsigned char queue;		/* schedule queue */
+	union snd_seq_timestamp time;	/* schedule time */
+
+
+	struct snd_seq_addr source;	/* source address */
+	struct snd_seq_addr dest;	/* destination address */
+
+	union {				/* event data... */
+		struct snd_seq_ev_note note;
+		struct snd_seq_ev_ctrl control;
+		struct snd_seq_ev_raw8 raw8;
+		struct snd_seq_ev_raw32 raw32;
+		struct snd_seq_ev_ext ext;
+		struct snd_seq_ev_queue_control queue;
+		union snd_seq_timestamp time;
+		struct snd_seq_addr addr;
+		struct snd_seq_connect connect;
+		struct snd_seq_result result;
+		struct snd_seq_ev_quote quote;
+	} data;
+};
+
+
+/*
+ * bounce event - stored as variable size data
+ */
+struct snd_seq_event_bounce {
+	int err;
+	struct snd_seq_event event;
+	/* external data follows here. */
+};
+
+
+	/* system information */
+struct snd_seq_system_info {
+	int queues;			/* maximum queues count */
+	int clients;			/* maximum clients count */
+	int ports;			/* maximum ports per client */
+	int channels;			/* maximum channels per port */
+	int cur_clients;		/* current clients */
+	int cur_queues;			/* current queues */
+	char reserved[24];
+};
+
+
+	/* system running information */
+struct snd_seq_running_info {
+	unsigned char client;		/* client id */
+	unsigned char big_endian;	/* 1 = big-endian */
+	unsigned char cpu_mode;		/* 4 = 32bit, 8 = 64bit */
+	unsigned char pad;		/* reserved */
+	unsigned char reserved[12];
+};
+
+
+	/* known client numbers */
+#define SNDRV_SEQ_CLIENT_SYSTEM		0
+	/* internal client numbers */
+#define SNDRV_SEQ_CLIENT_DUMMY		14	/* midi through */
+#define SNDRV_SEQ_CLIENT_OSS		15	/* oss sequencer emulator */
+
+
+	/* client types */
+typedef int __bitwise snd_seq_client_type_t;
+#define	NO_CLIENT	((snd_seq_client_type_t) 0)
+#define	USER_CLIENT	((snd_seq_client_type_t) 1)
+#define	KERNEL_CLIENT	((snd_seq_client_type_t) 2)
+                        
+	/* event filter flags */
+#define SNDRV_SEQ_FILTER_BROADCAST	(1<<0)	/* accept broadcast messages */
+#define SNDRV_SEQ_FILTER_MULTICAST	(1<<1)	/* accept multicast messages */
+#define SNDRV_SEQ_FILTER_BOUNCE		(1<<2)	/* accept bounce event in error */
+#define SNDRV_SEQ_FILTER_USE_EVENT	(1<<31)	/* use event filter */
+
+struct snd_seq_client_info {
+	int client;			/* client number to inquire */
+	snd_seq_client_type_t type;	/* client type */
+	char name[64];			/* client name */
+	unsigned int filter;		/* filter flags */
+	unsigned char multicast_filter[8]; /* multicast filter bitmap */
+	unsigned char event_filter[32];	/* event filter bitmap */
+	int num_ports;			/* RO: number of ports */
+	int event_lost;			/* number of lost events */
+	char reserved[64];		/* for future use */
+};
+
+
+/* client pool size */
+struct snd_seq_client_pool {
+	int client;			/* client number to inquire */
+	int output_pool;		/* outgoing (write) pool size */
+	int input_pool;			/* incoming (read) pool size */
+	int output_room;		/* minimum free pool size for select/blocking mode */
+	int output_free;		/* unused size */
+	int input_free;			/* unused size */
+	char reserved[64];
+};
+
+
+/* Remove events by specified criteria */
+
+#define SNDRV_SEQ_REMOVE_INPUT		(1<<0)	/* Flush input queues */
+#define SNDRV_SEQ_REMOVE_OUTPUT		(1<<1)	/* Flush output queues */
+#define SNDRV_SEQ_REMOVE_DEST		(1<<2)	/* Restrict by destination q:client:port */
+#define SNDRV_SEQ_REMOVE_DEST_CHANNEL	(1<<3)	/* Restrict by channel */
+#define SNDRV_SEQ_REMOVE_TIME_BEFORE	(1<<4)	/* Restrict to before time */
+#define SNDRV_SEQ_REMOVE_TIME_AFTER	(1<<5)	/* Restrict to time or after */
+#define SNDRV_SEQ_REMOVE_TIME_TICK	(1<<6)	/* Time is in ticks */
+#define SNDRV_SEQ_REMOVE_EVENT_TYPE	(1<<7)	/* Restrict to event type */
+#define SNDRV_SEQ_REMOVE_IGNORE_OFF 	(1<<8)	/* Do not flush off events */
+#define SNDRV_SEQ_REMOVE_TAG_MATCH 	(1<<9)	/* Restrict to events with given tag */
+
+struct snd_seq_remove_events {
+	unsigned int  remove_mode;	/* Flags that determine what gets removed */
+
+	union snd_seq_timestamp time;
+
+	unsigned char queue;	/* Queue for REMOVE_DEST */
+	struct snd_seq_addr dest;	/* Address for REMOVE_DEST */
+	unsigned char channel;	/* Channel for REMOVE_DEST */
+
+	int  type;	/* For REMOVE_EVENT_TYPE */
+	char  tag;	/* Tag for REMOVE_TAG */
+
+	int  reserved[10];	/* To allow for future binary compatibility */
+
+};
+
+
+	/* known port numbers */
+#define SNDRV_SEQ_PORT_SYSTEM_TIMER	0
+#define SNDRV_SEQ_PORT_SYSTEM_ANNOUNCE	1
+
+	/* port capabilities (32 bits) */
+#define SNDRV_SEQ_PORT_CAP_READ		(1<<0)	/* readable from this port */
+#define SNDRV_SEQ_PORT_CAP_WRITE	(1<<1)	/* writable to this port */
+
+#define SNDRV_SEQ_PORT_CAP_SYNC_READ	(1<<2)
+#define SNDRV_SEQ_PORT_CAP_SYNC_WRITE	(1<<3)
+
+#define SNDRV_SEQ_PORT_CAP_DUPLEX	(1<<4)
+
+#define SNDRV_SEQ_PORT_CAP_SUBS_READ	(1<<5)	/* allow read subscription */
+#define SNDRV_SEQ_PORT_CAP_SUBS_WRITE	(1<<6)	/* allow write subscription */
+#define SNDRV_SEQ_PORT_CAP_NO_EXPORT	(1<<7)	/* routing not allowed */
+
+	/* port type */
+#define SNDRV_SEQ_PORT_TYPE_SPECIFIC	(1<<0)	/* hardware specific */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC (1<<1)	/* generic MIDI device */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_GM	(1<<2)	/* General MIDI compatible device */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_GS	(1<<3)	/* GS compatible device */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_XG	(1<<4)	/* XG compatible device */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_MT32	(1<<5)	/* MT-32 compatible device */
+#define SNDRV_SEQ_PORT_TYPE_MIDI_GM2	(1<<6)	/* General MIDI 2 compatible device */
+
+/* other standards...*/
+#define SNDRV_SEQ_PORT_TYPE_SYNTH	(1<<10)	/* Synth device (no MIDI compatible - direct wavetable) */
+#define SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE (1<<11)	/* Sampling device (support sample download) */
+#define SNDRV_SEQ_PORT_TYPE_SAMPLE	(1<<12)	/* Sampling device (sample can be downloaded at any time) */
+/*...*/
+#define SNDRV_SEQ_PORT_TYPE_HARDWARE	(1<<16)	/* driver for a hardware device */
+#define SNDRV_SEQ_PORT_TYPE_SOFTWARE	(1<<17)	/* implemented in software */
+#define SNDRV_SEQ_PORT_TYPE_SYNTHESIZER	(1<<18)	/* generates sound */
+#define SNDRV_SEQ_PORT_TYPE_PORT	(1<<19)	/* connects to other device(s) */
+#define SNDRV_SEQ_PORT_TYPE_APPLICATION	(1<<20)	/* application (sequencer/editor) */
+
+/* misc. conditioning flags */
+#define SNDRV_SEQ_PORT_FLG_GIVEN_PORT	(1<<0)
+#define SNDRV_SEQ_PORT_FLG_TIMESTAMP	(1<<1)
+#define SNDRV_SEQ_PORT_FLG_TIME_REAL	(1<<2)
+
+struct snd_seq_port_info {
+	struct snd_seq_addr addr;	/* client/port numbers */
+	char name[64];			/* port name */
+
+	unsigned int capability;	/* port capability bits */
+	unsigned int type;		/* port type bits */
+	int midi_channels;		/* channels per MIDI port */
+	int midi_voices;		/* voices per MIDI port */
+	int synth_voices;		/* voices per SYNTH port */
+
+	int read_use;			/* R/O: subscribers for output (from this port) */
+	int write_use;			/* R/O: subscribers for input (to this port) */
+
+	void *kernel;			/* reserved for kernel use (must be NULL) */
+	unsigned int flags;		/* misc. conditioning */
+	unsigned char time_queue;	/* queue # for timestamping */
+	char reserved[59];		/* for future use */
+};
+
+
+/* queue flags */
+#define SNDRV_SEQ_QUEUE_FLG_SYNC	(1<<0)	/* sync enabled */
+
+/* queue information */
+struct snd_seq_queue_info {
+	int queue;		/* queue id */
+
+	/*
+	 *  security settings, only owner of this queue can start/stop timer
+	 *  etc. if the queue is locked for other clients
+	 */
+	int owner;		/* client id for owner of the queue */
+	unsigned locked:1;	/* timing queue locked for other queues */
+	char name[64];		/* name of this queue */
+	unsigned int flags;	/* flags */
+	char reserved[60];	/* for future use */
+
+};
+
+/* queue info/status */
+struct snd_seq_queue_status {
+	int queue;			/* queue id */
+	int events;			/* read-only - queue size */
+	snd_seq_tick_time_t tick;	/* current tick */
+	struct snd_seq_real_time time;	/* current time */
+	int running;			/* running state of queue */
+	int flags;			/* various flags */
+	char reserved[64];		/* for the future */
+};
+
+
+/* queue tempo */
+struct snd_seq_queue_tempo {
+	int queue;			/* sequencer queue */
+	unsigned int tempo;		/* current tempo, us/tick */
+	int ppq;			/* time resolution, ticks/quarter */
+	unsigned int skew_value;	/* queue skew */
+	unsigned int skew_base;		/* queue skew base */
+	char reserved[24];		/* for the future */
+};
+
+
+/* sequencer timer sources */
+#define SNDRV_SEQ_TIMER_ALSA		0	/* ALSA timer */
+#define SNDRV_SEQ_TIMER_MIDI_CLOCK	1	/* Midi Clock (CLOCK event) */
+#define SNDRV_SEQ_TIMER_MIDI_TICK	2	/* Midi Timer Tick (TICK event) */
+
+/* queue timer info */
+struct snd_seq_queue_timer {
+	int queue;			/* sequencer queue */
+	int type;			/* source timer type */
+	union {
+		struct {
+			struct snd_timer_id id;	/* ALSA's timer ID */
+			unsigned int resolution;	/* resolution in Hz */
+		} alsa;
+	} u;
+	char reserved[64];		/* for the future use */
+};
+
+
+struct snd_seq_queue_client {
+	int queue;		/* sequencer queue */
+	int client;		/* sequencer client */
+	int used;		/* queue is used with this client
+				   (must be set for accepting events) */
+	/* per client watermarks */
+	char reserved[64];	/* for future use */
+};
+
+
+#define SNDRV_SEQ_PORT_SUBS_EXCLUSIVE	(1<<0)	/* exclusive connection */
+#define SNDRV_SEQ_PORT_SUBS_TIMESTAMP	(1<<1)
+#define SNDRV_SEQ_PORT_SUBS_TIME_REAL	(1<<2)
+
+struct snd_seq_port_subscribe {
+	struct snd_seq_addr sender;	/* sender address */
+	struct snd_seq_addr dest;	/* destination address */
+	unsigned int voices;		/* number of voices to be allocated (0 = don't care) */
+	unsigned int flags;		/* modes */
+	unsigned char queue;		/* input time-stamp queue (optional) */
+	unsigned char pad[3];		/* reserved */
+	char reserved[64];
+};
+
+/* type of query subscription */
+#define SNDRV_SEQ_QUERY_SUBS_READ	0
+#define SNDRV_SEQ_QUERY_SUBS_WRITE	1
+
+struct snd_seq_query_subs {
+	struct snd_seq_addr root;	/* client/port id to be searched */
+	int type;		/* READ or WRITE */
+	int index;		/* 0..N-1 */
+	int num_subs;		/* R/O: number of subscriptions on this port */
+	struct snd_seq_addr addr;	/* R/O: result */
+	unsigned char queue;	/* R/O: result */
+	unsigned int flags;	/* R/O: result */
+	char reserved[64];	/* for future use */
+};
+
+
+/*
+ *  IOCTL commands
+ */
+
+#define SNDRV_SEQ_IOCTL_PVERSION	_IOR ('S', 0x00, int)
+#define SNDRV_SEQ_IOCTL_CLIENT_ID	_IOR ('S', 0x01, int)
+#define SNDRV_SEQ_IOCTL_SYSTEM_INFO	_IOWR('S', 0x02, struct snd_seq_system_info)
+#define SNDRV_SEQ_IOCTL_RUNNING_MODE	_IOWR('S', 0x03, struct snd_seq_running_info)
+
+#define SNDRV_SEQ_IOCTL_GET_CLIENT_INFO	_IOWR('S', 0x10, struct snd_seq_client_info)
+#define SNDRV_SEQ_IOCTL_SET_CLIENT_INFO	_IOW ('S', 0x11, struct snd_seq_client_info)
+
+#define SNDRV_SEQ_IOCTL_CREATE_PORT	_IOWR('S', 0x20, struct snd_seq_port_info)
+#define SNDRV_SEQ_IOCTL_DELETE_PORT	_IOW ('S', 0x21, struct snd_seq_port_info)
+#define SNDRV_SEQ_IOCTL_GET_PORT_INFO	_IOWR('S', 0x22, struct snd_seq_port_info)
+#define SNDRV_SEQ_IOCTL_SET_PORT_INFO	_IOW ('S', 0x23, struct snd_seq_port_info)
+
+#define SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT	_IOW ('S', 0x30, struct snd_seq_port_subscribe)
+#define SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT _IOW ('S', 0x31, struct snd_seq_port_subscribe)
+
+#define SNDRV_SEQ_IOCTL_CREATE_QUEUE	_IOWR('S', 0x32, struct snd_seq_queue_info)
+#define SNDRV_SEQ_IOCTL_DELETE_QUEUE	_IOW ('S', 0x33, struct snd_seq_queue_info)
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_INFO	_IOWR('S', 0x34, struct snd_seq_queue_info)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_INFO	_IOWR('S', 0x35, struct snd_seq_queue_info)
+#define SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE	_IOWR('S', 0x36, struct snd_seq_queue_info)
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS _IOWR('S', 0x40, struct snd_seq_queue_status)
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO	_IOWR('S', 0x41, struct snd_seq_queue_tempo)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO	_IOW ('S', 0x42, struct snd_seq_queue_tempo)
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_OWNER	_IOWR('S', 0x43, struct snd_seq_queue_owner)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_OWNER	_IOW ('S', 0x44, struct snd_seq_queue_owner)
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER	_IOWR('S', 0x45, struct snd_seq_queue_timer)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER	_IOW ('S', 0x46, struct snd_seq_queue_timer)
+/* XXX
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_SYNC	_IOWR('S', 0x53, struct snd_seq_queue_sync)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_SYNC	_IOW ('S', 0x54, struct snd_seq_queue_sync)
+*/
+#define SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT	_IOWR('S', 0x49, struct snd_seq_queue_client)
+#define SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT	_IOW ('S', 0x4a, struct snd_seq_queue_client)
+#define SNDRV_SEQ_IOCTL_GET_CLIENT_POOL	_IOWR('S', 0x4b, struct snd_seq_client_pool)
+#define SNDRV_SEQ_IOCTL_SET_CLIENT_POOL	_IOW ('S', 0x4c, struct snd_seq_client_pool)
+#define SNDRV_SEQ_IOCTL_REMOVE_EVENTS	_IOW ('S', 0x4e, struct snd_seq_remove_events)
+#define SNDRV_SEQ_IOCTL_QUERY_SUBS	_IOWR('S', 0x4f, struct snd_seq_query_subs)
+#define SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION	_IOWR('S', 0x50, struct snd_seq_port_subscribe)
+#define SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT	_IOWR('S', 0x51, struct snd_seq_client_info)
+#define SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT	_IOWR('S', 0x52, struct snd_seq_port_info)
+
+#endif /* __SOUND_ASEQUENCER_H */
diff -uNr linux-2.6.32/usr/include/sound/asound_fm.h clean_modified/linux-2.6.32/usr/include/sound/asound_fm.h
--- linux-2.6.32/usr/include/sound/asound_fm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/asound_fm.h	2019-04-14 13:24:03.211407884 -0500
@@ -0,0 +1,134 @@
+#ifndef __SOUND_ASOUND_FM_H
+#define __SOUND_ASOUND_FM_H
+
+/*
+ *  Advanced Linux Sound Architecture - ALSA
+ *
+ *  Interface file between ALSA driver & user space
+ *  Copyright (c) 1994-98 by Jaroslav Kysela <perex@perex.cz>,
+ *                           4Front Technologies
+ *
+ *  Direct FM control
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#define SNDRV_DM_FM_MODE_OPL2	0x00
+#define SNDRV_DM_FM_MODE_OPL3	0x01
+
+struct snd_dm_fm_info {
+	unsigned char fm_mode;		/* OPL mode, see SNDRV_DM_FM_MODE_XXX */
+	unsigned char rhythm;		/* percussion mode flag */
+};
+
+/*
+ *  Data structure composing an FM "note" or sound event.
+ */
+
+struct snd_dm_fm_voice {
+	unsigned char op;		/* operator cell (0 or 1) */
+	unsigned char voice;		/* FM voice (0 to 17) */
+
+	unsigned char am;		/* amplitude modulation */
+	unsigned char vibrato;		/* vibrato effect */
+	unsigned char do_sustain;	/* sustain phase */
+	unsigned char kbd_scale;	/* keyboard scaling */
+	unsigned char harmonic;		/* 4 bits: harmonic and multiplier */
+	unsigned char scale_level;	/* 2 bits: decrease output freq rises */
+	unsigned char volume;		/* 6 bits: volume */
+
+	unsigned char attack;		/* 4 bits: attack rate */
+	unsigned char decay;		/* 4 bits: decay rate */
+	unsigned char sustain;		/* 4 bits: sustain level */
+	unsigned char release;		/* 4 bits: release rate */
+
+	unsigned char feedback;		/* 3 bits: feedback for op0 */
+	unsigned char connection;	/* 0 for serial, 1 for parallel */
+	unsigned char left;		/* stereo left */
+	unsigned char right;		/* stereo right */
+	unsigned char waveform;		/* 3 bits: waveform shape */
+};
+
+/*
+ *  This describes an FM note by its voice, octave, frequency number (10bit)
+ *  and key on/off.
+ */
+
+struct snd_dm_fm_note {
+	unsigned char voice;	/* 0-17 voice channel */
+	unsigned char octave;	/* 3 bits: what octave to play */
+	unsigned int fnum;	/* 10 bits: frequency number */
+	unsigned char key_on;	/* set for active, clear for silent */
+};
+
+/*
+ *  FM parameters that apply globally to all voices, and thus are not "notes"
+ */
+
+struct snd_dm_fm_params {
+	unsigned char am_depth;		/* amplitude modulation depth (1=hi) */
+	unsigned char vib_depth;	/* vibrato depth (1=hi) */
+	unsigned char kbd_split;	/* keyboard split */
+	unsigned char rhythm;		/* percussion mode select */
+
+	/* This block is the percussion instrument data */
+	unsigned char bass;
+	unsigned char snare;
+	unsigned char tomtom;
+	unsigned char cymbal;
+	unsigned char hihat;
+};
+
+/*
+ *  FM mode ioctl settings
+ */
+
+#define SNDRV_DM_FM_IOCTL_INFO		_IOR('H', 0x20, struct snd_dm_fm_info)
+#define SNDRV_DM_FM_IOCTL_RESET		_IO ('H', 0x21)
+#define SNDRV_DM_FM_IOCTL_PLAY_NOTE	_IOW('H', 0x22, struct snd_dm_fm_note)
+#define SNDRV_DM_FM_IOCTL_SET_VOICE	_IOW('H', 0x23, struct snd_dm_fm_voice)
+#define SNDRV_DM_FM_IOCTL_SET_PARAMS	_IOW('H', 0x24, struct snd_dm_fm_params)
+#define SNDRV_DM_FM_IOCTL_SET_MODE	_IOW('H', 0x25, int)
+/* for OPL3 only */
+#define SNDRV_DM_FM_IOCTL_SET_CONNECTION	_IOW('H', 0x26, int)
+/* SBI patch management */
+#define SNDRV_DM_FM_IOCTL_CLEAR_PATCHES	_IO ('H', 0x40)
+
+#define SNDRV_DM_FM_OSS_IOCTL_RESET		0x20
+#define SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE		0x21
+#define SNDRV_DM_FM_OSS_IOCTL_SET_VOICE		0x22
+#define SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS	0x23
+#define SNDRV_DM_FM_OSS_IOCTL_SET_MODE		0x24
+#define SNDRV_DM_FM_OSS_IOCTL_SET_OPL		0x25
+
+/*
+ * Patch Record - fixed size for write
+ */
+
+#define FM_KEY_SBI	"SBI\032"
+#define FM_KEY_2OP	"2OP\032"
+#define FM_KEY_4OP	"4OP\032"
+
+struct sbi_patch {
+	unsigned char prog;
+	unsigned char bank;
+	char key[4];
+	char name[25];
+	char extension[7];
+	unsigned char data[32];
+};
+
+#endif /* __SOUND_ASOUND_FM_H */
diff -uNr linux-2.6.32/usr/include/sound/asound.h clean_modified/linux-2.6.32/usr/include/sound/asound.h
--- linux-2.6.32/usr/include/sound/asound.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/asound.h	2019-04-14 13:24:03.214338074 -0500
@@ -0,0 +1,895 @@
+/*
+ *  Advanced Linux Sound Architecture - ALSA - Driver
+ *  Copyright (c) 1994-2003 by Jaroslav Kysela <perex@perex.cz>,
+ *                             Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __SOUND_ASOUND_H
+#define __SOUND_ASOUND_H
+
+#include <linux/types.h>
+
+
+/*
+ *  protocol version
+ */
+
+#define SNDRV_PROTOCOL_VERSION(major, minor, subminor) (((major)<<16)|((minor)<<8)|(subminor))
+#define SNDRV_PROTOCOL_MAJOR(version) (((version)>>16)&0xffff)
+#define SNDRV_PROTOCOL_MINOR(version) (((version)>>8)&0xff)
+#define SNDRV_PROTOCOL_MICRO(version) ((version)&0xff)
+#define SNDRV_PROTOCOL_INCOMPATIBLE(kversion, uversion) \
+	(SNDRV_PROTOCOL_MAJOR(kversion) != SNDRV_PROTOCOL_MAJOR(uversion) || \
+	 (SNDRV_PROTOCOL_MAJOR(kversion) == SNDRV_PROTOCOL_MAJOR(uversion) && \
+	   SNDRV_PROTOCOL_MINOR(kversion) != SNDRV_PROTOCOL_MINOR(uversion)))
+
+/****************************************************************************
+ *                                                                          *
+ *        Digital audio interface					    *
+ *                                                                          *
+ ****************************************************************************/
+
+struct snd_aes_iec958 {
+	unsigned char status[24];	/* AES/IEC958 channel status bits */
+	unsigned char subcode[147];	/* AES/IEC958 subcode bits */
+	unsigned char pad;		/* nothing */
+	unsigned char dig_subframe[4];	/* AES/IEC958 subframe bits */
+};
+
+/****************************************************************************
+ *                                                                          *
+ *      Section for driver hardware dependent interface - /dev/snd/hw?      *
+ *                                                                          *
+ ****************************************************************************/
+
+#define SNDRV_HWDEP_VERSION		SNDRV_PROTOCOL_VERSION(1, 0, 1)
+
+enum {
+	SNDRV_HWDEP_IFACE_OPL2 = 0,
+	SNDRV_HWDEP_IFACE_OPL3,
+	SNDRV_HWDEP_IFACE_OPL4,
+	SNDRV_HWDEP_IFACE_SB16CSP,	/* Creative Signal Processor */
+	SNDRV_HWDEP_IFACE_EMU10K1,	/* FX8010 processor in EMU10K1 chip */
+	SNDRV_HWDEP_IFACE_YSS225,	/* Yamaha FX processor */
+	SNDRV_HWDEP_IFACE_ICS2115,	/* Wavetable synth */
+	SNDRV_HWDEP_IFACE_SSCAPE,	/* Ensoniq SoundScape ISA card (MC68EC000) */
+	SNDRV_HWDEP_IFACE_VX,		/* Digigram VX cards */
+	SNDRV_HWDEP_IFACE_MIXART,	/* Digigram miXart cards */
+	SNDRV_HWDEP_IFACE_USX2Y,	/* Tascam US122, US224 & US428 usb */
+	SNDRV_HWDEP_IFACE_EMUX_WAVETABLE, /* EmuX wavetable */	
+	SNDRV_HWDEP_IFACE_BLUETOOTH,	/* Bluetooth audio */
+	SNDRV_HWDEP_IFACE_USX2Y_PCM,	/* Tascam US122, US224 & US428 rawusb pcm */
+	SNDRV_HWDEP_IFACE_PCXHR,	/* Digigram PCXHR */
+	SNDRV_HWDEP_IFACE_SB_RC,	/* SB Extigy/Audigy2NX remote control */
+	SNDRV_HWDEP_IFACE_HDA,		/* HD-audio */
+	SNDRV_HWDEP_IFACE_USB_STREAM,	/* direct access to usb stream */
+
+	/* Don't forget to change the following: */
+	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_USB_STREAM
+};
+
+struct snd_hwdep_info {
+	unsigned int device;		/* WR: device number */
+	int card;			/* R: card number */
+	unsigned char id[64];		/* ID (user selectable) */
+	unsigned char name[80];		/* hwdep name */
+	int iface;			/* hwdep interface */
+	unsigned char reserved[64];	/* reserved for future */
+};
+
+/* generic DSP loader */
+struct snd_hwdep_dsp_status {
+	unsigned int version;		/* R: driver-specific version */
+	unsigned char id[32];		/* R: driver-specific ID string */
+	unsigned int num_dsps;		/* R: number of DSP images to transfer */
+	unsigned int dsp_loaded;	/* R: bit flags indicating the loaded DSPs */
+	unsigned int chip_ready;	/* R: 1 = initialization finished */
+	unsigned char reserved[16];	/* reserved for future use */
+};
+
+struct snd_hwdep_dsp_image {
+	unsigned int index;		/* W: DSP index */
+	unsigned char name[64];		/* W: ID (e.g. file name) */
+	unsigned char *image;	/* W: binary image */
+	size_t length;			/* W: size of image in bytes */
+	unsigned long driver_data;	/* W: driver-specific data */
+};
+
+#define SNDRV_HWDEP_IOCTL_PVERSION	_IOR ('H', 0x00, int)
+#define SNDRV_HWDEP_IOCTL_INFO		_IOR ('H', 0x01, struct snd_hwdep_info)
+#define SNDRV_HWDEP_IOCTL_DSP_STATUS	_IOR('H', 0x02, struct snd_hwdep_dsp_status)
+#define SNDRV_HWDEP_IOCTL_DSP_LOAD	_IOW('H', 0x03, struct snd_hwdep_dsp_image)
+
+/*****************************************************************************
+ *                                                                           *
+ *             Digital Audio (PCM) interface - /dev/snd/pcm??                *
+ *                                                                           *
+ *****************************************************************************/
+
+#define SNDRV_PCM_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 10)
+
+typedef unsigned long snd_pcm_uframes_t;
+typedef signed long snd_pcm_sframes_t;
+
+enum {
+	SNDRV_PCM_CLASS_GENERIC = 0,	/* standard mono or stereo device */
+	SNDRV_PCM_CLASS_MULTI,		/* multichannel device */
+	SNDRV_PCM_CLASS_MODEM,		/* software modem class */
+	SNDRV_PCM_CLASS_DIGITIZER,	/* digitizer class */
+	/* Don't forget to change the following: */
+	SNDRV_PCM_CLASS_LAST = SNDRV_PCM_CLASS_DIGITIZER,
+};
+
+enum {
+	SNDRV_PCM_SUBCLASS_GENERIC_MIX = 0, /* mono or stereo subdevices are mixed together */
+	SNDRV_PCM_SUBCLASS_MULTI_MIX,	/* multichannel subdevices are mixed together */
+	/* Don't forget to change the following: */
+	SNDRV_PCM_SUBCLASS_LAST = SNDRV_PCM_SUBCLASS_MULTI_MIX,
+};
+
+enum {
+	SNDRV_PCM_STREAM_PLAYBACK = 0,
+	SNDRV_PCM_STREAM_CAPTURE,
+	SNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,
+};
+
+typedef int __bitwise snd_pcm_access_t;
+#define	SNDRV_PCM_ACCESS_MMAP_INTERLEAVED	((snd_pcm_access_t) 0) /* interleaved mmap */
+#define	SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED	((snd_pcm_access_t) 1) /* noninterleaved mmap */
+#define	SNDRV_PCM_ACCESS_MMAP_COMPLEX		((snd_pcm_access_t) 2) /* complex mmap */
+#define	SNDRV_PCM_ACCESS_RW_INTERLEAVED		((snd_pcm_access_t) 3) /* readi/writei */
+#define	SNDRV_PCM_ACCESS_RW_NONINTERLEAVED	((snd_pcm_access_t) 4) /* readn/writen */
+#define	SNDRV_PCM_ACCESS_LAST		SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
+
+typedef int __bitwise snd_pcm_format_t;
+#define	SNDRV_PCM_FORMAT_S8	((snd_pcm_format_t) 0)
+#define	SNDRV_PCM_FORMAT_U8	((snd_pcm_format_t) 1)
+#define	SNDRV_PCM_FORMAT_S16_LE	((snd_pcm_format_t) 2)
+#define	SNDRV_PCM_FORMAT_S16_BE	((snd_pcm_format_t) 3)
+#define	SNDRV_PCM_FORMAT_U16_LE	((snd_pcm_format_t) 4)
+#define	SNDRV_PCM_FORMAT_U16_BE	((snd_pcm_format_t) 5)
+#define	SNDRV_PCM_FORMAT_S24_LE	((snd_pcm_format_t) 6) /* low three bytes */
+#define	SNDRV_PCM_FORMAT_S24_BE	((snd_pcm_format_t) 7) /* low three bytes */
+#define	SNDRV_PCM_FORMAT_U24_LE	((snd_pcm_format_t) 8) /* low three bytes */
+#define	SNDRV_PCM_FORMAT_U24_BE	((snd_pcm_format_t) 9) /* low three bytes */
+#define	SNDRV_PCM_FORMAT_S32_LE	((snd_pcm_format_t) 10)
+#define	SNDRV_PCM_FORMAT_S32_BE	((snd_pcm_format_t) 11)
+#define	SNDRV_PCM_FORMAT_U32_LE	((snd_pcm_format_t) 12)
+#define	SNDRV_PCM_FORMAT_U32_BE	((snd_pcm_format_t) 13)
+#define	SNDRV_PCM_FORMAT_FLOAT_LE	((snd_pcm_format_t) 14) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
+#define	SNDRV_PCM_FORMAT_FLOAT_BE	((snd_pcm_format_t) 15) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
+#define	SNDRV_PCM_FORMAT_FLOAT64_LE	((snd_pcm_format_t) 16) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
+#define	SNDRV_PCM_FORMAT_FLOAT64_BE	((snd_pcm_format_t) 17) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
+#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE ((snd_pcm_format_t) 18) /* IEC-958 subframe, Little Endian */
+#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE ((snd_pcm_format_t) 19) /* IEC-958 subframe, Big Endian */
+#define	SNDRV_PCM_FORMAT_MU_LAW		((snd_pcm_format_t) 20)
+#define	SNDRV_PCM_FORMAT_A_LAW		((snd_pcm_format_t) 21)
+#define	SNDRV_PCM_FORMAT_IMA_ADPCM	((snd_pcm_format_t) 22)
+#define	SNDRV_PCM_FORMAT_MPEG		((snd_pcm_format_t) 23)
+#define	SNDRV_PCM_FORMAT_GSM		((snd_pcm_format_t) 24)
+#define	SNDRV_PCM_FORMAT_SPECIAL	((snd_pcm_format_t) 31)
+#define	SNDRV_PCM_FORMAT_S24_3LE	((snd_pcm_format_t) 32)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_S24_3BE	((snd_pcm_format_t) 33)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U24_3LE	((snd_pcm_format_t) 34)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U24_3BE	((snd_pcm_format_t) 35)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_S20_3LE	((snd_pcm_format_t) 36)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_S20_3BE	((snd_pcm_format_t) 37)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U20_3LE	((snd_pcm_format_t) 38)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U20_3BE	((snd_pcm_format_t) 39)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_S18_3LE	((snd_pcm_format_t) 40)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_S18_3BE	((snd_pcm_format_t) 41)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U18_3LE	((snd_pcm_format_t) 42)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_U18_3BE	((snd_pcm_format_t) 43)	/* in three bytes */
+#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_U18_3BE
+
+#ifdef SNDRV_LITTLE_ENDIAN
+#define	SNDRV_PCM_FORMAT_S16		SNDRV_PCM_FORMAT_S16_LE
+#define	SNDRV_PCM_FORMAT_U16		SNDRV_PCM_FORMAT_U16_LE
+#define	SNDRV_PCM_FORMAT_S24		SNDRV_PCM_FORMAT_S24_LE
+#define	SNDRV_PCM_FORMAT_U24		SNDRV_PCM_FORMAT_U24_LE
+#define	SNDRV_PCM_FORMAT_S32		SNDRV_PCM_FORMAT_S32_LE
+#define	SNDRV_PCM_FORMAT_U32		SNDRV_PCM_FORMAT_U32_LE
+#define	SNDRV_PCM_FORMAT_FLOAT		SNDRV_PCM_FORMAT_FLOAT_LE
+#define	SNDRV_PCM_FORMAT_FLOAT64	SNDRV_PCM_FORMAT_FLOAT64_LE
+#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE
+#endif
+#ifdef SNDRV_BIG_ENDIAN
+#define	SNDRV_PCM_FORMAT_S16		SNDRV_PCM_FORMAT_S16_BE
+#define	SNDRV_PCM_FORMAT_U16		SNDRV_PCM_FORMAT_U16_BE
+#define	SNDRV_PCM_FORMAT_S24		SNDRV_PCM_FORMAT_S24_BE
+#define	SNDRV_PCM_FORMAT_U24		SNDRV_PCM_FORMAT_U24_BE
+#define	SNDRV_PCM_FORMAT_S32		SNDRV_PCM_FORMAT_S32_BE
+#define	SNDRV_PCM_FORMAT_U32		SNDRV_PCM_FORMAT_U32_BE
+#define	SNDRV_PCM_FORMAT_FLOAT		SNDRV_PCM_FORMAT_FLOAT_BE
+#define	SNDRV_PCM_FORMAT_FLOAT64	SNDRV_PCM_FORMAT_FLOAT64_BE
+#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE
+#endif
+
+typedef int __bitwise snd_pcm_subformat_t;
+#define	SNDRV_PCM_SUBFORMAT_STD		((snd_pcm_subformat_t) 0)
+#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD
+
+#define SNDRV_PCM_INFO_MMAP		0x00000001	/* hardware supports mmap */
+#define SNDRV_PCM_INFO_MMAP_VALID	0x00000002	/* period data are valid during transfer */
+#define SNDRV_PCM_INFO_DOUBLE		0x00000004	/* Double buffering needed for PCM start/stop */
+#define SNDRV_PCM_INFO_BATCH		0x00000010	/* double buffering */
+#define SNDRV_PCM_INFO_INTERLEAVED	0x00000100	/* channels are interleaved */
+#define SNDRV_PCM_INFO_NONINTERLEAVED	0x00000200	/* channels are not interleaved */
+#define SNDRV_PCM_INFO_COMPLEX		0x00000400	/* complex frame organization (mmap only) */
+#define SNDRV_PCM_INFO_BLOCK_TRANSFER	0x00010000	/* hardware transfer block of samples */
+#define SNDRV_PCM_INFO_OVERRANGE	0x00020000	/* hardware supports ADC (capture) overrange detection */
+#define SNDRV_PCM_INFO_RESUME		0x00040000	/* hardware supports stream resume after suspend */
+#define SNDRV_PCM_INFO_PAUSE		0x00080000	/* pause ioctl is supported */
+#define SNDRV_PCM_INFO_HALF_DUPLEX	0x00100000	/* only half duplex */
+#define SNDRV_PCM_INFO_JOINT_DUPLEX	0x00200000	/* playback and capture stream are somewhat correlated */
+#define SNDRV_PCM_INFO_SYNC_START	0x00400000	/* pcm support some kind of sync go */
+#define SNDRV_PCM_INFO_FIFO_IN_FRAMES	0x80000000	/* internal kernel flag - FIFO size is in frames */
+
+typedef int __bitwise snd_pcm_state_t;
+#define	SNDRV_PCM_STATE_OPEN		((snd_pcm_state_t) 0) /* stream is open */
+#define	SNDRV_PCM_STATE_SETUP		((snd_pcm_state_t) 1) /* stream has a setup */
+#define	SNDRV_PCM_STATE_PREPARED	((snd_pcm_state_t) 2) /* stream is ready to start */
+#define	SNDRV_PCM_STATE_RUNNING		((snd_pcm_state_t) 3) /* stream is running */
+#define	SNDRV_PCM_STATE_XRUN		((snd_pcm_state_t) 4) /* stream reached an xrun */
+#define	SNDRV_PCM_STATE_DRAINING	((snd_pcm_state_t) 5) /* stream is draining */
+#define	SNDRV_PCM_STATE_PAUSED		((snd_pcm_state_t) 6) /* stream is paused */
+#define	SNDRV_PCM_STATE_SUSPENDED	((snd_pcm_state_t) 7) /* hardware is suspended */
+#define	SNDRV_PCM_STATE_DISCONNECTED	((snd_pcm_state_t) 8) /* hardware is disconnected */
+#define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
+
+enum {
+	SNDRV_PCM_MMAP_OFFSET_DATA = 0x00000000,
+	SNDRV_PCM_MMAP_OFFSET_STATUS = 0x80000000,
+	SNDRV_PCM_MMAP_OFFSET_CONTROL = 0x81000000,
+};
+
+union snd_pcm_sync_id {
+	unsigned char id[16];
+	unsigned short id16[8];
+	unsigned int id32[4];
+};
+
+struct snd_pcm_info {
+	unsigned int device;		/* RO/WR (control): device number */
+	unsigned int subdevice;		/* RO/WR (control): subdevice number */
+	int stream;			/* RO/WR (control): stream direction */
+	int card;			/* R: card number */
+	unsigned char id[64];		/* ID (user selectable) */
+	unsigned char name[80];		/* name of this device */
+	unsigned char subname[32];	/* subdevice name */
+	int dev_class;			/* SNDRV_PCM_CLASS_* */
+	int dev_subclass;		/* SNDRV_PCM_SUBCLASS_* */
+	unsigned int subdevices_count;
+	unsigned int subdevices_avail;
+	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
+	unsigned char reserved[64];	/* reserved for future... */
+};
+
+typedef int snd_pcm_hw_param_t;
+#define	SNDRV_PCM_HW_PARAM_ACCESS	0	/* Access type */
+#define	SNDRV_PCM_HW_PARAM_FORMAT	1	/* Format */
+#define	SNDRV_PCM_HW_PARAM_SUBFORMAT	2	/* Subformat */
+#define	SNDRV_PCM_HW_PARAM_FIRST_MASK	SNDRV_PCM_HW_PARAM_ACCESS
+#define	SNDRV_PCM_HW_PARAM_LAST_MASK	SNDRV_PCM_HW_PARAM_SUBFORMAT
+
+#define	SNDRV_PCM_HW_PARAM_SAMPLE_BITS	8	/* Bits per sample */
+#define	SNDRV_PCM_HW_PARAM_FRAME_BITS	9	/* Bits per frame */
+#define	SNDRV_PCM_HW_PARAM_CHANNELS	10	/* Channels */
+#define	SNDRV_PCM_HW_PARAM_RATE		11	/* Approx rate */
+#define	SNDRV_PCM_HW_PARAM_PERIOD_TIME	12	/* Approx distance between
+						 * interrupts in us
+						 */
+#define	SNDRV_PCM_HW_PARAM_PERIOD_SIZE	13	/* Approx frames between
+						 * interrupts
+						 */
+#define	SNDRV_PCM_HW_PARAM_PERIOD_BYTES	14	/* Approx bytes between
+						 * interrupts
+						 */
+#define	SNDRV_PCM_HW_PARAM_PERIODS	15	/* Approx interrupts per
+						 * buffer
+						 */
+#define	SNDRV_PCM_HW_PARAM_BUFFER_TIME	16	/* Approx duration of buffer
+						 * in us
+						 */
+#define	SNDRV_PCM_HW_PARAM_BUFFER_SIZE	17	/* Size of buffer in frames */
+#define	SNDRV_PCM_HW_PARAM_BUFFER_BYTES	18	/* Size of buffer in bytes */
+#define	SNDRV_PCM_HW_PARAM_TICK_TIME	19	/* Approx tick duration in us */
+#define	SNDRV_PCM_HW_PARAM_FIRST_INTERVAL	SNDRV_PCM_HW_PARAM_SAMPLE_BITS
+#define	SNDRV_PCM_HW_PARAM_LAST_INTERVAL	SNDRV_PCM_HW_PARAM_TICK_TIME
+
+#define SNDRV_PCM_HW_PARAMS_NORESAMPLE	(1<<0)	/* avoid rate resampling */
+
+struct snd_interval {
+	unsigned int min, max;
+	unsigned int openmin:1,
+		     openmax:1,
+		     integer:1,
+		     empty:1;
+};
+
+#define SNDRV_MASK_MAX	256
+
+struct snd_mask {
+	__u32 bits[(SNDRV_MASK_MAX+31)/32];
+};
+
+struct snd_pcm_hw_params {
+	unsigned int flags;
+	struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - 
+			       SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+	struct snd_mask mres[5];	/* reserved masks */
+	struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+				        SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+	struct snd_interval ires[9];	/* reserved intervals */
+	unsigned int rmask;		/* W: requested masks */
+	unsigned int cmask;		/* R: changed masks */
+	unsigned int info;		/* R: Info flags for returned setup */
+	unsigned int msbits;		/* R: used most significant bits */
+	unsigned int rate_num;		/* R: rate numerator */
+	unsigned int rate_den;		/* R: rate denominator */
+	snd_pcm_uframes_t fifo_size;	/* R: chip FIFO size in frames */
+	unsigned char reserved[64];	/* reserved for future */
+};
+
+enum {
+	SNDRV_PCM_TSTAMP_NONE = 0,
+	SNDRV_PCM_TSTAMP_ENABLE,
+	SNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE,
+};
+
+struct snd_pcm_sw_params {
+	int tstamp_mode;			/* timestamp mode */
+	unsigned int period_step;
+	unsigned int sleep_min;			/* min ticks to sleep */
+	snd_pcm_uframes_t avail_min;		/* min avail frames for wakeup */
+	snd_pcm_uframes_t xfer_align;		/* obsolete: xfer size need to be a multiple */
+	snd_pcm_uframes_t start_threshold;	/* min hw_avail frames for automatic start */
+	snd_pcm_uframes_t stop_threshold;	/* min avail frames for automatic stop */
+	snd_pcm_uframes_t silence_threshold;	/* min distance from noise for silence filling */
+	snd_pcm_uframes_t silence_size;		/* silence block size */
+	snd_pcm_uframes_t boundary;		/* pointers wrap point */
+	unsigned char reserved[64];		/* reserved for future */
+};
+
+struct snd_pcm_channel_info {
+	unsigned int channel;
+	__kernel_off_t offset;		/* mmap offset */
+	unsigned int first;		/* offset to first sample in bits */
+	unsigned int step;		/* samples distance in bits */
+};
+
+struct snd_pcm_status {
+	snd_pcm_state_t state;		/* stream state */
+	struct timespec trigger_tstamp;	/* time when stream was started/stopped/paused */
+	struct timespec tstamp;		/* reference timestamp */
+	snd_pcm_uframes_t appl_ptr;	/* appl ptr */
+	snd_pcm_uframes_t hw_ptr;	/* hw ptr */
+	snd_pcm_sframes_t delay;	/* current delay in frames */
+	snd_pcm_uframes_t avail;	/* number of frames available */
+	snd_pcm_uframes_t avail_max;	/* max frames available on hw since last status */
+	snd_pcm_uframes_t overrange;	/* count of ADC (capture) overrange detections from last status */
+	snd_pcm_state_t suspended_state; /* suspended stream state */
+	unsigned char reserved[60];	/* must be filled with zero */
+};
+
+struct snd_pcm_mmap_status {
+	snd_pcm_state_t state;		/* RO: state - SNDRV_PCM_STATE_XXXX */
+	int pad1;			/* Needed for 64 bit alignment */
+	snd_pcm_uframes_t hw_ptr;	/* RO: hw ptr (0...boundary-1) */
+	struct timespec tstamp;		/* Timestamp */
+	snd_pcm_state_t suspended_state; /* RO: suspended stream state */
+};
+
+struct snd_pcm_mmap_control {
+	snd_pcm_uframes_t appl_ptr;	/* RW: appl ptr (0...boundary-1) */
+	snd_pcm_uframes_t avail_min;	/* RW: min available frames for wakeup */
+};
+
+#define SNDRV_PCM_SYNC_PTR_HWSYNC	(1<<0)	/* execute hwsync */
+#define SNDRV_PCM_SYNC_PTR_APPL		(1<<1)	/* get appl_ptr from driver (r/w op) */
+#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN	(1<<2)	/* get avail_min from driver */
+
+struct snd_pcm_sync_ptr {
+	unsigned int flags;
+	union {
+		struct snd_pcm_mmap_status status;
+		unsigned char reserved[64];
+	} s;
+	union {
+		struct snd_pcm_mmap_control control;
+		unsigned char reserved[64];
+	} c;
+};
+
+struct snd_xferi {
+	snd_pcm_sframes_t result;
+	void *buf;
+	snd_pcm_uframes_t frames;
+};
+
+struct snd_xfern {
+	snd_pcm_sframes_t result;
+	void * *bufs;
+	snd_pcm_uframes_t frames;
+};
+
+enum {
+	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,	/* gettimeofday equivalent */
+	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,	/* posix_clock_monotonic equivalent */
+	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,
+};
+
+#define SNDRV_PCM_IOCTL_PVERSION	_IOR('A', 0x00, int)
+#define SNDRV_PCM_IOCTL_INFO		_IOR('A', 0x01, struct snd_pcm_info)
+#define SNDRV_PCM_IOCTL_TSTAMP		_IOW('A', 0x02, int)
+#define SNDRV_PCM_IOCTL_TTSTAMP		_IOW('A', 0x03, int)
+#define SNDRV_PCM_IOCTL_HW_REFINE	_IOWR('A', 0x10, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_PARAMS	_IOWR('A', 0x11, struct snd_pcm_hw_params)
+#define SNDRV_PCM_IOCTL_HW_FREE		_IO('A', 0x12)
+#define SNDRV_PCM_IOCTL_SW_PARAMS	_IOWR('A', 0x13, struct snd_pcm_sw_params)
+#define SNDRV_PCM_IOCTL_STATUS		_IOR('A', 0x20, struct snd_pcm_status)
+#define SNDRV_PCM_IOCTL_DELAY		_IOR('A', 0x21, snd_pcm_sframes_t)
+#define SNDRV_PCM_IOCTL_HWSYNC		_IO('A', 0x22)
+#define SNDRV_PCM_IOCTL_SYNC_PTR	_IOWR('A', 0x23, struct snd_pcm_sync_ptr)
+#define SNDRV_PCM_IOCTL_CHANNEL_INFO	_IOR('A', 0x32, struct snd_pcm_channel_info)
+#define SNDRV_PCM_IOCTL_PREPARE		_IO('A', 0x40)
+#define SNDRV_PCM_IOCTL_RESET		_IO('A', 0x41)
+#define SNDRV_PCM_IOCTL_START		_IO('A', 0x42)
+#define SNDRV_PCM_IOCTL_DROP		_IO('A', 0x43)
+#define SNDRV_PCM_IOCTL_DRAIN		_IO('A', 0x44)
+#define SNDRV_PCM_IOCTL_PAUSE		_IOW('A', 0x45, int)
+#define SNDRV_PCM_IOCTL_REWIND		_IOW('A', 0x46, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_RESUME		_IO('A', 0x47)
+#define SNDRV_PCM_IOCTL_XRUN		_IO('A', 0x48)
+#define SNDRV_PCM_IOCTL_FORWARD		_IOW('A', 0x49, snd_pcm_uframes_t)
+#define SNDRV_PCM_IOCTL_WRITEI_FRAMES	_IOW('A', 0x50, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_READI_FRAMES	_IOR('A', 0x51, struct snd_xferi)
+#define SNDRV_PCM_IOCTL_WRITEN_FRAMES	_IOW('A', 0x52, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
+#define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
+#define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
+
+/*****************************************************************************
+ *                                                                           *
+ *                            MIDI v1.0 interface                            *
+ *                                                                           *
+ *****************************************************************************/
+
+/*
+ *  Raw MIDI section - /dev/snd/midi??
+ */
+
+#define SNDRV_RAWMIDI_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 0)
+
+enum {
+	SNDRV_RAWMIDI_STREAM_OUTPUT = 0,
+	SNDRV_RAWMIDI_STREAM_INPUT,
+	SNDRV_RAWMIDI_STREAM_LAST = SNDRV_RAWMIDI_STREAM_INPUT,
+};
+
+#define SNDRV_RAWMIDI_INFO_OUTPUT		0x00000001
+#define SNDRV_RAWMIDI_INFO_INPUT		0x00000002
+#define SNDRV_RAWMIDI_INFO_DUPLEX		0x00000004
+
+struct snd_rawmidi_info {
+	unsigned int device;		/* RO/WR (control): device number */
+	unsigned int subdevice;		/* RO/WR (control): subdevice number */
+	int stream;			/* WR: stream */
+	int card;			/* R: card number */
+	unsigned int flags;		/* SNDRV_RAWMIDI_INFO_XXXX */
+	unsigned char id[64];		/* ID (user selectable) */
+	unsigned char name[80];		/* name of device */
+	unsigned char subname[32];	/* name of active or selected subdevice */
+	unsigned int subdevices_count;
+	unsigned int subdevices_avail;
+	unsigned char reserved[64];	/* reserved for future use */
+};
+
+struct snd_rawmidi_params {
+	int stream;
+	size_t buffer_size;		/* queue size in bytes */
+	size_t avail_min;		/* minimum avail bytes for wakeup */
+	unsigned int no_active_sensing: 1; /* do not send active sensing byte in close() */
+	unsigned char reserved[16];	/* reserved for future use */
+};
+
+struct snd_rawmidi_status {
+	int stream;
+	struct timespec tstamp;		/* Timestamp */
+	size_t avail;			/* available bytes */
+	size_t xruns;			/* count of overruns since last status (in bytes) */
+	unsigned char reserved[16];	/* reserved for future use */
+};
+
+#define SNDRV_RAWMIDI_IOCTL_PVERSION	_IOR('W', 0x00, int)
+#define SNDRV_RAWMIDI_IOCTL_INFO	_IOR('W', 0x01, struct snd_rawmidi_info)
+#define SNDRV_RAWMIDI_IOCTL_PARAMS	_IOWR('W', 0x10, struct snd_rawmidi_params)
+#define SNDRV_RAWMIDI_IOCTL_STATUS	_IOWR('W', 0x20, struct snd_rawmidi_status)
+#define SNDRV_RAWMIDI_IOCTL_DROP	_IOW('W', 0x30, int)
+#define SNDRV_RAWMIDI_IOCTL_DRAIN	_IOW('W', 0x31, int)
+
+/*
+ *  Timer section - /dev/snd/timer
+ */
+
+#define SNDRV_TIMER_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 5)
+
+enum {
+	SNDRV_TIMER_CLASS_NONE = -1,
+	SNDRV_TIMER_CLASS_SLAVE = 0,
+	SNDRV_TIMER_CLASS_GLOBAL,
+	SNDRV_TIMER_CLASS_CARD,
+	SNDRV_TIMER_CLASS_PCM,
+	SNDRV_TIMER_CLASS_LAST = SNDRV_TIMER_CLASS_PCM,
+};
+
+/* slave timer classes */
+enum {
+	SNDRV_TIMER_SCLASS_NONE = 0,
+	SNDRV_TIMER_SCLASS_APPLICATION,
+	SNDRV_TIMER_SCLASS_SEQUENCER,		/* alias */
+	SNDRV_TIMER_SCLASS_OSS_SEQUENCER,	/* alias */
+	SNDRV_TIMER_SCLASS_LAST = SNDRV_TIMER_SCLASS_OSS_SEQUENCER,
+};
+
+/* global timers (device member) */
+#define SNDRV_TIMER_GLOBAL_SYSTEM	0
+#define SNDRV_TIMER_GLOBAL_RTC		1
+#define SNDRV_TIMER_GLOBAL_HPET		2
+#define SNDRV_TIMER_GLOBAL_HRTIMER	3
+
+/* info flags */
+#define SNDRV_TIMER_FLG_SLAVE		(1<<0)	/* cannot be controlled */
+
+struct snd_timer_id {
+	int dev_class;	
+	int dev_sclass;
+	int card;
+	int device;
+	int subdevice;
+};
+
+struct snd_timer_ginfo {
+	struct snd_timer_id tid;	/* requested timer ID */
+	unsigned int flags;		/* timer flags - SNDRV_TIMER_FLG_* */
+	int card;			/* card number */
+	unsigned char id[64];		/* timer identification */
+	unsigned char name[80];		/* timer name */
+	unsigned long reserved0;	/* reserved for future use */
+	unsigned long resolution;	/* average period resolution in ns */
+	unsigned long resolution_min;	/* minimal period resolution in ns */
+	unsigned long resolution_max;	/* maximal period resolution in ns */
+	unsigned int clients;		/* active timer clients */
+	unsigned char reserved[32];
+};
+
+struct snd_timer_gparams {
+	struct snd_timer_id tid;	/* requested timer ID */
+	unsigned long period_num;	/* requested precise period duration (in seconds) - numerator */
+	unsigned long period_den;	/* requested precise period duration (in seconds) - denominator */
+	unsigned char reserved[32];
+};
+
+struct snd_timer_gstatus {
+	struct snd_timer_id tid;	/* requested timer ID */
+	unsigned long resolution;	/* current period resolution in ns */
+	unsigned long resolution_num;	/* precise current period resolution (in seconds) - numerator */
+	unsigned long resolution_den;	/* precise current period resolution (in seconds) - denominator */
+	unsigned char reserved[32];
+};
+
+struct snd_timer_select {
+	struct snd_timer_id id;	/* bind to timer ID */
+	unsigned char reserved[32];	/* reserved */
+};
+
+struct snd_timer_info {
+	unsigned int flags;		/* timer flags - SNDRV_TIMER_FLG_* */
+	int card;			/* card number */
+	unsigned char id[64];		/* timer identificator */
+	unsigned char name[80];		/* timer name */
+	unsigned long reserved0;	/* reserved for future use */
+	unsigned long resolution;	/* average period resolution in ns */
+	unsigned char reserved[64];	/* reserved */
+};
+
+#define SNDRV_TIMER_PSFLG_AUTO		(1<<0)	/* auto start, otherwise one-shot */
+#define SNDRV_TIMER_PSFLG_EXCLUSIVE	(1<<1)	/* exclusive use, precise start/stop/pause/continue */
+#define SNDRV_TIMER_PSFLG_EARLY_EVENT	(1<<2)	/* write early event to the poll queue */
+
+struct snd_timer_params {
+	unsigned int flags;		/* flags - SNDRV_MIXER_PSFLG_* */
+	unsigned int ticks;		/* requested resolution in ticks */
+	unsigned int queue_size;	/* total size of queue (32-1024) */
+	unsigned int reserved0;		/* reserved, was: failure locations */
+	unsigned int filter;		/* event filter (bitmask of SNDRV_TIMER_EVENT_*) */
+	unsigned char reserved[60];	/* reserved */
+};
+
+struct snd_timer_status {
+	struct timespec tstamp;		/* Timestamp - last update */
+	unsigned int resolution;	/* current period resolution in ns */
+	unsigned int lost;		/* counter of master tick lost */
+	unsigned int overrun;		/* count of read queue overruns */
+	unsigned int queue;		/* used queue size */
+	unsigned char reserved[64];	/* reserved */
+};
+
+#define SNDRV_TIMER_IOCTL_PVERSION	_IOR('T', 0x00, int)
+#define SNDRV_TIMER_IOCTL_NEXT_DEVICE	_IOWR('T', 0x01, struct snd_timer_id)
+#define SNDRV_TIMER_IOCTL_TREAD		_IOW('T', 0x02, int)
+#define SNDRV_TIMER_IOCTL_GINFO		_IOWR('T', 0x03, struct snd_timer_ginfo)
+#define SNDRV_TIMER_IOCTL_GPARAMS	_IOW('T', 0x04, struct snd_timer_gparams)
+#define SNDRV_TIMER_IOCTL_GSTATUS	_IOWR('T', 0x05, struct snd_timer_gstatus)
+#define SNDRV_TIMER_IOCTL_SELECT	_IOW('T', 0x10, struct snd_timer_select)
+#define SNDRV_TIMER_IOCTL_INFO		_IOR('T', 0x11, struct snd_timer_info)
+#define SNDRV_TIMER_IOCTL_PARAMS	_IOW('T', 0x12, struct snd_timer_params)
+#define SNDRV_TIMER_IOCTL_STATUS	_IOR('T', 0x14, struct snd_timer_status)
+/* The following four ioctls are changed since 1.0.9 due to confliction */
+#define SNDRV_TIMER_IOCTL_START		_IO('T', 0xa0)
+#define SNDRV_TIMER_IOCTL_STOP		_IO('T', 0xa1)
+#define SNDRV_TIMER_IOCTL_CONTINUE	_IO('T', 0xa2)
+#define SNDRV_TIMER_IOCTL_PAUSE		_IO('T', 0xa3)
+
+struct snd_timer_read {
+	unsigned int resolution;
+	unsigned int ticks;
+};
+
+enum {
+	SNDRV_TIMER_EVENT_RESOLUTION = 0,	/* val = resolution in ns */
+	SNDRV_TIMER_EVENT_TICK,			/* val = ticks */
+	SNDRV_TIMER_EVENT_START,		/* val = resolution in ns */
+	SNDRV_TIMER_EVENT_STOP,			/* val = 0 */
+	SNDRV_TIMER_EVENT_CONTINUE,		/* val = resolution in ns */
+	SNDRV_TIMER_EVENT_PAUSE,		/* val = 0 */
+	SNDRV_TIMER_EVENT_EARLY,		/* val = 0, early event */
+	SNDRV_TIMER_EVENT_SUSPEND,		/* val = 0 */
+	SNDRV_TIMER_EVENT_RESUME,		/* val = resolution in ns */
+	/* master timer events for slave timer instances */
+	SNDRV_TIMER_EVENT_MSTART = SNDRV_TIMER_EVENT_START + 10,
+	SNDRV_TIMER_EVENT_MSTOP = SNDRV_TIMER_EVENT_STOP + 10,
+	SNDRV_TIMER_EVENT_MCONTINUE = SNDRV_TIMER_EVENT_CONTINUE + 10,
+	SNDRV_TIMER_EVENT_MPAUSE = SNDRV_TIMER_EVENT_PAUSE + 10,
+	SNDRV_TIMER_EVENT_MSUSPEND = SNDRV_TIMER_EVENT_SUSPEND + 10,
+	SNDRV_TIMER_EVENT_MRESUME = SNDRV_TIMER_EVENT_RESUME + 10,
+};
+
+struct snd_timer_tread {
+	int event;
+	struct timespec tstamp;
+	unsigned int val;
+};
+
+/****************************************************************************
+ *                                                                          *
+ *        Section for driver control interface - /dev/snd/control?          *
+ *                                                                          *
+ ****************************************************************************/
+
+#define SNDRV_CTL_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 6)
+
+struct snd_ctl_card_info {
+	int card;			/* card number */
+	int pad;			/* reserved for future (was type) */
+	unsigned char id[16];		/* ID of card (user selectable) */
+	unsigned char driver[16];	/* Driver name */
+	unsigned char name[32];		/* Short name of soundcard */
+	unsigned char longname[80];	/* name + info text about soundcard */
+	unsigned char reserved_[16];	/* reserved for future (was ID of mixer) */
+	unsigned char mixername[80];	/* visual mixer identification */
+	unsigned char components[128];	/* card components / fine identification, delimited with one space (AC97 etc..) */
+};
+
+typedef int __bitwise snd_ctl_elem_type_t;
+#define	SNDRV_CTL_ELEM_TYPE_NONE	((snd_ctl_elem_type_t) 0) /* invalid */
+#define	SNDRV_CTL_ELEM_TYPE_BOOLEAN	((snd_ctl_elem_type_t) 1) /* boolean type */
+#define	SNDRV_CTL_ELEM_TYPE_INTEGER	((snd_ctl_elem_type_t) 2) /* integer type */
+#define	SNDRV_CTL_ELEM_TYPE_ENUMERATED	((snd_ctl_elem_type_t) 3) /* enumerated type */
+#define	SNDRV_CTL_ELEM_TYPE_BYTES	((snd_ctl_elem_type_t) 4) /* byte array */
+#define	SNDRV_CTL_ELEM_TYPE_IEC958	((snd_ctl_elem_type_t) 5) /* IEC958 (S/PDIF) setup */
+#define	SNDRV_CTL_ELEM_TYPE_INTEGER64	((snd_ctl_elem_type_t) 6) /* 64-bit integer type */
+#define	SNDRV_CTL_ELEM_TYPE_LAST	SNDRV_CTL_ELEM_TYPE_INTEGER64
+
+typedef int __bitwise snd_ctl_elem_iface_t;
+#define	SNDRV_CTL_ELEM_IFACE_CARD	((snd_ctl_elem_iface_t) 0) /* global control */
+#define	SNDRV_CTL_ELEM_IFACE_HWDEP	((snd_ctl_elem_iface_t) 1) /* hardware dependent device */
+#define	SNDRV_CTL_ELEM_IFACE_MIXER	((snd_ctl_elem_iface_t) 2) /* virtual mixer device */
+#define	SNDRV_CTL_ELEM_IFACE_PCM	((snd_ctl_elem_iface_t) 3) /* PCM device */
+#define	SNDRV_CTL_ELEM_IFACE_RAWMIDI	((snd_ctl_elem_iface_t) 4) /* RawMidi device */
+#define	SNDRV_CTL_ELEM_IFACE_TIMER	((snd_ctl_elem_iface_t) 5) /* timer device */
+#define	SNDRV_CTL_ELEM_IFACE_SEQUENCER	((snd_ctl_elem_iface_t) 6) /* sequencer client */
+#define	SNDRV_CTL_ELEM_IFACE_LAST	SNDRV_CTL_ELEM_IFACE_SEQUENCER
+
+#define SNDRV_CTL_ELEM_ACCESS_READ		(1<<0)
+#define SNDRV_CTL_ELEM_ACCESS_WRITE		(1<<1)
+#define SNDRV_CTL_ELEM_ACCESS_READWRITE		(SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_VOLATILE		(1<<2)	/* control value may be changed without a notification */
+#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP		(1<<3)	/* when was control changed */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READ		(1<<4)	/* TLV read is possible */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE		(1<<5)	/* TLV write is possible */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE	(SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND	(1<<6)	/* TLV command is possible */
+#define SNDRV_CTL_ELEM_ACCESS_INACTIVE		(1<<8)	/* control does actually nothing, but may be updated */
+#define SNDRV_CTL_ELEM_ACCESS_LOCK		(1<<9)	/* write lock */
+#define SNDRV_CTL_ELEM_ACCESS_OWNER		(1<<10)	/* write lock owner */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK	(1<<28)	/* kernel use a TLV callback */ 
+#define SNDRV_CTL_ELEM_ACCESS_USER		(1<<29) /* user space element */
+/* bits 30 and 31 are obsoleted (for indirect access) */
+
+/* for further details see the ACPI and PCI power management specification */
+#define SNDRV_CTL_POWER_D0		0x0000	/* full On */
+#define SNDRV_CTL_POWER_D1		0x0100	/* partial On */
+#define SNDRV_CTL_POWER_D2		0x0200	/* partial On */
+#define SNDRV_CTL_POWER_D3		0x0300	/* Off */
+#define SNDRV_CTL_POWER_D3hot		(SNDRV_CTL_POWER_D3|0x0000)	/* Off, with power */
+#define SNDRV_CTL_POWER_D3cold		(SNDRV_CTL_POWER_D3|0x0001)	/* Off, without power */
+
+struct snd_ctl_elem_id {
+	unsigned int numid;		/* numeric identifier, zero = invalid */
+	snd_ctl_elem_iface_t iface;	/* interface identifier */
+	unsigned int device;		/* device/client number */
+	unsigned int subdevice;		/* subdevice (substream) number */
+        unsigned char name[44];		/* ASCII name of item */
+	unsigned int index;		/* index of item */
+};
+
+struct snd_ctl_elem_list {
+	unsigned int offset;		/* W: first element ID to get */
+	unsigned int space;		/* W: count of element IDs to get */
+	unsigned int used;		/* R: count of element IDs set */
+	unsigned int count;		/* R: count of all elements */
+	struct snd_ctl_elem_id *pids; /* R: IDs */
+	unsigned char reserved[50];
+};
+
+struct snd_ctl_elem_info {
+	struct snd_ctl_elem_id id;	/* W: element ID */
+	snd_ctl_elem_type_t type;	/* R: value type - SNDRV_CTL_ELEM_TYPE_* */
+	unsigned int access;		/* R: value access (bitmask) - SNDRV_CTL_ELEM_ACCESS_* */
+	unsigned int count;		/* count of values */
+	__kernel_pid_t owner;		/* owner's PID of this control */
+	union {
+		struct {
+			long min;		/* R: minimum value */
+			long max;		/* R: maximum value */
+			long step;		/* R: step (0 variable) */
+		} integer;
+		struct {
+			long long min;		/* R: minimum value */
+			long long max;		/* R: maximum value */
+			long long step;		/* R: step (0 variable) */
+		} integer64;
+		struct {
+			unsigned int items;	/* R: number of items */
+			unsigned int item;	/* W: item number */
+			char name[64];		/* R: value name */
+		} enumerated;
+		unsigned char reserved[128];
+	} value;
+	union {
+		unsigned short d[4];		/* dimensions */
+		unsigned short *d_ptr;		/* indirect - obsoleted */
+	} dimen;
+	unsigned char reserved[64-4*sizeof(unsigned short)];
+};
+
+struct snd_ctl_elem_value {
+	struct snd_ctl_elem_id id;	/* W: element ID */
+	unsigned int indirect: 1;	/* W: indirect access - obsoleted */
+        union {
+		union {
+			long value[128];
+			long *value_ptr;	/* obsoleted */
+		} integer;
+		union {
+			long long value[64];
+			long long *value_ptr;	/* obsoleted */
+		} integer64;
+		union {
+			unsigned int item[128];
+			unsigned int *item_ptr;	/* obsoleted */
+		} enumerated;
+		union {
+			unsigned char data[512];
+			unsigned char *data_ptr;	/* obsoleted */
+		} bytes;
+		struct snd_aes_iec958 iec958;
+        } value;                /* RO */
+	struct timespec tstamp;
+        unsigned char reserved[128-sizeof(struct timespec)];
+};
+
+struct snd_ctl_tlv {
+        unsigned int numid;	/* control element numeric identification */
+        unsigned int length;	/* in bytes aligned to 4 */
+        unsigned int tlv[0];	/* first TLV */
+};
+
+#define SNDRV_CTL_IOCTL_PVERSION	_IOR('U', 0x00, int)
+#define SNDRV_CTL_IOCTL_CARD_INFO	_IOR('U', 0x01, struct snd_ctl_card_info)
+#define SNDRV_CTL_IOCTL_ELEM_LIST	_IOWR('U', 0x10, struct snd_ctl_elem_list)
+#define SNDRV_CTL_IOCTL_ELEM_INFO	_IOWR('U', 0x11, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_READ	_IOWR('U', 0x12, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_WRITE	_IOWR('U', 0x13, struct snd_ctl_elem_value)
+#define SNDRV_CTL_IOCTL_ELEM_LOCK	_IOW('U', 0x14, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_ELEM_UNLOCK	_IOW('U', 0x15, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)
+#define SNDRV_CTL_IOCTL_ELEM_ADD	_IOWR('U', 0x17, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REPLACE	_IOWR('U', 0x18, struct snd_ctl_elem_info)
+#define SNDRV_CTL_IOCTL_ELEM_REMOVE	_IOWR('U', 0x19, struct snd_ctl_elem_id)
+#define SNDRV_CTL_IOCTL_TLV_READ	_IOWR('U', 0x1a, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_WRITE	_IOWR('U', 0x1b, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_TLV_COMMAND	_IOWR('U', 0x1c, struct snd_ctl_tlv)
+#define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR('U', 0x20, int)
+#define SNDRV_CTL_IOCTL_HWDEP_INFO	_IOR('U', 0x21, struct snd_hwdep_info)
+#define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE	_IOR('U', 0x30, int)
+#define SNDRV_CTL_IOCTL_PCM_INFO	_IOWR('U', 0x31, struct snd_pcm_info)
+#define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW('U', 0x32, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR('U', 0x40, int)
+#define SNDRV_CTL_IOCTL_RAWMIDI_INFO	_IOWR('U', 0x41, struct snd_rawmidi_info)
+#define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW('U', 0x42, int)
+#define SNDRV_CTL_IOCTL_POWER		_IOWR('U', 0xd0, int)
+#define SNDRV_CTL_IOCTL_POWER_STATE	_IOR('U', 0xd1, int)
+
+/*
+ *  Read interface.
+ */
+
+enum sndrv_ctl_event_type {
+	SNDRV_CTL_EVENT_ELEM = 0,
+	SNDRV_CTL_EVENT_LAST = SNDRV_CTL_EVENT_ELEM,
+};
+
+#define SNDRV_CTL_EVENT_MASK_VALUE	(1<<0)	/* element value was changed */
+#define SNDRV_CTL_EVENT_MASK_INFO	(1<<1)	/* element info was changed */
+#define SNDRV_CTL_EVENT_MASK_ADD	(1<<2)	/* element was added */
+#define SNDRV_CTL_EVENT_MASK_TLV	(1<<3)	/* element TLV tree was changed */
+#define SNDRV_CTL_EVENT_MASK_REMOVE	(~0U)	/* element was removed */
+
+struct snd_ctl_event {
+	int type;	/* event type - SNDRV_CTL_EVENT_* */
+	union {
+		struct {
+			unsigned int mask;
+			struct snd_ctl_elem_id id;
+		} elem;
+                unsigned char data8[60];
+        } data;
+};
+
+/*
+ *  Control names
+ */
+
+#define SNDRV_CTL_NAME_NONE				""
+#define SNDRV_CTL_NAME_PLAYBACK				"Playback "
+#define SNDRV_CTL_NAME_CAPTURE				"Capture "
+
+#define SNDRV_CTL_NAME_IEC958_NONE			""
+#define SNDRV_CTL_NAME_IEC958_SWITCH			"Switch"
+#define SNDRV_CTL_NAME_IEC958_VOLUME			"Volume"
+#define SNDRV_CTL_NAME_IEC958_DEFAULT			"Default"
+#define SNDRV_CTL_NAME_IEC958_MASK			"Mask"
+#define SNDRV_CTL_NAME_IEC958_CON_MASK			"Con Mask"
+#define SNDRV_CTL_NAME_IEC958_PRO_MASK			"Pro Mask"
+#define SNDRV_CTL_NAME_IEC958_PCM_STREAM		"PCM Stream"
+#define SNDRV_CTL_NAME_IEC958(expl,direction,what)	"IEC958 " expl SNDRV_CTL_NAME_##direction SNDRV_CTL_NAME_IEC958_##what
+
+#endif /* __SOUND_ASOUND_H */
diff -uNr linux-2.6.32/usr/include/sound/emu10k1.h clean_modified/linux-2.6.32/usr/include/sound/emu10k1.h
--- linux-2.6.32/usr/include/sound/emu10k1.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/emu10k1.h	2019-04-14 13:24:03.216285258 -0500
@@ -0,0 +1,371 @@
+#ifndef __SOUND_EMU10K1_H
+#define __SOUND_EMU10K1_H
+
+#include <linux/types.h>
+
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
+ *		     Creative Labs, Inc.
+ *  Definitions for EMU10K1 (SB Live!) chips
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+
+/*
+ * ---- FX8010 ----
+ */
+
+#define EMU10K1_CARD_CREATIVE			0x00000000
+#define EMU10K1_CARD_EMUAPS			0x00000001
+
+#define EMU10K1_FX8010_PCM_COUNT		8
+
+/* instruction set */
+#define iMAC0	 0x00	/* R = A + (X * Y >> 31)   ; saturation */
+#define iMAC1	 0x01	/* R = A + (-X * Y >> 31)  ; saturation */
+#define iMAC2	 0x02	/* R = A + (X * Y >> 31)   ; wraparound */
+#define iMAC3	 0x03	/* R = A + (-X * Y >> 31)  ; wraparound */
+#define iMACINT0 0x04	/* R = A + X * Y	   ; saturation */
+#define iMACINT1 0x05	/* R = A + X * Y	   ; wraparound (31-bit) */
+#define iACC3	 0x06	/* R = A + X + Y	   ; saturation */
+#define iMACMV   0x07	/* R = A, acc += X * Y >> 31 */
+#define iANDXOR  0x08	/* R = (A & X) ^ Y */
+#define iTSTNEG  0x09	/* R = (A >= Y) ? X : ~X */
+#define iLIMITGE 0x0a	/* R = (A >= Y) ? X : Y */
+#define iLIMITLT 0x0b	/* R = (A < Y) ? X : Y */
+#define iLOG	 0x0c	/* R = linear_data, A (log_data), X (max_exp), Y (format_word) */
+#define iEXP	 0x0d	/* R = log_data, A (linear_data), X (max_exp), Y (format_word) */
+#define iINTERP  0x0e	/* R = A + (X * (Y - A) >> 31)  ; saturation */
+#define iSKIP    0x0f	/* R = A (cc_reg), X (count), Y (cc_test) */
+
+/* GPRs */
+#define FXBUS(x)	(0x00 + (x))	/* x = 0x00 - 0x0f */
+#define EXTIN(x)	(0x10 + (x))	/* x = 0x00 - 0x0f */
+#define EXTOUT(x)	(0x20 + (x))	/* x = 0x00 - 0x0f physical outs -> FXWC low 16 bits */
+#define FXBUS2(x)	(0x30 + (x))	/* x = 0x00 - 0x0f copies of fx buses for capture -> FXWC high 16 bits */
+					/* NB: 0x31 and 0x32 are shared with Center/LFE on SB live 5.1 */
+
+#define C_00000000	0x40
+#define C_00000001	0x41
+#define C_00000002	0x42
+#define C_00000003	0x43
+#define C_00000004	0x44
+#define C_00000008	0x45
+#define C_00000010	0x46
+#define C_00000020	0x47
+#define C_00000100	0x48
+#define C_00010000	0x49
+#define C_00080000	0x4a
+#define C_10000000	0x4b
+#define C_20000000	0x4c
+#define C_40000000	0x4d
+#define C_80000000	0x4e
+#define C_7fffffff	0x4f
+#define C_ffffffff	0x50
+#define C_fffffffe	0x51
+#define C_c0000000	0x52
+#define C_4f1bbcdc	0x53
+#define C_5a7ef9db	0x54
+#define C_00100000	0x55		/* ?? */
+#define GPR_ACCU	0x56		/* ACCUM, accumulator */
+#define GPR_COND	0x57		/* CCR, condition register */
+#define GPR_NOISE0	0x58		/* noise source */
+#define GPR_NOISE1	0x59		/* noise source */
+#define GPR_IRQ		0x5a		/* IRQ register */
+#define GPR_DBAC	0x5b		/* TRAM Delay Base Address Counter */
+#define GPR(x)		(FXGPREGBASE + (x)) /* free GPRs: x = 0x00 - 0xff */
+#define ITRAM_DATA(x)	(TANKMEMDATAREGBASE + 0x00 + (x)) /* x = 0x00 - 0x7f */
+#define ETRAM_DATA(x)	(TANKMEMDATAREGBASE + 0x80 + (x)) /* x = 0x00 - 0x1f */
+#define ITRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x00 + (x)) /* x = 0x00 - 0x7f */
+#define ETRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x80 + (x)) /* x = 0x00 - 0x1f */
+
+#define A_ITRAM_DATA(x)	(TANKMEMDATAREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_DATA(x)	(TANKMEMDATAREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+#define A_ITRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_ADDR(x)	(TANKMEMADDRREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+#define A_ITRAM_CTL(x)	(A_TANKMEMCTLREGBASE + 0x00 + (x)) /* x = 0x00 - 0xbf */
+#define A_ETRAM_CTL(x)	(A_TANKMEMCTLREGBASE + 0xc0 + (x)) /* x = 0x00 - 0x3f */
+
+#define A_FXBUS(x)	(0x00 + (x))	/* x = 0x00 - 0x3f FX buses */
+#define A_EXTIN(x)	(0x40 + (x))	/* x = 0x00 - 0x0f physical ins */
+#define A_P16VIN(x)	(0x50 + (x))	/* x = 0x00 - 0x0f p16v ins (A2 only) "EMU32 inputs" */
+#define A_EXTOUT(x)	(0x60 + (x))	/* x = 0x00 - 0x1f physical outs -> A_FXWC1 0x79-7f unknown   */
+#define A_FXBUS2(x)	(0x80 + (x))	/* x = 0x00 - 0x1f extra outs used for EFX capture -> A_FXWC2 */
+#define A_EMU32OUTH(x)	(0xa0 + (x))	/* x = 0x00 - 0x0f "EMU32_OUT_10 - _1F" - ??? */
+#define A_EMU32OUTL(x)	(0xb0 + (x))	/* x = 0x00 - 0x0f "EMU32_OUT_1 - _F" - ??? */
+#define A3_EMU32IN(x)	(0x160 + (x))	/* x = 0x00 - 0x3f "EMU32_IN_00 - _3F" - Only when .device = 0x0008 */
+#define A3_EMU32OUT(x)	(0x1E0 + (x))	/* x = 0x00 - 0x0f "EMU32_OUT_00 - _3F" - Only when .device = 0x0008 */
+#define A_GPR(x)	(A_FXGPREGBASE + (x))
+
+/* cc_reg constants */
+#define CC_REG_NORMALIZED C_00000001
+#define CC_REG_BORROW	C_00000002
+#define CC_REG_MINUS	C_00000004
+#define CC_REG_ZERO	C_00000008
+#define CC_REG_SATURATE	C_00000010
+#define CC_REG_NONZERO	C_00000100
+
+/* FX buses */
+#define FXBUS_PCM_LEFT		0x00
+#define FXBUS_PCM_RIGHT		0x01
+#define FXBUS_PCM_LEFT_REAR	0x02
+#define FXBUS_PCM_RIGHT_REAR	0x03
+#define FXBUS_MIDI_LEFT		0x04
+#define FXBUS_MIDI_RIGHT	0x05
+#define FXBUS_PCM_CENTER	0x06
+#define FXBUS_PCM_LFE		0x07
+#define FXBUS_PCM_LEFT_FRONT	0x08
+#define FXBUS_PCM_RIGHT_FRONT	0x09
+#define FXBUS_MIDI_REVERB	0x0c
+#define FXBUS_MIDI_CHORUS	0x0d
+#define FXBUS_PCM_LEFT_SIDE	0x0e
+#define FXBUS_PCM_RIGHT_SIDE	0x0f
+#define FXBUS_PT_LEFT		0x14
+#define FXBUS_PT_RIGHT		0x15
+
+/* Inputs */
+#define EXTIN_AC97_L	   0x00	/* AC'97 capture channel - left */
+#define EXTIN_AC97_R	   0x01	/* AC'97 capture channel - right */
+#define EXTIN_SPDIF_CD_L   0x02	/* internal S/PDIF CD - onboard - left */
+#define EXTIN_SPDIF_CD_R   0x03	/* internal S/PDIF CD - onboard - right */
+#define EXTIN_ZOOM_L	   0x04	/* Zoom Video I2S - left */
+#define EXTIN_ZOOM_R	   0x05	/* Zoom Video I2S - right */
+#define EXTIN_TOSLINK_L	   0x06	/* LiveDrive - TOSLink Optical - left */
+#define EXTIN_TOSLINK_R    0x07	/* LiveDrive - TOSLink Optical - right */
+#define EXTIN_LINE1_L	   0x08	/* LiveDrive - Line/Mic 1 - left */
+#define EXTIN_LINE1_R	   0x09	/* LiveDrive - Line/Mic 1 - right */
+#define EXTIN_COAX_SPDIF_L 0x0a	/* LiveDrive - Coaxial S/PDIF - left */
+#define EXTIN_COAX_SPDIF_R 0x0b /* LiveDrive - Coaxial S/PDIF - right */
+#define EXTIN_LINE2_L	   0x0c	/* LiveDrive - Line/Mic 2 - left */
+#define EXTIN_LINE2_R	   0x0d	/* LiveDrive - Line/Mic 2 - right */
+
+/* Outputs */
+#define EXTOUT_AC97_L	   0x00	/* AC'97 playback channel - left */
+#define EXTOUT_AC97_R	   0x01	/* AC'97 playback channel - right */
+#define EXTOUT_TOSLINK_L   0x02	/* LiveDrive - TOSLink Optical - left */
+#define EXTOUT_TOSLINK_R   0x03	/* LiveDrive - TOSLink Optical - right */
+#define EXTOUT_AC97_CENTER 0x04	/* SB Live 5.1 - center */
+#define EXTOUT_AC97_LFE	   0x05 /* SB Live 5.1 - LFE */
+#define EXTOUT_HEADPHONE_L 0x06	/* LiveDrive - Headphone - left */
+#define EXTOUT_HEADPHONE_R 0x07	/* LiveDrive - Headphone - right */
+#define EXTOUT_REAR_L	   0x08	/* Rear channel - left */
+#define EXTOUT_REAR_R	   0x09	/* Rear channel - right */
+#define EXTOUT_ADC_CAP_L   0x0a	/* ADC Capture buffer - left */
+#define EXTOUT_ADC_CAP_R   0x0b	/* ADC Capture buffer - right */
+#define EXTOUT_MIC_CAP	   0x0c	/* MIC Capture buffer */
+#define EXTOUT_AC97_REAR_L 0x0d	/* SB Live 5.1 (c) 2003 - Rear Left */
+#define EXTOUT_AC97_REAR_R 0x0e	/* SB Live 5.1 (c) 2003 - Rear Right */
+#define EXTOUT_ACENTER	   0x11 /* Analog Center */
+#define EXTOUT_ALFE	   0x12 /* Analog LFE */
+
+/* Audigy Inputs */
+#define A_EXTIN_AC97_L		0x00	/* AC'97 capture channel - left */
+#define A_EXTIN_AC97_R		0x01	/* AC'97 capture channel - right */
+#define A_EXTIN_SPDIF_CD_L	0x02	/* digital CD left */
+#define A_EXTIN_SPDIF_CD_R	0x03	/* digital CD left */
+#define A_EXTIN_OPT_SPDIF_L     0x04    /* audigy drive Optical SPDIF - left */
+#define A_EXTIN_OPT_SPDIF_R     0x05    /*                              right */ 
+#define A_EXTIN_LINE2_L		0x08	/* audigy drive line2/mic2 - left */
+#define A_EXTIN_LINE2_R		0x09	/*                           right */
+#define A_EXTIN_ADC_L		0x0a    /* Philips ADC - left */
+#define A_EXTIN_ADC_R		0x0b    /*               right */
+#define A_EXTIN_AUX2_L		0x0c	/* audigy drive aux2 - left */
+#define A_EXTIN_AUX2_R		0x0d	/*                   - right */
+
+/* Audigiy Outputs */
+#define A_EXTOUT_FRONT_L	0x00	/* digital front left */
+#define A_EXTOUT_FRONT_R	0x01	/*               right */
+#define A_EXTOUT_CENTER		0x02	/* digital front center */
+#define A_EXTOUT_LFE		0x03	/* digital front lfe */
+#define A_EXTOUT_HEADPHONE_L	0x04	/* headphone audigy drive left */
+#define A_EXTOUT_HEADPHONE_R	0x05	/*                        right */
+#define A_EXTOUT_REAR_L		0x06	/* digital rear left */
+#define A_EXTOUT_REAR_R		0x07	/*              right */
+#define A_EXTOUT_AFRONT_L	0x08	/* analog front left */
+#define A_EXTOUT_AFRONT_R	0x09	/*              right */
+#define A_EXTOUT_ACENTER	0x0a	/* analog center */
+#define A_EXTOUT_ALFE		0x0b	/* analog LFE */
+#define A_EXTOUT_ASIDE_L	0x0c	/* analog side left  - Audigy 2 ZS */
+#define A_EXTOUT_ASIDE_R	0x0d	/*             right - Audigy 2 ZS */
+#define A_EXTOUT_AREAR_L	0x0e	/* analog rear left */
+#define A_EXTOUT_AREAR_R	0x0f	/*             right */
+#define A_EXTOUT_AC97_L		0x10	/* AC97 left (front) */
+#define A_EXTOUT_AC97_R		0x11	/*      right */
+#define A_EXTOUT_ADC_CAP_L	0x16	/* ADC capture buffer left */
+#define A_EXTOUT_ADC_CAP_R	0x17	/*                    right */
+#define A_EXTOUT_MIC_CAP	0x18	/* Mic capture buffer */
+
+/* Audigy constants */
+#define A_C_00000000	0xc0
+#define A_C_00000001	0xc1
+#define A_C_00000002	0xc2
+#define A_C_00000003	0xc3
+#define A_C_00000004	0xc4
+#define A_C_00000008	0xc5
+#define A_C_00000010	0xc6
+#define A_C_00000020	0xc7
+#define A_C_00000100	0xc8
+#define A_C_00010000	0xc9
+#define A_C_00000800	0xca
+#define A_C_10000000	0xcb
+#define A_C_20000000	0xcc
+#define A_C_40000000	0xcd
+#define A_C_80000000	0xce
+#define A_C_7fffffff	0xcf
+#define A_C_ffffffff	0xd0
+#define A_C_fffffffe	0xd1
+#define A_C_c0000000	0xd2
+#define A_C_4f1bbcdc	0xd3
+#define A_C_5a7ef9db	0xd4
+#define A_C_00100000	0xd5
+#define A_GPR_ACCU	0xd6		/* ACCUM, accumulator */
+#define A_GPR_COND	0xd7		/* CCR, condition register */
+#define A_GPR_NOISE0	0xd8		/* noise source */
+#define A_GPR_NOISE1	0xd9		/* noise source */
+#define A_GPR_IRQ	0xda		/* IRQ register */
+#define A_GPR_DBAC	0xdb		/* TRAM Delay Base Address Counter - internal */
+#define A_GPR_DBACE	0xde		/* TRAM Delay Base Address Counter - external */
+
+/* definitions for debug register */
+#define EMU10K1_DBG_ZC			0x80000000	/* zero tram counter */
+#define EMU10K1_DBG_SATURATION_OCCURED	0x02000000	/* saturation control */
+#define EMU10K1_DBG_SATURATION_ADDR	0x01ff0000	/* saturation address */
+#define EMU10K1_DBG_SINGLE_STEP		0x00008000	/* single step mode */
+#define EMU10K1_DBG_STEP		0x00004000	/* start single step */
+#define EMU10K1_DBG_CONDITION_CODE	0x00003e00	/* condition code */
+#define EMU10K1_DBG_SINGLE_STEP_ADDR	0x000001ff	/* single step address */
+
+/* tank memory address line */
+#define TANKMEMADDRREG_ADDR_MASK 0x000fffff	/* 20 bit tank address field			*/
+#define TANKMEMADDRREG_CLEAR	 0x00800000	/* Clear tank memory				*/
+#define TANKMEMADDRREG_ALIGN	 0x00400000	/* Align read or write relative to tank access	*/
+#define TANKMEMADDRREG_WRITE	 0x00200000	/* Write to tank memory				*/
+#define TANKMEMADDRREG_READ	 0x00100000	/* Read from tank memory			*/
+
+struct snd_emu10k1_fx8010_info {
+	unsigned int internal_tram_size;	/* in samples */
+	unsigned int external_tram_size;	/* in samples */
+	char fxbus_names[16][32];		/* names of FXBUSes */
+	char extin_names[16][32];		/* names of external inputs */
+	char extout_names[32][32];		/* names of external outputs */
+	unsigned int gpr_controls;		/* count of GPR controls */
+};
+
+#define EMU10K1_GPR_TRANSLATION_NONE		0
+#define EMU10K1_GPR_TRANSLATION_TABLE100	1
+#define EMU10K1_GPR_TRANSLATION_BASS		2
+#define EMU10K1_GPR_TRANSLATION_TREBLE		3
+#define EMU10K1_GPR_TRANSLATION_ONOFF		4
+
+struct snd_emu10k1_fx8010_control_gpr {
+	struct snd_ctl_elem_id id;		/* full control ID definition */
+	unsigned int vcount;		/* visible count */
+	unsigned int count;		/* count of GPR (1..16) */
+	unsigned short gpr[32];		/* GPR number(s) */
+	unsigned int value[32];		/* initial values */
+	unsigned int min;		/* minimum range */
+	unsigned int max;		/* maximum range */
+	unsigned int translation;	/* translation type (EMU10K1_GPR_TRANSLATION*) */
+	const unsigned int *tlv;
+};
+
+/* old ABI without TLV support */
+struct snd_emu10k1_fx8010_control_old_gpr {
+	struct snd_ctl_elem_id id;
+	unsigned int vcount;
+	unsigned int count;
+	unsigned short gpr[32];
+	unsigned int value[32];
+	unsigned int min;
+	unsigned int max;
+	unsigned int translation;
+};
+
+struct snd_emu10k1_fx8010_code {
+	char name[128];
+
+	DECLARE_BITMAP(gpr_valid, 0x200); /* bitmask of valid initializers */
+	__u32 *gpr_map;		/* initializers */
+
+	unsigned int gpr_add_control_count; /* count of GPR controls to add/replace */
+	struct snd_emu10k1_fx8010_control_gpr *gpr_add_controls; /* GPR controls to add/replace */
+
+	unsigned int gpr_del_control_count; /* count of GPR controls to remove */
+	struct snd_ctl_elem_id *gpr_del_controls; /* IDs of GPR controls to remove */
+
+	unsigned int gpr_list_control_count; /* count of GPR controls to list */
+	unsigned int gpr_list_control_total; /* total count of GPR controls */
+	struct snd_emu10k1_fx8010_control_gpr *gpr_list_controls; /* listed GPR controls */
+
+	DECLARE_BITMAP(tram_valid, 0x100); /* bitmask of valid initializers */
+	__u32 *tram_data_map;	  /* data initializers */
+	__u32 *tram_addr_map;	  /* map initializers */
+
+	DECLARE_BITMAP(code_valid, 1024); /* bitmask of valid instructions */
+	__u32 *code;		  /* one instruction - 64 bits */
+};
+
+struct snd_emu10k1_fx8010_tram {
+	unsigned int address;		/* 31.bit == 1 -> external TRAM */
+	unsigned int size;		/* size in samples (4 bytes) */
+	unsigned int *samples;		/* pointer to samples (20-bit) */
+					/* NULL->clear memory */
+};
+
+struct snd_emu10k1_fx8010_pcm_rec {
+	unsigned int substream;		/* substream number */
+	unsigned int res1;		/* reserved */
+	unsigned int channels;		/* 16-bit channels count, zero = remove this substream */
+	unsigned int tram_start;	/* ring buffer position in TRAM (in samples) */
+	unsigned int buffer_size;	/* count of buffered samples */
+	unsigned short gpr_size;		/* GPR containing size of ringbuffer in samples (host) */
+	unsigned short gpr_ptr;		/* GPR containing current pointer in the ring buffer (host = reset, FX8010) */
+	unsigned short gpr_count;	/* GPR containing count of samples between two interrupts (host) */
+	unsigned short gpr_tmpcount;	/* GPR containing current count of samples to interrupt (host = set, FX8010) */
+	unsigned short gpr_trigger;	/* GPR containing trigger (activate) information (host) */
+	unsigned short gpr_running;	/* GPR containing info if PCM is running (FX8010) */
+	unsigned char pad;		/* reserved */
+	unsigned char etram[32];	/* external TRAM address & data (one per channel) */
+	unsigned int res2;		/* reserved */
+};
+
+#define SNDRV_EMU10K1_VERSION		SNDRV_PROTOCOL_VERSION(1, 0, 1)
+
+#define SNDRV_EMU10K1_IOCTL_INFO	_IOR ('H', 0x10, struct snd_emu10k1_fx8010_info)
+#define SNDRV_EMU10K1_IOCTL_CODE_POKE	_IOW ('H', 0x11, struct snd_emu10k1_fx8010_code)
+#define SNDRV_EMU10K1_IOCTL_CODE_PEEK	_IOWR('H', 0x12, struct snd_emu10k1_fx8010_code)
+#define SNDRV_EMU10K1_IOCTL_TRAM_SETUP	_IOW ('H', 0x20, int)
+#define SNDRV_EMU10K1_IOCTL_TRAM_POKE	_IOW ('H', 0x21, struct snd_emu10k1_fx8010_tram)
+#define SNDRV_EMU10K1_IOCTL_TRAM_PEEK	_IOWR('H', 0x22, struct snd_emu10k1_fx8010_tram)
+#define SNDRV_EMU10K1_IOCTL_PCM_POKE	_IOW ('H', 0x30, struct snd_emu10k1_fx8010_pcm_rec)
+#define SNDRV_EMU10K1_IOCTL_PCM_PEEK	_IOWR('H', 0x31, struct snd_emu10k1_fx8010_pcm_rec)
+#define SNDRV_EMU10K1_IOCTL_PVERSION	_IOR ('H', 0x40, int)
+#define SNDRV_EMU10K1_IOCTL_STOP	_IO  ('H', 0x80)
+#define SNDRV_EMU10K1_IOCTL_CONTINUE	_IO  ('H', 0x81)
+#define SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER _IO ('H', 0x82)
+#define SNDRV_EMU10K1_IOCTL_SINGLE_STEP	_IOW ('H', 0x83, int)
+#define SNDRV_EMU10K1_IOCTL_DBG_READ	_IOR ('H', 0x84, int)
+
+/* typedefs for compatibility to user-space */
+typedef struct snd_emu10k1_fx8010_info emu10k1_fx8010_info_t;
+typedef struct snd_emu10k1_fx8010_control_gpr emu10k1_fx8010_control_gpr_t;
+typedef struct snd_emu10k1_fx8010_code emu10k1_fx8010_code_t;
+typedef struct snd_emu10k1_fx8010_tram emu10k1_fx8010_tram_t;
+typedef struct snd_emu10k1_fx8010_pcm_rec emu10k1_fx8010_pcm_t;
+
+#endif	/* __SOUND_EMU10K1_H */
diff -uNr linux-2.6.32/usr/include/sound/hdsp.h clean_modified/linux-2.6.32/usr/include/sound/hdsp.h
--- linux-2.6.32/usr/include/sound/hdsp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/hdsp.h	2019-04-14 13:24:03.216788543 -0500
@@ -0,0 +1,109 @@
+#ifndef __SOUND_HDSP_H
+#define __SOUND_HDSP_H
+
+/*
+ *   Copyright (C) 2003 Thomas Charbonnel (thomas@undata.org)
+ *    
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/types.h>
+
+#define HDSP_MATRIX_MIXER_SIZE 2048
+
+enum HDSP_IO_Type {
+	Digiface,
+	Multiface,
+	H9652,
+	H9632,
+	Undefined,
+};
+
+struct hdsp_peak_rms {
+	__u32 input_peaks[26];
+	__u32 playback_peaks[26];
+	__u32 output_peaks[28];
+	__u64 input_rms[26];
+	__u64 playback_rms[26];
+	/* These are only used for H96xx cards */
+	__u64 output_rms[26];
+};
+
+#define SNDRV_HDSP_IOCTL_GET_PEAK_RMS _IOR('H', 0x40, struct hdsp_peak_rms)
+
+struct hdsp_config_info {
+	unsigned char pref_sync_ref;
+	unsigned char wordclock_sync_check;
+	unsigned char spdif_sync_check;
+	unsigned char adatsync_sync_check;
+	unsigned char adat_sync_check[3];
+	unsigned char spdif_in;
+	unsigned char spdif_out;
+	unsigned char spdif_professional;
+	unsigned char spdif_emphasis;
+	unsigned char spdif_nonaudio;
+	unsigned int spdif_sample_rate;
+	unsigned int system_sample_rate;
+	unsigned int autosync_sample_rate;
+	unsigned char system_clock_mode;
+	unsigned char clock_source;
+	unsigned char autosync_ref;
+	unsigned char line_out;
+	unsigned char passthru; 
+	unsigned char da_gain;
+	unsigned char ad_gain;
+	unsigned char phone_gain;
+	unsigned char xlr_breakout_cable;
+	unsigned char analog_extension_board;
+};
+
+#define SNDRV_HDSP_IOCTL_GET_CONFIG_INFO _IOR('H', 0x41, struct hdsp_config_info)
+
+struct hdsp_firmware {
+	void *firmware_data;	/* 24413 x 4 bytes */
+};
+
+#define SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE _IOW('H', 0x42, struct hdsp_firmware)
+
+struct hdsp_version {
+	enum HDSP_IO_Type io_type;
+	unsigned short firmware_rev;
+};
+
+#define SNDRV_HDSP_IOCTL_GET_VERSION _IOR('H', 0x43, struct hdsp_version)
+
+struct hdsp_mixer {
+	unsigned short matrix[HDSP_MATRIX_MIXER_SIZE];
+};
+
+#define SNDRV_HDSP_IOCTL_GET_MIXER _IOR('H', 0x44, struct hdsp_mixer)
+
+struct hdsp_9632_aeb {
+	int aebi;
+	int aebo;
+};
+
+#define SNDRV_HDSP_IOCTL_GET_9632_AEB _IOR('H', 0x45, struct hdsp_9632_aeb)
+
+/* typedefs for compatibility to user-space */
+typedef enum HDSP_IO_Type HDSP_IO_Type;
+typedef struct hdsp_peak_rms hdsp_peak_rms_t;
+typedef struct hdsp_config_info hdsp_config_info_t;
+typedef struct hdsp_firmware hdsp_firmware_t;
+typedef struct hdsp_version hdsp_version_t;
+typedef struct hdsp_mixer hdsp_mixer_t;
+typedef struct hdsp_9632_aeb hdsp_9632_aeb_t;
+
+#endif /* __SOUND_HDSP_H */
diff -uNr linux-2.6.32/usr/include/sound/hdspm.h clean_modified/linux-2.6.32/usr/include/sound/hdspm.h
--- linux-2.6.32/usr/include/sound/hdspm.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/hdspm.h	2019-04-14 13:24:03.216788543 -0500
@@ -0,0 +1,134 @@
+#ifndef __SOUND_HDSPM_H
+#define __SOUND_HDSPM_H
+/*
+ *   Copyright (C) 2003 Winfried Ritsch (IEM)
+ *   based on hdsp.h from Thomas Charbonnel (thomas@undata.org)
+ *                      
+ *    
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Maximum channels is 64 even on 56Mode you have 64playbacks to matrix */
+#define HDSPM_MAX_CHANNELS      64
+
+/* -------------------- IOCTL Peak/RMS Meters -------------------- */
+
+/* peam rms level structure like we get from hardware 
+  
+   maybe in future we can memory map it so I just copy it
+   to user on ioctl call now an dont change anything
+   rms are made out of low and high values
+   where (long) ????_rms = (????_rms_l >> 8) + ((????_rms_h & 0xFFFFFF00)<<24)
+   (i asume so from the code)
+*/
+
+struct hdspm_peak_rms {
+
+	unsigned int level_offset[1024];
+
+	unsigned int input_peak[64];
+	unsigned int playback_peak[64];
+	unsigned int output_peak[64];
+	unsigned int xxx_peak[64];	/* not used */
+
+	unsigned int reserved[256];	/* not used */
+
+	unsigned int input_rms_l[64];
+	unsigned int playback_rms_l[64];
+	unsigned int output_rms_l[64];
+	unsigned int xxx_rms_l[64];	/* not used */
+
+	unsigned int input_rms_h[64];
+	unsigned int playback_rms_h[64];
+	unsigned int output_rms_h[64];
+	unsigned int xxx_rms_h[64];	/* not used */
+};
+
+struct hdspm_peak_rms_ioctl {
+	struct hdspm_peak_rms *peak;
+};
+
+/* use indirect access due to the limit of ioctl bit size */
+#define SNDRV_HDSPM_IOCTL_GET_PEAK_RMS \
+	_IOR('H', 0x40, struct hdspm_peak_rms_ioctl)
+
+/* ------------ CONFIG block IOCTL ---------------------- */
+
+struct hdspm_config_info {
+	unsigned char pref_sync_ref;
+	unsigned char wordclock_sync_check;
+	unsigned char madi_sync_check;
+	unsigned int system_sample_rate;
+	unsigned int autosync_sample_rate;
+	unsigned char system_clock_mode;
+	unsigned char clock_source;
+	unsigned char autosync_ref;
+	unsigned char line_out;
+	unsigned int passthru;
+	unsigned int analog_out;
+};
+
+#define SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO \
+	_IOR('H', 0x41, struct hdspm_config_info)
+
+
+/* get Soundcard Version */
+
+struct hdspm_version {
+	unsigned short firmware_rev;
+};
+
+#define SNDRV_HDSPM_IOCTL_GET_VERSION _IOR('H', 0x43, struct hdspm_version)
+
+
+/* ------------- get Matrix Mixer IOCTL --------------- */
+
+/* MADI mixer: 64inputs+64playback in 64outputs = 8192 => *4Byte =
+ * 32768 Bytes
+ */
+
+/* organisation is 64 channelfader in a continous memory block */
+/* equivalent to hardware definition, maybe for future feature of mmap of
+ * them
+ */
+/* each of 64 outputs has 64 infader and 64 outfader: 
+   Ins to Outs mixer[out].in[in], Outstreams to Outs mixer[out].pb[pb] */
+
+#define HDSPM_MIXER_CHANNELS HDSPM_MAX_CHANNELS
+
+struct hdspm_channelfader {
+	unsigned int in[HDSPM_MIXER_CHANNELS];
+	unsigned int pb[HDSPM_MIXER_CHANNELS];
+};
+
+struct hdspm_mixer {
+	struct hdspm_channelfader ch[HDSPM_MIXER_CHANNELS];
+};
+
+struct hdspm_mixer_ioctl {
+	struct hdspm_mixer *mixer;
+};
+
+/* use indirect access due to the limit of ioctl bit size */
+#define SNDRV_HDSPM_IOCTL_GET_MIXER _IOR('H', 0x44, struct hdspm_mixer_ioctl)
+
+/* typedefs for compatibility to user-space */
+typedef struct hdspm_peak_rms hdspm_peak_rms_t;
+typedef struct hdspm_config_info hdspm_config_info_t;
+typedef struct hdspm_version hdspm_version_t;
+typedef struct hdspm_channelfader snd_hdspm_channelfader_t;
+typedef struct hdspm_mixer hdspm_mixer_t;
+
+#endif				/* __SOUND_HDSPM_H */
diff -uNr linux-2.6.32/usr/include/sound/sb16_csp.h clean_modified/linux-2.6.32/usr/include/sound/sb16_csp.h
--- linux-2.6.32/usr/include/sound/sb16_csp.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/sb16_csp.h	2019-04-14 13:24:03.218862076 -0500
@@ -0,0 +1,115 @@
+#ifndef __SOUND_SB16_CSP_H
+#define __SOUND_SB16_CSP_H
+
+/*
+ *  Copyright (c) 1999 by Uros Bizjak <uros@kss-loka.si>
+ *                        Takashi Iwai <tiwai@suse.de>
+ *
+ *  SB16ASP/AWE32 CSP control
+ *
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/* CSP modes */
+#define SNDRV_SB_CSP_MODE_NONE		0x00
+#define SNDRV_SB_CSP_MODE_DSP_READ	0x01	/* Record from DSP */
+#define SNDRV_SB_CSP_MODE_DSP_WRITE	0x02	/* Play to DSP */
+#define SNDRV_SB_CSP_MODE_QSOUND		0x04	/* QSound */
+
+/* CSP load flags */
+#define SNDRV_SB_CSP_LOAD_FROMUSER	0x01
+#define SNDRV_SB_CSP_LOAD_INITBLOCK	0x02
+
+/* CSP sample width */
+#define SNDRV_SB_CSP_SAMPLE_8BIT		0x01
+#define SNDRV_SB_CSP_SAMPLE_16BIT		0x02
+
+/* CSP channels */
+#define SNDRV_SB_CSP_MONO			0x01
+#define SNDRV_SB_CSP_STEREO		0x02
+
+/* CSP rates */
+#define SNDRV_SB_CSP_RATE_8000		0x01
+#define SNDRV_SB_CSP_RATE_11025		0x02
+#define SNDRV_SB_CSP_RATE_22050		0x04
+#define SNDRV_SB_CSP_RATE_44100		0x08
+#define SNDRV_SB_CSP_RATE_ALL		0x0f
+
+/* CSP running state */
+#define SNDRV_SB_CSP_ST_IDLE		0x00
+#define SNDRV_SB_CSP_ST_LOADED		0x01
+#define SNDRV_SB_CSP_ST_RUNNING		0x02
+#define SNDRV_SB_CSP_ST_PAUSED		0x04
+#define SNDRV_SB_CSP_ST_AUTO		0x08
+#define SNDRV_SB_CSP_ST_QSOUND		0x10
+
+/* maximum QSound value (180 degrees right) */
+#define SNDRV_SB_CSP_QSOUND_MAX_RIGHT	0x20
+
+/* maximum microcode RIFF file size */
+#define SNDRV_SB_CSP_MAX_MICROCODE_FILE_SIZE	0x3000
+
+/* microcode header */
+struct snd_sb_csp_mc_header {
+	char codec_name[16];		/* id name of codec */
+	unsigned short func_req;	/* requested function */
+};
+
+/* microcode to be loaded */
+struct snd_sb_csp_microcode {
+	struct snd_sb_csp_mc_header info;
+	unsigned char data[SNDRV_SB_CSP_MAX_MICROCODE_FILE_SIZE];
+};
+
+/* start CSP with sample_width in mono/stereo */
+struct snd_sb_csp_start {
+	int sample_width;	/* sample width, look above */
+	int channels;		/* channels, look above */
+};
+
+/* CSP information */
+struct snd_sb_csp_info {
+	char codec_name[16];		/* id name of codec */
+	unsigned short func_nr;		/* function number */
+	unsigned int acc_format;	/* accepted PCM formats */
+	unsigned short acc_channels;	/* accepted channels */
+	unsigned short acc_width;	/* accepted sample width */
+	unsigned short acc_rates;	/* accepted sample rates */
+	unsigned short csp_mode;	/* CSP mode, see above */
+	unsigned short run_channels;	/* current channels  */
+	unsigned short run_width;	/* current sample width */
+	unsigned short version;		/* version id: 0x10 - 0x1f */
+	unsigned short state;		/* state bits */
+};
+
+/* HWDEP controls */
+/* get CSP information */
+#define SNDRV_SB_CSP_IOCTL_INFO		_IOR('H', 0x10, struct snd_sb_csp_info)
+/* load microcode to CSP */
+#define SNDRV_SB_CSP_IOCTL_LOAD_CODE	_IOW('H', 0x11, struct snd_sb_csp_microcode)
+/* unload microcode from CSP */
+#define SNDRV_SB_CSP_IOCTL_UNLOAD_CODE	_IO('H', 0x12)
+/* start CSP */
+#define SNDRV_SB_CSP_IOCTL_START		_IOW('H', 0x13, struct snd_sb_csp_start)
+/* stop CSP */
+#define SNDRV_SB_CSP_IOCTL_STOP		_IO('H', 0x14)
+/* pause CSP and DMA transfer */
+#define SNDRV_SB_CSP_IOCTL_PAUSE		_IO('H', 0x15)
+/* restart CSP and DMA transfer */
+#define SNDRV_SB_CSP_IOCTL_RESTART	_IO('H', 0x16)
+
+
+#endif /* __SOUND_SB16_CSP */
diff -uNr linux-2.6.32/usr/include/sound/sfnt_info.h clean_modified/linux-2.6.32/usr/include/sound/sfnt_info.h
--- linux-2.6.32/usr/include/sound/sfnt_info.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/sfnt_info.h	2019-04-14 13:24:03.220799126 -0500
@@ -0,0 +1,212 @@
+#ifndef __SOUND_SFNT_INFO_H
+#define __SOUND_SFNT_INFO_H
+
+/*
+ *  Patch record compatible with AWE driver on OSS
+ *
+ *  Copyright (C) 1999-2000 Takashi Iwai
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/asound.h>
+
+/*
+ * patch information record
+ */
+
+#ifdef SNDRV_BIG_ENDIAN
+#define SNDRV_OSS_PATCHKEY(id) (0xfd00|id)
+#else
+#define SNDRV_OSS_PATCHKEY(id) ((id<<8)|0xfd)
+#endif
+
+/* patch interface header: 16 bytes */
+struct soundfont_patch_info {
+	unsigned short key;		/* use the key below */
+#define SNDRV_OSS_SOUNDFONT_PATCH		SNDRV_OSS_PATCHKEY(0x07)
+
+	short device_no;		/* synthesizer number */
+	unsigned short sf_id;		/* file id (should be zero) */
+	short optarg;			/* optional argument */
+	int len;			/* data length (without this header) */
+
+	short type;			/* patch operation type */
+#define SNDRV_SFNT_LOAD_INFO		0	/* awe_voice_rec */
+#define SNDRV_SFNT_LOAD_DATA		1	/* awe_sample_info */
+#define SNDRV_SFNT_OPEN_PATCH	2	/* awe_open_parm */
+#define SNDRV_SFNT_CLOSE_PATCH	3	/* none */
+	/* 4 is obsolete */
+#define SNDRV_SFNT_REPLACE_DATA	5	/* awe_sample_info (optarg=#channels)*/
+#define SNDRV_SFNT_MAP_PRESET	6	/* awe_voice_map */
+	/* 7 is not used */
+#define SNDRV_SFNT_PROBE_DATA		8	/* optarg=sample */
+#define SNDRV_SFNT_REMOVE_INFO		9	/* optarg=(bank<<8)|instr */
+
+	short reserved;			/* word alignment data */
+
+	/* the actual patch data begins after this */
+};
+
+
+/*
+ * open patch
+ */
+
+#define SNDRV_SFNT_PATCH_NAME_LEN	32
+
+struct soundfont_open_parm {
+	unsigned short type;		/* sample type */
+#define SNDRV_SFNT_PAT_TYPE_MISC	0
+#define SNDRV_SFNT_PAT_TYPE_GUS	6
+#define SNDRV_SFNT_PAT_TYPE_MAP	7
+#define SNDRV_SFNT_PAT_LOCKED	0x100	/* lock the samples */
+#define SNDRV_SFNT_PAT_SHARED	0x200	/* sample is shared */
+
+	short reserved;
+	char name[SNDRV_SFNT_PATCH_NAME_LEN];
+};
+
+
+/*
+ * raw voice information record
+ */
+
+/* wave table envelope & effect parameters to control EMU8000 */
+struct soundfont_voice_parm {
+	unsigned short moddelay;	/* modulation delay (0x8000) */
+	unsigned short modatkhld;	/* modulation attack & hold time (0x7f7f) */
+	unsigned short moddcysus;	/* modulation decay & sustain (0x7f7f) */
+	unsigned short modrelease;	/* modulation release time (0x807f) */
+	short modkeyhold, modkeydecay;	/* envelope change per key (not used) */
+	unsigned short voldelay;	/* volume delay (0x8000) */
+	unsigned short volatkhld;	/* volume attack & hold time (0x7f7f) */
+	unsigned short voldcysus;	/* volume decay & sustain (0x7f7f) */
+	unsigned short volrelease;	/* volume release time (0x807f) */
+	short volkeyhold, volkeydecay;	/* envelope change per key (not used) */
+	unsigned short lfo1delay;	/* LFO1 delay (0x8000) */
+	unsigned short lfo2delay;	/* LFO2 delay (0x8000) */
+	unsigned short pefe;		/* modulation pitch & cutoff (0x0000) */
+	unsigned short fmmod;		/* LFO1 pitch & cutoff (0x0000) */
+	unsigned short tremfrq;		/* LFO1 volume & freq (0x0000) */
+	unsigned short fm2frq2;		/* LFO2 pitch & freq (0x0000) */
+	unsigned char cutoff;		/* initial cutoff (0xff) */
+	unsigned char filterQ;		/* initial filter Q [0-15] (0x0) */
+	unsigned char chorus;		/* chorus send (0x00) */
+	unsigned char reverb;		/* reverb send (0x00) */
+	unsigned short reserved[4];	/* not used */
+};
+
+
+/* wave table parameters: 92 bytes */
+struct soundfont_voice_info {
+	unsigned short sf_id;		/* file id (should be zero) */
+	unsigned short sample;		/* sample id */
+	int start, end;			/* sample offset correction */
+	int loopstart, loopend;		/* loop offset correction */
+	short rate_offset;		/* sample rate pitch offset */
+	unsigned short mode;		/* sample mode */
+#define SNDRV_SFNT_MODE_ROMSOUND		0x8000
+#define SNDRV_SFNT_MODE_STEREO		1
+#define SNDRV_SFNT_MODE_LOOPING		2
+#define SNDRV_SFNT_MODE_NORELEASE		4	/* obsolete */
+#define SNDRV_SFNT_MODE_INIT_PARM		8
+
+	short root;			/* midi root key */
+	short tune;			/* pitch tuning (in cents) */
+	unsigned char low, high;	/* key note range */
+	unsigned char vellow, velhigh;	/* velocity range */
+	signed char fixkey, fixvel;	/* fixed key, velocity */
+	signed char pan, fixpan;	/* panning, fixed panning */
+	short exclusiveClass;		/* exclusive class (0 = none) */
+	unsigned char amplitude;	/* sample volume (127 max) */
+	unsigned char attenuation;	/* attenuation (0.375dB) */
+	short scaleTuning;		/* pitch scale tuning(%), normally 100 */
+	struct soundfont_voice_parm parm;	/* voice envelope parameters */
+	unsigned short sample_mode;	/* sample mode_flag (set by driver) */
+};
+
+
+/* instrument info header: 4 bytes */
+struct soundfont_voice_rec_hdr {
+	unsigned char bank;		/* midi bank number */
+	unsigned char instr;		/* midi preset number */
+	char nvoices;			/* number of voices */
+	char write_mode;		/* write mode; normally 0 */
+#define SNDRV_SFNT_WR_APPEND		0	/* append anyway */
+#define SNDRV_SFNT_WR_EXCLUSIVE		1	/* skip if already exists */
+#define SNDRV_SFNT_WR_REPLACE		2	/* replace if already exists */
+};
+
+
+/*
+ * sample wave information
+ */
+
+/* wave table sample header: 32 bytes */
+struct soundfont_sample_info {
+	unsigned short sf_id;		/* file id (should be zero) */
+	unsigned short sample;		/* sample id */
+	int start, end;			/* start & end offset */
+	int loopstart, loopend;		/* loop start & end offset */
+	int size;			/* size (0 = ROM) */
+	short dummy;			/* not used */
+	unsigned short mode_flags;	/* mode flags */
+#define SNDRV_SFNT_SAMPLE_8BITS		1	/* wave data is 8bits */
+#define SNDRV_SFNT_SAMPLE_UNSIGNED	2	/* wave data is unsigned */
+#define SNDRV_SFNT_SAMPLE_NO_BLANK	4	/* no blank loop is attached */
+#define SNDRV_SFNT_SAMPLE_SINGLESHOT	8	/* single-shot w/o loop */
+#define SNDRV_SFNT_SAMPLE_BIDIR_LOOP	16	/* bidirectional looping */
+#define SNDRV_SFNT_SAMPLE_STEREO_LEFT	32	/* stereo left sound */
+#define SNDRV_SFNT_SAMPLE_STEREO_RIGHT	64	/* stereo right sound */
+#define SNDRV_SFNT_SAMPLE_REVERSE_LOOP	128	/* reverse looping */
+	unsigned int truesize;		/* used memory size (set by driver) */
+};
+
+
+/*
+ * voice preset mapping (aliasing)
+ */
+
+struct soundfont_voice_map {
+	int map_bank, map_instr, map_key;	/* key = -1 means all keys */
+	int src_bank, src_instr, src_key;
+};
+
+
+/*
+ * ioctls for hwdep
+ */
+
+#define SNDRV_EMUX_HWDEP_NAME	"Emux WaveTable"
+
+#define SNDRV_EMUX_VERSION	((1 << 16) | (0 << 8) | 0)	/* 1.0.0 */
+
+struct snd_emux_misc_mode {
+	int port;	/* -1 = all */
+	int mode;
+	int value;
+	int value2;	/* reserved */
+};
+
+#define SNDRV_EMUX_IOCTL_VERSION	_IOR('H', 0x80, unsigned int)
+#define SNDRV_EMUX_IOCTL_LOAD_PATCH	_IOWR('H', 0x81, struct soundfont_patch_info)
+#define SNDRV_EMUX_IOCTL_RESET_SAMPLES	_IO('H', 0x82)
+#define SNDRV_EMUX_IOCTL_REMOVE_LAST_SAMPLES _IO('H', 0x83)
+#define SNDRV_EMUX_IOCTL_MEM_AVAIL	_IOW('H', 0x84, int)
+#define SNDRV_EMUX_IOCTL_MISC_MODE	_IOWR('H', 0x84, struct snd_emux_misc_mode)
+
+#endif /* __SOUND_SFNT_INFO_H */
diff -uNr linux-2.6.32/usr/include/sound/sscape_ioctl.h clean_modified/linux-2.6.32/usr/include/sound/sscape_ioctl.h
--- linux-2.6.32/usr/include/sound/sscape_ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/sound/sscape_ioctl.h	2019-04-14 13:24:03.220799126 -0500
@@ -0,0 +1,21 @@
+#ifndef SSCAPE_IOCTL_H
+#define SSCAPE_IOCTL_H
+
+
+struct sscape_bootblock
+{
+  unsigned char code[256];
+  unsigned version;
+};
+
+#define SSCAPE_MICROCODE_SIZE  65536
+
+struct sscape_microcode
+{
+  unsigned char *code;
+};
+
+#define SND_SSCAPE_LOAD_BOOTB  _IOWR('P', 100, struct sscape_bootblock)
+#define SND_SSCAPE_LOAD_MCODE  _IOW ('P', 101, struct sscape_microcode)
+
+#endif
diff -uNr linux-2.6.32/usr/include/video/edid.h clean_modified/linux-2.6.32/usr/include/video/edid.h
--- linux-2.6.32/usr/include/video/edid.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/video/edid.h	2019-04-14 13:24:03.221949982 -0500
@@ -0,0 +1,11 @@
+#ifndef __linux_video_edid_h__
+#define __linux_video_edid_h__
+
+
+struct edid_info {
+	unsigned char dummy[128];
+};
+
+
+
+#endif /* __linux_video_edid_h__ */
diff -uNr linux-2.6.32/usr/include/video/sisfb.h clean_modified/linux-2.6.32/usr/include/video/sisfb.h
--- linux-2.6.32/usr/include/video/sisfb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/video/sisfb.h	2019-04-14 13:24:03.221949982 -0500
@@ -0,0 +1,209 @@
+/*
+ * sisfb.h - definitions for the SiS framebuffer driver
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#ifndef _LINUX_SISFB_H_
+#define _LINUX_SISFB_H_
+
+#include <linux/types.h>
+#include <asm/ioctl.h>
+
+/**********************************************/
+/*                   PUBLIC                   */
+/**********************************************/
+
+/* vbflags, public (others in sis.h) */
+#define CRT2_DEFAULT		0x00000001
+#define CRT2_LCD		0x00000002
+#define CRT2_TV			0x00000004
+#define CRT2_VGA		0x00000008
+#define TV_NTSC			0x00000010
+#define TV_PAL			0x00000020
+#define TV_HIVISION		0x00000040
+#define TV_YPBPR		0x00000080
+#define TV_AVIDEO		0x00000100
+#define TV_SVIDEO		0x00000200
+#define TV_SCART		0x00000400
+#define TV_PALM			0x00001000
+#define TV_PALN			0x00002000
+#define TV_NTSCJ		0x00001000
+#define TV_CHSCART		0x00008000
+#define TV_CHYPBPR525I		0x00010000
+#define CRT1_VGA		0x00000000
+#define CRT1_LCDA		0x00020000
+#define VGA2_CONNECTED          0x00040000
+#define VB_DISPTYPE_CRT1	0x00080000	/* CRT1 connected and used */
+#define VB_SINGLE_MODE		0x20000000	/* CRT1 or CRT2; determined by DISPTYPE_CRTx */
+#define VB_MIRROR_MODE		0x40000000	/* CRT1 + CRT2 identical (mirror mode) */
+#define VB_DUALVIEW_MODE	0x80000000	/* CRT1 + CRT2 independent (dual head mode) */
+
+/* Aliases: */
+#define CRT2_ENABLE		(CRT2_LCD | CRT2_TV | CRT2_VGA)
+#define TV_STANDARD		(TV_NTSC | TV_PAL | TV_PALM | TV_PALN | TV_NTSCJ)
+#define TV_INTERFACE		(TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR|TV_CHSCART|TV_CHYPBPR525I)
+
+/* Only if TV_YPBPR is set: */
+#define TV_YPBPR525I		TV_NTSC
+#define TV_YPBPR525P		TV_PAL
+#define TV_YPBPR750P		TV_PALM
+#define TV_YPBPR1080I		TV_PALN
+#define TV_YPBPRALL 		(TV_YPBPR525I | TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I)
+
+#define VB_DISPTYPE_DISP2	CRT2_ENABLE
+#define VB_DISPTYPE_CRT2	CRT2_ENABLE
+#define VB_DISPTYPE_DISP1	VB_DISPTYPE_CRT1
+#define VB_DISPMODE_SINGLE	VB_SINGLE_MODE
+#define VB_DISPMODE_MIRROR	VB_MIRROR_MODE
+#define VB_DISPMODE_DUAL	VB_DUALVIEW_MODE
+#define VB_DISPLAY_MODE		(SINGLE_MODE | MIRROR_MODE | DUALVIEW_MODE)
+
+/* Structure argument for SISFB_GET_INFO ioctl  */
+struct sisfb_info {
+	__u32	sisfb_id;		/* for identifying sisfb */
+#ifndef SISFB_ID
+#define SISFB_ID	  0x53495346    /* Identify myself with 'SISF' */
+#endif
+	__u32   chip_id;		/* PCI-ID of detected chip */
+	__u32   memory;			/* total video memory in KB */
+	__u32   heapstart;		/* heap start offset in KB */
+	__u8    fbvidmode;		/* current sisfb mode */
+
+	__u8	sisfb_version;
+	__u8	sisfb_revision;
+	__u8	sisfb_patchlevel;
+
+	__u8	sisfb_caps;		/* sisfb capabilities */
+
+	__u32	sisfb_tqlen;		/* turbo queue length (in KB) */
+
+	__u32	sisfb_pcibus;		/* The card's PCI ID */
+	__u32	sisfb_pcislot;
+	__u32	sisfb_pcifunc;
+
+	__u8	sisfb_lcdpdc;		/* PanelDelayCompensation */
+
+	__u8	sisfb_lcda;		/* Detected status of LCDA for low res/text modes */
+
+	__u32	sisfb_vbflags;
+	__u32	sisfb_currentvbflags;
+
+	__u32	sisfb_scalelcd;
+	__u32	sisfb_specialtiming;
+
+	__u8	sisfb_haveemi;
+	__u8	sisfb_emi30,sisfb_emi31,sisfb_emi32,sisfb_emi33;
+	__u8	sisfb_haveemilcd;
+
+	__u8	sisfb_lcdpdca;		/* PanelDelayCompensation for LCD-via-CRT1 */
+
+	__u16	sisfb_tvxpos, sisfb_tvypos;	/* Warning: Values + 32 ! */
+
+	__u32	sisfb_heapsize;		/* heap size (in KB) */
+	__u32	sisfb_videooffset;	/* Offset of viewport in video memory (in bytes) */
+
+	__u32	sisfb_curfstn;		/* currently running FSTN/DSTN mode */
+	__u32	sisfb_curdstn;
+
+	__u16	sisfb_pci_vendor;	/* PCI vendor (SiS or XGI) */
+
+	__u32	sisfb_vbflags2;		/* ivideo->vbflags2 */
+
+	__u8	sisfb_can_post;		/* sisfb can POST this card */
+	__u8	sisfb_card_posted;	/* card is POSTED */
+	__u8	sisfb_was_boot_device;	/* This card was the boot video device (ie is primary) */
+
+	__u8	reserved[183];		/* for future use */
+};
+
+#define SISFB_CMD_GETVBFLAGS	0x55AA0001	/* no arg; result[1] = vbflags */
+#define SISFB_CMD_SWITCHCRT1	0x55AA0010	/* arg[0]: 99 = query, 0 = off, 1 = on */
+/* more to come */
+
+#define SISFB_CMD_ERR_OK	0x80000000	/* command succeeded */
+#define SISFB_CMD_ERR_LOCKED	0x80000001	/* sisfb is locked */
+#define SISFB_CMD_ERR_EARLY	0x80000002	/* request before sisfb took over gfx system */
+#define SISFB_CMD_ERR_NOVB	0x80000003	/* No video bridge */
+#define SISFB_CMD_ERR_NOCRT2	0x80000004	/* can't change CRT1 status, CRT2 disabled */
+/* more to come */
+#define SISFB_CMD_ERR_UNKNOWN   0x8000ffff	/* Unknown command */
+#define SISFB_CMD_ERR_OTHER	0x80010000	/* Other error */
+
+/* Argument for SISFB_CMD ioctl */
+struct sisfb_cmd {
+	__u32  sisfb_cmd;
+	__u32  sisfb_arg[16];
+	__u32  sisfb_result[4];
+};
+
+/* Addtional IOCTLs for communication sisfb <> X driver                */
+/* If changing this, vgatypes.h must also be changed (for X driver)    */
+
+/* ioctl for identifying and giving some info (esp. memory heap start) */
+#define SISFB_GET_INFO_SIZE	_IOR(0xF3,0x00,__u32)
+#define SISFB_GET_INFO		_IOR(0xF3,0x01,struct sisfb_info)
+
+/* ioctrl to get current vertical retrace status */
+#define SISFB_GET_VBRSTATUS	_IOR(0xF3,0x02,__u32)
+
+/* ioctl to enable/disable panning auto-maximize (like nomax parameter) */
+#define SISFB_GET_AUTOMAXIMIZE	_IOR(0xF3,0x03,__u32)
+#define SISFB_SET_AUTOMAXIMIZE	_IOW(0xF3,0x03,__u32)
+
+/* ioctls to relocate TV output (x=D[31:16], y=D[15:0], + 32)*/
+#define SISFB_GET_TVPOSOFFSET	_IOR(0xF3,0x04,__u32)
+#define SISFB_SET_TVPOSOFFSET	_IOW(0xF3,0x04,__u32)
+
+/* ioctl for internal sisfb commands (sisfbctrl) */
+#define SISFB_COMMAND		_IOWR(0xF3,0x05,struct sisfb_cmd)
+
+/* ioctl for locking sisfb (no register access during lock) */
+/* As of now, only used to avoid register access during
+ * the ioctls listed above.
+ */
+#define SISFB_SET_LOCK		_IOW(0xF3,0x06,__u32)
+
+/* ioctls 0xF3 up to 0x3F reserved for sisfb */
+
+/****************************************************************/
+/* The following are deprecated and should not be used anymore: */
+/****************************************************************/
+/* ioctl for identifying and giving some info (esp. memory heap start) */
+#define SISFB_GET_INFO_OLD	   _IOR('n',0xF8,__u32)
+/* ioctrl to get current vertical retrace status */
+#define SISFB_GET_VBRSTATUS_OLD	   _IOR('n',0xF9,__u32)
+/* ioctl to enable/disable panning auto-maximize (like nomax parameter) */
+#define SISFB_GET_AUTOMAXIMIZE_OLD _IOR('n',0xFA,__u32)
+#define SISFB_SET_AUTOMAXIMIZE_OLD _IOW('n',0xFA,__u32)
+/****************************************************************/
+/*               End of deprecated ioctl numbers                */
+/****************************************************************/
+
+/* For fb memory manager (FBIO_ALLOC, FBIO_FREE) */
+struct sis_memreq {
+	__u32	offset;
+	__u32	size;
+};
+
+/**********************************************/
+/*                  PRIVATE                   */
+/*         (for IN-KERNEL usage only)         */
+/**********************************************/
+
+
+#endif
diff -uNr linux-2.6.32/usr/include/video/uvesafb.h clean_modified/linux-2.6.32/usr/include/video/uvesafb.h
--- linux-2.6.32/usr/include/video/uvesafb.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/video/uvesafb.h	2019-04-14 13:24:03.223147026 -0500
@@ -0,0 +1,60 @@
+#ifndef _UVESAFB_H
+#define _UVESAFB_H
+
+#include <linux/types.h>
+
+struct v86_regs {
+	__u32 ebx;
+	__u32 ecx;
+	__u32 edx;
+	__u32 esi;
+	__u32 edi;
+	__u32 ebp;
+	__u32 eax;
+	__u32 eip;
+	__u32 eflags;
+	__u32 esp;
+	__u16 cs;
+	__u16 ss;
+	__u16 es;
+	__u16 ds;
+	__u16 fs;
+	__u16 gs;
+};
+
+/* Task flags */
+#define TF_VBEIB	0x01
+#define TF_BUF_ESDI	0x02
+#define TF_BUF_ESBX	0x04
+#define TF_BUF_RET	0x08
+#define TF_EXIT		0x10
+
+struct uvesafb_task {
+	__u8 flags;
+	int buf_len;
+	struct v86_regs regs;
+};
+
+/* Constants for the capabilities field
+ * in vbe_ib */
+#define VBE_CAP_CAN_SWITCH_DAC	0x01
+#define VBE_CAP_VGACOMPAT	0x02
+
+/* The VBE Info Block */
+struct vbe_ib {
+	char  vbe_signature[4];
+	__u16 vbe_version;
+	__u32 oem_string_ptr;
+	__u32 capabilities;
+	__u32 mode_list_ptr;
+	__u16 total_memory;
+	__u16 oem_software_rev;
+	__u32 oem_vendor_name_ptr;
+	__u32 oem_product_name_ptr;
+	__u32 oem_product_rev_ptr;
+	__u8  reserved[222];
+	char  oem_data[256];
+	char  misc_data[512];
+} __attribute__ ((packed));
+
+#endif /* _UVESAFB_H */
diff -uNr linux-2.6.32/usr/include/xen/evtchn.h clean_modified/linux-2.6.32/usr/include/xen/evtchn.h
--- linux-2.6.32/usr/include/xen/evtchn.h	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/usr/include/xen/evtchn.h	2019-04-14 13:24:03.223147026 -0500
@@ -0,0 +1,88 @@
+/******************************************************************************
+ * evtchn.h
+ *
+ * Interface to /dev/xen/evtchn.
+ *
+ * Copyright (c) 2003-2005, K A Fraser
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __LINUX_PUBLIC_EVTCHN_H__
+#define __LINUX_PUBLIC_EVTCHN_H__
+
+/*
+ * Bind a fresh port to VIRQ @virq.
+ * Return allocated port.
+ */
+#define IOCTL_EVTCHN_BIND_VIRQ				\
+	_IOC(_IOC_NONE, 'E', 0, sizeof(struct ioctl_evtchn_bind_virq))
+struct ioctl_evtchn_bind_virq {
+	unsigned int virq;
+};
+
+/*
+ * Bind a fresh port to remote <@remote_domain, @remote_port>.
+ * Return allocated port.
+ */
+#define IOCTL_EVTCHN_BIND_INTERDOMAIN			\
+	_IOC(_IOC_NONE, 'E', 1, sizeof(struct ioctl_evtchn_bind_interdomain))
+struct ioctl_evtchn_bind_interdomain {
+	unsigned int remote_domain, remote_port;
+};
+
+/*
+ * Allocate a fresh port for binding to @remote_domain.
+ * Return allocated port.
+ */
+#define IOCTL_EVTCHN_BIND_UNBOUND_PORT			\
+	_IOC(_IOC_NONE, 'E', 2, sizeof(struct ioctl_evtchn_bind_unbound_port))
+struct ioctl_evtchn_bind_unbound_port {
+	unsigned int remote_domain;
+};
+
+/*
+ * Unbind previously allocated @port.
+ */
+#define IOCTL_EVTCHN_UNBIND				\
+	_IOC(_IOC_NONE, 'E', 3, sizeof(struct ioctl_evtchn_unbind))
+struct ioctl_evtchn_unbind {
+	unsigned int port;
+};
+
+/*
+ * Unbind previously allocated @port.
+ */
+#define IOCTL_EVTCHN_NOTIFY				\
+	_IOC(_IOC_NONE, 'E', 4, sizeof(struct ioctl_evtchn_notify))
+struct ioctl_evtchn_notify {
+	unsigned int port;
+};
+
+/* Clear and reinitialise the event buffer. Clear error condition. */
+#define IOCTL_EVTCHN_RESET				\
+	_IOC(_IOC_NONE, 'E', 5, 0)
+
+#endif /* __LINUX_PUBLIC_EVTCHN_H__ */
diff -uNr linux-2.6.32/.version clean_modified/linux-2.6.32/.version
--- linux-2.6.32/.version	1969-12-31 18:00:00.000000000 -0600
+++ clean_modified/linux-2.6.32/.version	2019-04-14 13:24:03.225100903 -0500
@@ -0,0 +1 @@
+56
